<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>移动端适配</title>
      <link href="/2022/01/06/CSS%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D-1/"/>
      <url>/2022/01/06/CSS%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D-1/</url>
      
        <content type="html"><![CDATA[<h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><h3 id="1、媒体查询"><a href="#1、媒体查询" class="headerlink" title="1、媒体查询"></a>1、媒体查询</h3><ul><li><p>使用媒体查询的方式：</p><ol><li>可以使用 <strong>link 与 style</strong> 中定义媒体查询</li><li>也可以用 <code>@import url(screen.css) screen</code> 形式媒体使用的样式</li></ol><p>可以用逗号分隔同时支持多个媒体设备，未指定媒体设备时等同于all</p></li></ul><h4 id="1、style"><a href="#1、style" class="headerlink" title="1、style"></a>1、style</h4><ul><li><p>常用的：一般并不会写media=”screen”，其实是默认了media=”all”</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style media=&quot;screen&quot;&gt;  //可以指定别的设备</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、link"><a href="#2、link" class="headerlink" title="2、link"></a>2、link</h4><ul><li><p>在 <code>link</code> 标签中通过 <code>media</code> 属性可以设置样式使用的媒体设备。</p></li><li><p>要写很多link标签，不太方便。不推荐使用</p></li><li><p>此外我们更多的时候是针对页面中某块区域，来单独写个样式控制其响应</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;common<span class="selector-class">.css</span>&quot;&gt; //没有指定媒体所以全局应用</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;screen<span class="selector-class">.css</span>&quot; media=&quot;screen&quot;&gt; //在屏幕设备</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;print<span class="selector-class">.css</span>&quot; media=&quot;print&quot;&gt; //在打印设备</span><br><span class="line"> <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;screen<span class="selector-class">.css</span>&quot; media=&quot;screen,print&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、-import"><a href="#3、-import" class="headerlink" title="3、@import"></a>3、@import</h4><ul><li><p>相比于link，我们更多的时候是针对页面中某块区域，来单独写个样式控制其响应</p></li><li><p>此时就可以在文件中<strong>引入一个样式文件</strong>，在这个文件中<strong>再引入其他媒体的样式文件。</strong>用<code>@import</code> ，引入指定设备的样式规则。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style<span class="selector-class">.css</span>&quot;&gt;  //这样就可以只有一个link了</span><br></pre></td></tr></table></figure><p><strong>style.css</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(screen.css) screen;</span><br><span class="line"><span class="keyword">@import</span> url(print.css) print;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(screen.css) screen,print; <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4、-media"><a href="#4、-media" class="headerlink" title="4、@media"></a>4、@media</h4><ul><li> <code>@media</code> 可以做到更细的控制，即<strong>在一个样式表中为多个媒体设备定义样式</strong></li></ul>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype 关键字 (media feature)  &#123;...&#125;</span><br><span class="line"><span class="keyword">@media</span> screen,print &#123;...&#125;  <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br><span class="line"></span><br><span class="line">media (<span class="attribute">min-width</span>: <span class="number">500px</span>), (max-width: <span class="number">700px</span>) &#123;....&#125;</span><br><span class="line">media only screen and (<span class="attribute">min-width</span>: <span class="number">500px</span>) and (max-width: <span class="number">700px</span>) &#123;....&#125;</span><br></pre></td></tr></table></figure><ul><li><p>mediatype：常用媒体类型还是screen</p><ul><li>all：所有媒体类型</li><li>screen：电脑屏幕，平板电脑，智能手机等</li><li>print：打印设备</li><li>speech：屏幕阅读器等发声设备</li></ul></li><li><p>and|or|not|only：关键字，实际使用3选1</p><ul><li>not：必须将not写在查询的最前面，表示不应用样式，即所有条件<strong>都满足</strong>时<strong>不应用</strong>样式</li><li>only：用来排除不支持媒体查询的浏览器<ul><li>only 和 not 一样只能出现在媒体查询的开始</li><li>对支持媒体查询的设备，正常调用样式，此时就当only不存在</li><li>对不支持媒体查询的设备不使用样式</li></ul></li></ul></li><li><p>media feature：width、min-width、max-width（布局视口的宽度、最小宽度…）</p></li><li><p>断点：样式切换的分界点，常用断点</p><ul><li>小于768 超小屏幕     大于768 小屏幕   大于992 中型屏幕    大于1200 大屏幕</li></ul></li></ul><h4 id="5、查询条件"><a href="#5、查询条件" class="headerlink" title="5、查询条件"></a>5、查询条件</h4><ul><li><p>可以使用不同条件限制使用的样式，条件表达式需要放在<strong>扩号</strong>中</p></li><li><p>style：设置查询条件的媒体查询：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style media=&quot;screen and (<span class="attribute">min-width</span>: <span class="number">768px</span>),screen and (orientation:landscape)<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">/*  orientation 属性可以定义设备的方向 */</span></span><br><span class="line"><span class="string">/* portrait竖屏设备即高度大于宽度    landscape横屏设备即宽度大于高度*/</span></span><br><span class="line"><span class="string">  body &#123;</span></span><br><span class="line"><span class="string">    color: blue;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>@media：设置查询条件的媒体查询：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#8e44ad</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、rem布局"><a href="#2、rem布局" class="headerlink" title="2、rem布局"></a>2、rem布局</h3><ul><li>作用：当设备尺寸发生改变的时候，等比例适配当前设备</li><li>rem计算：1rem = HTML的font-size  也是:root的font-size<ul><li>HTML的font-size：屏幕宽度 / 划分的份数</li></ul></li><li>做法：<ul><li>不同的媒体查询方式，不同的设备设置不同的HTML的font-size</li><li>然后页面元素用rem做尺寸单位</li><li>当html字体大小变化，元素尺寸也会发生变化，从而达到等比缩放的效果</li></ul></li></ul><h3 id="3、vw适配"><a href="#3、vw适配" class="headerlink" title="3、vw适配"></a>3、vw适配</h3><ul><li><p><code>vh、vw</code>方案即将视觉视口宽度 <code>window.innerWidth</code>和视觉视口高度 <code>window.innerHeight</code> 等分为 100 份。</p><ul><li><code>1vw</code>等于视觉视口的<code>1%</code>，<code>1vh</code> 为视觉视口高度的<code>1%</code></li><li><code>vmin</code> : <code>vw</code> 和 <code>vh</code> 中的较小值、较大值</li><li>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 3.75 = 20vw</code></li></ul></li><li><p>缺陷：</p><ul><li><code>px</code>转换成<code>vw</code>不一定能完全整除，因此有一定的像素差。</li><li>比如当容器使用<code>vw</code>，<code>margin</code>采用<code>px</code>时，很容易造成整体宽度超过<code>100vw</code>，从而影响布局效果。当然我们也是可以避免的，例如使用<code>padding</code>代替<code>margin</code>，结合<code>calc()</code>函数使用等等…</li></ul></li></ul><h3 id="4、视口"><a href="#4、视口" class="headerlink" title="4、视口"></a>4、视口</h3><h4 id="1、viewport的概念"><a href="#1、viewport的概念" class="headerlink" title="1、viewport的概念"></a>1、viewport的概念</h4><ul><li><p>通俗的讲，移动设备上的viewport：就是设备的<strong>屏幕上能用来显示网页的那块区域：</strong></p></li><li><p>但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大或小；</p></li><li><p>默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的：</p><ul><li>因为考虑到移动设备的分辨率相对于桌面来说都较小；</li><li>所以为了能在移动设备上正常显示为传统的为桌面设计的网站；</li><li>移动设备上的浏览器都会把自己默认的viewport设为980px或其他值</li><li>但后果就是浏<strong>览器会出现横向滚动条</strong>，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/18030682-a963ada3b9aed8fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/653/format/webp" alt="img"></p><h4 id="2、css的1px-设备1px"><a href="#2、css的1px-设备1px" class="headerlink" title="2、css的1px !== 设备1px"></a>2、css的1px !== 设备1px</h4><p>css中的像素只是一个抽象单位，在不同的设备或环境中<strong>，css中的1px代表的设备物理像素是不同的</strong></p><ul><li><p>css中一般使用px作为单位，对应电脑浏览器就是1px，一个物理像素；</p></li><li><p>但<strong>移动设备</strong>中并非如此：</p><ul><li>早期设备，屏幕像素比低。iphone3分辨率为320x480，一个css像素等于一个屏幕物理像素</li><li>但后期苹果推出了Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化：<ul><li>这意味着，同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的；</li></ul></li></ul></li><li><p><strong>用户缩放行为：</strong></p><ul><li>当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；</li><li>反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍</li></ul></li><li><p>**devicePixelRatio(设备像素比)**属性：window对象的</p><ul><li>设备物理像素和设备独立像素的比例，也就是 <strong>dpr = dp/ dips</strong>：<ul><li> <strong>dp(device pixels)：</strong>设备物理像素        css中的px</li><li> <strong>dips(device-independent pixels)：</strong>设备独立像素，dips = css像素/scale（缩放比例），所以dpr=(dp/css像素)*scale</li></ul></li><li>因此，通过devicePixelRatio可以知道该设备上一个css像素代表多少个物理像素。</li><li>但注意的是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题</li></ul></li></ul><h4 id="3、布局视口"><a href="#3、布局视口" class="headerlink" title="3、布局视口"></a>3、布局视口</h4><img src="https:////upload-images.jianshu.io/upload_images/18030682-07a1ff787499c9f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/497/format/webp" alt="img" style="zoom:50%;" /><ul><li><p>出现的目的：</p><p>浏览器默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。</p><ol><li>首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即便不是专为移动设备设计的网页</li><li>但移动设备的屏幕都不是很宽，如果以浏览器的可视区域作为viewport的话，那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团</li><li>因此，。。。</li></ol></li><li><p>ppk把这个浏览器默认的viewport叫做<strong>layout viewport(布局视口)</strong></p></li><li><p>获取：<code>document.documentElement.clientWidth / clientHeight</code></p></li></ul><h4 id="4、视觉视口"><a href="#4、视觉视口" class="headerlink" title="4、视觉视口"></a>4、视觉视口</h4><img src="https:////upload-images.jianshu.io/upload_images/18030682-d92903bf680a85cd.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp" alt="img" style="zoom:50%;" /><ul><li>layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 <strong>浏览器可视区域的大小</strong>：<strong>视觉视口</strong></li><li>用户可以缩放来查看网站的内容。<ul><li>缩小网站，看到的网站区域将变大，此时视觉视口也变大了，反之亦然</li><li>不管用户如何缩放，都不会影响到布局视口的宽度</li></ul></li><li>调用<code>window.innerWidth / innerHeight</code>来获取</li></ul><h4 id="5、理想视口"><a href="#5、理想视口" class="headerlink" title="5、理想视口"></a>5、理想视口</h4><ul><li><p>现在主流网站会为移动设备单独的设计，所以必须还要有一个能完美适配移动设备的viewport</p></li><li><p>完美适配指的是：</p><ol><li>不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；</li><li>显示的文字（图片等）的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清</li><li>理想的情况是这段14px的文字无论是在何种密度屏，何种分辨率，显示出来的都差不多的</li></ol></li><li><p><code>window.screen.width / height</code>来获取</p></li><li><p>ideal viewport 并没有固定的尺寸，不同的设备有不同的 ideal viewport：</p><ul><li><p>所有的 iphone 的 ideal viewport 宽度都是 320px，无论它的屏幕宽度是 320 还是 640</p></li><li><p>也就是说，在 iphone 中，css 中的 320px 就代表 iphone 屏幕的宽度。</p><img src="https:////upload-images.jianshu.io/upload_images/18030682-8a400bd06174edfa.png?imageMogr2/auto-orient/strip|imageView2/2/w/270/format/webp" alt="img" style="zoom:33%;" /></li></ul></li><li><p>这3类视口， ideal viewport 是最适合移动设备的viewport：只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。</p></li><li><p>ideal viewport 的意义：</p><p>无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。</p></li></ul><h3 id="5、meta标签"><a href="#5、meta标签" class="headerlink" title="5、meta标签"></a>5、meta标签</h3><h4 id="标准写法："><a href="#标准写法：" class="headerlink" title="标准写法："></a>标准写法：</h4><ul><li><p>移动设备<strong>默认的viewport是layout viewport</strong>，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport，常见的作法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>该meta标签的作用：</p><p>让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。</p></li><li><p>meta viewport 标签：在苹果的规范中，meta viewport 有6个属性</p><p>安卓还支持 target-densitydpi 私有属性，表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素，即将废弃。</p><img src="https:////upload-images.jianshu.io/upload_images/18030682-839f41e5291f76f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/549/format/webp" alt="img" style="zoom:50%;" /><p><img src="https://upload-images.jianshu.io/upload_images/18030682-76c58332c2eefc4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/657/format/webp" alt="img"></p></li></ul></li></ul><h4 id="不同的写法："><a href="#不同的写法：" class="headerlink" title="不同的写法："></a>不同的写法：</h4><ol><li> 这样写也能达到同样的效果：为什么？</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  // IE 会横竖屏不分</span><br></pre></td></tr></table></figure><ul><li>因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果；</li><li>因为缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport吗</li></ul><ol start="2"><li><strong>但如果 width 和 initial-scale=1 同时出现，并且还出现了冲突呢？</strong>比如：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=400, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  // iphone、ipad会横竖屏不分</span><br></pre></td></tr></table></figure><ul><li><p>width=400：把当前viewport的宽度设为400px</p></li><li><p>initial-scale=1：把当前viewport的宽度设为ideal viewport的宽度，<code>= 理想视口宽度 / 视觉视口宽度</code></p></li><li><p><strong>当遇到这种情况时，浏览器会取它们两个中较大的那个值</strong>：</p><p>ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度</p></li></ul><h4 id="用户缩放："><a href="#用户缩放：" class="headerlink" title="用户缩放："></a>用户缩放：</h4><p><code>initial-scale= 理想视口宽度 / 视觉视口宽度</code></p><ul><li><p>缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。</p><p>例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了</p><ul><li>原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了</li></ul></li><li><p>另一点，initial-scale：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</p></li></ul><h3 id="6、rem、em、vm"><a href="#6、rem、em、vm" class="headerlink" title="6、rem、em、vm"></a>6、rem、em、vm</h3><ul><li><p>px：像素，固定</p></li><li><p>em：</p><ul><li>相对于自己的字体大小；有继承的属性</li><li>如果自己没有，<strong>相对于父元素字体大小</strong></li></ul></li><li><p>rem：相对于<strong>根元素的字体font-size大小</strong>,任意浏览器默认字体都是16px</p><ul><li>html根元素的获取方式 <code>document.getElementsByTagName(&#39;html&#39;)[0]</code></li><li>Htmlfont-size：屏幕宽度 / 划分的份数</li><li>页面元素的rem值：页面元素值（px）/（屏幕宽度 / 划分的份数）</li></ul></li><li><p>百分比：</p><ul><li>用在字体中，相对于<strong>父元素</strong>字体大小</li><li>用在尺寸中，相对于父元素的width和height</li></ul></li><li><p>vm、vh</p><ul><li><code>1vw</code>等于视觉视口的<code>1%</code>，<code>1vh</code> 为视觉视口高度的<code>1%</code></li><li>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 3.75 = 20vw</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想玩的东西</title>
      <link href="/2022/01/02/%E6%83%B3%E7%8E%A9%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
      <url>/2022/01/02/%E6%83%B3%E7%8E%A9%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><h4 id="宫崎骏的电影："><a href="#宫崎骏的电影：" class="headerlink" title="宫崎骏的电影："></a>宫崎骏的电影：</h4><ul><li>猫的报恩</li><li>幽灵公主</li><li>还有几个看过不记得的</li></ul><h4 id="历史书：明朝那些事"><a href="#历史书：明朝那些事" class="headerlink" title="历史书：明朝那些事"></a>历史书：明朝那些事</h4><ul><li>想先看看大明1566那段，刚看完剧哈哈哈哈</li><li>看一看最后一部，想回忆回忆后面写的内容</li></ul><h4 id="练一首曲子："><a href="#练一首曲子：" class="headerlink" title="练一首曲子："></a>练一首曲子：</h4><ul><li>一直很安静，之前练了一半后来搁置的曲子；</li><li>还有练过的曲子，可能都不记得了，哈哈哈哈。</li><li>北京好玩的地方随便走走（顺便做短视频的素材呀）</li></ul><h3 id="论文："><a href="#论文：" class="headerlink" title="论文："></a>论文：</h3><h4 id="仿真代码：-重要等级1"><a href="#仿真代码：-重要等级1" class="headerlink" title="仿真代码：   重要等级1"></a>仿真代码：   重要等级1</h4><ul><li>明天开始写，不管写的怎么样，明天一定要开始写：先check一下前面的部分，然后想一下色痛怎么代码处理的问题；</li><li>计划在<strong>10号</strong>之前仿真结果能确定下来，后面可能会小修</li><li><strong>放假前跟老师沟通一次</strong>  内容大概是：仿真进度结果的情况，然后仿真的过程中，文档进一步细化，直接用笔标注，不要去改电子版，越改越乱，最后再改；</li><li>趁热打铁，跟导师沟通是否把不均匀场景也做出来，可以作为第3个点的补充，这样后面写文档可能会更有帮助</li></ul><h4 id="文档部分："><a href="#文档部分：" class="headerlink" title="文档部分："></a>文档部分：</h4><ul><li><p>开始点：等仿真做出来了开始写</p></li><li><p>先搭架子：<strong>很重要</strong> 春节以前要把架子搭玩</p><ul><li><p>自己重新做调研，包括最新的研究成果；</p></li><li><p>做完架子，给老师check，同时自己也要完善这部分的文档</p></li><li><p>关于idea的部分，仿真的过程中，一般文档完善的都差不多，后面再修改加进去架子里即可。这部分，只要核心工作做了，都是问题不大的</p></li></ul></li><li><p>加油呀，做完一件事就可以随便挑一个奖励喔！！！！！</p></li></ul><h3 id="控制玩手机："><a href="#控制玩手机：" class="headerlink" title="控制玩手机："></a>控制玩手机：</h3><ul><li><p>最近玩手机很严重，这个问题要引起重视，</p><p>因为容易陷入做什么事情就很焦虑的情绪中；</p><p>明天手机关机一整天，只有老年机工作；</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>驼峰命名转换</title>
      <link href="/2021/12/29/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/12/29/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<ul><li><p>网上有小伙伴说，这道题明显就是考正则；</p></li><li><p>问题来了，对于没学过正则或者跟我一样对正则只残留一点前世回忆怎么办？</p></li><li><p>ok，我们还是可以抢救一下滴</p><h4 id="下划线转驼峰"><a href="#下划线转驼峰" class="headerlink" title="下划线转驼峰"></a>下划线转驼峰</h4></li><li><p>命名转小驼峰，可能的输入：TestVal，test_val, TEST_VAL ，要求实现驼峰命名的输出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> trans = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = str.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"> <span class="comment">// case 1</span></span><br><span class="line">  <span class="keyword">if</span>(arr.indexOf(<span class="string">&#x27;_&#x27;</span>) === -<span class="number">1</span>)&#123; </span><br><span class="line">    arr[<span class="number">0</span>] = arr[<span class="number">0</span>].toLowerCase();</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// case 2+3</span></span><br><span class="line">  <span class="comment">// 遍历数组元素，每个开头均变成大写的：</span></span><br><span class="line">  arr = str.split(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="comment">// 每个元素是字符串</span></span><br><span class="line">    <span class="keyword">const</span> curArr = arr[i].split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; curArr.length; j++)&#123;</span><br><span class="line">      <span class="comment">// 如果不是第1组的 且是首字母，就是</span></span><br><span class="line">      <span class="keyword">if</span>(i !== <span class="number">0</span> &amp;&amp; j === <span class="number">0</span>)&#123;</span><br><span class="line">        res.push(curArr[j].toUpperCase());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.push(curArr[j].toLowerCase());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驼峰命名转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6的新特性</title>
      <link href="/2021/12/29/ES6%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2021/12/29/ES6%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6概括"><a href="#ES6概括" class="headerlink" title="ES6概括"></a>ES6概括</h2><p>涵盖了<strong>ES2015</strong>、<strong>ES2016</strong>、<strong>ES2017</strong>、<strong>ES2018</strong>、<strong>ES2019</strong>、<strong>ES2020</strong>。更新的内容主要分为以下几点</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f623a94c2f6f4cbeb46b1e8d66e75186~tplv-k3u1fbpfcp-watermark.image" alt="ES6缩略" style="zoom: 25%;" /><ul><li><strong>表达式</strong>：声明、解构赋值</li><li><strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</li><li><strong>语句与运算</strong>：Class、Module、Iterator</li><li><strong>异步编程</strong>：Promise、Generator、Async</li></ul><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="1、表达式"><a href="#1、表达式" class="headerlink" title="1、表达式"></a>1、表达式</h3><h4 id="1、声明：const、let"><a href="#1、声明：const、let" class="headerlink" title="1、声明：const、let"></a>1、声明：const、let</h4><h4 id="2、解构赋值"><a href="#2、解构赋值" class="headerlink" title="2、解构赋值"></a>2、解构赋值</h4><h5 id="1、语法："><a href="#1、语法：" class="headerlink" title="1、语法："></a>1、语法：</h5><ul><li> <strong>字符串解构</strong>：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></li><li> <strong>数值解构</strong>：<code>const &#123; toString: s &#125; = 123</code></li><li> <strong>布尔解构</strong>：<code>const &#123; toString: b &#125; = true</code></li><li>对象解构<ul><li>形式：<code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></li><li>默认：<code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></li><li>改名：<code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></li></ul></li><li>数组解构<ul><li>规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li><li>形式：<code>const [x, y] = [1, 2]</code></li><li>默认：<code>const [x, y = 2] = [1]</code></li></ul></li><li>函数参数解构<ul><li>数组解构：<code>function Func([x = 0, y = 1]) &#123;&#125;</code></li><li>对象解构：<code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></li></ul></li></ul><h5 id="2、应用场景："><a href="#2、应用场景：" class="headerlink" title="2、应用场景："></a>2、应用场景：</h5><ul><li>交换变量值：<code>[x, y] = [y, x]</code></li><li>返回函数多个值：<code>const [x, y, z] = Func()</code></li><li>定义函数参数：<code>Func([1, 2])</code></li><li>提取JSON数据：<code>const &#123; name, version &#125; = packageJson</code></li><li>定义函数参数默认值：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>遍历Map结构：<code>for (let [k, v] of Map) &#123;&#125;</code></li><li>输入模块指定属性和方法：<code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></li></ul><h5 id="3、重点难点"><a href="#3、重点难点" class="headerlink" title="3、重点难点"></a>3、重点难点</h5><ul><li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li><li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li><li>解构默认值生效条件：属性值严格等于<code>undefined</code></li><li>解构不成功时变量的值等于<code>undefined</code></li><li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li></ul><h3 id="2、内置对象"><a href="#2、内置对象" class="headerlink" title="2、内置对象"></a>2、内置对象</h3><h4 id="1、字符串扩展"><a href="#1、字符串扩展" class="headerlink" title="1、字符串扩展"></a>1、字符串扩展</h4><ul><li> <strong>Unicode表示法</strong>：<code>大括号包含</code>表示Unicode字符(<code>\u&#123;0xXX&#125;</code>或<code>\u&#123;0XXX&#125;</code>)</li><li> <strong>字符串遍历</strong>：可通过<code>for-of</code>遍历字符串</li><li> <strong>字符串模板</strong>：可单行可多行可插入变量的增强版字符串</li><li> <strong>标签模板</strong>：函数参数的特殊调用</li><li> **String.raw()**：返回把字符串所有变量替换且对斜杠进行转义的结果</li><li> **String.fromCodePoint()**：返回码点对应字符</li><li> **codePointAt()**：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</li><li> **normalize()**：把字符的不同表示方法统一为同样形式，返回<code>新字符串</code>(Unicode正规化)</li><li> **repeat()**：把字符串重复n次，返回<code>新字符串</code></li><li> **matchAll()**：返回正则表达式在字符串的所有匹配</li><li> **includes()**：是否存在指定字符串</li><li> **startsWith()**：是否存在字符串头部指定字符串</li><li> **endsWith()**：是否存在字符串尾部指定字符串</li></ul><h4 id="2、数值扩展"><a href="#2、数值扩展" class="headerlink" title="2、数值扩展"></a>2、数值扩展</h4><ul><li> <strong>二进制表示法</strong>：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li><li> <strong>八进制表示法</strong>：<code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li></ul><h5 id="1、Number："><a href="#1、Number：" class="headerlink" title="1、Number："></a>1、Number：</h5><ul><li> <strong>Number.EPSILON</strong>：数值最小精度</li><li> <strong>Number.MIN_SAFE_INTEGER</strong>：最小安全数值(<code>-2^53</code>)</li><li> <strong>Number.MAX_SAFE_INTEGER</strong>：最大安全数值(<code>2^53</code>)</li><li> **Number.parseInt()**：返回转换值的整数部分</li><li> **Number.parseFloat()**：返回转换值的浮点数部分</li><li> **Number.isFinite()**：是否为有限数值</li><li> **Number.isNaN()**：是否为NaN</li><li> **Number.isInteger()**：是否为整数</li><li> **Number.isSafeInteger()**：是否在数值安全范围内</li></ul><h5 id="2、Math："><a href="#2、Math：" class="headerlink" title="2、Math："></a>2、Math：</h5><ul><li> **Math.sign()**：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li><li> **Math.cbrt()**：返回数值立方根</li><li> 对数、立方根、双曲、正弦、、、</li></ul><h4 id="3、对象扩展"><a href="#3、对象扩展" class="headerlink" title="3、对象扩展"></a>3、对象扩展</h4><ul><li> <strong>简洁表示法</strong>：键值相同</li><li> <strong>属性名表达式</strong>：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</li><li> <strong>属性的可枚举性和遍历</strong>：描述对象的<code>enumerable</code></li><li> <strong>super关键字</strong>：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</li><li> **Object.assign()**：合并对象(浅拷贝)，返回原对象</li><li> **Object.getPrototypeOf()**：返回对象的原型对象</li><li> **Object.setPrototypeOf()**：设置对象的原型对象</li><li> **<strong>proto</strong>**：返回或设置对象的原型对象</li></ul><blockquote><p>属性遍历</p></blockquote><ul><li>描述：<code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></li><li>遍历<ul><li><code>for-in</code>：遍历对象<code>自身可继承可枚举</code>属性</li><li><code>Object.keys()</code>：返回对象<code>自身可枚举</code>属性键组成的数组</li><li><code>Object.getOwnPropertyNames()</code>：返回对象<code>自身非Symbol</code>属性键组成的数组</li><li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>自身Symbol</code>属性键组成的数组</li><li><code>Reflect.ownKeys()</code>：返回对象<code>自身全部</code>属性键组成的数组</li></ul></li><li>规则<ul><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有Symbol键，按照加入时间升序排列</li></ul></li></ul><h4 id="4、数组扩展"><a href="#4、数组扩展" class="headerlink" title="4、数组扩展"></a>4、数组扩展</h4><h5 id="1、语法：-1"><a href="#1、语法：-1" class="headerlink" title="1、语法："></a>1、语法：</h5><ul><li> <strong>扩展运算符(…)</strong></li><li>Array.from()：转换具有Iterator接口的数据结构为真正数组，返回新数组<ul><li>类数组对象：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li><li>可遍历对象：<code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li></ul></li><li> **Array.of()**：转换一组值为真正数组，返回新数组</li><li> **copyWithin()**：把指定位置的成员复制到其他位置，返回原数组</li><li> **find()**：返回第一个符合条件的成员</li><li> **findIndex()**：返回第一个符合条件的成员索引值</li><li> **fill()**：根据指定值填充整个数组，返回原数组</li><li> **keys()**：返回以索引值为遍历器的对象</li><li> **values()**：返回以属性值为遍历器的对象</li><li> **entries()**：返回以索引值和属性值为遍历器的对象</li></ul><h5 id="2、扩展应用"><a href="#2、扩展应用" class="headerlink" title="2、扩展应用"></a>2、扩展应用</h5><ul><li>克隆数组：<code>const arr = [...arr1]</code></li><li>合并数组：<code>const arr = [...arr1, ...arr2]</code></li><li>拼接数组：<code>arr.push(...arr1)</code></li><li>代替apply：<code>Math.max.apply(null, [x, y])</code> =&gt; <code>Math.max(...[x, y])</code></li><li>转换字符串为数组：<code>[...&quot;hello&quot;]</code></li><li>转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></li><li>转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></li><li>与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></li></ul><h4 id="5、函数扩展"><a href="#5、函数扩展" class="headerlink" title="5、函数扩展"></a>5、函数扩展</h4><h5 id="1、参数默认值：为函数参数指定默认值"><a href="#1、参数默认值：为函数参数指定默认值" class="headerlink" title="1、参数默认值：为函数参数指定默认值"></a>1、参数默认值：为函数参数指定默认值</h5><ul><li>形式：<code>function Func(x = 1, y = 2) &#123;&#125;</code></li><li>参数赋值：惰性求值(函数调用后才求值)</li><li>参数位置：尾参数</li><li>参数作用域：函数作用域</li><li>声明方式：默认声明，不能用<code>const</code>或<code>let</code>再次声明</li><li>length：返回没有指定默认值的参数个数</li><li>与解构赋值默认值结合：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>应用<ul><li>指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) &#123;&#125;</code></li><li>将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></li></ul></li></ul><h5 id="2、剩余参数-…-：返回函数多余参数"><a href="#2、剩余参数-…-：返回函数多余参数" class="headerlink" title="2、剩余参数(…)：返回函数多余参数"></a>2、剩余参数(…)：返回函数多余参数</h5><ul><li>形式：以数组的形式存在，之后不能再有其他参数</li><li>作用：代替<code>Arguments对象</code></li><li>length：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li></ul><h5 id="3、箭头函数-gt-：函数简写"><a href="#3、箭头函数-gt-：函数简写" class="headerlink" title="3、箭头函数(=&gt;)：函数简写"></a>3、箭头函数(=&gt;)：函数简写</h5><ul><li><p>无参数、单个参数、多个参数、解构参数<code>(&#123;x, y&#125;) =&gt; &#123;&#125;</code>、</p></li><li><p>嵌套使用：部署管道机制</p></li><li><p>this指向固定化，这种特性很有利于封装回调函数</p><ul><li>并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></li><li>因为没有<code>this</code>，因此不能用作构造函数</li><li>不可使用<code>Arguments对象</code>，此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li><li>返回对象时必须在对象外面加上括号</li></ul></li></ul><h5 id="4、尾调用优化：只保留内层函数的调用帧"><a href="#4、尾调用优化：只保留内层函数的调用帧" class="headerlink" title="4、尾调用优化：只保留内层函数的调用帧"></a>4、尾调用优化：只保留内层函数的调用帧</h5><ul><li>尾调用<ul><li>定义：某个函数的最后一步是调用另一个函数</li><li>形式：<code>function f(x) &#123; return g(x); &#125;</code></li></ul></li><li>尾递归<ul><li>定义：函数尾调用自身</li><li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li><li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul><h4 id="6、正则扩展"><a href="#6、正则扩展" class="headerlink" title="6、正则扩展"></a>6、正则扩展</h4><h4 id="7、Symbol"><a href="#7、Symbol" class="headerlink" title="7、Symbol"></a>7、Symbol</h4><h4 id="8、Set"><a href="#8、Set" class="headerlink" title="8、Set"></a>8、Set</h4><h5 id="1、用法"><a href="#1、用法" class="headerlink" title="1、用法"></a>1、用法</h5><ul><li>定义：成员值都是唯一且没有重复的值</li><li>声明：<code>const set = new Set(arr)</code></li><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回Set</li><li><strong>size</strong>：返回实例成员总数</li></ul></li><li>方法<ul><li>**add()**：添加值，返回实例            **clear()**：清除所有成员</li><li>**delete()**：删除值，返回布尔   **has()**：检查值，返回布尔</li><li>**keys()**：返回以属性值为遍历器的对象</li><li>**values()**：返回以属性值为遍历器的对象</li><li>**entries()**：返回以属性值和属性值为遍历器的对象</li><li>**forEach()**：使用回调函数遍历每个成员</li></ul></li></ul><h5 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h5><ul><li>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></li><li>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></li><li>集合数组<ul><li>声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></li><li>并集：<code>new Set([...a, ...b])</code></li><li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li><li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li></ul></li><li>映射集合<ul><li>声明：<code>let set = new Set(arr)</code></li><li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li></ul></li></ul><h5 id="3、重点难点-1"><a href="#3、重点难点-1" class="headerlink" title="3、重点难点"></a>3、重点难点</h5><ul><li>遍历顺序：插入顺序</li><li>没有键只有值，可认为键和值两值相等</li><li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li><li>添加相同的对象时，会认为是不同的对象</li><li>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li><li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li></ul><h4 id="9、WeakSet"><a href="#9、WeakSet" class="headerlink" title="9、WeakSet"></a>9、WeakSet</h4><h5 id="1、用法-1"><a href="#1、用法-1" class="headerlink" title="1、用法"></a>1、用法</h5><ul><li>定义：和Set结构类似，成员值只能是对象</li><li>声明：<code>const set = new WeakSet(arr)</code></li><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回WeakSet</li></ul></li><li>方法<ul><li>**add()**：添加值，返回实例</li><li>**delete()**：删除值，返回布尔</li><li>**has()**：检查值，返回布尔</li></ul></li></ul><h5 id="2、应用场景-1"><a href="#2、应用场景-1" class="headerlink" title="2、应用场景"></a>2、应用场景</h5><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li><li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动消失</li></ul><h5 id="3、重点难点-2"><a href="#3、重点难点-2" class="headerlink" title="3、重点难点"></a>3、重点难点</h5><ul><li>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li><li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet结构不可遍历</code></li><li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet结构</code>中</li></ul><h4 id="10、Map"><a href="#10、Map" class="headerlink" title="10、Map"></a>10、Map</h4><h5 id="1、用法-2"><a href="#1、用法-2" class="headerlink" title="1、用法"></a>1、用法</h5><ul><li>定义：成员键是任何类型的值</li><li>声明：<code>const set = new Map(arr)</code></li><li>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回Map</li><li><strong>size</strong>：返回实例成员总数</li></ul></li><li>方法<ul><li>**get()**：返回键值对       **set()**：添加键值对，返回实例       **has()**：检查键值对，返回布尔</li><li>**delete()**：删除键值对，返回布尔        **clear()**：清除所有成员</li><li>**keys()**：返回以键为遍历器的对象</li><li>**values()**：返回以值为遍历器的对象</li><li>**entries()**：返回以键和值为遍历器的对象</li><li>**forEach()**：使用回调函数遍历每个成员</li></ul></li></ul><h5 id="2、重点难点"><a href="#2、重点难点" class="headerlink" title="2、重点难点"></a>2、重点难点</h5><ul><li>遍历顺序：插入顺序</li><li>对同一个键多次赋值，后面的值将覆盖前面的值</li><li>对同一个对象的引用，被视为一个键</li><li>对同样值的两个实例，被视为两个键</li><li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li><li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li><li><code>Object结构</code>提供<code>字符串—值</code>的对应，<code>Map结构</code>提供<code>值—值</code>的对应</li></ul><h4 id="11、WeakMap"><a href="#11、WeakMap" class="headerlink" title="11、WeakMap"></a>11、WeakMap</h4><h5 id="1、用法-3"><a href="#1、用法-3" class="headerlink" title="1、用法"></a>1、用法</h5><ul><li>定义：和Map结构类似，成员键只能是对象</li><li>声明：<code>const set = new WeakMap(arr)</code></li><li>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回WeakMap</li></ul></li><li>方法<ul><li>**get()**：返回键值对</li><li>**set()**：添加键值对，返回实例</li><li>**delete()**：删除键值对，返回布尔</li><li>**has()**：检查键值对，返回布尔</li></ul></li></ul><h5 id="2、应用场景-2"><a href="#2、应用场景-2" class="headerlink" title="2、应用场景"></a>2、应用场景</h5><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li><li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul><h5 id="3、重点难点-3"><a href="#3、重点难点-3" class="headerlink" title="3、重点难点"></a>3、重点难点</h5><ul><li>成员键都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li><li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap结构不可遍历</code></li><li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap结构</code>中</li><li>一旦不再需要，成员会自动消失，不用手动删除引用</li><li>弱引用的<code>只是键而不是值</code>，值依然是正常引用</li><li>即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul><h4 id="12、Proxy"><a href="#12、Proxy" class="headerlink" title="12、Proxy"></a>12、Proxy</h4><ul><li>定义：修改某些操作的默认行为</li><li>声明：<code>const proxy = new Proxy(target, handler)</code></li><li>入参<ul><li><strong>target</strong>：拦截的目标对象</li><li><strong>handler</strong>：定制拦截行为</li></ul></li><li>方法<ul><li>**Proxy.revocable()**：返回可取消的Proxy实例(返回<code>&#123; proxy, revoke &#125;</code>，通过revoke()取消代理)</li></ul></li><li>拦截方式<ul><li>**get()**：拦截对象属性读取</li><li>**set()**：拦截对象属性设置，返回布尔</li><li>**has()**：拦截对象属性检查<code>k in obj</code>，返回布尔</li><li>**deleteProperty()**：拦截对象属性删除<code>delete obj[k]</code>，返回布尔</li><li>**defineProperty()**：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔</li><li>**ownKeys()**：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li><li>**getOwnPropertyDescriptor()**：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li><li>**getPrototypeOf()**：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li><li>**setPrototypeOf()**：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔</li><li>**isExtensible()**：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔</li><li>**preventExtensions()**：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔</li><li>**apply()**：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li><li>**construct()**：拦截Proxy实例作为构造函数调用<code>new proxy()</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li><li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li><li><code>set()</code>：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li><li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li><li><code>deleteProperty()</code>：保护内部属性不被删除</li><li><code>defineProperty()</code>：阻止属性被外部定义</li><li><code>ownKeys()</code>：保护内部属性不被遍历</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>要使<code>Proxy</code>起作用，必须针对<code>实例</code>进行操作，而不是针对<code>目标对象</code>进行操作</li><li>没有设置任何拦截时，等同于<code>直接通向原对象</code></li><li>属性被定义为<code>不可读写/扩展/配置/枚举</code>时，使用拦截方法会报错</li><li>代理下的目标对象，内部<code>this</code>指向<code>Proxy代理</code></li></ul><h4 id="13、Reflect"><a href="#13、Reflect" class="headerlink" title="13、Reflect"></a>13、Reflect</h4><ul><li>定义：保持<code>Object方法</code>的默认行为</li><li>方法<ul><li>**get()**：返回对象属性</li><li>**set()**：设置对象属性，返回布尔</li><li>**has()**：检查对象属性，返回布尔</li><li>**deleteProperty()**：删除对象属性，返回布尔</li><li>**defineProperty()**：定义对象属性，返回布尔</li><li>**ownKeys()**：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li><li>**getOwnPropertyDescriptor()**：返回对象属性描述，返回对象</li><li>**getPrototypeOf()**：返回对象原型，返回对象</li><li>**setPrototypeOf()**：设置对象原型，返回布尔</li><li>**isExtensible()**：返回对象是否可扩展，返回布尔</li><li>**preventExtensions()**：设置对象不可扩展，返回布尔</li><li>**apply()**：绑定this后执行指定函数</li><li>**construct()**：调用构造函数创建实例</li></ul></li></ul><blockquote><p>设计目的</p></blockquote><ul><li>将<code>Object</code>属于<code>语言内部的方法</code>放到<code>Reflect</code>上</li><li>将某些Object方法报错情况改成返回<code>false</code></li><li>让<code>Object操作</code>变成<code>函数行为</code></li><li><code>Proxy</code>与<code>Reflect</code>相辅相成</li></ul><blockquote><p>废弃方法</p></blockquote><ul><li><code>Object.defineProperty()</code> =&gt; <code>Reflect.defineProperty()</code></li><li><code>Object.getOwnPropertyDescriptor()</code> =&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li><li><code>Proxy</code>和<code>Reflect</code>联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li></ul><blockquote><p>数据绑定：观察者模式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observerQueue = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> observerQueue.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">tgt, key, val, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.forEach(<span class="function"><span class="params">v</span> =&gt;</span> v());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123; <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">name</span>: <span class="string">&quot;Yajun&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> print = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> is <span class="subst">$&#123;person.age&#125;</span> years old`</span>);</span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">&quot;Joway&quot;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="14、Class-15、Module-16、Iterator-17、Promise-18、Generator"><a href="#14、Class-15、Module-16、Iterator-17、Promise-18、Generator" class="headerlink" title="14、Class           15、Module    16、Iterator    17、Promise   18、Generator"></a>14、Class           15、Module    16、Iterator    17、Promise   18、Generator</h4><h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b6131b43a2415e8deb82c53a054432~tplv-k3u1fbpfcp-watermark.image" alt="ES2016" style="zoom:25%;" /><h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65ff57811aff4f0e884a9b250fa1b6fb~tplv-k3u1fbpfcp-watermark.image" alt="ES2017" style="zoom:25%;" /><h3 id="1、声明"><a href="#1、声明" class="headerlink" title="1、声明"></a>1、声明</h3><ul><li> <strong>共享内存和原子操作</strong>：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在<code>JS主线程</code>和<code>web-worker线程</code>之间共享</li></ul><h3 id="2、字符串扩展"><a href="#2、字符串扩展" class="headerlink" title="2、字符串扩展"></a>2、字符串扩展</h3><ul><li> **padStart()**：把指定字符串填充到字符串头部，返回新字符串</li><li> **padEnd()**：把指定字符串填充到字符串尾部，返回新字符串</li></ul><h3 id="3、对象扩展-1"><a href="#3、对象扩展-1" class="headerlink" title="3、对象扩展"></a>3、对象扩展</h3><ul><li> **Object.getOwnPropertyDescriptors()**：返回对象所有自身属性(非继承属性)的描述对象</li><li> **Object.values()**：返回以值组成的数组</li><li> **Object.entries()**：返回以键和值组成的数组</li></ul><h3 id="4、函数扩展"><a href="#4、函数扩展" class="headerlink" title="4、函数扩展"></a>4、函数扩展</h3><ul><li> <strong>函数参数尾逗号</strong>：允许函数最后一个参数有尾逗号</li></ul><h3 id="5、Async"><a href="#5、Async" class="headerlink" title="5、Async"></a>5、Async</h3><ul><li>定义：使异步函数以同步函数的形式书写(Generator函数语法糖)</li><li>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</li><li>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></li><li>声明<ul><li>具名函数：<code>async function Func() &#123;&#125;</code></li><li>函数表达式：<code>const func = async function() &#123;&#125;</code></li><li>箭头函数：<code>const func = async() =&gt; &#123;&#125;</code></li><li>对象方法：<code>const obj = &#123; async func() &#123;&#125; &#125;</code></li><li>类方法：<code>class Cla &#123; async Func() &#123;&#125; &#125;</code></li></ul></li><li>await命令：等待当前Promise对象状态变更完毕<ul><li>正常情况：后面是Promise对象则返回其结果，否则返回对应的值</li><li>后随<code>Thenable对象</code>：将其等同于Promise对象返回其结果</li></ul></li><li>错误处理：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</li></ul><blockquote><p>Async对Generator改进</p></blockquote><ul><li>内置执行器</li><li>更好的语义</li><li>更广的适用性</li><li>返回值是Promise对象</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>按顺序完成异步操作</li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>Async函数</code>返回<code>Promise对象</code>，可使用<code>then()</code>添加回调函数</li><li>内部<code>return返回值</code>会成为后续<code>then()</code>的出参</li><li>内部抛出错误会导致返回的Promise对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</li><li>返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></li><li>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</li><li>希望即使前一个异步操作失败也不要中断后面的异步操作<ul><li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li><li><code>await命令Promise对象</code>跟一个<code>catch()</code></li></ul></li><li><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</li><li>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</li><li><code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</li><li>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</li><li>可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</li></ul><h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee2ee331aa642c49fc3119bdf3eb974~tplv-k3u1fbpfcp-watermark.image" alt="ES2018" style="zoom: 25%;" /><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li> <strong>放松对标签模板里字符串转义的限制</strong>：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</li></ul><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li> **扩展运算符(…)**：转换对象为用逗号分隔的参数序列(<code>&#123; ...obj &#125;</code>，相当于<code>rest/spread参数</code>的逆运算)</li></ul><blockquote><p>扩展应用</p></blockquote><ul><li>克隆对象：<code>const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;</code></li><li>合并对象：<code>const obj = &#123; ...obj1, ...obj2 &#125;</code></li><li>转换字符串为对象：<code>&#123; ...&quot;hello&quot; &#125;</code></li><li>转换数组为对象：<code>&#123; ...[1, 2] &#125;</code></li><li>与对象解构赋值结合：<code>const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3  &#125;</code>(不能复制继承自原型对象的属性)</li><li>修改现有对象部分属性：<code>const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;</code></li></ul><h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li><p><strong>s修饰符</strong>：dotAll模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll模式</code>)</p></li><li><p><strong>dotAll</strong>：是否设置<code>s修饰符</code></p></li><li><p><strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</p></li><li><p><strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</p></li><li><p>Unicode属性转义</p><p>：匹配符合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unicode某种属性</span><br></pre></td></tr></table></figure><p>的所有字符</p><ul><li>正向匹配：<code>\p&#123;PropRule&#125;</code></li><li>反向匹配：<code>\P&#123;PropRule&#125;</code></li><li>限制：<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li></ul></li><li><p>具名组匹配</p><p>：为每组匹配指定名字(</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?&lt;GroupName&gt;</span><br></pre></td></tr></table></figure><p>)</p><ul><li>形式：<code>str.exec().groups.GroupName</code></li><li>解构赋值替换<ul><li>声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?\d&#123;4&#125;)-(?\d&#123;2&#125;)-(?\d&#123;2&#125;)/u</code></li><li>匹配：<code>time.replace(regexp, &quot;$/$/$&quot;)</code></li></ul></li></ul></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul><li> **finally()**：指定不管最后状态如何都会执行的回调函数</li></ul><h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><ul><li> **异步迭代器(for-await-of)**：循环等待每个<code>Promise对象</code>变为<code>resolved状态</code>才进入下一步</li></ul><h2 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ae43118d7ef4e1eb9b3aac7b0f89777~tplv-k3u1fbpfcp-watermark.image" alt="ES2019"></p><h3 id="字符串扩展-1"><a href="#字符串扩展-1" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li> <strong>直接输入U+2028和U+2029</strong>：字符串可直接输入<code>行分隔符</code>和<code>段分隔符</code></li><li> <strong>JSON.stringify()改造</strong>：可返回不符合UTF-8标准的字符串</li><li> **trimStart()**：消除字符串头部空格，返回新字符串</li><li> **trimEnd()**：消除字符串尾部空格，返回新字符串</li></ul><h3 id="对象扩展-1"><a href="#对象扩展-1" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li> **Object.fromEntries()**：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</li></ul><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li> <strong>sort()稳定性</strong>：排序关键字相同的项目其排序前后的顺序不变，默认为<code>稳定</code></li><li> **flat()**：扁平化数组，返回新数组</li><li> **flatMap()**：映射且扁平化数组，返回新数组(只能展开一层数组)</li></ul><h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li> <strong>toString()改造</strong>：返回函数原始代码(与编码一致)</li><li> <strong>catch()参数可省略</strong>：<code>catch()</code>中的参数可省略</li></ul><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li> <strong>description</strong>：返回<code>Symbol值</code>的描述</li></ul><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4762da8a25d242eb82da69576b05b035~tplv-k3u1fbpfcp-watermark.image" alt="ES2020" style="zoom:25%;" /><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li><p>globalThis</p><p>：作为顶层对象，指向全局环境下的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure><ul><li>Browser：顶层对象是<code>window</code></li><li>Node：顶层对象是<code>global</code></li><li>WebWorker：顶层对象是<code>self</code></li><li>以上三者：通用顶层对象是<code>globalThis</code></li></ul></li></ul><h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><p>BigInt</p><p>：任何位数的整数(新增的数据类型，使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure><p>结尾)</p><ul><li>**BigInt()**：转换普通数值为BigInt类型</li><li>**BigInt.asUintN()**：转换BigInt为0到2n-1之间对应的值</li><li>**BigInt.asIntN()**：转换BigInt为-2n-1 到2n-1-1</li><li>**BigInt.parseInt()**：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的BigInt类型</li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>BigInt同样可使用各种进制表示，都要加上后缀</li><li>BigInt与普通整数是两种值，它们之间并不相等</li><li>typeof运算符对于BigInt类型的数据返回<code>bigint</code></li></ul><h3 id="对象扩展-2"><a href="#对象扩展-2" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><p>链判断操作符(?.)</p><p>：是否存在对象属性(不存在返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined</span><br></pre></td></tr></table></figure><p>且不再往下执行)</p><ul><li>对象属性：<code>obj?.prop</code>、<code>obj?.[expr]</code></li><li>函数调用：<code>func?.(...args)</code></li></ul></li><li><p>**空判断操作符(??)**：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</p></li></ul><h3 id="正则扩展-1"><a href="#正则扩展-1" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li> **matchAll()**：返回所有匹配的遍历器</li></ul><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li><p>import()</p><p>：动态导入(返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise</span><br></pre></td></tr></table></figure><ul><li>背景：<code>import命令</code>被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li></ul></li><li><p>位置：可在任何地方使用</p><ul><li>区别：<code>require()</code>是<strong>同步加载</strong>，<code>import()</code>是<strong>异步加载</strong></li><li>场景：按需加载、条件加载、模块路径动态化</li></ul></li></ul><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul><li> <strong>for-in遍历顺序</strong>：不同的引擎已就如何迭代属性达成一致，从而使行为标准化</li></ul><h3 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h3><ul><li><p>Promise.allSettled()</p><p>：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)</p><ul><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>成功：成员包含<code>status</code>和<code>value</code>，<code>status</code>为<code>fulfilled</code>，<code>value</code>为返回值</li><li>失败：成员包含<code>status</code>和<code>reason</code>，<code>status</code>为<code>rejected</code>，<code>value</code>为错误原因</li></ul></li></ul><h2 id="ES提案"><a href="#ES提案" class="headerlink" title="ES提案"></a>ES提案</h2><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68085d653c054f68a496cb158496ed8b~tplv-k3u1fbpfcp-watermark.image" alt="ES提案" style="zoom:33%;" /><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><ul><li> <strong>do表达式</strong>：封装块级作用域的操作，返回内部最后执行表达式的值(<code>do&#123;&#125;</code>)</li><li> <strong>throw表达式</strong>：直接使用<code>throw new Error()</code>，无需<code>()</code>或<code>&#123;&#125;</code>包括</li><li> <strong>!#命令</strong>：指定脚本执行器(写在文件首行)</li></ul><h3 id="数值扩展-1"><a href="#数值扩展-1" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li> **数值分隔符(_)**：使用<code>_</code>作为千分位分隔符(增加数值的可读性)</li><li> **Math.signbit()**：返回数值符号是否设置</li></ul><h3 id="函数扩展-1"><a href="#函数扩展-1" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><p><strong>函数部分执行</strong>：复用函数功能(<code>?</code>表示单个参数占位符，<code>...</code>表示多个参数占位符)</p></li><li><p>**管道操作符(|&gt;)**：把左边表达式的值传入右边的函数进行求值(<code>f(x)</code> =&gt; <code>x |&gt; f</code>)</p></li><li><p>绑定运算符(::)</p><p>：函数绑定(左边是对象右边是函数，取代</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call</span><br></pre></td></tr></table></figure><p>调用)</p><ul><li>bind：<code>bar.bind(foo)</code> =&gt; <code>foo::bar</code></li><li>apply：<code>bar.apply(foo, arguments)</code> =&gt; <code>foo::bar(...arguments)</code></li></ul></li></ul><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul><li>定义：提供<code>沙箱功能</code>，允许隔离代码，防止被隔离的代码拿到全局对象</li><li>声明：<code>new Realm().global</code></li></ul><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul><li> <strong>静态属性</strong>：使用<code>static</code>定义属性，该属性<code>不会被实例继承</code>，只能通过类来调用</li><li> <strong>私有属性</strong>：使用<code>#</code>定义属性，该属性只能在类内部访问</li><li> <strong>私有方法</strong>：使用<code>#</code>定义方法，该方法只能在类内部访问</li><li> <strong>装饰器</strong>：使用<code>@</code>注释或修改类和类方法</li></ul><h3 id="Module-1"><a href="#Module-1" class="headerlink" title="Module"></a>Module</h3><ul><li> <strong>import.meta</strong>：返回脚本元信息</li></ul><h3 id="Promise-2"><a href="#Promise-2" class="headerlink" title="Promise"></a>Promise</h3><ul><li><p>Promise.any()</p><p>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</p><ul><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>成功：其中一个实例状态变成<code>fulfilled</code>，最终状态就会变成<code>fulfilled</code></li><li>失败：只有全部实例状态变成<code>rejected</code>，最终状态才会变成<code>rejected</code></li></ul></li><li><p>**Promise.try()**：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</p></li></ul><h3 id="Async-1"><a href="#Async-1" class="headerlink" title="Async"></a>Async</h3><ul><li> <strong>顶层Await</strong>：允许在模块的顶层独立使用<code>await命令</code>(借用<code>await</code>解决模块异步加载的问题)</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虾皮一面中的数组去重</title>
      <link href="/2021/12/29/%E8%99%BE%E7%9A%AE%E4%B8%80%E9%9D%A2%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2021/12/29/%E8%99%BE%E7%9A%AE%E4%B8%80%E9%9D%A2%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<ul><li>当时一紧张，只想到了用数据结构存储的思路，哈哈哈。补充一下其他方法</li></ul><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>// 原地修改数组</p><h4 id="法1：双层for-splice-基本数据类型"><a href="#法1：双层for-splice-基本数据类型" class="headerlink" title="法1：双层for+splice            基本数据类型"></a>法1：双层for+splice            基本数据类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]===arr[j])&#123;</span><br><span class="line">        arr.splice(j,<span class="number">1</span>)  <span class="comment">//splice是能改变原数组的，slice不行</span></span><br><span class="line">        j--  <span class="comment">//如果有重复元素，删除之后一定要j--</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法2：用额外空间存储已经出现过的元素"><a href="#法2：用额外空间存储已经出现过的元素" class="headerlink" title="法2：用额外空间存储已经出现过的元素"></a>法2：用额外空间存储已经出现过的元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.indexOf(arr[i])==-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//  if(!res.includes(arr[i]))&#123;</span></span><br><span class="line">      res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">版本<span class="number">2</span>：对象的键名存储(能对NAN去重，对象只留前面一个，基本数据类型：)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj.hasOwnProperty(<span class="keyword">typeof</span> item + item))&#123;</span><br><span class="line">      res.push(item)</span><br><span class="line">      obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">版本<span class="number">3</span>：<span class="built_in">Map</span> 的键名可以是任意类型，而不是像对象那样必须是字符串类型，所以利用这一点，简化版本<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(item))&#123;  <span class="comment">//map没有当前元素键名</span></span><br><span class="line">      res.push(item)</span><br><span class="line">      map.set(item,<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法3：filter-indexOf，基本数据类型："><a href="#方法3：filter-indexOf，基本数据类型：" class="headerlink" title="方法3：filter+indexOf，基本数据类型："></a>方法3：filter+indexOf，基本数据类型：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">法<span class="number">1</span>：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">cur,index</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// indexOf:返回的是元素在数组中跟的索引位置，-1代表不存，</span></span><br><span class="line">    <span class="comment">// 否则结果是索引位置，且是从左到右第一次找到的与该元素相等或就是该元素的位置</span></span><br><span class="line">    <span class="comment">// 所以arr.indexOf(cur) == index说明是第一次出现的元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(cur) == index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">法<span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> unique = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  arr.filter(<span class="function"><span class="params">i</span> =&gt;</span> arr.indexOf(i) === arr.lastIndexOf(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法4：Set，基本数据类型：NaN能去重，对象不可以"><a href="#方法4：Set，基本数据类型：NaN能去重，对象不可以" class="headerlink" title="方法4：Set，基本数据类型：NaN能去重，对象不可以"></a>方法4：Set，基本数据类型：NaN能去重，对象不可以</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">  <span class="comment">// 或者：return Array.from(new Set(arr))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组去重 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的5种遍历</title>
      <link href="/2021/12/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%845%E7%A7%8D%E9%81%8D%E5%8E%86/"/>
      <url>/2021/12/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%845%E7%A7%8D%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前、中、后、层遍历"><a href="#前、中、后、层遍历" class="headerlink" title="前、中、后、层遍历"></a>前、中、后、层遍历</h2><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><h3 id="1、前序遍历-144简"><a href="#1、前序遍历-144简" class="headerlink" title="1、前序遍历          144简"></a>1、前序遍历          144简</h3><h4 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  res.push(root.val);</span><br><span class="line">  preorderTraversal(root.left, res);</span><br><span class="line">  preorderTraversal(root.right, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = stack.pop();</span><br><span class="line">    res.push(n.val);</span><br><span class="line">    n.right &amp;&amp; stack.push(n.right);</span><br><span class="line">    n.left &amp;&amp; stack.push(n.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、中序遍历-94简"><a href="#2、中序遍历-94简" class="headerlink" title="2、中序遍历 94简"></a>2、中序遍历 94简</h3><h4 id="递归版本-1"><a href="#递归版本-1" class="headerlink" title="递归版本"></a>递归版本</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  inorderTraversal(root.left, res);</span><br><span class="line">  res.push(root.val);</span><br><span class="line">  inorderTraversal(root.right, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非递归版本-1"><a href="#非递归版本-1" class="headerlink" title="非递归版本"></a>非递归版本</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> cur = root;</span><br><span class="line">  <span class="keyword">while</span>(stack.length || cur)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">      stack.push(cur);</span><br><span class="line">      cur = cur.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">      res.push(node.val);</span><br><span class="line">      cur = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：遍历到了所有的节点，O(N)，N就是节点数</li><li>空间复杂度：使用了线性增长的栈，是一个数组，所以O(N)</li></ul><h3 id="3、后序遍历-145简"><a href="#3、后序遍历-145简" class="headerlink" title="3、后序遍历        145简"></a>3、后序遍历        145简</h3><p>根-右-左，再倒过来就是后续遍历了。而前面跟先序遍历很像</p><h4 id="递归版本-2"><a href="#递归版本-2" class="headerlink" title="递归版本"></a>递归版本</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  postorderTraversal(root.left, res);</span><br><span class="line">  postorderTraversal(root.right, res);</span><br><span class="line">  res.push(root.val);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非递归版本：先序取反"><a href="#非递归版本：先序取反" class="headerlink" title="非递归版本：先序取反"></a>非递归版本：先序取反</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="comment">// 中 右 左</span></span><br><span class="line">  <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = stack.pop();</span><br><span class="line">    res.push(n.val);</span><br><span class="line">    n.left &amp;&amp; stack.push(n.left);</span><br><span class="line">    n.right &amp;&amp; stack.push(n.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor(res.length / <span class="number">2</span>); i++)&#123;</span><br><span class="line">    [res[i], res[res.length-<span class="number">1</span>-i]]= [res[res.length-<span class="number">1</span>-i], res[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、广度优先遍历"><a href="#2、广度优先遍历" class="headerlink" title="2、广度优先遍历"></a>2、广度优先遍历</h4><h5 id="非递归版本-2"><a href="#非递归版本-2" class="headerlink" title="非递归版本"></a>非递归版本</h5><ul><li>新建一个队列，把根节点入队</li><li>把队头出队并访问。</li><li>把队头的children挨个入队，重复二三，直到队列为空</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">while</span>(stack.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//2.1根节点出队</span></span><br><span class="line">    <span class="keyword">const</span> n = stack.shift()</span><br><span class="line">    <span class="comment">//2.2访问出队的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(n.val)</span><br><span class="line">    <span class="comment">//3.将children入队</span></span><br><span class="line">    <span class="keyword">if</span>(n.left)&#123;stack.push(n.left)&#125;</span><br><span class="line">    <span class="keyword">if</span>(n.right)&#123;stack.push(n.right)&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、层序遍历-102简"><a href="#4、层序遍历-102简" class="headerlink" title="4、层序遍历           102简"></a>4、层序遍历           102简</h3><p>即逐层地，从左到右访问所有节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">    res.push([]);</span><br><span class="line">    <span class="keyword">let</span> len = queue.length;</span><br><span class="line">    <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">      <span class="keyword">let</span> n = queue.shift();</span><br><span class="line">      res[res.length - <span class="number">1</span>].push(n.val);</span><br><span class="line">      n.left &amp;&amp; queue.push(n.left);</span><br><span class="line">      n.right &amp;&amp; queue.push(n.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)，广度优先遍历，遍历每个节点,N是节点数</li><li>空间复杂度：线性增长的q，数组中元素的个数取决于节点数，O(N)</li></ul><h3 id="5、层序遍历2-107中-快手"><a href="#5、层序遍历2-107中-快手" class="headerlink" title="5、层序遍历2           107中   快手"></a>5、层序遍历2           107中   快手</h3><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。即取反层序遍历102</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span>[];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">    res.push([]);</span><br><span class="line">    <span class="keyword">let</span> len = queue.length;</span><br><span class="line">    <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">      <span class="keyword">let</span> n = queue.shift();</span><br><span class="line">      res[res.length - <span class="number">1</span>].push(n.val);</span><br><span class="line">      n.left &amp;&amp; queue.push(n.left);</span><br><span class="line">      n.right &amp;&amp; queue.push(n.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)，广度优先遍历，遍历每个节点,N是节点数</li><li>空间复杂度：线性增长的q，数组中元素的个数取决于节点数，O(N)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典の排序算法</title>
      <link href="/2021/12/29/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/29/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><h3 id="0、分类比较"><a href="#0、分类比较" class="headerlink" title="0、分类比较"></a>0、分类比较</h3><h4 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h4><ul><li><p><strong>非线性时间比较类排序</strong>：通过<strong>比较来决定元素间的相对次序</strong>，由于其时间不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</p></li></ul><img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402132530342-980121409.png" alt="img" style="zoom: 33%;" /><h4 id="2、复杂度对比"><a href="#2、复杂度对比" class="headerlink" title="2、复杂度对比"></a>2、复杂度对比</h4><ul><li><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p></li></ul><img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png" alt="img" style="zoom:33%;" /><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><ul><li><p>最简单的一个，但性能最差，工作很少用，但面试可能会遇到</p></li><li><p>原理：</p><ul><li>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</li><li>走访数列的工作是重复地进行直到没有再需要交换</li></ul></li><li><p>图示：</p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img" style="zoom: 50%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//this就是调用的数组</span></span><br><span class="line">  <span class="comment">// 外层循环：控制有多少趟：每趟冒泡一个最大值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 内层循环：控制每趟比较时，需要比较多少次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="built_in">this</span>.length-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>[j] &gt; <span class="built_in">this</span>[j+<span class="number">1</span>])&#123;</span><br><span class="line">        [<span class="built_in">this</span>[j], <span class="built_in">this</span>[j+<span class="number">1</span>]] = [<span class="built_in">this</span>[j+<span class="number">1</span>], <span class="built_in">this</span>[j]]; <span class="comment">// 相邻元素交换</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">arr.bubbleSort();</span><br></pre></td></tr></table></figure><ul><li>时间：两个for循环嵌套，O(n^2)</li></ul></li></ul><h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><ul><li><p>原理：（类似于老师安排小朋友排队）</p><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </li></ul></li><li><p>图示：</p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="img" style="zoom:50%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selectSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//第一轮经过循环，找到最小值，并进行交换</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="built_in">this</span>.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> indexMin = i;    <span class="comment">// 记录indexMin，遍历后面的查找是否有更小的，然后交换二者位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; <span class="built_in">this</span>.length; j++)&#123; <span class="comment">// 之前的都已经排好了</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>[j] &lt; <span class="built_in">this</span>[indexMin]) indexMin = j;</span><br><span class="line">      <span class="comment">//找到了最小值的索引，然后交换第一位</span></span><br><span class="line">      <span class="keyword">if</span>(indexMin !== i) &#123;</span><br><span class="line">        [<span class="built_in">this</span>[i], <span class="built_in">this</span>[indexMin]] = [<span class="built_in">this</span>[indexMin], <span class="built_in">this</span>[i]];<span class="comment">//将最小值交换过来</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  * 时间：两个嵌套循环，也是O(n^2)，跟冒泡一样性能差</span><br><span class="line">  * 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好</span><br><span class="line"></span><br><span class="line">### 3、插入排序 ###</span><br><span class="line"></span><br><span class="line">* 原理：</span><br><span class="line"></span><br><span class="line">  通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</span><br><span class="line"></span><br><span class="line">* 具体步骤：</span><br><span class="line"></span><br><span class="line">  * 从第一个元素开始，该元素可以认为已经被排序；</span><br><span class="line">  * 取出下一个元素，在已经排序的元素序列中从后向前扫描；</span><br><span class="line">  * 如果该元素（已排序）大于新元素，将该元素移到下一位置；</span><br><span class="line">  * 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</span><br><span class="line">  * 将新元素插入到该位置后；</span><br><span class="line">  * 重复步骤2~5。</span><br><span class="line">  </span><br><span class="line">* 图示：</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif&quot; alt=&quot;img&quot; style=&quot;zoom: 33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  Array.prototype.insertSort = function()&#123;</span><br><span class="line">    for(let i = 1; i &lt; this.length; i++)&#123;</span><br><span class="line">      const tempValue = this[i];</span><br><span class="line">      let j = i;  // 记录当前索引，从当前开始往前比较</span><br><span class="line">      while(j&gt;0)&#123;</span><br><span class="line">        //如果前面有第一个比它大的元素，前面元素后移一位</span><br><span class="line">        if(this[j-1] &gt; tempValue)&#123; </span><br><span class="line">          this[j] = this[j-1]; // 如果前面有比它大的，将那个元素后移一位</span><br><span class="line">        &#125;</span><br><span class="line">        else break; </span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      //放到合适的位置</span><br><span class="line">      this[j] = tempValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h3><ul><li><p>第一个突破O(n2)的排序算法，是简单插入排序的改进版。</p></li><li><p>它与插入排序的不同之处，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p></li><li><p>原理：</p><ul><li>核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列</li></ul></li><li><p>图示：</p><img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif" alt="img" style="zoom:33%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shellSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;         <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h3><h4 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h4><ul><li><p>分治法的一个非常典型的应用。</p></li><li><p>原理：</p><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p><p>若将两个有序表合并成一个有序表，称为2-路归并。 </p></li><li><p>实现思路</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li></ul></li><li><p>将两个排序好的子序列合并成一个最终的排序序列。</p></li><li><p>图示：</p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt="img" style="zoom:33%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, mid);</span><br><span class="line">  <span class="keyword">const</span> right = arr.slice(mid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> orderLeft = mergeSort(left); <span class="comment">// 递归到最深处</span></span><br><span class="line">  <span class="keyword">const</span> orderRight = mergeSort(right);</span><br><span class="line"><span class="keyword">return</span> merge(orderLeft, orderRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 比较左右：同时对头出队，比较，合并到res中</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> curVal = left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]? left.shift() : right.shift();</span><br><span class="line">    res.push(curVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.length) res.push(left.shift());</span><br><span class="line">  <span class="keyword">while</span> (right.length) res.push(right.shift());</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分：O(logN)，每次都把数组劈成两半，logN次。log这个函数用于求2的多少次方等于n，一个数组劈多少次变成n个数字，就是logN次。一般二分操作，基本可以联想到logN</li><li>合并的复杂度：O(n)，while循环实现的       所以总体时间: O(n*logN)</li><li>稳定排序</li></ul></li></ul><h4 id="变形面试题：合并有序数组"><a href="#变形面试题：合并有序数组" class="headerlink" title="变形面试题：合并有序数组"></a>变形面试题：合并有序数组</h4><ul><li><p>a和b都是有序的数组，利用归并排序实现合并为一个有序数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reSort = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">Math</span>.min(arr1.length, arr2.length);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> curVal = arr1[i] &lt; arr2[i] ? arr1.shift(): arr2.shift();</span><br><span class="line">    res.push(curVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(arr1.length) res.push(...arr1);</span><br><span class="line">  <span class="keyword">if</span>(arr2.length) res.push(...arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h3><ul><li><p>原理：</p><p>通过一趟排序，用分治法来把一个串（list）分为两个子串（sub-lists），分别对这两部分继续排序，以达到整个有序</p></li><li><p>实现思路：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重排数列，所有比基准值小的放在基准前面，所有比基准值大的摆在基准后面（相同的数可以到扔一边）。在这个分区退出之后，该基准就处于数列的中间位置。这称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></li><li><p>图示：</p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt="img" style="zoom: 50%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>)</span>&#123;  <span class="comment">// 版本1：</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> partitionIndex = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, partitionIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;    <span class="comment">// 分区操作</span></span><br><span class="line">  <span class="keyword">let</span> pivot = left;                    <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">  <span class="keyword">let</span> index = pivot + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;  <span class="comment">// 小于基准的，扔左边</span></span><br><span class="line">      [arr[i], arr[index]] = [arr[index], arr[i]];</span><br><span class="line">      index++;</span><br><span class="line">    &#125;       </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将基准值移到正确位置index-1</span></span><br><span class="line">[arr[pivot], arr[index - <span class="number">1</span>]] = [arr[index - <span class="number">1</span>], arr[pivot]];</span><br><span class="line">  <span class="keyword">return</span> index-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">const</span> left = [];</span><br><span class="line">  <span class="keyword">const</span> right = [];</span><br><span class="line">  <span class="keyword">const</span> mid = arr[<span class="number">0</span>]; <span class="comment">// 基准</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; mid)&#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...rec(left), mid, ...rec(right)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7、堆排序"><a href="#7、堆排序" class="headerlink" title="7、堆排序"></a>7、堆排序</h3><h4 id="1、堆：数据结构"><a href="#1、堆：数据结构" class="headerlink" title="1、堆：数据结构"></a>1、堆：数据结构</h4><ul><li><p>堆是一个完全二叉树，每层节点都完全填满，最后一层如果不是满的，则只缺少右边的</p></li><li><p>堆上的任意节点值都必须大于等于（<strong>大顶堆</strong>）或小于等于（<strong>小顶堆</strong>）其左右子节点值</p></li><li><p>二叉树是用Object来构建的，堆是一种完全二叉树的结构，为何堆用数组构建呢？</p><p>因为堆的结构，用数组表示符合以下规律</p><ul><li>第<code>i</code>个元素：其父节点为：<code>(n-1)/2</code>，左子节点为 <code>2i+1</code> ，右子节点为 <code>2i+2</code></li><li>最后一个非叶子节点为： <code>Math.floor(array.length / 2) - 1</code> </li></ul><p>例如<strong>大顶堆：</strong></p><img src="https://pic.leetcode-cn.com/1624163681-hJGivE-image.png" alt="image.png" style="zoom: 50%;" /><p>对堆中的节点按层进行编号，映射到数组中如下图</p><img src="https://pic.leetcode-cn.com/1624163693-HYBERK-image.png" alt="image.png" style="zoom:50%;" /></li><li><p>建堆方式：</p><ol start="2"><li>原地创建：又称<strong>堆化</strong>，给定一组节点，实现一个大顶堆（或小顶堆）</li><li>插入式创建：每次插入一个节点，实现一个大顶堆（或小顶堆）</li></ol></li><li><p>用途：</p><ul><li>高效快速的找出<strong>最大值/最小值</strong>，时间复杂度：O(1)。最上面的就是最大/最小</li><li>找出<strong>第K个最大（小）元素</strong><ul><li>构建一个<strong>最小堆</strong>，并将元素依次插入堆中</li><li>当堆的容量超过K，就删除堆顶（最小元素）</li><li>插入结束后，堆顶就是第K个最大元素</li></ul></li></ul></li></ul><h4 id="2、堆化建堆"><a href="#2、堆化建堆" class="headerlink" title="2、堆化建堆"></a>2、堆化建堆</h4><h5 id="思路总结："><a href="#思路总结：" class="headerlink" title="思路总结："></a>思路总结：</h5><ul><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素「沉」到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶与当前末尾元素，反复执行调整、交换步骤，直到整个序列有序。</li></ul><h5 id="构造初始堆"><a href="#构造初始堆" class="headerlink" title="构造初始堆"></a>构造初始堆</h5><ol><li><p>给定无序序列结构 </p><img src="https://pic.leetcode-cn.com/1624163715-VXPhZJ-image.png" alt="image.png" style="zoom:50%;" /></li><li><p><strong>此时从最后一个非叶子节点开始调整</strong>，从左到右，从上到下进行调整。也就是 元素为 6 的节点。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较时：先让 5 与 9 比较，得到最大那个，再和 6 比较，发现 9 大于 6，则调整他们的位置</span><br></pre></td></tr></table></figure></li><li><p>找到第二个非叶子节点 4，由于 <code>[4,9,8]</code> 中，9 元素最大，则 4 和 9 交换</p><img src="https://pic.leetcode-cn.com/1624163737-nWDnEx-image.png" alt="image.png" style="zoom: 67%;" /></li><li><p>此时，交换导致子根 <code>[4,5,6]</code> 结构混乱，将其继续调整。<code>[4,5,6]</code> 中 6 最大，将 4 与 6 调整。此时，就将一个无序序列构造成了一个大顶堆。</p><img src="https://pic.leetcode-cn.com/1624163748-vVZNTN-image.png" alt="image.png" style="zoom: 67%;" /></li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从最后一个非叶子节点开始构建大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    adjustHeap(arr, i, arr.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从左向右，自上而下的调整节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustHeap</span>(<span class="params">arr, i, len</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = i * <span class="number">2</span> + <span class="number">1</span>;             <span class="comment">// 左子节点索引</span></span><br><span class="line">  <span class="keyword">let</span> right = i * <span class="number">2</span> + <span class="number">2</span>;            <span class="comment">// 右子节点索引</span></span><br><span class="line">  <span class="keyword">let</span> maxIndex = i;                <span class="comment">// 最大值索引</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录最大值索引</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[maxIndex]) maxIndex = left;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[maxIndex]) maxIndex = right;</span><br><span class="line">  <span class="comment">// maxIndex为父节点，若发生改变则说明不是最大节点，需要交换</span></span><br><span class="line">  <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">    [arr[maxIndex], arr[i]] = [arr[i], arr[maxIndex]];</span><br><span class="line">    adjustHeap(arr, maxIndex, len); <span class="comment">// 交换之后，结构会混乱，so递归再次调整比较</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(buildMaxHeap([<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>]))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">nums,heapSize</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="built_in">Math</span>.floor(heapSize/<span class="number">2</span>)-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        maxHeapify(nums,i,heapSize)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 从左向右，自上而下的调整节点</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">nums,i,heapSize</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> l=i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">       <span class="keyword">let</span> r=i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">       <span class="keyword">let</span> largest=i</span><br><span class="line">       <span class="keyword">if</span>(l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest])&#123;</span><br><span class="line">           largest=l</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest])&#123;</span><br><span class="line">           largest=r</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(largest!==i)&#123;</span><br><span class="line">           swap(nums,i,largest) <span class="comment">// 进行节点调整</span></span><br><span class="line">           <span class="comment">// 继续调整下面的非叶子节点</span></span><br><span class="line">           maxHeapify(nums,largest,heapSize)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、插入式建堆"><a href="#3、插入式建堆" class="headerlink" title="3、插入式建堆"></a>3、插入式建堆</h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/1727787c5661104a~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 25%;" /><ul><li>时间复杂度：O(logk),k为插入堆中的元素的大小,上移操作上最多循环次数是堆的高度，而二叉树中堆的高度与节点的关系是logk</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大顶堆创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.heap = [];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">shiftUp</span>(<span class="params">index</span>)</span>&#123;        <span class="comment">//插入过程中的上移操作</span></span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//上移到堆顶了</span></span><br><span class="line">    <span class="keyword">const</span> parentIndex = (index-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">//Math.floor((i-1)/2)简化代码</span></span><br><span class="line">    <span class="comment">//与父节点比较,条件必须最后父节点小于等于该节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.heap[parentIndex] &lt; <span class="built_in">this</span>.heap[index])&#123; <span class="comment">//小顶堆这里改为 大于&gt;</span></span><br><span class="line">      [<span class="built_in">this</span>.heap[parentIndex], <span class="built_in">this</span>.heap[index]] = [<span class="built_in">this</span>.heap[index], <span class="built_in">this</span>.heap[parentIndex]];</span><br><span class="line">      <span class="built_in">this</span>.shiftUp(parentIndex); <span class="comment">// 注意传参是父节点了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.heap.push(value);</span><br><span class="line">    <span class="built_in">this</span>.shiftUp(<span class="built_in">this</span>.heap.length-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h = <span class="keyword">new</span> MinHeap();</span><br><span class="line">h.heap = [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">h.insert(<span class="number">8</span>); <span class="comment">//h.heap: [  8, 5, 6, 1, 3, 2, 4]</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>删除堆顶</strong>：</p><ul><li><strong>删除堆顶：</strong>直接删除堆顶，后面的元素会前移，会破坏堆结构。所以要用数组的尾部元素来替换堆顶，然后下移，将新堆顶和他的子节点进行交换，直到子节点大于等于这个新堆顶<ul><li>时间复杂度：O(logk)，时间主要花在下移的操作，操作也是堆的高度</li></ul></li><li><strong>获取堆顶和堆的大小</strong><ul><li>获取堆顶：数组的头部</li><li>获取堆的大小：数组的长度</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.删除栈顶</span></span><br><span class="line"><span class="function"><span class="title">pop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.heap[<span class="number">0</span>] = <span class="built_in">this</span>.heap.pop();</span><br><span class="line">  <span class="built_in">this</span>.shiftDown(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">shiftDown</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> leftIndex = index*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> rightIndex = index*<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 若子节点“左或右大于当前节点</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.heap[leftIndex] &gt; <span class="built_in">this</span>.heap[index])&#123;</span><br><span class="line">    [<span class="built_in">this</span>.heap[leftIndex], <span class="built_in">this</span>.heap[index]] = [<span class="built_in">this</span>.heap[index], <span class="built_in">this</span>.heap[leftIndex]]; <span class="comment">// 交换位置</span></span><br><span class="line">    <span class="built_in">this</span>.shiftDown(leftIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.heap[rightIndex] &gt; <span class="built_in">this</span>.heap[index])&#123;</span><br><span class="line">    [<span class="built_in">this</span>.heap[rightIndex], <span class="built_in">this</span>.heap[index]] = [<span class="built_in">this</span>.heap[index], <span class="built_in">this</span>.heap[rightIndex]]; <span class="comment">// 交换位置</span></span><br><span class="line">    <span class="built_in">this</span>.shiftDown(rightIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、堆排序"><a href="#4、堆排序" class="headerlink" title="4、堆排序"></a>4、堆排序</h4><ul><li><p>堆排序可以认为是<strong>选择排序的改进版</strong>，像<a href="https://juejin.cn/post/7034819462687621133">选择排序</a>一样将输入划分为已排序和待排序</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">heapSort(arr);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line">  buildMaxHeap(array); <span class="comment">// 构建一个大顶堆</span></span><br><span class="line">  <span class="comment">// 调整为大顶堆后，顶元素为最大元素并与末尾元素交换</span></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123; <span class="comment">// 当len&lt;= 0时，说明已经到堆顶</span></span><br><span class="line">    [array[<span class="number">0</span>], array[len - <span class="number">1</span>]] = [array[len - <span class="number">1</span>], array[<span class="number">0</span>]]; <span class="comment">// 交换</span></span><br><span class="line">    len--; <span class="comment">// 交换之后相当于把树中的最大值弹出去了，所以len--</span></span><br><span class="line">    <span class="comment">// 交换值并剔除了最大值后，继续调整使之再次成为大顶堆</span></span><br><span class="line">    adjustHeap(array, <span class="number">0</span>, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>建堆过程的时间是 <code>O(n)</code> ，排序过程的时间是 <code>O(nlogn)</code> ，整体时间是 <code>O(nlogn)</code></li></ul></li></ul><h3 id="8、计数排序-略"><a href="#8、计数排序-略" class="headerlink" title="8、计数排序  略"></a>8、计数排序  略</h3><h3 id="9、桶排序-略"><a href="#9、桶排序-略" class="headerlink" title="9、桶排序    略"></a>9、桶排序    略</h3><h3 id="10、基数排序-略"><a href="#10、基数排序-略" class="headerlink" title="10、基数排序  略"></a>10、基数排序  略</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的一些方法</title>
      <link href="/2021/12/29/%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
      <url>/2021/12/29/%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><h4 id="1、splice"><a href="#1、splice" class="headerlink" title="1、splice"></a>1、splice</h4><p>作用：向数组中添加/删除项目，然后返回被删除的项目构成的新数组，同时原数组也发生了改变</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure><ul><li><p>index：添加/删除项目的位置，使用负数可从数组结尾处规定位置 —必需</p></li><li><p>howmany：要删除的项目数量。<strong>如果设置为 0</strong>，<strong>则不会删除项目</strong> –必需</p></li><li><p>第3项：向数组添加的新项目      –可选</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;William&quot;</span>)<span class="comment">//创建一个新数组，并将索引为2的那项添加wiliam，后面的索引依次后移</span></span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;William&quot;</span>) <span class="comment">//删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素</span></span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;William&quot;</span>) <span class="comment">//删除从 index 2 (&quot;Thomas&quot;) 开始的三个元素，并添加一个新元素 (&quot;William&quot;) 来替代被删除的元素</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、slice：没有修改原数组，返回新数组"><a href="#2、slice：没有修改原数组，返回新数组" class="headerlink" title="2、slice：没有修改原数组，返回新数组"></a>2、slice：没有修改原数组，返回新数组</h4><p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</p><ul><li>若传参为空，则返回数组拷贝</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arrayObject.slice(start,end)</span><br></pre></td></tr></table></figure><ul><li>start：从何处开始选取。负数，从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。  —必需</li><li>end：从何处结束选取。如果没有指定，那么start到数组结束的所有元素，负数，从数组尾部开始算起   –可选</li></ul><h4 id="3、filter"><a href="#3、filter" class="headerlink" title="3、filter"></a>3、filter</h4><ul><li><p>遍历数组中每一个元素，返回所有函数返回结果为true的元素，这些元素构成的数组就是filter()方法的返回值</p></li><li><p>```js<br>// 定义数组<br>var names = [“abc”, “cb”, “mba”, “dna”]</p><p>// 获取names中所有包含’a’字符的元素<br>var newNames = names.filter(function (t) {</p><pre><code>return t.indexOf(&quot;a&quot;) != -1</code></pre><p>})</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">array.filter(function(value,index,array),contetx)</span><br><span class="line">- value—当前数组值，必须</span><br><span class="line">- index—数组索引，非必须</span><br><span class="line">- array—当前数组，非必须</span><br><span class="line">- context—指定回调函数的this值，一般不穿，默认是undefined的</span><br></pre></td></tr></table></figure></li></ul><ul><li>实现如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span>(<span class="params">fn,context</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 调用.myFilter方法的那个数组</span></span><br><span class="line">      <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">var</span> newArr = []</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fn.call(context,arr[i],i,arr))&#123;</span><br><span class="line">          newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToFilter = <span class="function"><span class="keyword">function</span> (<span class="params">fn,context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.call(<span class="built_in">this</span>, current, index)) &#123;</span><br><span class="line">      target.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、map"><a href="#4、map" class="headerlink" title="4、map"></a>4、map</h4><ul><li>遍历数组，每个元素经过某函数的作用后，变成新元素，最后形成一个新数组</li><li>与forEach的区别：<ol><li>forEach返回的是undefined，因此它也不支持链式调用；而map不改变原数组但是会 返回新数组</li><li>forEach没有返回值，不可以中断，不能使用return返回到外层函数；map可以break中断循环，可以return返回到外层函数<ul><li>forEach() 对于空数组是不会执行回调函数的。</li><li>for可以用continue跳过循环中的一个迭代，forEach用continue会报错。</li><li>forEach() 需要用 return 跳过循环中的一个迭代，跳过之后会执行下一个迭代。</li></ul></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,array</span>), <span class="title">context</span>)</span></span><br><span class="line"><span class="function">- <span class="title">value</span>—当前数组值，必须</span></span><br><span class="line"><span class="function">- <span class="title">index</span>—数组索引，非必须</span></span><br><span class="line"><span class="function">- <span class="title">array</span>—该数组，非必须</span></span><br><span class="line"><span class="function">- <span class="title">context</span>—指定回调函数的<span class="title">this</span>值</span></span><br></pre></td></tr></table></figure><ul><li>实现如下</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="comment">//map处理完就push</span></span><br><span class="line">    newArr.push(fn.call(context, arr[i], i, arr))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">用reduce实现map</span><br><span class="line"><span class="built_in">Array</span>.prototype.reduceToMap = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line"><span class="comment">// this就是使用map的数组实例</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">target.push(fn.call(<span class="built_in">this</span>, current, index))</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5、reduce"><a href="#5、reduce" class="headerlink" title="5、reduce"></a>5、reduce</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur,index,arr</span>),<span class="title">initalval</span>)</span></span><br><span class="line"><span class="function">- <span class="title">pre</span>—当前累加值，必须</span></span><br><span class="line"><span class="function">- <span class="title">cur</span>—当前数组值，必须</span></span><br><span class="line"><span class="function">- <span class="title">index</span>—数组索引，非必须</span></span><br><span class="line"><span class="function">- <span class="title">arr</span>—该数组，非必须</span></span><br><span class="line"><span class="function">- <span class="title">initalVal</span>—累加值初始值，非必须，**不传值的话，数组第一个元素为默认值**</span></span><br></pre></td></tr></table></figure><ul><li>实现核心：没有传入initalVal时，初始值设为数组第1个元素，并从第2个元素开始便利。回到函数应该处理第二个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myReduce=<span class="function"><span class="keyword">function</span>(<span class="params">fn,inital</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> arr = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">let</span> total = inital ? inital:arr[<span class="number">0</span>]  <span class="comment">//关键</span></span><br><span class="line">      <span class="keyword">let</span> startIndex = inital ? <span class="number">0</span>:<span class="number">1</span>       <span class="comment">//关键</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=startIndex; i&lt;arr.length; i++)&#123;</span><br><span class="line">        total = fn.call(<span class="literal">null</span>,total,arr[i],i,arr); <span class="comment">//注意要传入一个null，第二个是total</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Sort"><a href="#6、Sort" class="headerlink" title="6、Sort"></a>6、Sort</h4><p>在原数组上排序，不生成副本</p><ul><li><p>若参数为空，按照字符编码的顺序进行排序</p></li><li><p>其他标准：提供比较函数</p><ul><li><p>该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数 a 和 b，其返回值如下：</p><ul><li><p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</p></li><li><p>若 a 等于 b，则返回 0。</p></li><li><p>若 a 大于 b，则返回一个大于 0 的值</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="built_in">Array</span>.from(map).sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 如果a是较小的，那么b[1]-a[1]就是正的。a应该在b之后。所以输出是降序排列</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7、some"><a href="#7、some" class="headerlink" title="7、some"></a>7、some</h4><p>只要有一个元素比对结果为true，返回结果就为true</p><h4 id="8、every"><a href="#8、every" class="headerlink" title="8、every"></a>8、every</h4><ul><li><p>使用指定函数检测数组中的所有元素是否都符合指定条件，所有符合，return true，否则返回false</p></li><li><p>不会改变原始数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9、Array-from"><a href="#9、Array-from" class="headerlink" title="9、Array.from"></a>9、Array.from</h4><ul><li>从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例<ul><li>伪数组对象（拥有一个 <code>length</code> 属性和若干索引属性的任意对象）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/iterable">可迭代对象</a>（可以获取对象中的元素,如 Map和 Set 等）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">// [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ] 从 String 生成数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]);  从 <span class="built_in">Set</span> 生成数组</span><br><span class="line"><span class="built_in">Array</span>.from(set);     <span class="comment">// [ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapper = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]);  <span class="comment">//从 Map 生成数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(map);    <span class="comment">//[[&#x27;1&#x27;, &#x27;a&#x27;], [&#x27;2&#x27;, &#x27;b&#x27;]]</span></span><br><span class="line"><span class="built_in">Array</span>.from(mapper.values());  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;];</span></span><br><span class="line"><span class="built_in">Array</span>.from(mapper.keys());   <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;];</span></span><br><span class="line"></span><br><span class="line">从类数组对象（<span class="built_in">arguments</span>）生成数组</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">x</span> =&gt;</span> x + x);       <span class="comment">// [2, 4, 6] 在 Array.from 中使用箭头函数</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i);    <span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="built_in">Array</span>.from(map).sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="是否改变数组"><a href="#是否改变数组" class="headerlink" title="是否改变数组"></a>是否改变数组</h3><ul><li><h4 id="改变：push、unshift、pop、shift、reverse-、sort、splice"><a href="#改变：push、unshift、pop、shift、reverse-、sort、splice" class="headerlink" title="改变：push、unshift、pop、shift、reverse 、sort、splice"></a>改变：push、unshift、pop、shift、reverse 、sort、splice</h4></li><li><h4 id="不改变：concat-、map、every、some-、filter、toString、slice-、join、indexOf"><a href="#不改变：concat-、map、every、some-、filter、toString、slice-、join、indexOf" class="headerlink" title="不改变：concat 、map、every、some 、filter、toString、slice 、join、indexOf"></a>不改变：concat 、map、every、some 、filter、toString、slice 、join、indexOf</h4></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域中的CORS、JSONP</title>
      <link href="/2021/12/27/%E8%B7%A8%E5%9F%9F%E4%B8%AD%E7%9A%84CORS%E3%80%81JSONP/"/>
      <url>/2021/12/27/%E8%B7%A8%E5%9F%9F%E4%B8%AD%E7%9A%84CORS%E3%80%81JSONP/</url>
      
        <content type="html"><![CDATA[<h3 id="方案1、CORS（跨域资源共享）"><a href="#方案1、CORS（跨域资源共享）" class="headerlink" title="方案1、CORS（跨域资源共享）"></a>方案1、CORS（跨域资源共享）</h3><p>浏览器与服务器商量后的一个结果</p><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><ul><li><p>是一种机制，使用额外的 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 头来允许服务器声明哪些源 可以通过浏览器有权限访问哪些资源。</p></li><li><p>不需要在客户端做任何特殊的操作，浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p></li><li><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><ul><li>简单请求：不会触发预检请求的请求</li><li>复杂请求：除了简单请求</li></ul></li></ul><h4 id="2、简单请求如何工作"><a href="#2、简单请求如何工作" class="headerlink" title="2、简单请求如何工作"></a>2、简单请求如何工作</h4><p>浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息添加一个<code>Origin</code>字段：</p><ul><li>用来说明，本次请求来自哪个源（协议 + 域名 + 端口）</li><li>服务器根据这个值，决定是否同意这次请求</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="attr">Origin</span>: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line"><span class="attr">Connection</span>: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure><ol><li><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应：</p><p>浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获</p><p>【注意】：这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200</p></li><li><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p></li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line">// 指定后，可以返回`FooBar`字段的值</span><br><span class="line"><span class="attribute">Access-Control-Expose-Headers</span><span class="punctuation">: </span>FooBar</span><br><span class="line"></span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><ul><li>必须。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求</li></ul><p><strong>（2）Access-Control-Allow-Credentials</strong></p><ul><li><p>可选。它的值是一个布尔值，表示<strong>是否允许发送Cookie</strong></p></li><li><p>默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p></li><li><p>这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可</p></li></ul><p><strong>（3）Access-Control-Expose-Headers</strong></p><ul><li><p>可选，CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code></p></li><li><p>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定</p></li></ul><h4 id="3、-withCredentials-属性"><a href="#3、-withCredentials-属性" class="headerlink" title="3、 withCredentials 属性"></a>3、 withCredentials 属性</h4><ol><li>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段</li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理</li></ol><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</li></ol><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></blockquote><p>【注意】：</p><ol><li>如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</li><li>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传</li><li>且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie</li></ol><h4 id="4、复杂请求如何工作"><a href="#4、复杂请求如何工作" class="headerlink" title="4、复杂请求如何工作"></a>4、复杂请求如何工作</h4><p>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求，通过该请求来知道服务端是否允许跨域请求</p><ul><li>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段</li><li>只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错</li></ul><h4 id="4-1、预检请求的发送"><a href="#4-1、预检请求的发送" class="headerlink" title="4.1、预检请求的发送"></a>4.1、预检请求的发送</h4><ul><li><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p></li><li><p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段</p></li></ul><p><strong>（1）Access-Control-Request-Method</strong></p><ul><li>必须，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code></li></ul><p><strong>（2）Access-Control-Request-Headers</strong></p><ul><li>是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code></li></ul><p>下面是一段浏览器的JavaScript脚本。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://api.alice.com/cors&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></blockquote><p>这个”预检”请求的HTTP头信息。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2、预检请求的回应"><a href="#4-2、预检请求的回应" class="headerlink" title="4.2、预检请求的回应"></a>4.2、预检请求的回应</h4><ul><li><p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应</p></li><li><p>HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure></blockquote><ol><li>HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li><p>如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但没有任何CORS相关的头信息字段</p><p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure></li><li><p>服务器回应的其他CORS相关字段如下。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span><span class="punctuation">: </span>1728000</span><br></pre></td></tr></table></figure></blockquote><h5 id="（1）Access-Control-Allow-Methods"><a href="#（1）Access-Control-Allow-Methods" class="headerlink" title="（1）Access-Control-Allow-Methods"></a>（1）Access-Control-Allow-Methods</h5><ul><li>必须，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</li><li>返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求</li></ul><h5 id="（2）Access-Control-Allow-Headers"><a href="#（2）Access-Control-Allow-Headers" class="headerlink" title="（2）Access-Control-Allow-Headers"></a>（2）Access-Control-Allow-Headers</h5><ul><li>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的</li><li>也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段</li></ul><h5 id="（3）Access-Control-Allow-Credentials"><a href="#（3）Access-Control-Allow-Credentials" class="headerlink" title="（3）Access-Control-Allow-Credentials"></a>（3）Access-Control-Allow-Credentials</h5><ul><li>该字段与简单请求时的含义相同</li></ul><h5 id="（4）Access-Control-Max-Age"><a href="#（4）Access-Control-Max-Age" class="headerlink" title="（4）Access-Control-Max-Age"></a>（4）Access-Control-Max-Age</h5><ul><li>可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天）</li><li>在此期间，不用发出另一条预检请求</li></ul></li></ol><h4 id="4-3-、浏览器的正常请求和回应"><a href="#4-3-、浏览器的正常请求和回应" class="headerlink" title="4.3 、浏览器的正常请求和回应"></a>4.3 、浏览器的正常请求和回应</h4><ul><li><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会自动有一个<code>Origin</code>头信息字段。</p></li><li><p>服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p></li></ul><p>下面是”预检”请求之后，浏览器的正常CORS请求。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">X-Custom-Header</span><span class="punctuation">: </span>value</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure></blockquote><p>下面是服务器正常的回应</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-4、配置流程："><a href="#4-4、配置流程：" class="headerlink" title="4.4、配置流程："></a>4.4、配置流程：</h4><ul><li><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如上面所说的，后端是实现 CORS 通信的关键</p></li><li><p>前端：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;name=xiamen&#x27;</span> <span class="comment">// cookie不能跨域</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span> <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;http://localhost:4000/getData&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xiamen&#x27;</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure></li><li><p>后端配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server1.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server2.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">&#x27;http://localhost:3000&#x27;</span>] <span class="comment">//设置白名单</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.headers.origin;</span><br><span class="line">  <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)</span><br><span class="line">    <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">    <span class="comment">// 允许携带cookie</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 预检的存活时间</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 允许返回的头</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      res.end() <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(<span class="string">&#x27;/getData&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.setHeader(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jw&#x27;</span>) <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">  res.end(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/getData&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.end(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line">app.listen(<span class="number">4000</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、与JSONP比较"><a href="#5、与JSONP比较" class="headerlink" title="5、与JSONP比较"></a>5、与JSONP比较</h4><p>使用目的相同，但是比JSONP更强大：</p><ul><li>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求</li><li>JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</li></ul><h4 id="6、简单、复杂请求"><a href="#6、简单、复杂请求" class="headerlink" title="6、简单、复杂请求"></a>6、简单、复杂请求</h4><h5 id="1、简单请求"><a href="#1、简单请求" class="headerlink" title="1、简单请求"></a>1、简单请求</h5><p>不会触发 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS%23Preflighted_requests">CORS 预检请求</a>。这样的请求为“简单请求”：</p><ul><li><p>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</p><ul><li>get、head、post</li></ul></li><li><p>情况二: 人为设置以下集合外的请求头</p><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> （需要注意额外的限制）</li><li><code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code></li></ul></li><li><p>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 application/json 为非简单请求)</p><ul><li><code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code></li></ul></li><li><p>情况四:</p><p>请求中的任意<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload"><code>XMLHttpRequest.upload</code></a> 属性访问</p></li><li><p>情况五:</p><p>请求中没有使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 对象</p></li></ul><h5 id="2、复杂请求"><a href="#2、复杂请求" class="headerlink" title="2、复杂请求"></a>2、复杂请求</h5><p>除了简单请求</p>]]></content>
      
      
      <categories>
          
          <category> Ajax、Axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>animation动画的demo</title>
      <link href="/2021/12/25/CSS%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BBanimation-demo/"/>
      <url>/2021/12/25/CSS%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BBanimation-demo/</url>
      
        <content type="html"><![CDATA[<h2 id="明天再复习一下，会再更新的…"><a href="#明天再复习一下，会再更新的…" class="headerlink" title="明天再复习一下，会再更新的…."></a>明天再复习一下，会再更新的….</h2><h3 id="animation动画demo"><a href="#animation动画demo" class="headerlink" title="animation动画demo"></a>animation动画demo</h3><h4 id="实现物体移动"><a href="#实现物体移动" class="headerlink" title="实现物体移动"></a>实现物体移动</h4><img src="https://doc.houdunren.com/assets/img/Untitled-8874535.c42328d7.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>定义不同时间点来让物体元素移动一圈，这里就可以不设置<code>from/to</code> 系统将定义为元素初始状态。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">2px</span> white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e67e22</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;&#125;  // 不设置：仍然是原始状态</span><br><span class="line">  <span class="number">25%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">300%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">300%</span>, <span class="number">300%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">75%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">300%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="炫彩背景"><a href="#炫彩背景" class="headerlink" title="炫彩背景"></a>炫彩背景</h4><img src="https://doc.houdunren.com/assets/img/Untitled-8878649.86285441.gif" alt="Untitled" style="zoom: 25%;" /><p>声明三个动画，使用 <code>animation-duration</code>为每个动画设置不同执行的时间</p><ul><li><p>DOm结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">main</span>&gt;&lt;/<span class="selector-tag">main</span>&gt;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#34495e</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: scale, colors, rotate;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>, <span class="number">5s</span>, <span class="number">1s</span>;   // <span class="number">3</span>种动画执行次数不同</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>旋转、颜色、大小：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> scale &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> colors &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#e67e22</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#34495e</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#16a085</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rotate &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="心动的感觉"><a href="#心动的感觉" class="headerlink" title="心动的感觉"></a>心动的感觉</h4><img src="https://doc.houdunren.com/assets/img/Untitled-8894047.f0ee8861.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>心的构成：两个圆+正方形，圆把正方形压住。整体旋转正</p><img src="https://doc.houdunren.com/assets/img/image-20190919170506721.7bd12d30.png" alt="image-20190919170506721" style="zoom:25%;" /></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;heart&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);<span class="comment">/*旋转变正*/</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">animation-name</span>: heart;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">::before</span> &#123;   <span class="comment">/* 两个圆的1号圆：圆的直径等于正方形的边长*/</span></span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0px</span>);  <span class="comment">/* 在垂直方向居中 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">::after</span> &#123;  <span class="comment">/* 两个圆的2号圆*/</span></span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> heart &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">3</span>) <span class="built_in">rotate</span>(<span class="number">45deg</span>); <span class="comment">/*此处的rotate(45deg)不要拿掉了，原本是这样的*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">rotate</span>(<span class="number">45deg</span>);<span class="comment">/*变大：跳动*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个心跳"><a href="#多个心跳" class="headerlink" title="多个心跳"></a>多个心跳</h4><img src="https://doc.houdunren.com/assets/img/Untitled-9072635.d0d86895.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>Dom结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>normal<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>reverse<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>alternate<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>alternate-reverse<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>主要样式部分：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  // 设置具体宽高....</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">// 设置<span class="selector-tag">li</span>下面列方向排列....</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd;  </span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&gt;<span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">animation-direction</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&gt;<span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">animation-direction</span>: reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)&gt;<span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>)&gt;<span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="弹跳的小球"><a href="#弹跳的小球" class="headerlink" title="弹跳的小球"></a>弹跳的小球</h4><img src="https://doc.houdunren.com/assets/img/Untitled-8895617.c0966e33.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>使用合适的运动方向 <code>alternate-reverse</code> 制作跳动的小球：0-100  100 -0</p><ul><li>球落下和弹起，相反的过程；</li><li>落下和弹起时阴影模糊程度变大，减轻</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  // 设置阴影</span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置球的样式 */</span> ....省略</span><br><span class="line">  <span class="attribute">animation-name</span>: ball;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> ball &#123;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">600px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: shadow;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> shadow &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">9</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="微场景"><a href="#微场景" class="headerlink" title="微场景"></a>微场景</h4><img src="https://doc.houdunren.com/assets/img/Untitled-8899531.e8d14a71.gif" alt="Untitled" style="zoom: 33%;" /><ul><li><p>基本Dom结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  后盾人</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lesson&quot;</span>&gt;</span></span><br><span class="line">    系统课程是多个实战课程的组合，用来全面掌握一门</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;video hd-translate&quot;</span>&gt;</span></span><br><span class="line">    fsgdgfh艾弗森课程的组合，用来全面掌握一门语</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">  houdunren.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CSS部分：重点是动画设置：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-translate;  // 隐藏---出现</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-rotate;  // 隐藏---出现 +选择<span class="number">1</span>圈（xy平面）</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-class">.lesson</span> &#123;</span><br><span class="line">  //... 基本布局</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100vw</span>, -<span class="number">100vh</span>); //控制原始状态隐藏</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-rotate;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-class">.video</span> &#123;</span><br><span class="line">  //... 基本布局</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-translate;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100vw</span>, -<span class="number">100vh</span>);</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  //... 基本布局</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-skew; // 倾斜</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">3s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100vw</span>);</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd-translate &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100vw</span>, -<span class="number">100vh</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd-rotate &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100%</span>, -<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd-skew &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>) <span class="built_in">skew</span>(-<span class="number">45deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="柱状起落"><a href="#柱状起落" class="headerlink" title="柱状起落"></a>柱状起落</h4><img src="https://doc.houdunren.com/assets/img/Untitled-9379048.a9342460.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>5条不同的柱状，下降曲线不同的效果</p></li><li><p>Dom结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ease<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ease-in<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ease-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ease-in-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>linear<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>样式设置：</p><ul><li></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr;  //只有<span class="number">1</span>行<span class="number">1</span>列</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;houdunren.com&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">5</span>, <span class="number">1</span>fr);  // <span class="number">1</span>行<span class="number">5</span>列</span><br><span class="line">  gap: <span class="number">10px</span>;   //每列间隔</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">animation-name</span>: move;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">3s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">90vh</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="改进弹跳小球"><a href="#改进弹跳小球" class="headerlink" title="改进弹跳小球"></a>改进弹跳小球</h4><img src="https://doc.houdunren.com/assets/img/Untitled-9139804.a095202a.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>改进的点：优化小球弹起过程幅度越来越小</p></li><li><p>如果想多个小球，可以再设置一个，位置上区分开，动画延时错开</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  //...</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0vw</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(at right top, <span class="number">#f39c12</span>, <span class="number">#d35400</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: jump;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> jump &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">30%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">10vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">60%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">40vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">80%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">60vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">95%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">75vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">15%</span>,<span class="number">45%</span>,<span class="number">70%</span>,<span class="number">85%</span>,<span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">80vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="魔术的小球"><a href="#魔术的小球" class="headerlink" title="魔术的小球"></a>魔术的小球</h4><img src="https://doc.houdunren.com/assets/img/Untitled-8904065.907dbaa9.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>效果：一群球不同时间进去，不同时间出来</p></li><li><p>乱跳的效果：控制动画%更小一点，精细一点</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  // ....</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">20vw</span>, -<span class="number">300%</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(at right top, <span class="number">#f39c12</span>, <span class="number">#d35400</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: jump;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1.5s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: .<span class="number">2s</span>;    <span class="comment">/*分别延迟不同的时间*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> jump &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">20vw</span>, -<span class="number">300%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">10%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">15vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">20%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">20vw</span>, -<span class="number">200%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">30%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">30vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">40%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">40vw</span>, -<span class="number">120%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">50vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">60%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">60vw</span>, -<span class="number">70%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">70%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">70vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">80%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">80vw</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">90%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">90vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">95%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">95vw</span>, -<span class="number">30%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">100vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="comment">/* transform: translateY(-400%); */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="comment">/* right: 100px; */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="按钮提交"><a href="#按钮提交" class="headerlink" title="按钮提交"></a>按钮提交</h4><ul><li><p>模拟向后台提交数据时，等待的那种效果</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 只保留了主要功能代码 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="comment">/*移动第一个宽度   3个宽度   5个宽度*/</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">0</span> currentColor, <span class="number">9px</span> <span class="number">0</span> currentColor, <span class="number">15px</span> <span class="number">0</span> currentColor;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">animation-name</span>: point;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> point &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;  //起始的时候没有点</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">30%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">0</span> currentColor; // 只有<span class="number">1</span>个点</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">60%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">0</span> currentColor, <span class="number">9px</span> <span class="number">0</span> currentColor; //<span class="number">2</span>个点</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">90%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">0</span> currentColor, <span class="number">9px</span> <span class="number">0</span> currentColor, <span class="number">15px</span> <span class="number">0</span> currentColor; //<span class="number">3</span>个点</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>阴影使用API：原理就是底下有个黑盒子，所以最大水平移动自己宽度，再继续移就出来了。</p></li><li><p>如果给某个元素设置颜色color，就是阴影的颜色</p></li><li><p>background-color:orange;是元素本身的颜色</p></li><li><p>concurentColor：指的是当前的文本颜色</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>h-shadow</em></td><td align="left">必需。水平阴影的位置。允许负值。</td></tr><tr><td align="left"><em>v-shadow</em></td><td align="left">必需。垂直阴影的位置。允许负值。</td></tr><tr><td align="left"><em>blur</em></td><td align="left">可选。模糊距离。</td></tr><tr><td align="left"><em>spread</em></td><td align="left">可选。阴影的尺寸。</td></tr><tr><td align="left"><em>color</em></td><td align="left">可选。阴影的颜色。请参阅 CSS 颜色值。</td></tr><tr><td align="left">inset</td><td align="left">可选。将外部阴影 (outset) 改为内部阴影。</td></tr></tbody></table></li></ul></li></ul><h4 id="步进动画steps"><a href="#步进动画steps" class="headerlink" title="步进动画steps"></a>步进动画steps</h4><img src="https://doc.houdunren.com/assets/img/Untitled-9469170.45d93747.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p><code>steps(n,start)</code> 可以简单理解为从第二个开始，<code>steps(n,end)</code> 从第一个开始</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">main</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">1</span> &lt;small&gt;houdunren<span class="selector-class">.com</span>&lt;/small&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">2</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">3</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">4</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">5</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">6</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">7</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">8</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">main</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;END&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;  //父元素相对定位，<span class="attribute">z-index</span>浮在上面</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e67e22</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">animation-name</span>: move;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">4</span>, end);</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;START&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#9b59b6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">animation-name</span>: move;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">4</span>, start); //从<span class="number">2</span>开始的</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">400px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改效果为：在1-2之间来回走</p><img src="https://doc.houdunren.com/assets/img/Untitled-9484950.4ca2375f.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>此时如果只是修改translate的距离100，step的n为1就不可以，不会动，因为你只有1步</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)<span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2.5s</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;START&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#8e44ad</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: step-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;END&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#27ae60</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: step-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd &#123;</span><br><span class="line">  <span class="number">50%</span> &#123; </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);  //修改此处</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);  //回到原处</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="纯css轮播"><a href="#纯css轮播" class="headerlink" title="纯css轮播"></a>纯css轮播</h4><img src="https://doc.houdunren.com/assets/img/Untitled-9059867.a86bf9bf.gif" alt="Untitled" style="zoom: 33%;" /><ul><li><p>使用无JS参与的图片轮换效果，图片切换使用<code>steps</code> 步进与<code>animation-play-state</code>播放状态</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">5px</span> <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">section</span> &#123; // 鼠标经过暂停：图片+数字</span><br><span class="line">  <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">ul</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">animation-name</span>: slide;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">4s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">4</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> <span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  //<span class="attribute">flex</span>居中...</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  //<span class="attribute">flex</span>居中...</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  //画圆....</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">animation-name</span>: num;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">4s</span>;   //时间一致保持同步</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">4</span>, end);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> slide &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> num &#123;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h4><img src="https://doc.houdunren.com/assets/img/Untitled-9067254.58a8233a.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>具体区别：</p><ol><li>none：等待后，第1帧–结束–直接恢复到起始状态</li><li>backwards：等待过程中，使用的是第一帧的效果</li><li>forwards：执行技术完后，定在结束帧（等待验收）</li><li>both：结合两个，起始的时候使用的就是第一帧的效果，执行技术完后，定在结束帧（等待验收）</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>none<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>backwards<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>forwards<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>both<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>houdunren.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ecf0f1</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: backwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#9b59b6</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>animation动画基本使用</title>
      <link href="/2021/12/25/CSS%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BBanimation/"/>
      <url>/2021/12/25/CSS%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BBanimation/</url>
      
        <content type="html"><![CDATA[<h3 id="动画animation"><a href="#动画animation" class="headerlink" title="动画animation"></a>动画animation</h3><h4 id="1、关键帧"><a href="#1、关键帧" class="headerlink" title="1、关键帧"></a>1、关键帧</h4><ul><li>使用<code>@keyframes</code> 规则配置动画中的各个帧<ul><li>from 表示起始点（可以用 0% 代替），to表示终点（可以用 100% 代替）</li><li>可以用百分数如 20%，动画运行到20%时间时</li><li>动画命名不要使用CSS关键字如 <code>none</code></li></ul></li></ul><h4 id="2、时间点"><a href="#2、时间点" class="headerlink" title="2、时间点"></a>2、时间点</h4><p>帧动画需要定义在不同时间执行的动作，开始与结束可以用 <code>form/to</code> 或 <code>0%/100%</code> 声明。</p><ul><li>必须添加百分号，25%是正确写法</li><li>时间点没有顺序要求，即100%写在25%前也可以</li><li>未设置<code>0%</code>与<code>100%</code> 时<strong>将使用元素原始状态</strong></li><li>时间点可以动画样式一样时可以一起声明（类似于h1, h2 样式一样时，写在一起）。</li></ul><h4 id="3、动画名"><a href="#3、动画名" class="headerlink" title="3、动画名"></a>3、动画名</h4><ul><li><p>使用<code>animation-name</code> 规则可以在元素身上<strong>同时使用多个动画。</strong></p><ul><li><p>使用多个动画时用逗号分隔</p></li><li><p>多个动画有相同属性时，<strong>后面动画的属性优先使用</strong>：多个动画对用一个元素操作同一属性时，后面动画优先级更高</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation-name</span>: scale, colors, rotate; </span><br><span class="line">// 假如rotate与colors设置过相同的属性，优先rotate设置，rotate时间用完了，才会有colors用，因此入股ocolors的持续时间=== 或&lt; rotate的时间，是没机会生效的</span><br><span class="line"><span class="attribute">animation-duration</span>: <span class="number">1s</span>, <span class="number">5s</span>, <span class="number">1s</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>不是所有的属性都会产生动画效果：</p><ul><li><p>一般有中间值的属性都可以设置动画如宽度、透明度等。但是宽度不能设置auto这样的值，因为无法计算中间值。如果是auto会马上变成最终效果，没有动画过渡效果。</p></li><li><p>比如solid和dotted这种，没有中间值，不是慢慢演化改变的。</p></li></ul></li></ul><h4 id="4、持续时间"><a href="#4、持续时间" class="headerlink" title="4、持续时间"></a>4、持续时间</h4><ul><li>使用 <code>animation-duration</code> 可以声明动画播放的时间，即把所有帧执行一遍所需要的时间。<ul><li>可以使用m秒，ms毫秒时间单位</li><li>可为不同动画单独设置执行时间</li><li>如果动画数量大于时间数量，将重新从时间列表中计算</li></ul></li></ul><h4 id="5、重复播放次数-循环"><a href="#5、重复播放次数-循环" class="headerlink" title="5、重复播放次数-循环"></a>5、重复播放次数-循环</h4><ul><li><code>animation-iteration-count</code> 规则设置动画<strong>重复执行</strong>次数，设置值为 <code>infinite</code> 表示无限循环执行。<ul><li>可同时设置元素的多个动画重复，使用逗号分隔</li><li>如果动画数量大于重复数量定义，后面的动画将重新计算重复</li></ul></li></ul><h4 id="6、-运行方向"><a href="#6、-运行方向" class="headerlink" title="6、 运行方向"></a>6、 运行方向</h4><ul><li><code>animation-direction</code> 控制动画运行的方向<ul><li>normal：    从0%到100%运行动画，活干完了，<strong>一下子瞬间收回去；</strong></li><li>reverse：    从100%到0%运行动画</li><li>alternate：    先从0%到100%，然后从100%到0%，活干完了，<strong>慢慢再收回去；</strong></li><li>alternate-reverse：    先从100%到0%，然后从0%到100%</li></ul></li></ul><h4 id="7、动画延迟"><a href="#7、动画延迟" class="headerlink" title="7、动画延迟"></a>7、动画延迟</h4><ul><li>使用 <code>animation-delay</code> 规则定义动画等待多长时间后执行；</li><li>使用情况分析：<ul><li>假如希望一个动画，先延迟2秒再执行，可以通过将50%的样式设置为跟初始一样，比如scale(1)；</li><li>但如果动画执行次数是无限次，那么每次开始前都有等待时间，但我不想这样的效果，希望每次开始后，不要再等了：此时就可以用 <code>animation-delay</code> 这个属性了。</li></ul></li><li>例子：微场景</li></ul><h4 id="8、动画速率"><a href="#8、动画速率" class="headerlink" title="8、动画速率"></a>8、动画速率</h4><ul><li><h5 id="系统属性：可以在帧中单独定义，将影响当前帧的速率"><a href="#系统属性：可以在帧中单独定义，将影响当前帧的速率" class="headerlink" title="系统属性：可以在帧中单独定义，将影响当前帧的速率"></a>系统属性：可以在帧中单独定义，将影响当前帧的速率</h5><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">linear</td><td align="left">规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td></tr><tr><td align="left">ease</td><td align="left">开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）</td></tr><tr><td align="left">ease-in</td><td align="left">开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)）</td></tr><tr><td align="left">ease-out</td><td align="left">开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)）</td></tr><tr><td align="left">ease-in-out</td><td align="left">中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)）</td></tr><tr><td align="left">cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td align="left">在 cubic-bezier 函数中定义自己的值</td></tr></tbody></table></li><li><h5 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h5><p>需要设置四个值 <code>cubic-bezier(, , , )</code>，来控制曲线速度，可在 <a href="https://cubic-bezier.com/">https://cubic-bezier.com (opens new window)</a>网站在线体验效果。</p><img src="https://doc.houdunren.com/assets/img/image-20190917143208598.d3bc3aad.png" alt="image-20190917143208598" style="zoom:50%;" /></li></ul><h4 id="9、步进速度"><a href="#9、步进速度" class="headerlink" title="9、步进速度"></a>9、步进速度</h4><ul><li><p>一帧一帧的感觉，有点像现实生活中的机械舞，下面是把过渡分五步完成。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>steps(n,start)</td><td>设置n个时间点，第一时间点变化状态</td></tr><tr><td>steps(n,end)</td><td>设置n个时间点，第一时间点初始状态</td></tr><tr><td>step-start</td><td>等于steps(1,start)，可以理解为从下一步开始</td></tr><tr><td>step-end</td><td>等于steps(1,end)，可以理解为从当前步开始</td></tr></tbody></table></li></ul><h4 id="10、播放状态"><a href="#10、播放状态" class="headerlink" title="10、播放状态"></a>10、播放状态</h4><ul><li>使用 <code>animation-play-state</code> 可以控制动画的暂停与运行。<ul><li>paused：暂停</li><li>running：运行</li></ul></li></ul><h4 id="11、填充模式"><a href="#11、填充模式" class="headerlink" title="11、填充模式"></a>11、填充模式</h4><ul><li><p><code>animation-fill-mode</code> 用于定义动画播放结束后的处理模式，是回到原来状态还是停止在动画结束状态。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>需要等延迟结束，起始帧属性才应用</td></tr><tr><td>backwards</td><td>动画效果在起始帧，不等延迟结束</td></tr><tr><td>forwards</td><td>结束后停留动画的最后一帧</td></tr><tr><td>both</td><td>包含backwards与forwards规则，即动画效果在起始帧，不等延迟结束，并且在结束后停止在最后一帧</td></tr></tbody></table></li></ul><h4 id="12、组合定义"><a href="#12、组合定义" class="headerlink" title="12、组合定义"></a>12、组合定义</h4><ul><li><p>和CSS中的其他属性一样，可以使用<code>animation</code>组合定义帧动画。animation 属性是一个简写属性，用于设置六个动画属性：</p><ul><li>animation-name</li><li>animation-duration</li><li>animation-timing-function</li><li>animation-delay</li><li>animation-iteration-count</li><li>animation-direction</li></ul><p>必须存在 <code>animation-duration</code>属性，否则过渡时间为0没有动画效果。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>transform动画的demo</title>
      <link href="/2021/12/25/CSS%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BBdemo/"/>
      <url>/2021/12/25/CSS%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BBdemo/</url>
      
        <content type="html"><![CDATA[<p>只标注了部分关键代码，并没有传全部代码</p><h3 id="transform的实现demo"><a href="#transform的实现demo" class="headerlink" title="transform的实现demo"></a>transform的实现demo</h3><h4 id="1、实现动感渐变表单"><a href="#1、实现动感渐变表单" class="headerlink" title="1、实现动感渐变表单"></a>1、实现动感渐变表单</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7851179.821af195.gif" alt="Untitled" style="zoom:50%;" /><ul><li><p>鼠标放上去时，下面呈现波纹效果：</p><ul><li><p>控制鼠标放上去时，translateX的移动</p></li><li><p>未放上去时，在左侧区域，并overflow不展示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入后盾人帐号&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  //居中显...</span><br><span class="line">  // <span class="attribute">flex</span>设置子元素居中...</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">5px</span> silver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.field</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;  </span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.field</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, white, <span class="number">#1abc9c</span>, <span class="number">#f1c40f</span>, <span class="number">#e74c3c</span>, white);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>);  //一开始不显示</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.field</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100%</span>); // 显示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2、页面切换"><a href="#2、页面切换" class="headerlink" title="2、页面切换"></a>2、页面切换</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7584912.730ab731.gif" alt="Untitled" style="zoom:50%;" /><p>移动效果制作的页面切换效果。</p><ul><li><p>点击不同菜单时，有不同的动画效果，呈现不同的效果</p><ul><li>控制底部的3个bar不同的样式的伪类target；</li><li>分别设置3个伪类添加时的样式不同；</li><li>颜色使用过渡展示；</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-home&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    houdunren.com</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-vimeo&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;live&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-viadeo&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#video&quot;</span>&gt;</span>video<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#live&quot;</span>&gt;</span>live<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  // <span class="attribute">flex</span>居中...</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">border-right</span>: solid <span class="number">1px</span> <span class="number">#aaa</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: solid <span class="number">1px</span> <span class="number">#aaa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  // <span class="attribute">flex</span>居中...</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, -<span class="number">100%</span>);  // y轴上的平移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:target</span> &#123;  // 点击时，平移</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0%</span>, <span class="number">0%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)<span class="selector-pseudo">:target</span> &#123;  // 点击时换颜色</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#3498db</span>;</span><br><span class="line">&#125;</span><br><span class="line">...同理，别的子元素</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、缩放菜单"><a href="#3、缩放菜单" class="headerlink" title="3、缩放菜单"></a>3、缩放菜单</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7638319.e0db60be.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>鼠标没放上去时：缩放transform：scale（0）</p></li><li><p>放上去后，再显示出来：scale（1）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">main</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">strong</span>&gt;<span class="selector-tag">VIDEO</span>&lt;/<span class="selector-tag">strong</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;PHP&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;hdcms&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;laravel&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">strong</span>&gt;LIVE&lt;/<span class="selector-tag">strong</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;houdunren&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;angular&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;css3&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">main</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;   // 垂直水平居中....&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">strong</span>+<span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;  // 缩放的基点位置  左上 <span class="number">0</span>， <span class="number">0</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);      //隐藏</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transition</span>: .<span class="number">6s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">strong</span>+<span class="selector-tag">div</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;  // 要转成块级才能<span class="attribute">transform</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">strong</span>+<span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);   //hover时显示出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、相册放大"><a href="#4、相册放大" class="headerlink" title="4、相册放大"></a>4、相册放大</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7641188.78385d23.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>Dom结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>hover时目标对象放大，且靠近；</p></li><li><p>非目标元素缩小scale</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  // felx居中...</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">8</span>) <span class="built_in">translateY</span>(-<span class="number">30px</span>);   // 缩小，向下移动了<span class="number">30px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.6</span>);  //目标对象放大</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;  //要把别的盖住</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、旋转文字"><a href="#5、旋转文字" class="headerlink" title="5、旋转文字"></a>5、旋转文字</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7605104.746a27d4.gif" alt="Untitled" style="zoom:50%;" /><ul><li><p>注意：transition添加到哪里 main 的div的strong</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>h<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>ou<span class="tag">&lt;<span class="name">strong</span>&gt;</span>d<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>unren.com</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line"><span class="attribute">transition</span>: <span class="number">3s</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">strong</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">strong</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6、酷炫按钮："><a href="#6、酷炫按钮：" class="headerlink" title="6、酷炫按钮："></a>6、酷炫按钮：</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7636893.3e63a4ce.gif" alt="Untitled" style="zoom:50%;" /><ul><li><p>初始宽度为0，经过后，宽度扩大为200%，离开后，再反向恢复</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line">    HOUDUNREN</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  //... 主要实现水平居中等</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.btn</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">8s</span>;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0%</span>;    <span class="comment">/* 从0过渡到200% */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;   <span class="comment">/* 保证背景色，不要把文字遮盖住 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skewX</span>(-<span class="number">45deg</span>);  <span class="comment">/* 产生倾斜效果 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.btn</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7、立体盒子按钮："><a href="#7、立体盒子按钮：" class="headerlink" title="7、立体盒子按钮："></a>7、立体盒子按钮：</h4><img src="https://doc.houdunren.com/assets/img/image-20190906135344963.f9a01bf5.png" alt="image-20190906135344963" style="zoom:33%;" /><ul><li><p> 重点理解，盒子左下，右下阴影怎么实现的；</p></li><li><p>宽高设置、left的意义</p></li><li><p>要为什么skewY， 还要translate的位移</p></li></ul>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;btn&quot;&gt; Nightwish&lt;/<span class="selector-tag">a</span>&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">25deg</span>) <span class="built_in">rotate</span>(-<span class="number">15deg</span>); // 再调这边的，控制的整个btn</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  // 宽、高居中 等样式设置...</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">10px</span>; <span class="comment">/* 刚好能抵消 width为10的宽度*/</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skewY</span>(-<span class="number">45deg</span>) <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">5px</span>); // 先调这边的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">10px</span>; <span class="comment">/* 刚好能抵消 height为10 */</span> </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skewX</span>(-<span class="number">45deg</span>) <span class="built_in">translate</span>(-<span class="number">5px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、三维旋转"><a href="#8、三维旋转" class="headerlink" title="8、三维旋转"></a>8、三维旋转</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7932004.12f1c62a.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>实现立体的旋转，可以指定角度。不同的transform-origin原点不同，效果不同：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  //...居中代码</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">5px</span> silver;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">900px</span>) <span class="built_in">rotateX</span>(<span class="number">60deg</span>);  // 是以y、z轴构成的平面选择。默认是中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  // ...居中代码</span><br><span class="line">  // 不加，是翻书效果：很好玩</span><br><span class="line">  <span class="attribute">transform-origin</span>: left bottom <span class="number">200px</span>;  //加了<span class="number">200px</span>,其实是z轴方向，可以飞起来</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">3s</span>;   // 持续<span class="number">3</span>秒</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">720deg</span>);  <span class="comment">/* 旋转2圈*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9、新年贺卡"><a href="#9、新年贺卡" class="headerlink" title="9、新年贺卡"></a>9、新年贺卡</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7939019.ed7152ba.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>注意透视加的位置，翻书效果实现</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span>houdunren<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"> // 居中设置.... </span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;  //实现卡片透视效果</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">900px</span>) <span class="built_in">rotateX</span>(<span class="number">35deg</span>) <span class="built_in">rotateY</span>(<span class="number">15deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">3s</span>;   //注意<span class="attribute">transition</span>添加的位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;新年&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;快乐&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;  // 宽度为一半</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform-origin</span>: right bottom;   // 翻书效果 ==<span class="attribute">right</span> == <span class="attribute">right</span> center</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(-<span class="number">179deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">179deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10、电子时钟："><a href="#10、电子时钟：" class="headerlink" title="10、电子时钟："></a>10、电子时钟：</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7645507.b3731f7b.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>整体Dom结构：</p><ul><li>main是整体的大表盘：（两个盘叠加，z-index控制层叠）<ul><li>带渐变色的大表盘最大（scale 1.2），但是z-index小，所以相比于main大表盘，只会漏出外环</li><li>main：最大表盘，大小刚好设置为彩带环内大小</li></ul></li><li>line是插入6条线的部分：6条白色的线，旋转不同的角度；<ul><li>6条线都垂直水平居中，并在环内不同角度旋转，旋转原点是自己中点</li></ul></li><li>mark：是小表盘，叠在线上面，（scale 0.8）</li><li>圆点：同样宽、高更小，50%  设置为圆。垂直水平居中 ，且要提高他的z-index</li><li>时、分、秒：大致一样的，<ul><li>指针长度不同：wid控制即可</li><li>旋转的圆点：left bottom</li></ul></li><li>动画：hover时，旋转指定度数</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mark&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;point&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hour&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;minute&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">      houdunren.com <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      向军大叔</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>首先画大圆盘：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#34495e</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;    // 带渐变色的大表盘</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;   </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.2</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(at right, <span class="number">#27ae60</span>, <span class="number">#e67e22</span>, <span class="number">#e67e22</span>, <span class="number">#27ae60</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着画大圆盘的时针，要漏出来一点：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">section</span> class=&quot;line&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">section</span>&gt;</span><br><span class="line">  </span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;  // 线</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">95%</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">120deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">150deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>小表盘：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-tag">div</span><span class="selector-attr">[class=<span class="string">&quot;mark&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#34495e</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表盘的圆点：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-class">.point</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>时针：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.hour</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#95a5a6</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.minute</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">35%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#3498db</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left bottom;  // 旋转：末端</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.second</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">35%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f1c40f</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表盘经过的效果、文字效果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.second</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">10s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">260deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">20px</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11、动态旋转菜单"><a href="#11、动态旋转菜单" class="headerlink" title="11、动态旋转菜单"></a>11、动态旋转菜单</h4><img src="https://doc.houdunren.com/assets/img/Untitled-8015150.745be0aa.gif" alt="Untitled" style="zoom:50%;" /><ul><li><p>首选画这么多个圆，然后围绕这几个圆的中心旋转；</p></li><li><p>将这几个圆挪到圆中间：让ul垂直水平居中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">nav</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-<span class="selector-tag">address</span>-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-adjust&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-bars&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-bug&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-compress&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-ban&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-beer&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-bus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">nav</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">150px</span> <span class="number">150px</span>;   // 按几个圆的正中心位置</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">40deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&gt;<span class="selector-tag">span</span> &#123; //控制字体显示不要歪</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">1040deg</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">80deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">// ... 旋转不同的角度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制显、隐</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transition</span>: .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;   <span class="comment">/* 控制图标歪 */</span></span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;  <span class="comment">/* 控制span */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="12、3D旋转图集"><a href="#12、3D旋转图集" class="headerlink" title="12、3D旋转图集"></a>12、3D旋转图集</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7838254.e56c8d56.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>实现思路：</p><ul><li><p>DOM结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">main</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">5</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">1</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">3</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">5</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">1</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">3</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">main</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>每个图像设置在一起，但是Y轴旋转角度不同，且旋转不是以xz轴，而是以</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center center -<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">120deg</span>);</span><br><span class="line">&#125;//...</span><br></pre></td></tr></table></figure></li><li><p>而是将旋转麻木的中心点设置为旋转原点</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d; <span class="comment">/* 开启3D视觉， 此时要把rotateX调整下方便看*/</span></span><br><span class="line">  <span class="attribute">transform-origin</span>: center center -<span class="number">300px</span>; <span class="comment">/* 调整旋转中心是旋转木马中心*/</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotateX</span>(-<span class="number">45deg</span>);</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">6s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="comment">/* translate(-50%, -50%)： 不加，会导致旋转跑偏了*/</span> </span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotateX</span>(-<span class="number">45deg</span>) <span class="built_in">rotateY</span>(<span class="number">900deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="立方体"><a href="#立方体" class="headerlink" title="立方体"></a>立方体</h4><img src="https://doc.houdunren.com/assets/img/Untitled-7784965.483715b7.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>四个边的盒子旋转以z轴中间作为基点，分别旋转rotateY90 180 270</p></li><li><p>两个盖子，分别以y轴旋转rotateX</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>后盾人<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">       <span class="attribute">position</span>: absolute;</span><br><span class="line">       // 居中...</span><br><span class="line">       <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">       <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">50%</span> <span class="number">50px</span>;  //在z轴中心旋转</span><br><span class="line">       <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">180deg</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span> &#123;</span><br><span class="line">       <span class="attribute">position</span>: absolute;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">       //... 居中</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: right;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#1abc9c</span>;</span><br><span class="line">       <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">200px</span>) <span class="built_in">rotateX</span>(-<span class="number">90deg</span>);</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: right;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#27ae60</span>;</span><br><span class="line">       <span class="attribute">transform-origin</span>: top;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">200px</span>) <span class="built_in">rotateX</span>(<span class="number">90deg</span>);</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#e67e22</span>;</span><br><span class="line">       <span class="attribute">transform-origin</span>: right;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">200px</span>) <span class="built_in">rotateY</span>(<span class="number">90deg</span>);</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: top;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#8e44ad</span>;</span><br><span class="line">       <span class="attribute">transform-origin</span>: left;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>) <span class="built_in">rotateY</span>(-<span class="number">90deg</span>);</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#ecf0f1</span>;</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#ecf0f1</span>;</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>transform动画基本使用</title>
      <link href="/2021/12/25/CSS%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"/>
      <url>/2021/12/25/CSS%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="transform-C3新增"><a href="#transform-C3新增" class="headerlink" title="transform  C3新增"></a>transform  C3新增</h3><p>使用 <code>transform</code> 规则控制元素的变形操作，包括控制移动translate、旋转rotate、缩放scale、倾斜skew、3D转换等</p><h4 id="1、translate位移"><a href="#1、translate位移" class="headerlink" title="1、translate位移"></a>1、translate位移</h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><ul><li><p>改变元素形状或位置，不会影响页面布局（<strong>不脱标</strong>，也不会对别的元素影响，比如挤别的盒子）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(x,y) // 定义 <span class="number">2</span>D 转换， 同时控制x, y  不定宽高时，实现水平垂直居中</span><br><span class="line">transform: <span class="built_in">translate3d</span>(x, y, z)  // <span class="number">3</span>d效果 同时控制X/Y/Z轴的移动，三个值必须输入如果某个轴不需要移动时设置为零</span><br><span class="line"></span><br><span class="line">transform: <span class="built_in">translateX</span>() 延 X 轴平移  +： 向右、向下        -： 向左、向上</span><br><span class="line">transform: <span class="built_in">translateY</span>() 延 Y 轴平移 </span><br><span class="line">transform: <span class="built_in">translateZ</span>() 延 Z 轴平移</span><br></pre></td></tr></table></figure></li></ul><h5 id="遵守的规则："><a href="#遵守的规则：" class="headerlink" title="遵守的规则："></a>遵守的规则：</h5><ol><li><p>重复设置变形操作时只在原形态上操作，同时设置多个，只有最后一个生效；除非，伪类上在原有基础上，再进行这样的位移，这样的可以生效</p></li><li><p>设置该属性的元素，相对于自己原位置来改变，<strong>不脱标</strong></p></li><li><p>位移时，<strong>默认原点</strong>是元素的中心位置；</p></li><li><p>在平移元素时，可以是具体像素或百分比，百分比是相对于自身计算</p></li><li><p>行内元素不产生变形效果，将其转为 <code>inline-block</code> 或 <code>block</code> 以及弹性元素时都可以产生变化效果</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">span</span>&gt;算法大多数&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>) <span class="built_in">translateX</span>(<span class="number">50px</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#9b59b6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="translateZ："><a href="#translateZ：" class="headerlink" title="translateZ："></a>translateZ：</h5><ul><li><p>控制Z轴移动，正向外、负向里移动。因为Z轴是透视轴没有像X/Y一样的固定尺寸，so不能用百分数</p></li><li><p>如果想体现纵向的视觉效果：需要设置perspective，加了后才有近大远小的效果；</p><img src="https://doc.houdunren.com/assets/img/Untitled-7827784.63fc4fc8.gif" alt="Untitled" style="zoom:25%;" /></li></ul><h4 id="2、scale缩放"><a href="#2、scale缩放" class="headerlink" title="2、scale缩放"></a>2、scale缩放</h4><ul><li><p>对元素进行等比例缩放：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(x, y)  按n倍缩放  n&gt;<span class="number">1</span>放大效果，&lt;<span class="number">1</span> 缩小效果</span><br><span class="line">transform: <span class="built_in">scale3d</span>(x, y, z) 沿X/Y/Z三个轴绽放元素</span><br><span class="line"></span><br><span class="line">transform: <span class="built_in">scaleX</span>() </span><br><span class="line">transform: <span class="built_in">scaleY</span>()</span><br><span class="line">transform: <span class="built_in">scaleZ</span>() // 沿Z轴缩放元素，需要有<span class="number">3</span>D透视才可以查看到效果</span><br></pre></td></tr></table></figure></li><li><p>应用场景：</p><p><strong>菜单缩放：</strong></p><ul><li>效果：鼠标放上去，子菜单显示；不放上去，不显示子菜单；</li><li>实现：<ul><li>没放上去时：缩放transform：scale（0）</li><li>放上去后，再显示出来：scale（1）</li><li>默认缩放原点是中心，如果想左上方式： transform-origin：left top;</li></ul></li></ul><p><strong>图片放大</strong></p></li></ul><h4 id="3、rotate旋转"><a href="#3、rotate旋转" class="headerlink" title="3、rotate旋转"></a>3、rotate旋转</h4><ul><li><p>默认绕着中心位置旋转</p></li><li><p>一般不会单独使用，会结合keyframes关键帧使用 或者与 translate 连用，先后位置影响视觉效果</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>()// 在X与Y轴平面旋转，效果与使用 rotateZ 相同</span><br><span class="line"> - x, y 一样时，沿着对角线旋转</span><br><span class="line"> - 谁大，转的时候偏那边的较多</span><br><span class="line"><span class="built_in">rotate3d</span>(tx,ty,tz,angle) //  同时设置X/Y/Z轴的旋转向量值来控制元素的旋转</span><br><span class="line"></span><br><span class="line">transform: <span class="built_in">rotateX</span>(<span class="number">0</span>-<span class="number">360</span>度) // rotateX（<span class="number">30deg</span>）</span><br><span class="line">transform: <span class="built_in">rotateY</span>()</span><br><span class="line">transform: <span class="built_in">rotateZ</span>()  // 沿Z轴旋转元素，效果就是沿 X/Y轴的平面 旋转</span><br></pre></td></tr></table></figure></li><li><p>旋转90deg不可见；旋转89deg，只会看到一条线</p></li><li><p>父级透视：当X旋转90度后无法看到元素，这时可以控制父级旋转从上看子元素。</p></li><li><p>只旋转x轴：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(<span class="number">35deg</span>);</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 只旋转x轴：</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(<span class="number">35deg</span>) <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">645deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 只旋转y轴</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(-<span class="number">645deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">// xy旋转</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(<span class="number">35deg</span>) <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">645deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">// xz旋转：加入适当的Z向量值，可增加元素沿Z轴旋转的力度。</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(<span class="number">35deg</span>) <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">0</span>, .<span class="number">5</span>, -<span class="number">245deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、skew倾斜变换"><a href="#4、skew倾斜变换" class="headerlink" title="4、skew倾斜变换"></a>4、skew倾斜变换</h4><ul><li><p>对元素进行倾斜：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">skew</span>(x, y);  // x、y轴的同时倾斜角度</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewX</span>();</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewY</span>();</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、旋转点transform-origin"><a href="#5、旋转点transform-origin" class="headerlink" title="5、旋转点transform-origin"></a>5、旋转点transform-origin</h4><ul><li><p>变化的起点：默认 center，用<strong>transform-origin</strong> 可以改变变形的起始点</p></li><li><p>元素移动不受变形基点所影响：基点是元素原始空间位，而不是translate移动后的空间位</p></li><li><p>rotate、skew都可以</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: left/right  center/bottom;</span><br><span class="line"><span class="attribute">transform-origin</span>: left top;   === <span class="number">0</span> <span class="number">0</span>;  左上角  <span class="number">1</span>, <span class="number">1</span>  中心原点  </span><br><span class="line"><span class="attribute">transform-origin</span>: <span class="number">100%</span>， <span class="number">100%</span>;  右下角  === <span class="attribute">right</span> <span class="attribute">bottom</span></span><br><span class="line"><span class="attribute">transform-origin</span>: <span class="number">200%</span> <span class="number">200%</span>;  <span class="comment">/* 可以在外部，也可以在内部*/</span>  也可以是具体像素位置</span><br></pre></td></tr></table></figure></li></ul><h4 id="6、透视perspective："><a href="#6、透视perspective：" class="headerlink" title="6、透视perspective："></a>6、透视perspective：</h4><h5 id="1、perspective"><a href="#1、perspective" class="headerlink" title="1、perspective"></a>1、perspective</h5><ul><li><p>视觉效果上：近大远小</p></li><li><p>舞台透视：</p><ul><li><code>perspective</code> 规则用于<strong>将父级整个做为透视元素</strong>，会造成里面的每个子元素的透视是不一样的。就像现实中摆一排杯子，是使用统一透视的，每个杯子的透视不一样，造成有大有小。</li></ul></li><li><p>单独透视：</p><ul><li><code>perspective</code> 函数用于为元素设置单独透视，每个元素的透视效果是一样的</li></ul></li><li><p>3D透视：transform-style用于控制3d透视</p><ul><li><p>应用于舞台即变形元素的父级元素</p></li><li><p>设置 <code>overflow:visible</code> 时 <code>preserve-3d</code> 才无效</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">flat<span class="number">2</span>D平面舞台</span><br><span class="line">preserve-<span class="number">3</span>d<span class="number">3</span>D透视舞台</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2、视角perspective-origin"><a href="#2、视角perspective-origin" class="headerlink" title="2、视角perspective-origin"></a>2、视角perspective-origin</h5><ol><li><p><code>perspective-origin</code>用于控制视线的落点，就像我们眼睛看物体时的聚焦点。</p></li><li><p>可以理解眼镜看物体的位置，比如看一台汽车，是在看车头左边看还是车头右边看。</p><ul><li><p>需要设置 <code>perspective</code> 透视后才可以看到效果。</p></li><li><p>一般设置在舞台元素上来控制子元素</p></li></ul></li><li><p>使用规则：</p><ul><li>x-axis：定义该视图在 x 轴上的位置。默认值：50%。可值：left、center、right、length、%</li><li>y-axis：定义该视图在 y 轴上的位置。默认值：50%。可值：top、center、bottom、length、%</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假进阶计划</title>
      <link href="/2021/12/23/%E5%AF%92%E5%81%87%E8%BF%9B%E9%98%B6%E8%AE%A1%E5%88%92/"/>
      <url>/2021/12/23/%E5%AF%92%E5%81%87%E8%BF%9B%E9%98%B6%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="1、前端"><a href="#1、前端" class="headerlink" title="1、前端"></a>1、前端</h3><ul><li><p>想要做的事：</p><ul><li>某个系列的深入研究；</li><li>形成自己的思考，开放社区贡献</li></ul></li><li><p>需要学习的list：</p><ol><li>看一看小黄书加强JS</li><li>学习别人写的优秀代码</li><li>leetcode刷题</li><li>博客美化一下，再弄个服务器，有时间再说吧，优先级最低。博客的管理更新问题<h3 id="2、论文"><a href="#2、论文" class="headerlink" title="2、论文"></a>2、论文</h3></li></ol></li><li><p>目前进展：90% ，年前做完剩下10%；</p></li><li><p>主要工作：</p><ol><li>第2个点的代码仿真还需要修改完善；</li><li>是否需要复现另一篇idea，跟导师沟通；</li><li>第2个点的文档细化，已有初步，但还要再细致细致，让别人都能看懂，而不是只有自己看懂；</li><li>论文大架子，在元旦之前搭好。手上别的东西已经有了，搭好之后可以直接填进去；</li></ol></li></ul><h3 id="3、实习"><a href="#3、实习" class="headerlink" title="3、实习"></a>3、实习</h3><ul><li><p>实习的目的是什么？</p></li><li><p>自己希望得到的成长是什么？</p></li><li><p>会在实习中侧重培养自己的什么？提升哪方面？克服什么弱点呢？</p></li><li><p>对自己的前端方向的思考….未来的思考，这个问题对现在的我好难回答出来，现在的生活充满了太多的不确定性了，I don’t 。。。</p><h3 id="年终总结…-待续"><a href="#年终总结…-待续" class="headerlink" title="年终总结….待续"></a>年终总结….待续</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>H5的新特性</title>
      <link href="/2021/12/23/H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2021/12/23/H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="H5新特性"><a href="#H5新特性" class="headerlink" title="H5新特性"></a>H5新特性</h3><h4 id="一、声明方式"><a href="#一、声明方式" class="headerlink" title="一、声明方式"></a>一、声明方式</h4><ul><li><p>HTML4 规定了三种不同的 <code>&lt;!DOCTYPE&gt;</code> 声明，分别是：Strict、Transitional 和 Frameset;</p><p><strong>HTML4 Strict</strong> / 严格</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span><span class="meta-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>HTML4 Transitional</strong> /过渡</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>HTML4 Frameset</strong>/框架集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>而HTML5因为不是<code>SGML</code>(一般指标准通用置标语言)的子集，只需要<code>&lt;!DOCTYPE&gt;</code>就可以了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">对于中文网页需要使用 <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> 声明编码，否则会出现乱码</span><br></pre></td></tr></table></figure></li></ul><h4 id="二、语义化标签"><a href="#二、语义化标签" class="headerlink" title="二、语义化标签"></a>二、语义化标签</h4><h5 id="语义化：根据内容-选择合适的标签"><a href="#语义化：根据内容-选择合适的标签" class="headerlink" title="语义化：根据内容, 选择合适的标签"></a>语义化：根据内容, 选择合适的标签</h5><ul><li>有利于 **’SEO’**：和搜索引擎建立良好沟通, 有助于爬虫抓取更多的有效信息。爬虫依赖于 标签 来确定, 上下文 和各个关键字的权重</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><h5 id="常见的语义标签功能："><a href="#常见的语义标签功能：" class="headerlink" title="常见的语义标签功能："></a>常见的语义标签功能：</h5><img src="https://www.runoob.com/wp-content/uploads/2013/07/html5-layout.jpg" alt="HTML5 语义元素" style="zoom: 50%;" /><p>H5 提供了 8 个新 HTML <strong>语义</strong> 元素来明确一个Web页面的不同部分，都是 <strong>块级</strong> 元素:</p><ul><li><p>header：文档的头部区域，用于定义内容的介绍展示区域，在页面中该元素可以使用多次</p></li><li><p>nav：定义导航链接的部分；但是，不是所有的链接都需要包含在 nav 元素中!</p></li><li><p>article：定义页面主区域内容之外的内容（比如侧边栏），内容应与主区域内容相关</p></li><li><p>section：定义文档中的节（section、区段）；区块（有语义化的div）</p></li><li><p>aside：定义其所处内容之外的内容（侧边）；</p></li><li><p>footer：描述了文档的底部区域，可使用多次</p><p>一个页脚通常包含文档的作者，著作权信息，链接的使用条款，联系信息等；</p></li></ul><h4 id="三、多媒体"><a href="#三、多媒体" class="headerlink" title="三、多媒体"></a>三、多媒体</h4><ul><li><h4 id="多媒体标签：Video-Audio"><a href="#多媒体标签：Video-Audio" class="headerlink" title="多媒体标签：Video/Audio"></a>多媒体标签：Video/Audio</h4><ol><li><p>提供了 播放、暂停和音量控件来控制视频</p></li><li><p>width 和 height 属性控制视频的尺寸</p></li><li><p>JS控制：</p><p>属性：时长、音量、是否可以播放</p><p>方法：开始播放、已暂停，已停止</p><p>事件：用于播放、暂停以及加载</p></li><li><p>source标签：定义多种媒体资源；track标签定义在媒体播放器文本轨迹（歌词）</p></li></ol></li></ul><h4 id="四、表单元素"><a href="#四、表单元素" class="headerlink" title="四、表单元素"></a>四、表单元素</h4><ul><li><p>新的表单输入类型，提供了更好的输入控制和验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color、date、datetime、datetime-local、email、month、number、range、</span><br><span class="line">search、tel、time、url、week</span><br></pre></td></tr></table></figure><ul><li>更有利于移动端做表单时候，比如电话号码，email，输入类型的限制；</li><li><strong>但是</strong>：真正做项目时，不能光靠这个来校验，不仅前端要校验，一个合格的后端不应该相信前端传入的任何数据</li></ul></li></ul><h4 id="五、6个API"><a href="#五、6个API" class="headerlink" title="五、6个API"></a>五、6个API</h4><ul><li>本地存储、离线存储、websocket、webworker、canvas、地理定位</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS和CSRF攻击</title>
      <link href="/2021/12/22/%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB/"/>
      <url>/2021/12/22/%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS和CSRF攻击"><a href="#XSS和CSRF攻击" class="headerlink" title="XSS和CSRF攻击"></a>XSS和CSRF攻击</h2><h3 id="1、XSS攻击"><a href="#1、XSS攻击" class="headerlink" title="1、XSS攻击"></a>1、XSS攻击</h3><h4 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h4><ul><li>跨站脚本攻击，攻击者在<strong>网站注入恶意脚本</strong>，当用户浏览网页时，嵌入网页的Script代码会执行，通过对用户浏览器进行控制或者拿到用户隐私数据</li><li>重点不在于跨站点，XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</li><li>攻击者可以通过这种攻击方式可以进行以下操作：<ul><li>获取页面的数据，如DOM、cookie、localStorage；</li><li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li><li>破坏页面结构；</li><li>流量劫持（将链接指向某网站）；</li></ul></li></ul><h4 id="2、类型"><a href="#2、类型" class="headerlink" title="2、类型"></a>2、类型</h4><h5 id="1、反射型-非持久型"><a href="#1、反射型-非持久型" class="headerlink" title="1、反射型/非持久型"></a>1、反射型/非持久型</h5><ul><li>攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 需要服务端交互</li><li><strong>反射型 XSS 的攻击步骤：</strong><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol></li><li>场景：通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</li></ul><h5 id="2、存储型-持久型"><a href="#2、存储型-持久型" class="headerlink" title="2、存储型/持久型"></a>2、存储型/持久型</h5><ul><li><p>把恶意脚本<strong>存储到服务器的数据库</strong>当中，浏览器请求数据时，脚本就被传回并执行，达到攻击效果</p></li><li><p><strong>存储型 XSS 的攻击步骤：</strong></p><ol><li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li><li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol></li><li><p>举例：</p><p>当有人在留言内容中插入恶意脚本时，留言肯定会保存到服务器中。</p><p>由于服务器要像每一个访客展示之前的留言内容，所以后面的访客自然会接收到之前留言中的恶意脚本而不幸躺枪</p></li><li><p>场景：带有用户保存数据的网站功能，比如论坛发帖、商品评价、用户私信等等</p></li><li><p>反射型 XSS 跟存储型 XSS 的区别是：</p><p>存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥</p></li></ul><h5 id="3、DOM型"><a href="#3、DOM型" class="headerlink" title="3、DOM型"></a>3、DOM型</h5><ul><li>不需要服务端交互，<strong>纯粹发生在客户端</strong></li><li>通过恶意脚本修改DOM结构，通过修改页面的 DOM 节点形成的 XSS。</li><li><strong>DOM 型 XSS 的攻击步骤：</strong><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL。</li><li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol></li><li>举例：看小说的时候下面有小广告，直接改变当前页面的Dom结构</li><li>DOM 型 XSS 跟前两种 XSS 的区别：<ul><li>DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</li></ul></li></ul><h4 id="3、防范措施："><a href="#3、防范措施：" class="headerlink" title="3、防范措施："></a>3、防范措施：</h4><h5 id="方式1：从浏览器的执行来进行预防，使用纯前端的方式："><a href="#方式1：从浏览器的执行来进行预防，使用纯前端的方式：" class="headerlink" title="方式1：从浏览器的执行来进行预防，使用纯前端的方式："></a>方式1：从浏览器的执行来进行预防，<strong>使用纯前端的方式：</strong></h5><ol><li>使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）</li><li>对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。<ul><li>拒绝innerHTML, 使用.innerText、.setAttribute、.style，</li><li>Vue：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<strong>绝不要</strong>对用户提供的内容使用插值</li></ul></li></ol><h5 id="方式2：使用CSP白名单"><a href="#方式2：使用CSP白名单" class="headerlink" title="方式2：使用CSP白名单"></a>方式2：使用CSP白名单</h5><ul><li>CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li><li>对于用户的任何输入要进行<strong>转码</strong>和<strong>过滤</strong>。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。<ol><li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li><li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 </li></ol></li></ul><h5 id="方式3：cookie安全策略："><a href="#方式3：cookie安全策略：" class="headerlink" title="方式3：cookie安全策略："></a>方式3：cookie安全策略：</h5><ul><li><p>很多xss攻击都是为获取cookie中内容，这样浏览器禁止JS访问带有HTTPOnly属性的cookie，也可以使用验证码，避免脚本伪装成用户执行一些操作。</p></li><li><p><strong>使用场景：</strong></p><p>我们访问网站的时候账户信息可能存储在cookie中，方便用户验证信息，转账等页面操作。这种操作可能引发XSS攻击（<strong>反射型</strong>），通过执行当前页面的JS代码，获取到cookie里信息，发给攻击者的网站</p></li><li><p><strong>做法：</strong>在服务端设置首部字段set-cookie为HTTPOnly，这样可以防止用户通过JS获取cookie。对cookie的读写/发送一般有如下字段设置：</p><ul><li>HTTP-Only：只允许HTTPS/http请求读取cookie，JS代码是无法读取cookie的，发送请求时自动发送cookie</li><li>secure-Only：只允许HTTPS请求读取，发送请求时自动发送cookie</li><li>host-Only：只允许主机域名与domain设置完成一致的网站才才能访问cookie</li></ul></li></ul><h3 id="2、CSRF"><a href="#2、CSRF" class="headerlink" title="2、CSRF"></a>2、CSRF</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>跨站请求伪造：</p><ul><li>攻击者诱导用户进入一个第三方网站，然后该网站向<strong>被攻击网站</strong>发送跨站请求。</li><li>如果用户在<strong>被攻击网站中保存了登录状态</strong>，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</li><li>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></li></ul><p>举例：</p><ul><li>比如登录一个银行的网页，在没有退出当前网页时（保存了登陆态），一般是黑客诱使用户点击链接，打开<strong>第三方网站</strong>黑客网站会发起请求，</li><li>然后利用用户的cookie（包含用户信息）欺骗服务器，服务器以为请求时正常用户发的就正常处理</li><li>攻击者盗用了用户的身份，以用户的名义发送了恶意请求<img src="https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg" alt="img" style="zoom: 50%;" /></li></ul><h4 id="2、攻击类型："><a href="#2、攻击类型：" class="headerlink" title="2、攻击类型："></a>2、攻击类型：</h4><ul><li>get型：恶意网站会自动发送http请求，向目标网站发起攻击。比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li><li>post型：会利用表单提交，向目标网站发送post请求，达到攻击效果。比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li><li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击</li></ul><h4 id="3、防范措施"><a href="#3、防范措施" class="headerlink" title="3、防范措施"></a>3、防范措施</h4><h5 id="1、进行同源检测"><a href="#1、进行同源检测" class="headerlink" title="1、进行同源检测"></a>1、进行同源检测</h5><ul><li>服务器根据 http 请求头中 origin 或者 referer 信息来<strong>判断请求是否为允许访问的站点</strong>，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。<ul><li><strong>origin</strong>：包含请求的域名（不包含path及query）</li><li><strong>refer</strong>：包含具体的URL地址</li></ul></li><li>这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li></ul><h5 id="2、token验证"><a href="#2、token验证" class="headerlink" title="2、token验证"></a>2、token验证</h5><p>CSRF成功的原因就是攻击的网络请求带有cookie而cookie中有正常用户的身份信息，欺骗了服务器。故在HTTP请求中加入一个随机产生的token，服务器拦截验证这个token是否合法，不合法就拒绝这个网络请求。</p><ul><li><p>服务器需要生成一个通过加密算法加密的 Token；</p></li><li><p>将该 Token 保存在 Session 或者 Redis；</p></li><li><p>将该 Token 传给客户端，客户端在请求时要将其 Token 一并带上，如 <code>GET</code> 请求 <code>/api/message?token=xxx</code> 或 <code>POST</code> 请求在form表单追加或 <code>Ajax</code> 请求在页面添加，通过 JS 去获取该 meta 值；</p></li><li><p>请求到服务器后，服务器就可以通过解密对比来判断该 Token 的有效性了。</p></li></ul><h5 id="3、Set-Cookie：SameSite-√"><a href="#3、Set-Cookie：SameSite-√" class="headerlink" title="3、Set-Cookie：SameSite                     √"></a>3、Set-Cookie：SameSite                     √</h5><p><strong>限制 cookie 不能作为被第三方使用</strong>，即在响应头 <code>Set-Cookie</code> 设置 SameSite 属性，表示该 Cookie 访问同源网站而非来源第三方网站。从而可以避免被攻击者利用。</p><ul><li>Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用</li></ul><h3 id="3、网络劫持有哪几种，如何防范？"><a href="#3、网络劫持有哪几种，如何防范？" class="headerlink" title="3、网络劫持有哪几种，如何防范？"></a>3、网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种:</p><p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)</p><ul><li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li><li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li></ul><p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p><p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我不允许你还不知道什么是HTTP缓存</title>
      <link href="/2021/12/22/HTTP%E7%BC%93%E5%AD%98/"/>
      <url>/2021/12/22/HTTP%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><h3 id="1、缓存基本"><a href="#1、缓存基本" class="headerlink" title="1、缓存基本"></a>1、缓存基本</h3><ul><li><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了</p></li><li><h4 id="为什么要有缓存？"><a href="#为什么要有缓存？" class="headerlink" title="为什么要有缓存？"></a>为什么要有缓存？</h4><ol><li><p>减少了请求的次数，提高了网站的性能，加快客户端加载网页的速度， 提升用户体验。</p><p>浏览器的缓存，主要针对的是前端的静态资源，最好的效果是，在发请求之后，拉取相应的静态资源，并存在本地。</p></li></ol><ul><li>如果服务器的静态资源没更新，那在下次请求时，就直接从本地读取即可</li><li>如果服务器的静态资源已更新，那再次请求时，就到服务器拉取新的资源，并存在本地</li></ul><ol start="2"><li>降低服务器的压力</li></ol></li><li><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，<strong>即客户端与服务器之间存在一次通信。</strong></p></li><li><p>在 <code>chrome</code> 中<strong>强缓存</strong>（虽然没发出真实的 <code>http</code> 请求）的<strong>请求状态码</strong>返回是 <code>200 (from cache)</code>；</p></li><li><p>而命中协商缓存，请求状态码是 <code>304 (not modified)</code></p><blockquote><p>其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。<br><img src="https://segmentfault.com/img/remote/1460000021661660" alt="image.png"></p></blockquote></li></ul></li></ul><h3 id="2、请求流程"><a href="#2、请求流程" class="headerlink" title="2、请求流程"></a>2、请求流程</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6837d8d1c74cf2894d8967a20115d9~tplv-k3u1fbpfcp-watermark.awebp" alt="业务流程图1.png" style="zoom: 50%;" /><ol><li><p>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 <code>response header</code> ，以供下次加载时对比使用；</p></li><li><p>下一次加载资源时，会获取该缓存资源的 <code>header</code> 中的信息。由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差：</p><p>如果没有超过<code>cache-control</code> 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则用 <code>expires</code> 头判断是否过期；</p></li><li><p>如果资源已过期，则表明<strong>强制缓存没被命中，则协商缓存</strong>，浏览器就会发送请求到服务器，这次请求会带上 <code>IF-Modified-Since</code> 或者 <code>IF-None-Match</code>, 它们的值分别是第一次请求返回 <code>Last-Modified</code>或者 <code>Etag</code></p></li><li><p>服务器收到请求后，优先根据  <code>Etag</code>的值判断被请求的文件有没有做修改</p><ul><li> <code>Etag</code>值一致则没有修改，命中协商缓存，返回 304；</li><li> 如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li></ul><p>很多网站的资源后面都加了版本号，目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器缓存，<strong>强制改变版本号</strong>，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，<strong>以保证用户能够及时获得网站的最新更新。</strong></p></li></ol><h3 id="3-强缓存"><a href="#3-强缓存" class="headerlink" title="3. 强缓存"></a>3. 强缓存</h3><p>强缓存是根据返回头中的 <code>Expires</code> 或者 <code>Cache-Control</code> 两个字段来控制的，都是表示资源的缓存有效时间。</p><ul><li><code>Expires</code> ：http 1.0，值是一个<code>GMT</code> 格式的时间点字符串，比如 <code>Expires:Mon,18 Oct 2066 23:59:59 GMT</code> 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存<ul><li>缺点：失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。</li></ul></li><li><code>Cache-Control</code>： <code>http 1.1</code> 的规范，一般常用该字段的 <code>max-age</code> 值来进行判断，它是一个相对时间，比如 .<code>Cache-Control:max-age=3600</code> 代表资源的有效期是 3600 秒。并且返回头中的 <code>Date</code> 表示消息发送的时间，表示当前资源在 <code>Date ~ Date +3600s</code> 这段时间里都是有效的。<code>Cache-Control</code> 还有其他几个值可以设置：<ul><li><code>no-cache</code> 不使用本地缓存。需要使用协商缓存。</li><li><code>no-store</code>直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 <code>network</code> 中的 <code>disabled cache</code>。</li><li><code>public</code> 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。</li><li><code>private</code> 只能被终端用户的浏览器缓存。</li></ul></li><li>如果 <code>Cache-Control</code>与 <code>Expires</code> 同时存在的话， <code>Cache-Control</code> 的优先级高于 <code>Expires</code> </li></ul><h3 id="4-协商缓存"><a href="#4-协商缓存" class="headerlink" title="4. 协商缓存"></a>4. 协商缓存</h3><p>由服务器来确定缓存资源是否可用，这次请求会带上 <code>IF-Modified-Since</code> 或者 <code>IF-None-Match</code>, 它们的值分别是第一次请求返回 <code>Last-Modified</code>或者 <code>Etag</code>，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段</p><ul><li><p><code>Last-Modified/If-Modified-Since</code> ：二者的值都是 GMT 格式的时间字符串，</p><p><code>Last-Modified</code> ：标记最后文件修改时间， 下一次请求时，请求头中会带上 <code>If-Modified-Since</code> 值就是 <code>Last-Modified</code> 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化</p><ul><li>如果文件没有变更则返回 <code>304 Not Modified</code> ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 <code>304 Not Modified</code> 的响应时，<code>response header</code> 中不会再添加的 <code>Last-Modified</code> 去试图更新本地缓存的 <code>Last-Modified</code>， 因为没变化</li><li>如果资源有变化，就正常返回返回资源内容，新的 <code>Last-Modified</code> 会在 <code>response header</code> 返回，并在下次请求之前更新本地缓存的 <code>Last-Modified</code>，下次请求时，<code>If-Modified-Since</code>会启用更新后的 <code>Last-Modified</code>。</li></ul></li><li><p><code>Etag/If-None-Match</code>：值都是由服务器为每一个资源生成的<strong>唯一标识串</strong>，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 <code>ETag</code>字段返回给浏览器，接收到 <code>If-None-Match</code> 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。</p><ul><li>与 <code>Last-Modified</code> <strong>不一样的是</strong>，当服务器返回 <code>304 Not Modified</code> 的响应时，由于在服务器上<code>ETag</code> 重新计算过，<code>response header</code>中还会把这个 <code>ETag</code> 返回，即使这个 <code>ETag</code> 跟之前的没变化</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优先级： Cache-Control  &gt; expires &gt; Etag &gt; Last-Modified</span><br></pre></td></tr></table></figure><h3 id="5-为什么要有-Etag"><a href="#5-为什么要有-Etag" class="headerlink" title="5. 为什么要有 Etag"></a>5. 为什么要有 Etag</h3><p><code>HTTP1.1</code> 中 <code>Etag</code> 的出现主要是为了解决几个 <code>Last-Modified</code> 比较难解决的问题：</p><ol><li><p>时间的精确度：</p><p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，这样会造成缓存命中的不准确。使用 <code>Etag</code> 就能够保证这种需求下客户端在 1 秒内能刷新 N 次 cache。</p></li><li><p>周期性改动：</p><p>一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；</p></li></ol><h3 id="6-用户行为"><a href="#6-用户行为" class="headerlink" title="6. 用户行为"></a>6. 用户行为</h3><p>用户行为对浏览器缓存的影响：</p><table><thead><tr><th>用户操作</th><th>Expires/Cache-Control</th><th>Last-Modied/Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td>有效</td><td>有效</td></tr><tr><td>页面链接跳转</td><td>有效</td><td>有效</td></tr><tr><td>新开窗口</td><td>有效</td><td>有效</td></tr><tr><td>前进回退</td><td>有效</td><td>有效</td></tr><tr><td>F5 刷新</td><td>无效(有争议，不同浏览器反馈不一致)</td><td>有效</td></tr><tr><td>Ctrl+F5 强制刷新</td><td>无效</td><td>无效</td></tr></tbody></table><ul><li><p><strong>点击刷新按钮或者按 F5：</strong> 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</p><p><strong>用户按 Ctrl+F5（强制刷新）：</strong> 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</p><p>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</p></li></ul><h3 id="浏览器资源缓存的位置"><a href="#浏览器资源缓存的位置" class="headerlink" title="浏览器资源缓存的位置"></a>浏览器资源缓存的位置</h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p><ol><li><strong>Service Worker</strong>：Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。<ul><li>它可以让我们自由控制缓存哪些文件、如何匹配缓存、读取缓存，且<strong>缓存是持续性的</strong>。</li><li>当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch</code> 函数获取  数据。也就是说，会根据缓存查找优先级去查找数据。</li><li><strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。</strong></li></ul></li><li><strong>Memory Cache：</strong> 内存缓存，效率最快，<strong>但持续性很短，会随着进程的释放而释放。</strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li><li><strong>Disk Cache：</strong> 硬盘缓存，读取速度慢点，但是什么都能存储到磁盘中<ul><li>比之 Memory Cache <strong>胜在容量和存储时效性上。</strong></li><li>它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></li></ul></li></ol><p><strong>Push Cache：</strong> 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：</p><ul><li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li><li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>可以给其他域名推送资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie、session、Token</title>
      <link href="/2021/12/21/cookie%E5%92%8Csession/"/>
      <url>/2021/12/21/cookie%E5%92%8Csession/</url>
      
        <content type="html"><![CDATA[<h3 id="1、为什么会诞生cookie与session？"><a href="#1、为什么会诞生cookie与session？" class="headerlink" title="1、为什么会诞生cookie与session？"></a>1、为什么会诞生cookie与session？</h3><p>二者诞生的契机：http是一个无状态协议</p><ul><li><p>什么是无状态呢？</p><p>这一次请求和上一次请求是没有任何关联的，这种无状态的的好处是快速。但坏处就是：无法把<code>www.zhihu.com/login.html</code>和<code>www.zhihu.com/index.html</code>关联起来</p></li><li><p>session和cookie出现解决了什么？</p><ul><li>由于http的无状态性，服务端并不知道是张三还是李四在和自己打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合</li><li>SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</li></ul></li></ul><h3 id="2、cookie和session如何配合"><a href="#2、cookie和session如何配合" class="headerlink" title="2、cookie和session如何配合"></a>2、cookie和session如何配合</h3><h4 id="1、用户首次登录时："><a href="#1、用户首次登录时：" class="headerlink" title="1、用户首次登录时："></a>1、用户首次登录时：</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/2/1730fcc51a6e8670~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li><p>用户访问 <code>a.com/pageA</code>，并输入密码登录</p></li><li><p>服务器验证密码无误后，会创建 SessionId，并将它保存起来</p><p>服务器端的 SessionId 可能存放在很多地方，例如：内存、文件、数据库等</p></li><li><p>服务器端发送一个http响应到客户端，这个响应头中就包含Set-Cookie头部，该头部包含了sessionId，Set-Cookie格式如下：<br><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></p></li><li><p>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中：</p><ul><li>浏览器安装目录下会<strong>专门有一个 cookie 文件夹</strong>存放各个域下设置的cookie</li><li>当网页要发请求时，浏览器<strong>自动检查</strong>是否有相应的cookie，有则自动添加在request header中的cookie字段中</li></ul></li></ol><h4 id="2、第2次访问"><a href="#2、第2次访问" class="headerlink" title="2、第2次访问"></a>2、第2次访问</h4><p><strong>后续的访问：</strong>就可以直接使用 Cookie 身份验证了：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/2/1730fcc51a81b9f8~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li>用户访问 <code>a.com/pageB</code> 页面时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动在请求头中添加cookie</li><li>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 找对应的 Session 信息，如果没找到，说明用户没有登录或登录失效</li><li>如果找到 Session 证明用户已经登录，可执行后面操作</li></ol><h4 id="问题1：可以只用cookie，不用session吗？"><a href="#问题1：可以只用cookie，不用session吗？" class="headerlink" title="问题1：可以只用cookie，不用session吗？"></a>问题1：可以只用cookie，不用session吗？</h4><p>此时账户信息全存在客户端：安全、存储空间</p><ul><li>账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露</li><li>客户端数据量变大，网络传输的数据量也会变大。而用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。</li></ul><h4 id="问题2：cookie被禁用怎么办"><a href="#问题2：cookie被禁用怎么办" class="headerlink" title="问题2：cookie被禁用怎么办"></a>问题2：cookie被禁用怎么办</h4><p>既然服务端根据 Cookie 中的信息判断用户是否登录，那如果浏览器中禁止 Cookie，如何保障整个机制的正常运转？</p><h5 id="1、方案1：请求参数"><a href="#1、方案1：请求参数" class="headerlink" title="1、方案1：请求参数"></a>1、方案1：请求参数</h5><ul><li>每次请求中都携带一个 SessionID 参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code></li></ul><h5 id="2、方案2：Token-机制"><a href="#2、方案2：Token-机制" class="headerlink" title="2、方案2：Token 机制"></a>2、方案2：Token 机制</h5><ul><li><p>在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(Storage)!==<span class="string">&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>常用API：</p><ul><li>保存数据：localStorage.setItem(key,value); localStorage.keyname= “菜鸟教程”;</li><li>读取数据：localStorage.getItem(key);</li><li>删除单个、所有数据：localStorage.removeItem(key)、localStorage.clear();</li><li>得到某个索引的key：localStorage.key(index);</li></ul></li></ul><h3 id="3、cookie相关API"><a href="#3、cookie相关API" class="headerlink" title="3、cookie相关API"></a>3、cookie相关API</h3><ul><li>存储形式：由<strong>键值对</strong> key=value构成，<strong>键值对之间由一个分号和一个空格隔开</strong></li><li>前端原生API获取cookie的方法：<strong>document.cookie</strong>，但只能获取 HttpOnly 类型的cookie</li></ul><h4 id="1、cookie常见属性："><a href="#1、cookie常见属性：" class="headerlink" title="1、cookie常见属性："></a>1、cookie常见属性：</h4><p>设置这些属性时，属性之间由一个分号和一个空格隔开：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly&quot;</span></span><br></pre></td></tr></table></figure><h5 id="expires："><a href="#expires：" class="headerlink" title="expires："></a>expires：</h5><ul><li>GMT 格式时间，如不设置，默认有效期为session，即会话cookie。浏览器关闭就没</li><li>http/1.0 —&gt; expires(失效时刻) ,  http/1.1 —-&gt;由 max-age 选项代替(cookie失效时刻= 创建时刻+ max-age)<ul><li>max-age 的默认值是 -1(即有效期为 session )</li><li>有三种可能值：负数（有效期session）、0（删除）、正数（创建时刻+ max-age）</li></ul></li></ul><h5 id="domain-和-path："><a href="#domain-和-path：" class="headerlink" title="domain 和 path："></a>domain 和 path：</h5><ul><li>域名+路径，两者构成了 URL，共同限制 cookie 能被哪些 URL 访问，所以决定了cookie何时被浏览器自动添加到请求头部中发送出去</li><li>若没有显式设置，则浏览器会自动取 url 的 host 作为 domain 值</li><li>path默认值为设置该cookie的网页所在的目录</li></ul><p>【注意1】：<strong>跨域xhr请求时</strong>，即使请求URL的域名和路径都满足 cookie 的 domain 和 path，默认情况下<strong>cookie也不会自动被添加到请求头</strong>：为什么？</p><ul><li><p>在<code>CORS</code>标准中规定，默认情况下，浏览器发跨域请求时，不能发任何认证信息（<code>credentials</code>）如”<code>cookies</code>“和”<code>HTTP authentication schemes</code>“，除非<code>xhr.withCredentials</code>为<code>true</code>（<code>xhr</code>对象一个属性，默认值为<code>false</code>）</p></li><li><p><code>cookies</code>也是一种认证信息，在跨域请求中，<code>client</code>端必须<strong>手动设置</strong><code>xhr.withCredentials=true</code>，且<code>server</code>端也<strong>必须允许</strong><code>request</code>能携带认证信息（即<code>response header</code>中包含<code>Access-Control-Allow-Credentials:true</code>），这样浏览器才会自动将<code>cookie</code>加在<code>request header</code>中</p><p>【特别注意】：</p><ul><li>一旦跨域<code>request</code>能携带认证信息，<code>server</code>端一定不能将<code>Access-Control-Allow-Origin</code>设为<code>*</code>，而必须设为请求页面的域名</li></ul></li></ul><p>【注意2】：domain是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀 public suffix</p><ul><li><p>如果页面域名为 <a href="http://www.baidu.com/">www.baidu.com</a>, domain可以设置为“<a href="http://www.baidu.com”,或“baidu.com”,但不能设置为“.com”或“com”/">www.baidu.com”，或“baidu.com”，但不能设置为“.com”或“com”</a></p></li><li><p>显式设置 domain 时，如果 value 最前面带点，则浏览器处理时会将这个点去掉，所以最后浏览器存的就是没有点的</p></li><li><p>前面带点‘.’和不带点‘.’有啥区别：</p><p>带点：任何 subdomain 都可以访问，包括父 domain</p><p>不带点：只有完全一样的域名才能访问，subdomain 不能（但在 IE 下比较特殊，它支持 subdomain 访问）</p></li></ul><h5 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h5><p>当请求是HTTPS或其他安全协议时，包含 secure 选项的 cookie才能被发至服务器，<strong>默认cookie不带secure选项</strong></p><ul><li><p>设置一个 secure类型的 cookie：可在控制台看见</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;name=huang; secure&quot;;</span><br></pre></td></tr></table></figure></li></ul><p>【注意】：在网页中通过 js 设置secure类型的 cookie，必须保证网页是https协议的。在http协议的网页中是无法设置secure类型cookie的</p><h5 id="httpOnly"><a href="#httpOnly" class="headerlink" title="httpOnly"></a>httpOnly</h5><ul><li><p>用来<strong>设置cookie能否通过 js 访</strong>问，这个选项<strong>只能由服务端设置，客户端不可</strong>，且凡是httpOnly类型的cookie，其 HTTP 一列都会打上√</p><p>通过document.cookie是<strong>不能获取的，也不能修改</strong></p></li><li><p>默认cookie不带httpOnly选项，此时客户端是可通过js代码去访问（包括读取、修改、删除等）cookie</p></li><li><p>当cookie带httpOnly选项时，客户端无法通过js代码访问</p></li></ul><p>【httpOnly与安全】：<strong>为什么要限制客户端去访问cookie？</strong>安全</p><p>如果任何 cookie 都能被客户端通过document.cookie获取会发生什么可怕的事情</p><ol><li>当网页遭受 XSS 攻击，一段恶意script脚本插到网页中，脚本通过document.cookie读取用户身份验证相关的 cookie，并将这些 cookie 发到了攻击者的服务器</li><li><strong>攻击者轻而易举就拿到了用户身份验证信息</strong>，充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证</li></ol><h4 id="2、操作cookie"><a href="#2、操作cookie" class="headerlink" title="2、操作cookie"></a>2、操作cookie</h4><h5 id="操作方："><a href="#操作方：" class="headerlink" title="操作方："></a>操作方：</h5><ul><li><p>客户端设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;name=Jonh; &quot;;</span><br><span class="line">document.cookie=&quot;age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;;</span><br></pre></td></tr></table></figure><ul><li>没有设置的选项会采用默认值</li><li>无法设置HttpOnly选项</li><li>secure：有条件，必须安全才能设置</li><li>多个cookie设置，不能一下子：document.cookie = “name=Jonh; age=12; class=111”;</li></ul></li><li><p>服务端设置：</p><ul><li><p>请求资源文件、ajax请求时，服务端返回的response header中的<strong>set-cookie</strong>，是服务端专门用来设置cookie的</p></li><li><p>set-cookie字段的值就是普通的字符串，一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段</p></li><li><p>服务端可设置cookie 所有选项：expires、domain、path、secure、HttpOnly</p><img src="https://img-blog.csdn.net/20180306222521824" alt="img" style="zoom:33%;" /></li></ul></li></ul><h5 id="修改、删除cookie："><a href="#修改、删除cookie：" class="headerlink" title="修改、删除cookie："></a>修改、删除cookie：</h5><ul><li><p>修改cookie：</p><p>重新赋值，覆盖旧的。【注意】：在设置新cookie时，path/domain这几个选项一定要旧cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie</p></li><li><p>删除cookie：（下面封装思路有）</p><p>重新赋值，新cookie的expires 设为一个过去的时间点。</p><p>【注意】：path/domain/这几个选项一定要旧cookie 保持一样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> cookieExpire=date.getTime()-<span class="number">1000</span>; <span class="comment">// 设置为一个过去的时间</span></span><br><span class="line"><span class="comment">// 删除 cookie 时，名称、路径和域名必须相同</span></span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot; username=JavaScript  ; expire= &quot;</span> + cookieExpire + <span class="string">&quot; ;path=/;domain=www.bababa.org &quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="cookie-编码："><a href="#cookie-编码：" class="headerlink" title="cookie 编码："></a>cookie 编码：</h5><ul><li><p>cookie是个字符串，但其中<strong>逗号、分号、空格</strong>被当做了特殊符号</p></li><li><p>所以当cookie的 key 和 value 中含有这3个特殊字符时，要对其额外编码；</p></li><li><p>一般用escape编码，读取时用unescape解码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="built_in">escape</span>(<span class="string">&quot;name;value&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> value = <span class="built_in">escape</span>(<span class="string">&quot;this is a value contain , and ;&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.cookie= key + <span class="string">&quot;=&quot;</span> + value + <span class="string">&quot;; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、封装一个cookie"><a href="#3、封装一个cookie" class="headerlink" title="3、封装一个cookie"></a>3、封装一个cookie</h4><ul><li><p>设置、删除、获取指定名称的cookie、打印所有cookie</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Cookie = &#123;</span><br><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line">  <span class="attr">setCookie</span>: <span class="function">(<span class="params">name, value</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> Days = <span class="number">30</span>;</span><br><span class="line">       <span class="keyword">const</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">       exp.setTime(exp.getTime() + Days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">       <span class="built_in">document</span>.cookie =</span><br><span class="line">         name + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">escape</span>(value) + <span class="string">&#x27;;expires=&#x27;</span> + exp.toUTCString();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 删除cookie</span></span><br><span class="line">  <span class="attr">delCookie</span>: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> Days = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">const</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">     <span class="keyword">const</span> value = Cookie.getCookie(name);</span><br><span class="line">     exp.setTime(exp.getTime() + Days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">     <span class="built_in">document</span>.cookie =</span><br><span class="line">       name + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">escape</span>(value) + <span class="string">&#x27;;expires=&#x27;</span> + exp.toUTCString();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 打印所有cookie</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> strcookie = <span class="built_in">document</span>.cookie;<span class="comment">//获取cookie字符串</span></span><br><span class="line">      <span class="keyword">var</span> arrcookie = strcookie.split(<span class="string">&quot;;&quot;</span>);<span class="comment">//分割</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//遍历匹配</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrcookie.length; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> arr = arrcookie[i].split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(arr[<span class="number">0</span>] +<span class="string">&quot;：&quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 获取指定名称的cookie</span></span><br><span class="line">  <span class="attr">getCookie</span>: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 正则匹配</span></span><br><span class="line">     <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;(^| )&#x27;</span> + name + <span class="string">&#x27;=([^;]*)(;|$)&#x27;</span>);</span><br><span class="line">     <span class="keyword">const</span> arr = <span class="built_in">document</span>.cookie.match(reg);</span><br><span class="line">     <span class="keyword">if</span> (arr != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(arr[<span class="number">2</span>]);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 循环，不借助正则</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> strcookie = <span class="built_in">document</span>.cookie;<span class="comment">//获取cookie字符串</span></span><br><span class="line">      <span class="keyword">var</span> arrcookie = strcookie.split(<span class="string">&quot;; &quot;</span>);<span class="comment">//分割</span></span><br><span class="line">      <span class="comment">//遍历匹配</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrcookie.length; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> arr = arrcookie[i].split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (arr[<span class="number">0</span>] == name)&#123;</span><br><span class="line">              <span class="keyword">return</span> arr[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Cookie;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、cookie与session特点对比"><a href="#4、cookie与session特点对比" class="headerlink" title="4、cookie与session特点对比"></a>4、cookie与session特点对比</h3><h4 id="1、存储大小和位置"><a href="#1、存储大小和位置" class="headerlink" title="1、存储大小和位置"></a>1、存储大小和位置</h4><ul><li>cookie：<ul><li>服务端生成，<strong>客户端维护和存储</strong>，以键值对的形式。</li><li>每个域名下Cookie的数量不能超过20个，单个 Cookie 保存的数据不能超过 4K；</li></ul></li><li>Session：<ul><li>客户端请求服务端，服务端会为这次请求生成一个 <strong>Session 对象</strong>，代表着服务器和客户端一次会话的过程</li><li>session对象：结构为 <code>ConcurrentHashMap</code>，存储特定用户会话所需属信息</li><li>session基于cookie实现的，要先攻破cookie获取sessionID</li></ul></li></ul><h4 id="2、生存期"><a href="#2、生存期" class="headerlink" title="2、生存期"></a>2、生存期</h4><ul><li>Cookie分类： Session Cookies、持久性 Cookie<ul><li>如 Cookie 不包含到期日期，则视为会话 Cookie。存在内存中不会写入磁盘，当浏览器关闭时， Cookie 将永久丢失</li><li>如 Cookie 包含<code>有效期</code> ，则视为持久性 Cookie。在到期时，Cookie 将从磁盘中删除</li></ul></li><li>Session：<ul><li>存储在 Session 对象中的变量，在整个用户会话中一直存在下去</li><li>当客户端关闭会话，或者 Session 超时失效时会话结束</li></ul></li></ul><h4 id="3、隐私策略"><a href="#3、隐私策略" class="headerlink" title="3、隐私策略"></a>3、隐私策略</h4><ul><li><p>Cookie：</p><ul><li><p>存在客户端，容易被窃取</p></li><li><p>同源窗口共享：同一域名发送http请求，会携带相同cookie，服务器拿到cookie解析得到客户端状态。不支持跨域名</p></li></ul></li><li><p>Session 存储在服务端，安全性相对 Cookie 要好一些。并且session基于cookie实现的</p><ul><li>要先攻破cookie获取session ID，session ID是加密的</li><li>如果禁用cookie就要通过重写url的方式：把sessionID放到url中</li></ul></li></ul><h4 id="4、缺点"><a href="#4、缺点" class="headerlink" title="4、缺点"></a>4、缺点</h4><ul><li><p>cookie：</p><ul><li><p>性能缺陷：cookie紧跟域名，域名相同的请求，不管是否需要都携带，浪费性能</p></li><li><p>安全问题：HTTP明文传递，第三方攻击拦截；或者获取本地文件就能获取cookie数据</p><p>易遭受XSS攻击，所以有<strong>cookie安全策略</strong>；</p><p>易遭受XSRF攻击，所以有<strong>Set-Cookie：SameSite</strong>   </p></li></ul></li><li><p>session：比如 A 服务器存储了 Session，做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 访问，但B 服务器并没有存 A 的 Session，会导致 Session 失效</p></li></ul><h3 id="5、cookie和session的缺陷"><a href="#5、cookie和session的缺陷" class="headerlink" title="5、cookie和session的缺陷"></a>5、cookie和session的缺陷</h3><p>存在一些问题：存储空间、分布式问题、安全</p><ol><li>存储空间：由于服务器端需要对接大量的客户端，也就需要存放大量的 SessionId，这样会导致服务器存储压力过大。</li><li>分布式问题：如果服务器端是一个集群，为了同步登录态，需要将 SessionId 同步到每一台机器上，增加服务器端维护成本。</li><li>安全：由于 SessionId 存放在 Cookie 中，所以无法避免 CSRF 攻击：<ul><li>攻击者诱导用户进入一个第三方网站，然后该网站向<strong>被攻击网站</strong>发送跨站请求。</li><li>如果用户在<strong>被攻击网站中保存了登录状态</strong>，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</li><li>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></li></ul></li></ol><h3 id="6、Token机制"><a href="#6、Token机制" class="headerlink" title="6、Token机制"></a>6、Token机制</h3><ul><li><p>诞生的原因：为了解决 Session + Cookie 机制问题：</p><ul><li>安全：存登录凭证相关信息，不必放在cookie中；</li><li>存储空间：不再存储，而是验证即可</li></ul></li><li><p>Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌</p><ul><li><p>当第一次登录后，服务器会生成一个 Token 并返回给客户端；</p></li><li><p>客户端后续访问时，只需带上这个 Token 即可完成身份认证。</p></li></ul></li></ul><h4 id="1、Token-机制实现流程"><a href="#1、Token-机制实现流程" class="headerlink" title="1、Token 机制实现流程"></a>1、Token 机制实现流程</h4><p>用户<strong>首次登录</strong>时：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/2/1730fcc51ab8a1db~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由<strong>客户端自由保存</strong>。</li></ol><p><strong>后续页面访问时：</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/2/1730fcc519ee3add~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li>用户访问 <code>a.com/pageB</code> 时，带上第一次登录时获取的 Token。</li><li>服务器端验证 Token ，有效则身份验证成功。</li></ol><h4 id="2、Token-机制的特点"><a href="#2、Token-机制的特点" class="headerlink" title="2、Token 机制的特点"></a>2、Token 机制的特点</h4><p>根据上面的案例，分析出 Token 的优缺点：</p><ul><li>服务器端<strong>无需维护Token存储空间</strong>，只需要首次生成Token，<strong>后续验证即可：</strong><ul><li>所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本</li></ul></li><li>Token 可存放在前端任何地方，可以不用存在 Cookie 中，提升页面安全性</li><li>Token 下发之后，只要在生效时间之内，就一直有效，如果服务器端<strong>想收回此 Token 的权限，并不容易</strong></li></ul><h4 id="3、Token-的生成步骤"><a href="#3、Token-的生成步骤" class="headerlink" title="3、Token 的生成步骤"></a>3、Token 的生成步骤</h4><ul><li><p>最常见： JWT（Json Web Token），通信双方之间以 JSON 对象的形式安全的传递信息</p></li><li><h4 id="JWT构成：主要分为-3-个部分：header（头信息），playload（消息体），signature（签名）"><a href="#JWT构成：主要分为-3-个部分：header（头信息），playload（消息体），signature（签名）" class="headerlink" title="JWT构成：主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）"></a>JWT构成：主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）</h4><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210206202812405.png" alt="image-20210206202812405" style="zoom: 33%;" /><ol><li><p>header 部分指定了该 JWT 使用的签名算法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">header = <span class="string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   </span><br><span class="line"> <span class="comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名：同一个密钥加密解密</span></span><br><span class="line"> <span class="comment">// JWT，固定值，通常都写成JWT即可</span></span><br></pre></td></tr></table></figure></li><li><p>playload 部分：携带的数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     </span><br><span class="line"><span class="comment">//iat 表示令牌生成的时间</span></span><br><span class="line"><span class="comment">// exp（expiration time）：过期时间</span></span><br></pre></td></tr></table></figure></li><li><p>signature 部分为 JWT 的签名：</p><p>主要为了让 JWT 不能被随意篡改，签名的方法分为两个步骤：</p><ol><li>输入 <code>base64url</code> 编码的 header 部分、 <code>.</code> 、<code>base64url</code> 编码的 playload 部分，输出 unsignedToken。</li><li>输入服务器端私钥、unsignedToken，输出 signature 签名</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = encodeBase64(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = encodeBase64(payload)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;服务器私钥&#x27;</span></span><br><span class="line"></span><br><span class="line">signature = HMAC(key, unsignedToken)</span><br></pre></td></tr></table></figure></li><li><p>最后的 Token 计算：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Signature = encodeBase64(signature)</span><br><span class="line">token = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>.<span class="subst">$&#123;base64Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="4、服务器解密Token"><a href="#4、服务器解密Token" class="headerlink" title="4、服务器解密Token"></a>4、服务器解密Token</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [base64Header, base64Payload, base64Signature] = token.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature1 = decodeBase64(base64Signature);</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> signature2 = HMAC(<span class="string">&#x27;服务器私钥&#x27;</span>, unsignedToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signature1 === signature2) <span class="keyword">return</span> <span class="string">&#x27;签名验证成功，token 没有被篡改&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload =  decodeBase64(base64Payload)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - payload.iat &lt; <span class="string">&#x27;token 有效期&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;token 有效&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="7、分布式session问题"><a href="#7、分布式session问题" class="headerlink" title="7、分布式session问题"></a>7、分布式session问题</h3><p>前面说到了session+cookie的3点缺陷，其实token只解决了两点。而对于分布式问题：</p><ul><li>互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来撑前端用户请求</li><li>那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会登录失效问题</li></ul><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li><li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li><li>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致   推荐这一种</li></ul><h3 id="8、localStorage-amp-sessionStorage"><a href="#8、localStorage-amp-sessionStorage" class="headerlink" title="8、localStorage &amp; sessionStorage"></a>8、localStorage &amp; sessionStorage</h3><h4 id="1、诞生的契机"><a href="#1、诞生的契机" class="headerlink" title="1、诞生的契机"></a>1、诞生的契机</h4><ul><li><p>cookie：</p><p>设置“<strong>每次请求都要携带的信息（最典型的就是身份认证信息</strong>）”就特别适合放在cookie中，免去了重复添加操作，其他类型的数据就不适合了</p></li><li><p>在 localStorage 出现之前，cookie被滥用当做了存储工具。什么数据都放在cookie中，即使这些数据只在页面中使用而不需要随请求传送到服务</p></li></ul><h4 id="2、localStorage"><a href="#2、localStorage" class="headerlink" title="2、localStorage"></a>2、localStorage</h4><ul><li><strong>持久化存储：</strong>长期存数据，浏览器关闭后数据不丢失，存的数据没有过期时间，直到手动去除；</li><li>**同源: **   同源窗口中都是共享的</li></ul><h4 id="3、sessionStorage"><a href="#3、sessionStorage" class="headerlink" title="3、sessionStorage"></a>3、sessionStorage</h4><ul><li><strong>持久化存储：</strong>临时存储数据，在关闭窗口或标签页之后会删除</li><li>**同源问题: **   更严苛：不仅要求同源，还要求同一个浏览器窗口中打开</li></ul><img src="https://www.runoob.com/wp-content/uploads/2019/04/3793073884-56950753e65db_articlex.png" alt="img" style="zoom: 33%;" /><h4 id="4、存储超容量问题"><a href="#4、存储超容量问题" class="headerlink" title="4、存储超容量问题"></a>4、存储超容量问题</h4><p><strong>localstorage超容量会怎样？</strong>                    美团</p><p>问题根源：</p><ul><li>同一个域名共享同一个 localStorage，而同一个域名下存在过多独立的业务线，业务线之间各自为政，毫无节制的攫取公共资源</li></ul><p>问题本质：</p><ul><li><p>localStorage 归根结底就两个作用：<strong>持久化存储与跨页面传数据</strong>。问题就出在跨页面传数据上，上一个页面因为 localStorage 存满导致数据没有写入，下一个页面读取数据为空，从而导致错误。</p></li><li><p>浏览器反应：</p><ul><li>不存储数据, 也不会覆盖现有数据。</li><li>引发 QUOTA_EXCEEDED_ERR 异常。</li></ul></li><li><p>该怎么办？</p><p>1、划分域名：各域名下的存储空间由各业务组统一规划使用</p><p>2、跨页面传数据：考虑单页应用、优先采用 url 传数据。</p><ul><li>每一个域名下的localStorage容量是5M，假如a.com域名下localstorage存不下了</li><li>可以用iframe创建b.com域框架(子页面)用于存 a.com剩下的数据。然后用postMessage读写数据</li></ul><p>3、indexDB</p><p>4、最后的兜底方案：清掉别人的存储</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-大顶堆与小顶堆</title>
      <link href="/2021/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8E%E5%B0%8F%E9%A1%B6%E5%A0%86/"/>
      <url>/2021/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8E%E5%B0%8F%E9%A1%B6%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h3 id="6-1、第K个最大元素-215中"><a href="#6-1、第K个最大元素-215中" class="headerlink" title="6.1、第K个最大元素       215中"></a>6.1、第K个最大元素       215中</h3><p>在未排序的数组中找到第 <strong>k 个最大</strong>的元素。</p><h4 id="思路1：大顶堆"><a href="#思路1：大顶堆" class="headerlink" title="思路1：大顶堆"></a>思路1：大顶堆</h4><p>思路总结：</p><ul><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素「沉」到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶与当前末尾元素，反复执行调整、交换步骤，直到整个序列有序。</li></ul><h4 id="1、构造初始堆"><a href="#1、构造初始堆" class="headerlink" title="1、构造初始堆"></a>1、构造初始堆</h4><ol><li><p>给定无序序列结构 </p><img src="https://pic.leetcode-cn.com/1624163715-VXPhZJ-image.png" alt="image.png" style="zoom:50%;" /></li><li><p><strong>此时从最后一个非叶子节点开始调整</strong>，从左到右，从上到下进行调整。也就是 元素为 6 的节点。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较时：先让 5 与 9 比较，得到最大那个，再和 6 比较，发现 9 大于 6，则调整他们的位置</span><br></pre></td></tr></table></figure></li><li><p>找到第二个非叶子节点 4，由于 <code>[4,9,8]</code> 中，9 元素最大，则 4 和 9 交换</p><img src="https://pic.leetcode-cn.com/1624163737-nWDnEx-image.png" alt="image.png" style="zoom: 67%;" /></li><li><p>此时，交换导致子根 <code>[4,5,6]</code> 结构混乱，将其继续调整。<code>[4,5,6]</code> 中 6 最大，将 4 与 6 调整。此时，就将一个无序序列构造成了一个大顶堆。</p><img src="https://pic.leetcode-cn.com/1624163748-vVZNTN-image.png" alt="image.png" style="zoom: 67%;" /></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从最后一个非叶子节点开始 自下而上构建一颗大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    adjustHeap(arr, i, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从左向右，自上而下的调整节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustHeap</span>(<span class="params">arr, i, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = i * <span class="number">2</span> + <span class="number">1</span>;             <span class="comment">// 左子节点索引</span></span><br><span class="line">  <span class="keyword">let</span> right = i * <span class="number">2</span> + <span class="number">2</span>;            <span class="comment">// 右子节点索引</span></span><br><span class="line">  <span class="keyword">let</span> maxIndex = i;                <span class="comment">// 最大值索引</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最大的给父节点</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[maxIndex]) maxIndex = left;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[maxIndex]) maxIndex = right;</span><br><span class="line">  <span class="comment">// maxIndex为父节点，若发生改变则说明不是最大节点，需要交换</span></span><br><span class="line">  <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">    [arr[maxIndex], arr[i]] = [arr[i], arr[maxIndex]];</span><br><span class="line">    adjustHeap(arr, maxIndex, heapSize); <span class="comment">// 继续调整下面的非叶子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、将堆顶元素与末尾元素交换"><a href="#2、将堆顶元素与末尾元素交换" class="headerlink" title="2、将堆顶元素与末尾元素交换"></a>2、将堆顶元素与末尾元素交换</h4><p>将堆顶元素与末尾元素交换，使其末尾元素最大。然后继续调整，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p><ol><li><p>将堆顶元素 9 和末尾元素 4 交换</p><img src="https://pic.leetcode-cn.com/1624163757-rooMsP-image.png" alt="image.png" style="zoom:50%;" /></li><li><p>重新调整结构，使其继续满足堆定义</p><img src="https://pic.leetcode-cn.com/1624163766-WsYato-image.png" alt="image.png" style="zoom:50%;" /></li><li><p>再将堆顶元素 8 与末尾元素 5 交换，得到第二大元素 8</p><img src="https://pic.leetcode-cn.com/1624163783-IhXOJT-image.png" alt="image.png" style="zoom:50%;" /></li><li><p>后续过程，继续进行调整、交换，如此反复进行，最终使得整个序列有序</p></li></ol>   <img src="https://pic.leetcode-cn.com/1624163793-fGUBxG-image.png" alt="image.png" style="zoom:50%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> heapSize = nums.length;</span><br><span class="line">  buildMaxHeap(nums, heapSize); <span class="comment">// 构建好一个大顶堆</span></span><br><span class="line">  <span class="comment">// 进行下沉 大顶堆是最大元素下沉到末尾</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = nums.length-<span class="number">1</span>; i&gt;=nums.length-k+<span class="number">1</span>; i--)&#123;</span><br><span class="line">    [nums[i], nums[<span class="number">0</span>]] = [nums[<span class="number">0</span>], nums[i]];</span><br><span class="line">    heapSize--; <span class="comment">// 下沉后的元素不参与到大顶堆的调整</span></span><br><span class="line">    <span class="comment">// 重新调整大顶堆</span></span><br><span class="line">    adjustHeap(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk)</li><li>空间复杂度：O(k)</li></ul><h4 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h4><ul><li>注意事项（代码实现的关键思路）：<ul><li>第一步构建初始堆：是自底向上构建，从最后一个非叶子节点开始。</li><li>第二步就是<strong>下沉操作</strong>让尾部元素与堆顶元素交换，最大值被放在数组末尾，并且<strong>缩小数组的length</strong>，不参与后面大顶堆的调整</li><li>第三步就是调整：是<strong>从上到下，从左到右</strong>,因为堆顶元素下沉到末尾了，要重新调整这颗大顶堆</li></ul></li></ul><h3 id="6-2、前-K-个高频元素-347中"><a href="#6-2、前-K-个高频元素-347中" class="headerlink" title="6.2、前 K 个高频元素   347中"></a>6.2、前 K 个高频元素   347中</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><ul><li>输入: nums = [1,1,1,2,2,3], k = 2           输出: [1,2]</li></ul><h4 id="思路1：map-小顶堆"><a href="#思路1：map-小顶堆" class="headerlink" title="思路1：map + 小顶堆"></a>思路1：map + 小顶堆</h4><ul><li><p>遍历一遍数组统计每个元素频率，并将元素值（ key ）与出现的频率（ value ）存到 map </p></li><li><p>遍历 map ，将所有元素构建一个小顶堆</p></li><li><p>再逐个从小顶堆的第1个淘汰，置换到尾部：从len — k个</p><ul><li>从len-1开始，直到索引为k；</li><li>注意，每次淘汰一个，都要将数组中删除该元素，不要再参与后续堆调整</li></ul></li><li><p>淘汰结束，剩下数组中的就是前k个频率最高的元素了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> topKFrequent = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="comment">// 统计次数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    map.set(num, (map.get(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> arr = [...map.keys()];</span><br><span class="line">  <span class="keyword">let</span> heapSize = arr.length;</span><br><span class="line">  <span class="keyword">if</span>(map.size &lt;= k) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">  buildMinHeap(arr, heapSize, map);<span class="comment">// 构建小堆顶</span></span><br><span class="line">  <span class="comment">// 下沉 小顶堆是最小元素下沉到末尾</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length-<span class="number">1</span>; i&gt;= k; i--)&#123;</span><br><span class="line">    [arr[i], arr[<span class="number">0</span>]] = [arr[<span class="number">0</span>], arr[i]];</span><br><span class="line">     <span class="comment">// 下沉后的元素不参与到小顶堆的调整</span></span><br><span class="line">    heapSize--;</span><br><span class="line">    <span class="comment">// 重新调整小顶堆</span></span><br><span class="line">    arr.splice(i, <span class="number">1</span>)</span><br><span class="line">    adjustHeap(arr, <span class="number">0</span>, heapSize, map);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMinHeap</span>(<span class="params">arr, heapSize, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    adjustHeap(arr, i, heapSize, map);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustHeap</span>(<span class="params">arr, i, heapSize, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = i * <span class="number">2</span> + <span class="number">1</span>;             </span><br><span class="line">  <span class="keyword">let</span> right = i * <span class="number">2</span> + <span class="number">2</span>;          </span><br><span class="line">  <span class="keyword">let</span> minIndex = i;                </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left&lt;heapSize &amp;&amp; map.get(arr[left])&lt;map.get(arr[minIndex])) minIndex = left;</span><br><span class="line">  <span class="keyword">if</span> (right&lt;heapSize &amp;&amp; map.get(arr[right])&lt;map.get(arr[minIndex])) minIndex = right;</span><br><span class="line">  <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">    [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];</span><br><span class="line">    adjustHeap(arr, minIndex, heapSize, map); <span class="comment">// 交换之后递归再次调整比较</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于前端页面渲染</title>
      <link href="/2021/12/13/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/"/>
      <url>/2021/12/13/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h2 id="这部分的东西会结合JS的整个运行重新梳理，这个笔记不太满意"><a href="#这部分的东西会结合JS的整个运行重新梳理，这个笔记不太满意" class="headerlink" title="这部分的东西会结合JS的整个运行重新梳理，这个笔记不太满意"></a>这部分的东西会结合JS的整个运行重新梳理，这个笔记不太满意</h2><h2 id="1、Webkit渲染流程"><a href="#1、Webkit渲染流程" class="headerlink" title="1、Webkit渲染流程"></a>1、Webkit渲染流程</h2><p>浏览器获取到html，然后解析，渲染</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d69da20c3f84782948226798effc60a~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:50%;" /><h3 id="1、DOM树构建"><a href="#1、DOM树构建" class="headerlink" title="1、DOM树构建"></a>1、DOM树构建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure><h4 id="1、转换"><a href="#1、转换" class="headerlink" title="1、转换"></a>1、转换</h4><ul><li>浏览器将获得的HTML内容是0/1这样的原始 <code>字节流</code>，根据文件的指定编码 (例如 UTF-8) 将它们转换成各个 <code>字符</code></li></ul><h4 id="2、分词"><a href="#2、分词" class="headerlink" title="2、分词"></a>2、分词</h4><ul><li><p>进行 <code>词法解析</code> ，把字符流初步解析成我们可理解的 <code>词</code>，学名叫 <code>token</code></p></li><li><p><code>词</code> 是编译原理中的最小单元，如标签开始、属性、标签结束、注释、CDATA节点</p></li><li><p><code>Tokens</code> 这个阶段中会标识出当前 <code>Token</code> 是 <code>开始标签</code> 或是 <code>结束标签</code> 亦或是 <code>文本</code> 等信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;haha&quot;</span>&gt;haha&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;div# 哦，看到了&lt;div，这是一个div标签的开始</span><br><span class="line"><span class="number">2.</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;haha&quot;</span> # 这是一个<span class="class"><span class="keyword">class</span>属性</span></span><br><span class="line"><span class="class">3. &gt;# 哦，到这儿是一个完整的<span class="title">div</span>开始标签</span></span><br><span class="line"><span class="class">4. <span class="title">haha</span># 嗯，这是一个文本</span></span><br><span class="line"><span class="class">5. &lt;/<span class="title">div</span>&gt;# 奥，看到了&lt;/<span class="title">div</span>&gt;，整个<span class="title">div</span>标签结束了</span></span><br></pre></td></tr></table></figure><img src="https://segmentfault.com/img/remote/1460000013662139" alt="img" style="zoom: 67%;" /></li></ul><h4 id="3、节点创建"><a href="#3、节点创建" class="headerlink" title="3、节点创建"></a>3、节点创建</h4><ul><li>在每个 <code>Token</code> 被生成后，会立刻消耗这个 <code>Token</code> 创建出节点对象，就是 节点 (Nodes) 阶段</li><li>把开始结束标签配对、属性赋值好、父子关系这些都连接好了，最终就构成了 <code>DOM</code> 树</li><li>到此 <code>DOM Tree</code> 就解析完了</li></ul><h3 id="2、解析CSS—-gt-CSSOM"><a href="#2、解析CSS—-gt-CSSOM" class="headerlink" title="2、解析CSS—&gt;CSSOM"></a>2、解析CSS—&gt;CSSOM</h3><ul><li><p>CSS规则树的生成也是类似</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure><p>譬如<code>style.css</code>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的CSSOM树就是：</p><img src="https://segmentfault.com/img/remote/1460000013662141" alt="img" style="zoom: 50%;" /></li></ul><h4 id="2、CSS阻塞"><a href="#2、CSS阻塞" class="headerlink" title="2、CSS阻塞"></a>2、CSS阻塞</h4><ul><li><p>节点样式是可以继承的，所以在构建的过程中浏览器得递归 <code>DOM</code> 树来确定元素到底是什么样式</p></li><li><p>为了 <code>CSSOM</code> 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 <code>DOM</code> 已经构建完了，也得等 <code>CSSOM</code>，在 CSSOM 构建完毕之前，不会渲染任何已处理的内容</p></li><li><p>所以 <code>CSS</code> 的加载速度与构建 <code>CSSOM</code> 的速度<strong>会影响首屏渲染速度</strong>，这就是常说的 <code>CSS</code> 资源的加载会阻塞渲染</p></li></ul><h3 id="3、解析JS脚本"><a href="#3、解析JS脚本" class="headerlink" title="3、解析JS脚本"></a>3、解析JS脚本</h3><h4 id="1-1、JS既会阻塞HTML、CSS的解析"><a href="#1-1、JS既会阻塞HTML、CSS的解析" class="headerlink" title="1.1、JS既会阻塞HTML、CSS的解析"></a>1.1、JS既会阻塞HTML、CSS的解析</h4><ul><li><p>解析 <code>JS</code> 的步骤是不固定的，因为在构建DOM 树的过程中，当 <code>HTML</code> 解析器遇到一个 <code>script</code> 标记时，<strong>即遇到了js，立即阻塞DOM树的构建</strong></p></li><li><p>就会将控制权移交给 <code>JS</code> 引擎，等到 <code>JS</code> 引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建</p></li><li><p>设计的原因：JS可以对DOM操作节点，浏览器无法预测未来的DOM节点的具体内容，<strong>为了防止无效操作，节省资源，只能阻塞DOM树的构建</strong></p><p>假如不阻塞，若 JS 删了某个DOM节点A，那么浏览器为构建此节点A花费的资源是无效的</p></li><li><p><strong>遇到img图片类资源</strong></p><p>直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p></li></ul><h4 id="1-2、优化："><a href="#1-2、优化：" class="headerlink" title="1.2、优化："></a>1.2、优化：</h4><ol><li><p>尽量将JavaScript文件放在body的最后</p><p>若在 HTML 头部加载 JS 文件，由于 JS 阻塞，会推迟页面的首绘，所以为了加快页面渲染，一般将 JS 文件放到HTML 底部进行加载</p></li><li><p>script标签引入：对 JS 文件执行 <code>async</code> 或 <code>defer</code> 加载</p><ul><li><code>script</code>立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li><li><code>async</code> 是下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；一定在 <code>onload</code> 前，但不确定在 <code>DOMContentLoaded</code> 事件的前或后</li><li><code>defer</code> 是加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行，所以在浏览器看起来的效果像是将脚本放在了 <code>body</code> 后面一样，按规范应该是在 <code>DOMContentLoaded</code> 事件前，但不同浏览器不同</li></ul></li></ol><h5 id="loaded-domcontentloaded"><a href="#loaded-domcontentloaded" class="headerlink" title="loaded/domcontentloaded"></a>loaded/domcontentloaded</h5><ul><li><p><code>DOMContentLoaded</code> ：仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)，所以js可以访问所有DOM节点，初始化界面</p></li><li><p><code>load </code>：页面上所有的DOM，样式表，脚本，图片都已经加载完成了</p></li><li><p><code>unload</code> – 当用户离开页面的时候触发，可以询问用户是否保存了更改以及是否确定要离开页面,，可是我们无法阻止用户转移到另一个页面上。</p></li><li><p><code>beforeunload</code>:用户即将离开页面或者关闭窗口时，beforeunload事件将会被触发以进行额外的确认</p></li><li><p><code>document.readyState</code>表征页面的加载状态，可以在<code>readystatechange</code>中追踪页面的变化状态：</p><ul><li><code>loading</code> — 页面正在加载中。</li><li><code>interactive</code> – 页面解析完毕，时间上和 <code>DOMContentLoaded</code>同时发生，不过顺序在它之前。</li><li><code>complete</code> – 页面上的资源都已加载完毕，时间上和<code>window.onload</code>同时发生，不过顺序在他之前</li></ul></li></ul><h4 id="2-1、CSS阻塞页面渲染"><a href="#2-1、CSS阻塞页面渲染" class="headerlink" title="2.1、CSS阻塞页面渲染"></a>2.1、CSS阻塞页面渲染</h4><p>使用CSS有三种方式：使用<strong>link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p><ul><li><p><strong>link</strong>：浏览器会派发一个新等线程(<strong>HTTP线程</strong>)去加载资源文件，<strong>与此同时GUI渲染线程</strong>会继续向下渲染代码</p></li><li><p><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(<strong>阻碍浏览器渲染</strong>)</p></li><li><p><strong>style</strong>：GUI直接渲染，减少关键渲染资源从服务器端到客户端的往返次数，因为不用link那样请求</p></li><li><p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p></li><li><p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p></li></ul><p><strong>针对DOM树、CSSOM树：</strong> 可以通过以下几种方式来减少渲染的时间：</p><ul><li>HTML文件的代码层级尽量不要太深</li><li>使用语义化的标签，来避免不标准语义化的特殊处理</li><li>减少CSSD代码的层级，因为选择器是从左向右进行解析的</li></ul><h4 id="3、-CSS-如何阻塞JS脚本执行？"><a href="#3、-CSS-如何阻塞JS脚本执行？" class="headerlink" title="3、 CSS 如何阻塞JS脚本执行？"></a>3、 CSS 如何阻塞JS脚本执行？</h4><ul><li>JS脚本执行时<strong>可能在文档的解析过程中请求样式信息</strong>，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</li><li>所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将<strong>延迟 JS 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建</strong></li><li>在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JS，最后再继续文档的解析。</li></ul><h3 id="4、构建render树"><a href="#4、构建render树" class="headerlink" title="4、构建render树"></a>4、构建render树</h3><h4 id="1、构建顺序"><a href="#1、构建顺序" class="headerlink" title="1、构建顺序"></a>1、构建顺序</h4><ul><li>渲染树 由 <code>DOM树</code>、<code>CSSOM树</code> 合并而成，但并不是必须等 <code>DOM树</code> 及 <code>CSSOM树</code> 加载完成后才开始合并构建 <code>渲染树</code></li><li>三者的构建并无先后条件，也并非完全独立，而是会有交叉，并行构建，因此会形成一边加载，一边解析，一边渲染的工作现象</li><li>渲染树的节点被称为<strong>渲染对象</strong>，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，<strong>不可见的 DOM 元素不会被插入渲染树</strong>。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li></ul><h4 id="2、render树构建流程"><a href="#2、render树构建流程" class="headerlink" title="2、render树构建流程"></a>2、render树构建流程</h4><ol><li>浏览器首先会从DOM树的根节点开始遍历每个可见节点<ul><li>例如脚本标记、元标记等有些节点不可见，因为它们不会体现在渲染输出中，所以会被忽略</li><li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如上图的其中一个 <code>span</code> 标签有 <code>display: none</code> 属性，也会被忽略</li><li>一般来说，渲染树和DOM树不是严格对应。因为有一些不可见的DOM元素不会插入到渲染树中，如<strong>head这种不可见的标签</strong>或者<code>display: none</code>等</li></ul></li><li>对于每个可见节点，找到其对应的的 CSSOM 规则并应用它们</li><li>输出可见节点，连同其内容和计算的样式</li></ol><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/22/1719d8c1564c3947~tplv-t2oaga2asx-watermark.awebp" alt="image-20200418220809467" style="zoom:67%;" /><h3 id="5、布局阶段"><a href="#5、布局阶段" class="headerlink" title="5、布局阶段"></a>5、布局阶段</h3><ul><li><p>至此，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们还没有计算它们在设备 <a href="https://link.juejin.cn/?target=https://developers.google.com/web/fundamentals/design-and-ux/responsive?hl=zh-cn%23set-the-viewport">视口</a> 内的确切位置和大小，而这就是 <code>布局</code> ( Layout ) 阶段，也称为 <code>回流</code> ( Reflow )</p></li><li><p>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p></li><li><p>布局流程的输出是一个 <code>盒模型</code>，它会精确地捕获每个元素在视口内的确切位置和尺寸，当然，所有相对测量值都转换为屏幕上的绝对像素</p></li></ul><h3 id="6、绘制"><a href="#6、绘制" class="headerlink" title="6、绘制"></a>6、绘制</h3><ul><li>由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，我们将这些信息传递给最后一个阶段将渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 <code>绘制</code> 或 <code>栅格化</code></li></ul><h4 id="1、重绘"><a href="#1、重绘" class="headerlink" title="1、重绘"></a>1、重绘</h4><ul><li>元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了，这叫做 <code>重绘</code> ( Repaint )</li><li>outline, visibility, color, background-color等</li></ul><h4 id="2、回流"><a href="#2、回流" class="headerlink" title="2、回流"></a>2、回流</h4><ul><li><p>一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p></li><li><h4 id="回流的场景："><a href="#回流的场景：" class="headerlink" title="回流的场景："></a>回流的场景：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line">4.窗口resize，字体大小会引起回流!!!</span><br><span class="line">5.最复杂的一种：获取某些属性，引发回流，很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （1）offset(Top/Left/Width/Height)</span><br><span class="line">     (2) scroll(Top/Left/Width/Height)</span><br><span class="line">     (3) cilent(Top/Left/Width/Height)</span><br><span class="line">     (4) width,height</span><br><span class="line">     (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、如何减少和避免回流重绘"><a href="#3、如何减少和避免回流重绘" class="headerlink" title="3、如何减少和避免回流重绘"></a>3、如何减少和避免回流重绘</h4><p>其实就是尽量避免上面那些操作</p><ul><li>减少逐项更改样式，最好一次性更改 <code>style</code>，或者将样式定义为 <code>class</code> 并一次性更新</li><li>避免循环操作DOM，让DOM离线后再修改<ul><li>创建一个 <code>documentFragment</code> ，在它上面应用所有DOM操作，最后再把它添加到 <code>window.document</code></li><li>先把DOM节点 <code>display:none</code> ( 会触发一次回流)，然后做修改后，再把它显示出来</li><li>克隆一个DOM节点在内存里，修改之后，与在线的节点相替换</li></ul></li><li>避免多次读取offset等属性，无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li><li>改变字体大小也会引发回流，所以尽可能减少这种操作</li><li>table布局，一个小改动会造成整个table的重新布局，所以，少用为好</li></ul><h3 id="7、合成"><a href="#7、合成" class="headerlink" title="7、合成"></a>7、合成</h3><p>到目前我们经历渲染过程如下</p><ul><li>首先解析 <code>HTML</code> 文档，形成 DOM 树</li><li>接着解析 <code>CSS</code>，产生 CSSOM树</li><li>在DOM和CSSOM树解析过程中，遇到 JS，会立即阻塞DOM树的构建，JS解析完成，接着走上面两步</li><li>再接着，浏览器通过DOM和CSSOM树构建渲染树 <ul><li>这个过程中，DOM中不可见标签元素不会放到渲染树中，就像<code> 或 display:none</code></li><li>CSSOM树规则会附加给渲染树的每个元素上</li></ul></li><li>渲染树构建完成，浏览器会对这些元素进行定位和布局，这一步也叫 重排/回流 ( <code>Reflow</code>) 或 布局(<code>Layout</code> )</li><li>接下来绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做 重绘 (<code>Repaint</code>)</li><li>再接下来是我们这最后一步合成( <code>composite</code> )，浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</li></ul><h3 id="8、浏览器渲染方式"><a href="#8、浏览器渲染方式" class="headerlink" title="8、浏览器渲染方式"></a>8、浏览器渲染方式</h3><p>浏览器在渲染图形的时候，有一个绘图上下文，绘图上下文又分成两种类型</p><ul><li>第一种是用来绘制2D图形的上下文，称之为2D绘图上下文</li><li>第二种是绘制3D图形的上下文，称之为3D绘图上下文</li></ul><p>网页也有三种渲染方式</p><ul><li>软件渲染（CPU内存）</li><li>使用软件绘图的合成化渲染（GPU内存）CSS3D、WebGL</li><li>硬件加速的合成化渲染（GPU内存）</li></ul><h4 id="1、软件渲染技术"><a href="#1、软件渲染技术" class="headerlink" title="1、软件渲染技术"></a>1、软件渲染技术</h4><p>Webkit 在不需要硬件加速内容的时候（包括但不限于 <code>CSS3 3D变形</code>、<code>CSS3 3D变换</code> 、 <code>WebGL</code> 和 <code>视频</code>），它就可以使用 <code>软件渲染技术</code> 来完成页面绘制</p><p>对于每个渲染对象，需要三个阶段绘制自己</p><ul><li>第一阶段是绘制该层中所有块的背景和边框</li><li>第二阶段是绘制浮动内容</li><li>第三阶段是前景 ( Foreground ) ，也就是内容部分、轮廓、字体颜色、大小等 ( 内嵌元素的背景、边框等发生在这一阶段 )</li></ul><h4 id="2、硬件加速技术"><a href="#2、硬件加速技术" class="headerlink" title="2、硬件加速技术"></a>2、硬件加速技术</h4><p>硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页 ( GPU的作用主要是用来绘制3D图形并且性能很 nice )</p><h4 id="3、普通图层和复合图层"><a href="#3、普通图层和复合图层" class="headerlink" title="3、普通图层和复合图层"></a>3、普通图层和复合图层</h4><p>浏览器渲染的图层一般包含两大类：<code>普通图层</code> 以及 <code>复合图层</code></p><ul><li><p><strong>普通文档流：</strong></p><p>叫它<code>默认复合层</code>，因为里面不管添加多少元素，其实都是在同一个复合图层中</p><p><code>absolute</code> 布局、 <code>fixed</code> 也一样，虽然可以脱离普通文档流，但它仍然属于 <code>默认复合层</code></p></li><li><p><strong>复合图层：</strong></p><p>可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p><p>但也不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大</p></li><li><p>GPU中，各个复合图层是单独绘制的，所以也互不影响</p></li><li><p>通过 <code>硬件加速</code> 的方式，会声明一个 <code>新的复合图层</code> ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 <code>默认复合层</code> 里的回流重绘</p></li></ul><h4 id="4、何为复合图层-硬件加速"><a href="#4、何为复合图层-硬件加速" class="headerlink" title="4、何为复合图层/硬件加速"></a>4、何为复合图层/硬件加速</h4><p>复合图层或者说硬件加速，其实就是仅触发合成 <code>composite</code> ，那么也就必须符合以下三个条件</p><ul><li>不影响文档流</li><li>不依赖文档流</li><li>不会造成重绘</li></ul><p>可以做到这种情况得</p><ul><li><p>最常用的方式是 <code>transform</code></p><p>假如我们给一个元素加了 <code>transform</code> 属性吧，那么该元素就不会影响也不会依赖文档流，也不会造成重绘，就变成了一个复合图层</p><p>也就可以说我们对它使用了传说中的 <code>硬件加速技术</code></p></li><li><p><code>opacity</code> 属性 / 过渡动画 (需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态)</p></li><li><p><code>will-chang</code> 属性 (这个比较偏僻)，一般配合 <code>opacity</code> 与 <code>translate</code> 使用，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层，作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作 (最好用完后就释放)</p></li></ul><h4 id="5、absolute？"><a href="#5、absolute？" class="headerlink" title="5、absolute？"></a>5、absolute？</h4><p> <code>absolute</code> 是脱离文档流，为什么上面复合图层或者说硬件加速中没有 <code>absolute</code> 呢？</p><ul><li>其实，<code>absolute</code> 虽然可以脱离普通文档流，但是无法脱离默认复合层，就像它的 <code>left</code> 属性可以使用百分比的值，依赖于它的 <code>offset parent</code></li><li>所以，就算 <code>absolute</code> 中信息改变时不会改变普通文档流中的 <code>渲染树</code> </li><li>但浏览器最终绘制时，是整个复合层绘制的，所以 <code>absolute</code> 中信息改变，仍会影响整个复合层的绘制，浏览器还是会重绘它</li><li>如果复合层中内容多，<code>absolute</code> 带来的绘制信息变化过大，资源消耗也非常严重</li><li>硬件加速，那直接就是在另一个复合层了，所以它的信息改变不会影响默认复合层，当然内部肯定会影响属于自己的复合层，仅仅是引发最后的合成渲染</li></ul><h3 id="9、页面渲染优化"><a href="#9、页面渲染优化" class="headerlink" title="9、页面渲染优化"></a>9、页面渲染优化</h3><p>总结下页面渲染这块的优化实践：</p><ul><li>HTML文档结构层次尽量少，最好不深于六层</li><li>JS 脚本尽量后放</li><li>样式结构层次尽量简单</li><li>少量首屏样式使用内联方式放在标签内</li><li>在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流</li><li>减少通过 JS 代码修改元素样式，尽量使用修改 <code>class</code> 名方式操作样式或动画</li><li>尽量减少浏览器重排和重绘的一些情况发生</li><li>2020年了！就不要使用 <code>table</code> 布局了</li><li>CSS 动画中尽量只使用 <code>transform</code> 和 <code>opacity</code> ，不会发生重排和重绘</li><li>隐藏在屏幕外，或在页面滚动时，尽量停止动画</li><li>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</li><li>避免浏览器的隐式合成</li><li>改变复合层的尺寸</li></ul><h3 id="10、如何优化关键渲染路径？"><a href="#10、如何优化关键渲染路径？" class="headerlink" title="10、如何优化关键渲染路径？"></a>10、如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p><p>（1）关键资源的数量。</p><p>（2）关键路径长度。</p><p>（3）关键字节的数量。</p><ul><li>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</li><li>同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。</li><li>要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</li></ul><p>优化关键渲染路径的常规步骤如下：</p><p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p><p>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p><p>（3）优化关键字节数以缩短下载时间（往返次数）。</p><p>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页面解析渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于跨域问题</title>
      <link href="/2021/12/13/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/13/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1、跨域问题"><a href="#1、跨域问题" class="headerlink" title="1、跨域问题"></a>1、跨域问题</h3><ul><li><p><strong>什么是跨域：</strong>一个网页向另一个不同域名/不同协议/不同端口的网页请求资源</p></li><li><p><strong>跨域条件：</strong>协议，域名，端口，有一个不同就算跨域</p></li><li><p><strong>为什么会产生跨域请求：</strong></p><p>浏览器同源策略，规定了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的重要安全机制</p></li></ul><h3 id="2、非同源限制"><a href="#2、非同源限制" class="headerlink" title="2、非同源限制"></a>2、非同源限制</h3><ul><li>无法共享非同源网页的 Cookie、LocalStorage 和 IndexedDB     <strong>cookie跨域</strong></li><li>无法接触非同源网页的 DOM         <strong>跨域窗口iframe</strong></li><li>无法向非同源地址发送 AJAX 请求     </li></ul><h3 id="方案1、CORS（跨域资源共享）"><a href="#方案1、CORS（跨域资源共享）" class="headerlink" title="方案1、CORS（跨域资源共享）"></a>方案1、CORS（跨域资源共享）</h3><p>浏览器与服务器商量后的一个结果</p><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><ul><li><p>是一种机制，使用额外的 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 头来允许服务器声明哪些源 可以通过浏览器有权限访问哪些资源。</p></li><li><p>不需要在客户端做任何特殊的操作，浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p></li><li><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><ul><li>简单请求：不会触发预检请求的请求</li><li>复杂请求：除了简单请求</li></ul></li></ul><h4 id="2、简单请求如何工作"><a href="#2、简单请求如何工作" class="headerlink" title="2、简单请求如何工作"></a>2、简单请求如何工作</h4><p>浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息添加一个<code>Origin</code>字段：</p><ul><li>用来说明，本次请求来自哪个源（协议 + 域名 + 端口）</li><li>服务器根据这个值，决定是否同意这次请求</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="attr">Origin</span>: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line"><span class="attr">Connection</span>: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure><ol><li><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应：</p><p>浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获</p><p>【注意】：这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200</p></li><li><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p></li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line">// 指定后，可以返回`FooBar`字段的值</span><br><span class="line"><span class="attribute">Access-Control-Expose-Headers</span><span class="punctuation">: </span>FooBar</span><br><span class="line"></span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><ul><li>必须。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求</li></ul><p><strong>（2）Access-Control-Allow-Credentials</strong></p><ul><li><p>可选。它的值是一个布尔值，表示<strong>是否允许发送Cookie</strong></p></li><li><p>默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p></li><li><p>这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可</p></li></ul><p><strong>（3）Access-Control-Expose-Headers</strong></p><ul><li><p>可选，CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code></p></li><li><p>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定</p></li></ul><h4 id="3、-withCredentials-属性"><a href="#3、-withCredentials-属性" class="headerlink" title="3、 withCredentials 属性"></a>3、 withCredentials 属性</h4><ol><li>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段</li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理</li></ol><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</li></ol><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></blockquote><p>【注意】：</p><ol><li>如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</li><li>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传</li><li>且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie</li></ol><h4 id="4、复杂请求如何工作"><a href="#4、复杂请求如何工作" class="headerlink" title="4、复杂请求如何工作"></a>4、复杂请求如何工作</h4><p>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求，通过该请求来知道服务端是否允许跨域请求</p><ul><li>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段</li><li>只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错</li></ul><h4 id="4-1、预检请求的发送"><a href="#4-1、预检请求的发送" class="headerlink" title="4.1、预检请求的发送"></a>4.1、预检请求的发送</h4><ul><li><p>预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p></li><li><p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段</p></li></ul><p><strong>（1）Access-Control-Request-Method</strong></p><ul><li>必须，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code></li></ul><p><strong>（2）Access-Control-Request-Headers</strong></p><ul><li>是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code></li></ul><p>下面是一段浏览器的JavaScript脚本。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://api.alice.com/cors&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></blockquote><p>这个”预检”请求的HTTP头信息。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2、预检请求的回应"><a href="#4-2、预检请求的回应" class="headerlink" title="4.2、预检请求的回应"></a>4.2、预检请求的回应</h4><ul><li><p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应</p></li><li><p>HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure></blockquote><ol><li>HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li><p>如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段</p><p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure></li><li><p>服务器回应的其他CORS相关字段如下。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span><span class="punctuation">: </span>1728000</span><br></pre></td></tr></table></figure></blockquote><h5 id="（1）Access-Control-Allow-Methods"><a href="#（1）Access-Control-Allow-Methods" class="headerlink" title="（1）Access-Control-Allow-Methods"></a>（1）Access-Control-Allow-Methods</h5><ul><li>必须，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</li><li>返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求</li></ul><h5 id="（2）Access-Control-Allow-Headers"><a href="#（2）Access-Control-Allow-Headers" class="headerlink" title="（2）Access-Control-Allow-Headers"></a>（2）Access-Control-Allow-Headers</h5><ul><li>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的</li><li>也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段</li></ul><h5 id="（3）Access-Control-Allow-Credentials"><a href="#（3）Access-Control-Allow-Credentials" class="headerlink" title="（3）Access-Control-Allow-Credentials"></a>（3）Access-Control-Allow-Credentials</h5><ul><li>该字段与简单请求时的含义相同</li></ul><h5 id="（4）Access-Control-Max-Age"><a href="#（4）Access-Control-Max-Age" class="headerlink" title="（4）Access-Control-Max-Age"></a>（4）Access-Control-Max-Age</h5><ul><li>可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天）</li><li>在此期间，不用发出另一条预检请求</li></ul></li></ol><h4 id="4-3-、浏览器的正常请求和回应"><a href="#4-3-、浏览器的正常请求和回应" class="headerlink" title="4.3 、浏览器的正常请求和回应"></a>4.3 、浏览器的正常请求和回应</h4><ul><li><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会自动有一个<code>Origin</code>头信息字段。</p></li><li><p>服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p></li></ul><p>下面是”预检”请求之后，浏览器的正常CORS请求。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">X-Custom-Header</span><span class="punctuation">: </span>value</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure></blockquote><p>下面是服务器正常的回应</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-4、配置流程："><a href="#4-4、配置流程：" class="headerlink" title="4.4、配置流程："></a>4.4、配置流程：</h4><ul><li><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键</p></li><li><p>前端：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;name=xiamen&#x27;</span> <span class="comment">// cookie不能跨域</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span> <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;http://localhost:4000/getData&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xiamen&#x27;</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure></li><li><p>后端配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server1.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server2.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">&#x27;http://localhost:3000&#x27;</span>] <span class="comment">//设置白名单</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.headers.origin</span><br><span class="line">  <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)</span><br><span class="line">    <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">    <span class="comment">// 允许携带cookie</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 预检的存活时间</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 允许返回的头</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      res.end() <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(<span class="string">&#x27;/getData&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.setHeader(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jw&#x27;</span>) <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">  res.end(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/getData&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.end(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line">app.listen(<span class="number">4000</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、与JSONP比较"><a href="#5、与JSONP比较" class="headerlink" title="5、与JSONP比较"></a>5、与JSONP比较</h4><p>使用目的相同，但是比JSONP更强大：</p><ul><li>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求</li><li>JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</li></ul><h4 id="6、简单、复杂请求"><a href="#6、简单、复杂请求" class="headerlink" title="6、简单、复杂请求"></a>6、简单、复杂请求</h4><h5 id="1、简单请求"><a href="#1、简单请求" class="headerlink" title="1、简单请求"></a>1、简单请求</h5><p>不会触发 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS%23Preflighted_requests">CORS 预检请求</a>。这样的请求为“简单请求”：</p><ul><li><p>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</p><ul><li>get、head、post</li></ul></li><li><p>情况二: 人为设置以下集合外的请求头</p><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a>、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> （需要注意额外的限制）</li><li><code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code></li></ul></li><li><p>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 application/json 为非简单请求)</p></li><li><p><code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code></p></li><li><p>情况四:</p><p>请求中的任意<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器、<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload"><code>XMLHttpRequest.upload</code></a> 属性访问</p></li><li><p>情况五:</p><p>请求中没有使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 对象</p></li></ul><h5 id="2、复杂请求"><a href="#2、复杂请求" class="headerlink" title="2、复杂请求"></a>2、复杂请求</h5><p>除了简单请求</p><h3 id="方案2：JSONP"><a href="#方案2：JSONP" class="headerlink" title="方案2：JSONP"></a>方案2：JSONP</h3><h4 id="1、JSONP如何产生的？"><a href="#1、JSONP如何产生的？" class="headerlink" title="1、JSONP如何产生的？"></a>1、JSONP如何产生的？</h4><ul><li>AJAX直接请求普通文件存在跨域无权访问的问题；网页中<strong>拥有<code>src</code>属性的标签</strong>天然具备跨域能力，页面上调用js文件时则不受是否跨域的影响：<ul><li>img、script、link、iframe</li></ul></li><li>JSON：纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被JS原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</li></ul><h4 id="2、实现思想："><a href="#2、实现思想：" class="headerlink" title="2、实现思想："></a>2、实现思想：</h4><ol><li>允许用户传递一个<code>callback</code>参数给服务端</li><li>然后服务端返回数据时会将这个<code>callback</code>参数作为函数名来包裹住JSON数据</li><li>这样客户端就可以随意定制自己的函数来自动处理返回数据了</li></ol><h4 id="3、实现例子："><a href="#3、实现例子：" class="headerlink" title="3、实现例子："></a>3、实现例子：</h4><ul><li>客户端：<ol><li>定义获取数据后调用的回调函数</li><li>动态生成对服务端JS进行引用的代码<ul><li>设置<code>url</code>为提供<code>jsonp</code>服务的<code>url</code>地址，并在该<code>url</code>中设置相关<code>callback</code>参数</li><li>创建<code>script</code>标签，并设置其<code>src</code>属性</li><li>把<code>script</code>标签加入<code>head</code>，此时<strong>调用开始</strong></li></ul></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 1. 动态的创建一个 script 标签</span></span><br><span class="line">   <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//2. 设置 script 的 src， 设置回调函数</span></span><br><span class="line">   script.src = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     alert(data.name);</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="comment">// 3. 将 script 添加到 body 中，调用开始</span></span><br><span class="line">   <span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure><ul><li>服务端：将客户端发送的<code>callback</code>参数作为函数名来包裹住<code>JSON</code>数据，返回数据至客户端</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 服务器中路由的处理-------</span></span><br><span class="line"> router.get(<span class="string">&quot;/testAJAX&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;收到请求&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> callback = req.query.callback;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="attr">ame</span>: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">   &#125;</span><br><span class="line">   res.send(callback + <span class="string">&quot;(&quot;</span> + <span class="built_in">JSON</span>.stringify(obj) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h4 id="4、缺点："><a href="#4、缺点：" class="headerlink" title="4、缺点："></a>4、缺点：</h4><ol><li><p><strong>安全问题：</strong>JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。 此时除了完全删除 JSONP 没有其他办法</p></li><li><p><strong>只接受GET请求方式</strong>：<code>script</code>，<code>link</code>，<code>img</code> 等标签引入外部资源，都是<code>GET</code>请求的，那么就决定了 <strong>JSONP 一定是GET</strong>的</p></li><li><p>不确定请求是否失败：虽然 HTML5 规定了<script>元素的 onerror 事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应，但这并不准确</p></li></ol><h4 id="5、AJAX与JSONP的不同："><a href="#5、AJAX与JSONP的不同：" class="headerlink" title="5、AJAX与JSONP的不同："></a>5、AJAX与JSONP的不同：</h4><ul><li><strong>相同点：</strong>调用方式上“看起来”很像，目的也一样，都是请求一个<code>url</code>，然后把服务器返回的数据处理</li></ul><ul><li><p><strong>不同点：</strong>本质上是不同的东西</p><ol><li><p><strong>AJAX的核心</strong>：通过<code>XmlHttpRequest</code>获取非本页内容</p></li><li><p><strong>JSONP的核心：</strong>动态添加<code>script</code>标签来调用服务器提供的js脚本</p><p>JSONP是一种方式，如同AJAX一样，它也不一定非要用JSON格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用JSONP提供公开服务</p></li><li><p><strong>所以区别不在于是否跨</strong>：AJAX通过服务端代理一样可以实现跨域，JSONP本身也不排斥同域的数据的获取</p></li></ol></li></ul><h3 id="方案3：正向代理"><a href="#方案3：正向代理" class="headerlink" title="方案3：正向代理"></a>方案3：正向代理</h3><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域，,它没有同源策略的限制</p><h4 id="1、脚手架中的"><a href="#1、脚手架中的" class="headerlink" title="1、脚手架中的"></a>1、脚手架中的</h4><ul><li><h4 id="webpack配置proxy"><a href="#webpack配置proxy" class="headerlink" title="webpack配置proxy"></a>webpack配置proxy</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: 8000,</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    &quot;/api&quot;: &#123;</span><br><span class="line">      target: &quot;http://localhost:8080&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><h4 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a><code>vue-cli</code></h4><p>配置 proxyTable 来进行跨域：</p><p><code>webpack</code> 提供一个<code>http</code>代理服务器。请求接口时,实际上是请求的<code>webpack</code>提供的这个<code>http</code>代理服务器。再由这个代理服务器请求真实的数据服务器。</p><p>最后数据经由<code>webpack</code>代理服务器,最后转交给<code>vue</code>程序</p><img src="https:////upload-images.jianshu.io/upload_images/2701794-8c98b9b1fb747a35.png?imageMogr2/auto-orient/strip|imageView2/2/w/1011/format/webp" alt="img" style="zoom:50%;" /></li></ul><h4 id="2、使用代理工具"><a href="#2、使用代理工具" class="headerlink" title="2、使用代理工具"></a>2、使用代理工具</h4><ul><li>使用代理库：cors-anywhere</li><li>charles代理工具：利用 charles 进行跨域，本质就是请求的拦截与代理</li></ul><h3 id="方案4：反向代理？？？"><a href="#方案4：反向代理？？？" class="headerlink" title="方案4：反向代理？？？"></a>方案4：反向代理？？？</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h3 id="方案5-Node中间件代理-两次跨域-？？？"><a href="#方案5-Node中间件代理-两次跨域-？？？" class="headerlink" title="方案5. Node中间件代理(两次跨域)？？？"></a>方案5. Node中间件代理(两次跨域)？？？</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> 代理服务器，需要做以下几个步骤：</p><ul><li><p>接受客户端请求 </p></li><li><p>将请求 转发给服务器</p></li><li><p>拿到服务器 响应 数据</p></li><li><p>将 响应 转发给客户端</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/17/1685c5bed77e7788~tplv-t2oaga2asx-watermark.awebp" alt="img"></p></li></ul><p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html(http://127.0.0.1:5500)</span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   $.ajax(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;xiamen&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">contentType</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result) <span class="comment">// &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">// server1.js 代理服务器(http://localhost:3000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 第一步：接受客户端请求</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span></span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 第二步：将请求转发给服务器</span></span><br><span class="line">  <span class="keyword">const</span> proxyRequest = http</span><br><span class="line">    .request(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">4000</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: request.method,</span><br><span class="line">        <span class="attr">headers</span>: request.headers</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="params">serverResponse</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第三步：收到服务器的响应</span></span><br><span class="line">        <span class="keyword">var</span> body = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        serverResponse.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">          body += chunk</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;The data is &#x27;</span> + body)</span><br><span class="line">          <span class="comment">// 第四步：将响应结果转发给浏览器</span></span><br><span class="line">          response.end(body)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;The proxyServer is running at http://localhost:3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server2.js(http://localhost:4000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">title</span>: <span class="string">&#x27;fontend&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    response.end(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">4000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;The server is running at http://localhost:4000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>&#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</code></p><h3 id="方案6：Websocket"><a href="#方案6：Websocket" class="headerlink" title="方案6：Websocket"></a>方案6：Websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// socket.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let socket = new WebSocket(&#x27;ws://localhost:3000&#x27;);</span><br><span class="line">    socket.onopen = function () &#123;</span><br><span class="line">      socket.send(&#x27;我爱你&#x27;);//向服务器发送数据</span><br><span class="line">    &#125;</span><br><span class="line">    socket.onmessage = function (e) &#123;</span><br><span class="line">      console.log(e.data);//接收服务器返回的数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br><span class="line">// server.js</span><br><span class="line">let express = require(&#x27;express&#x27;);</span><br><span class="line">let app = express();</span><br><span class="line">let WebSocket = require(&#x27;ws&#x27;);//记得安装ws</span><br><span class="line">let wss = new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class="line">wss.on(&#x27;connection&#x27;,function(ws) &#123;</span><br><span class="line">  ws.on(&#x27;message&#x27;, function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    ws.send(&#x27;我不爱你&#x27;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2、跨域窗口"><a href="#2、跨域窗口" class="headerlink" title="2、跨域窗口"></a>2、跨域窗口</h2><p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p><ul><li><p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myIFrame&quot;</span>).contentWindow.document</span><br><span class="line"><span class="comment">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span></span><br></pre></td></tr></table></figure></blockquote><p>反之亦然，子窗口获取主窗口的DOM也会报错。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.document.body</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>对<strong>于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</strong></p><blockquote><ul><li>window.name+iframe</li><li>location.hash+iframe</li><li>跨文档通信API（postMessage   ）</li></ul></blockquote></li></ul><h3 id="方案7：window-name-iframe"><a href="#方案7：window-name-iframe" class="headerlink" title="方案7：window.name+iframe"></a>方案7：window.name+iframe</h3><p>浏览器窗口有<code>window.name</code>属性。这个<strong>属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</strong></p><p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = data;</span><br></pre></td></tr></table></figure></blockquote><p>接着，子窗口跳回一个与主窗口同域的网址。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location = <span class="string">&#x27;http://parent.url.com/xxx.html&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><p>然后，主窗口就可以读取子窗口的<code>window.name</code>了。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myFrame&#x27;</span>).contentWindow.name;</span><br></pre></td></tr></table></figure></blockquote><p>优点：<code>window.name</code>容量很大，可以放置非常长的字符串；</p><p>缺点：必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p><h3 id="方案8：location-hash-iframe"><a href="#方案8：location-hash-iframe" class="headerlink" title="方案8：location.hash+iframe"></a>方案8：location.hash+iframe</h3><ul><li><p>URL的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p><p>父窗口可以把信息，写入子窗口的片段标识符。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myIFrame&#x27;</span>).src = src;</span><br></pre></td></tr></table></figure></blockquote><p>子窗口通过监听<code>hashchange</code>事件得到通知。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>同样的，子窗口也可以改变父窗口的片段标识符。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.location.href= target + <span class="string">&quot;#&quot;</span> + hash;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="方案9：postMessage"><a href="#方案9：postMessage" class="headerlink" title="方案9：postMessage"></a>方案9：postMessage</h3><h4 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h4><p>HTML5为解决这个问题，引入了一全新的API：是可以跨域操作的window属性之一，用于解决：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li></ul><h4 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h4><ul><li><p>这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，<strong>允许跨窗口通信，不论这两个窗口是否同源。</strong></p><p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">&#x27;http://bbb.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line">popup.postMessage(<span class="string">&#x27;Hello World!&#x27;</span>, <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>```<br>someWindow.postMessage(message, targetOrigin, [transfer]);</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * someWindow ：窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames</span><br><span class="line">  * message 将要发送到其他 window的数据。</span><br><span class="line">  * targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;（表示无限制）。不提供确切的目标将导致数据泄露等安全问题</span><br><span class="line">  * transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</span><br><span class="line"></span><br><span class="line">* `message`事件的事件对象`event`，提供以下三个属性。</span><br><span class="line"></span><br><span class="line">  &gt; * `event.source`：发送消息的窗口</span><br><span class="line">  &gt; * `event.origin`: 消息发向的网址</span><br><span class="line">  &gt; * `event.data`: 消息内容</span><br><span class="line"></span><br><span class="line">* 通过`window.postMessage`，读写其他窗口的 LocalStorage 也可以</span><br><span class="line"></span><br><span class="line">#### 3、举例 ####</span><br><span class="line"></span><br><span class="line">* // a.html</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">   &lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt; //等它加载完触发一个事件</span><br><span class="line">    //内嵌在http://localhost:3000/a.html</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">        function load() &#123;</span><br><span class="line">          let frame = document.getElementById(&#x27;frame&#x27;)</span><br><span class="line">          frame.contentWindow.postMessage(&#x27;我爱你&#x27;, &#x27;http://localhost:4000&#x27;) //发送数据</span><br><span class="line">          window.onmessage = function(e) &#123; //接受返回数据</span><br><span class="line">            console.log(e.data) //我不爱你</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>// b.html</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data) <span class="comment">//我爱你</span></span><br><span class="line">    e.source.postMessage(<span class="string">&#x27;我不爱你&#x27;</span>, e.origin)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方案10：cookie跨域"><a href="#方案10：cookie跨域" class="headerlink" title="方案10：cookie跨域"></a>方案10：cookie跨域</h3><ul><li><p>Cookie：只有同源的网页才能共享。但是，<strong>两个网页一级域名相同，只是二级域名不同</strong>，浏览器允许通过设置<code>document.domain</code>共享 Cookie</p><p>举例来说，A网页是<code>http://w1.example.com/a.html</code>，B网页是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享Cookie</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;example.com&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><p>现在，A网页通过脚本设置一个 Cookie</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;test1=hello&quot;</span>;</span><br></pre></td></tr></table></figure></blockquote><p>B网页就可以读到这个 Cookie</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookie = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>注意，这种方法<strong>只适用于 Cookie 和 iframe 窗口</strong>，<strong>LocalStorage 和 IndexDB 无法通过这种方法</strong>，规避同源政策，而要使用PostMessage API</p></li><li><p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。</p></li></ul><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>key=value; domain=.example.com; path=/</span><br></pre></td></tr></table></figure></blockquote><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HTTP</title>
      <link href="/2021/12/13/%E5%85%B3%E4%BA%8EHTTP/"/>
      <url>/2021/12/13/%E5%85%B3%E4%BA%8EHTTP/</url>
      
        <content type="html"><![CDATA[<h3 id="1、HTTP概述"><a href="#1、HTTP概述" class="headerlink" title="1、HTTP概述"></a>1、HTTP概述</h3><h4 id="1、是什么："><a href="#1、是什么：" class="headerlink" title="1、是什么："></a>1、是什么：</h4><ol><li>超文本传输协议，基于TCP/IP协议，<strong>是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></li><li>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息</li></ol><h4 id="2、特点："><a href="#2、特点：" class="headerlink" title="2、特点："></a>2、特点：</h4><h5 id="1、灵活可扩展"><a href="#1、灵活可扩展" class="headerlink" title="1、灵活可扩展"></a>1、灵活可扩展</h5><ul><li>一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。</li><li>另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据</li></ul><h5 id="2、请求-应答模式"><a href="#2、请求-应答模式" class="headerlink" title="2、请求-应答模式"></a>2、请求-应答模式</h5><ul><li>通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等</li></ul><h5 id="3、可靠传输"><a href="#3、可靠传输" class="headerlink" title="3、可靠传输"></a>3、可靠传输</h5><ul><li>HTTP是基于TCP/IP，因此把这一特性继承了下来</li></ul><h5 id="4、无状态"><a href="#4、无状态" class="headerlink" title="4、无状态"></a>4、无状态</h5><ul><li><p>指协议对于事物处理没有记忆能力。不对请求和响应之间的通信状态进行保存</p></li><li><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传</p></li><li><p>无状态协议解决办法：</p><p>1、通过、Cookie  </p><p>2、通过Session会话保存</p></li></ul><h4 id="3、优、缺点"><a href="#3、优、缺点" class="headerlink" title="3、优、缺点"></a>3、优、缺点</h4><h5 id="1、无状态"><a href="#1、无状态" class="headerlink" title="1、无状态"></a>1、无状态</h5><ul><li>有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等</li><li>另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说</li></ul><h5 id="2、明文传输"><a href="#2、明文传输" class="headerlink" title="2、明文传输"></a>2、明文传输</h5><ul><li>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式</li><li>这让HTTP的报文信息暴露给了外界，给攻击者带来了便利</li><li>不验证对方信息，会遭遇伪装；</li></ul><h5 id="3、队头阻塞"><a href="#3、队头阻塞" class="headerlink" title="3、队头阻塞"></a>3、队头阻塞</h5><ul><li>当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题</li></ul><h3 id="2、HTTP-状态码"><a href="#2、HTTP-状态码" class="headerlink" title="2、HTTP 状态码"></a>2、HTTP 状态码</h3><p>RFC 规定 HTTP 的状态码为<strong>「三位数」</strong>，第一个数字定义了响应的类别，被分为五类:</p><ul><li><strong>「1xx」</strong>: 代表请求已被接受，需要继续处理。</li><li><strong>「2xx」</strong>: 表示成功状态。</li><li><strong>「3xx」</strong>: 重定向状态。</li><li><strong>「4xx」</strong>: 客户端错误。</li><li><strong>「5xx」</strong>: 服务器端错误。</li></ul><h4 id="1、1xx-信息类"><a href="#1、1xx-信息类" class="headerlink" title="1、1xx 信息类"></a>1、1xx 信息类</h4><ul><li>100继续 ：指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100允许客户端继续或用417告诉客户端不同意接受附件。     HTTP 1.1中新加入的</li><li>101转换协议：指服务器将按照其上的头信息变为一个不同的协议。 HTTP 1.1中新加入的</li></ul><h4 id="2、2xx-成功"><a href="#2、2xx-成功" class="headerlink" title="2、2xx 成功"></a>2、2xx 成功</h4><ul><li><p>200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页</p></li><li><p>201 （已创建） 请求成功并且服务器创建了新的资源。 </p></li><li><p>204：请求得到了成功处理，但返回的响应报文中不含实体的主体部分（没有资源可以返回）</p></li><li><p>206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 <strong>「Content-Range」</strong> 指定范围的实体内容。</p></li></ul><h4 id="3、3xx-重定向"><a href="#3、3xx-重定向" class="headerlink" title="3、3xx 重定向"></a>3、3xx 重定向</h4><h5 id="同样是重定向，307，303，302的区别？"><a href="#同样是重定向，307，303，302的区别？" class="headerlink" title="同样是重定向，307，303，302的区别？"></a>同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h5><ul><li><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。</p><ul><li> 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。</li><li> 307会遵照浏览器标准，不会从post变为get。</li></ul></li><li><p>301 （永久移动）表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI，新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。</p><ul><li>若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址</li><li>使用场景：<ul><li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul></li></ul></li><li><p>302 （临时移动） 表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。</p><ul><li> 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。</li><li> 若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</li><li> 同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li><li>使用场景：<ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。</li></ul></li></ul></li><li><p>303 （查看其他位置）表示由于请求对应的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源</p><ul><li>和 302 Found 状态码有着相似的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源</li><li>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</li><li>注意：<ul><li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li><li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做</li></ul></li></ul></li><li><p><strong>304 （未修改，协商缓存可用） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</strong> </p><p>304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系</p><ol><li><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul></li><li><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。</li></ul></li><li><p><strong>HTTP状态码304是多好还是少好</strong></p><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。</p><p>若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p></li></ol></li><li><p>305 （使用<strong>代理</strong>） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</p></li><li><p>307 （临时重定向）会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容</p></li></ul><h4 id="4、4XX-客户端错误"><a href="#4、4XX-客户端错误" class="headerlink" title="4、4XX 客户端错误"></a>4、4XX 客户端错误</h4><ul><li><p>400  请求报文存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p></li><li><p>401 unauthorized，表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败。</p><ul><li><p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p></li><li><p>出现401场景：</p><ul><li>401.1 - 登录失败。</li><li>401.2 - 服务器配置导致登录失败。</li><li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li><li>401.4 - 筛选器授权失败。</li><li>401.5 - ISAPI/CGI 应用程序授权失败。</li><li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li></ul></li></ul></li><li><p>403 forbidden，表示对请求资源的访问被服务器拒绝。服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。<strong>进入该状态后，不能再继续进行验证。</strong>该访问是永久禁止的，并且与应用逻辑密切相关。</p></li><li><p>404 not found，表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：</p></li><li><p>405  表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。</p><p>GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、5XX-服务器错误"><a href="#5、5XX-服务器错误" class="headerlink" title="5、5XX 服务器错误"></a>5、5XX 服务器错误</h4><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误。</li><li>502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li></ul><h3 id="3、HTTP版本差异"><a href="#3、HTTP版本差异" class="headerlink" title="3、HTTP版本差异"></a>3、HTTP版本差异</h3><h4 id="1、HTTP-0-9"><a href="#1、HTTP-0-9" class="headerlink" title="1、HTTP 0.9"></a>1、HTTP 0.9</h4><ul><li>91年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，已过时。</li></ul><h4 id="2、HTTP-1-0"><a href="#2、HTTP-1-0" class="headerlink" title="2、HTTP 1.0"></a>2、HTTP 1.0</h4><ul><li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件</li><li>除了GET命令，还引入了POST命令和HEAD命令</li><li>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</li><li>只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li><li>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</li></ul><h4 id="3、HTTP-1-1"><a href="#3、HTTP-1-1" class="headerlink" title="3、HTTP 1.1"></a>3、HTTP 1.1</h4><p><strong>http1.1是目前最为主流的http协议版本</strong>，从1999年发布至今，仍是主流的http协议版本。</p><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li><li>引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率</li><li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效</li><li>支持断点续传，通过使用请求头中的 <code>Range</code> 来实现</li><li>使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE</li></ul><h4 id="3-2、总结1-0与1-1区别"><a href="#3-2、总结1-0与1-1区别" class="headerlink" title="3.2、总结1.0与1.1区别"></a>3.2、总结1.0与1.1区别</h4><ul><li><p><strong>连接方面</strong></p><p>http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延</p></li><li><p><strong>资源请求方面</strong></p><p>在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</p></li><li><p><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p></li><li><p>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</p></li><li><p>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</p></li></ul><h4 id="4、http1-x版本问题"><a href="#4、http1-x版本问题" class="headerlink" title="4、http1.x版本问题"></a>4、http1.x版本问题</h4><ul><li><h4 id="安全："><a href="#安全：" class="headerlink" title="安全："></a>安全：</h4><p>在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性</p></li><li><h4 id="队头阻塞："><a href="#队头阻塞：" class="headerlink" title="队头阻塞："></a>队头阻塞：</h4><p>HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞</p></li><li><h4 id="Keep-alive性能问题"><a href="#Keep-alive性能问题" class="headerlink" title="Keep-alive性能问题"></a>Keep-alive性能问题</h4><p>http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间 </p></li></ul><h4 id="5、HTTP-2-0"><a href="#5、HTTP-2-0" class="headerlink" title="5、HTTP 2.0"></a>5、HTTP 2.0</h4><h5 id="1、二进制分帧"><a href="#1、二进制分帧" class="headerlink" title="1、二进制分帧"></a>1、<code>二进制分帧</code></h5><ul><li>这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。</li><li>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li></ul><h5 id="2、头部压缩"><a href="#2、头部压缩" class="headerlink" title="2、头部压缩"></a>2、<code>头部压缩</code></h5><ul><li>HTTP 1.1版本会出现 <strong>「User-Agent、Cookie、Accept、Server、Range」</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。</li><li>HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li></ul><h5 id="3、多路复用"><a href="#3、多路复用" class="headerlink" title="3、多路复用"></a>3、<code>多路复用</code></h5><ul><li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</li></ul><h5 id="4、服务器推送"><a href="#4、服务器推送" class="headerlink" title="4、服务器推送"></a>4、<code>服务器推送</code></h5><ul><li>允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li></ul><h5 id="5、请求优先级"><a href="#5、请求优先级" class="headerlink" title="5、请求优先级"></a>5、<code>请求优先级</code></h5><ul><li>可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验</li></ul><h4 id="6、3-0-QUIC-协议"><a href="#6、3-0-QUIC-协议" class="headerlink" title="6、3.0  QUIC 协议"></a>6、3.0  QUIC 协议</h4><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a0a2ec0ef143b49d79256cea543418~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:25%;" /><h5 id="1-特点："><a href="#1-特点：" class="headerlink" title="1. 特点："></a>1. 特点：</h5><ul><li>HTTP/3 是基于 UDP 实现的，实现了类似于 TCP 的多路数据流、传输可靠性等功能，称为 QUIC 协议<ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li><li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li><li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li><li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li></ul></li></ul><h5 id="2-HTTP-3-的挑战"><a href="#2-HTTP-3-的挑战" class="headerlink" title="2. HTTP/3 的挑战"></a>2. HTTP/3 的挑战</h5><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ul><h3 id="4、对HTTP-2理解"><a href="#4、对HTTP-2理解" class="headerlink" title="4、对HTTP/2理解"></a>4、对HTTP/2理解</h3><h4 id="1、头部压缩"><a href="#1、头部压缩" class="headerlink" title="1、头部压缩"></a>1、头部压缩</h4><ul><li><p>由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。</p><ul><li><p>所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p></li><li><p><strong>「User-Agent、Cookie、Accept、Server、Range」</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重</p></li></ul></li><li><p>HTTP/2 实现了头信息压缩，引入了头信息压缩机制。</p><ul><li>一方面，头信息使用 gzip 或 compress 压缩后再发送；</li><li>另一方面，客户端和服务器同时维护一张头信息表<code>HPACK</code> 算法，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了</li></ul></li><li><h4 id="HPACK-算法：-传索引"><a href="#HPACK-算法：-传索引" class="headerlink" title="HPACK 算法：  传索引"></a><code>HPACK</code> 算法：  传索引</h4><ul><li>类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引</li><li>对于之前出现过的头部信息，只需要把<strong>「索引」</strong>(比如1，2，…)传给对方，对方拿到索引查表就行了</li></ul></li></ul><img src="https://user-images.githubusercontent.com/34484322/89356545-a3fd4100-d6f0-11ea-8e0a-8870d832e96e.png" alt="img" style="zoom: 33%;" /><ul><li><h4 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h4><ol><li><p>这种<strong>「传索引」</strong>的方式，可以说让请求头字段得到极大程度的精简和复用</p></li><li><p>其次是对于整数和字符串进行<strong>「哈夫曼编码」</strong></p><p>哈夫曼编码的原理就是先将所有出现的字符建立一张索引表</p><p>然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>「索引序列」</strong>，可以达到非常高的压缩率</p></li></ol></li></ul><h4 id="2、多路复用"><a href="#2、多路复用" class="headerlink" title="2、多路复用"></a>2、多路复用</h4><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p><h5 id="HTTP2中："><a href="#HTTP2中：" class="headerlink" title="HTTP2中："></a>HTTP2中：</h5><ul><li><p>同域名下所有通信都在单个连接上完成。</p></li><li><p>单个连接可以承载任意数量的双向数据流。</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是<code>Stream ID</code>，流标识符</p><p>有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。</p></li><li><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了**”队头堵塞”**的问题。</p></li></ul><h4 id="3、服务器推送"><a href="#3、服务器推送" class="headerlink" title="3、服务器推送"></a>3、服务器推送</h4><ul><li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送，这样就可以相对减少一些延迟时间</li><li>需要注意的是 http2 下服务器主动推送的是<strong>静态资源</strong>，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><h5 id="相比较http-1-1的优势👇"><a href="#相比较http-1-1的优势👇" class="headerlink" title="相比较http/1.1的优势👇"></a>相比较http/1.1的优势👇</h5><ul><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li></ul><h4 id="4、二进制分帧与数据流"><a href="#4、二进制分帧与数据流" class="headerlink" title="4、二进制分帧与数据流"></a>4、二进制分帧与数据流</h4><h5 id="二进制帧："><a href="#二进制帧：" class="headerlink" title="二进制帧："></a>二进制帧：</h5><ul><li><p>在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。</p></li><li><p>HTTP/2 则是一个彻底的二进制协议，一个报文格式就被拆分为一个个二进制帧，帧的概念是它实现多路复用的基础。</p><ul><li><p>用<strong>「Headers帧」</strong>存放头部字段，<strong>「Data帧」</strong>存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了HTTP队头阻塞问题</p></li><li><p>HTTP/2采用二进制格式，全部传输01串，便于机器解码</p><p>明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低</p></li></ul></li></ul><h5 id="数据流："><a href="#数据流：" class="headerlink" title="数据流："></a>数据流：</h5><ul><li>在客户端与服务器之间，双方都可以互相发送二进制帧，这样子<strong>「双向传输的序列」</strong>，称为<code>流</code>，所以HTTP/2中以<strong>流</strong>来<strong>表示一个TCP连接上进行多个数据帧的通信</strong>，这就是<strong>多路复用</strong>概念</li><li>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。<ul><li>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流；</li><li>每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li></ul></li></ul><h5 id="那乱序的二进制帧，是如何组装成对于的报文呢？"><a href="#那乱序的二进制帧，是如何组装成对于的报文呢？" class="headerlink" title="那乱序的二进制帧，是如何组装成对于的报文呢？"></a>那乱序的二进制帧，是如何组装成对于的报文呢？</h5><ul><li>乱序，指的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的</li><li>接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文</li><li>二进制帧中有一些字段，控制着<code>优先级</code>和<code>流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验</li></ul><h5 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h5><ul><li>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的；</li><li>HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。</li><li>队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理；</li><li>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</li></ul><h3 id="5、keep-alive"><a href="#5、keep-alive" class="headerlink" title="5、keep-alive"></a>5、keep-alive</h3><h4 id="1、什么是keep-alive"><a href="#1、什么是keep-alive" class="headerlink" title="1、什么是keep-alive"></a>1、什么是keep-alive</h4><ul><li><h4 id="普通模式："><a href="#普通模式：" class="headerlink" title="普通模式："></a>普通模式：</h4><p>HTTP协议采用“请求-应答”模式，当使用普通模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接，这就是<strong>短连接</strong>。（HTTP协议为无连接的协议）</p></li><li><h4 id="Keep-Alive模式："><a href="#Keep-Alive模式：" class="headerlink" title="Keep-Alive模式："></a>Keep-Alive模式：</h4><p>当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 ，这就是<strong>长连接</strong>。</p></li></ul><h4 id="2、为什么要使用keep-alive"><a href="#2、为什么要使用keep-alive" class="headerlink" title="2、为什么要使用keep-alive"></a>2、为什么要使用keep-alive</h4><ul><li><strong>创建目的：</strong>能在多次HTTP之前重用同一个TCP连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）</li></ul><img src="https://user-images.githubusercontent.com/34484322/89356849-64832480-d6f1-11ea-8f53-5372f8c30f39.png" alt="img" style="zoom:50%;" /><ul><li>优点：<ul><li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li><li>允许请求和应答的HTTP管线化；</li><li>降低拥塞控制 （TCP连接减少了）；</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li><li>报告错误⽆需关闭TCP连；</li></ul></li><li>缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li></ul><h4 id="3、客户端如何开启"><a href="#3、客户端如何开启" class="headerlink" title="3、客户端如何开启"></a>3、客户端如何开启</h4><p>Keep-Alive的<strong>建立过程</strong>：</p><ul><li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li><li>服务器收到请求并处理 Connection字段</li><li>服务器回送Connection:Keep-Alive字段给客户端</li><li>客户端接收到Connection字段</li><li>Keep-Alive连接建立成功</li></ul><p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p><ul><li>客户端向服务器只是发送内容报文（不包含Connection字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有Connection字段，断开连接</li></ul><p><strong>客户端请求断开连接过程</strong>：</p><ul><li>客户端向服务器发送Connection:close字段</li><li>服务器收到请求并处理connection字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接</li></ul><h3 id="6、请求方法get-post"><a href="#6、请求方法get-post" class="headerlink" title="6、请求方法get/post"></a>6、请求方法get/post</h3><h4 id="1、HTTP请求方法"><a href="#1、HTTP请求方法" class="headerlink" title="1、HTTP请求方法"></a>1、HTTP请求方法</h4><ul><li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</li><li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li></ul><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li><p>GET：                请求获取Request-URI所标识的资源</p></li><li><p>POST：              在Request-URI所标识的资源后附加新的数据</p></li><li><p>HEAD：             请求获取由Request-URI所标识的资源的响应消息报头，没有响应体</p></li><li><p>PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）</p><ul><li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等</li><li>也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li></ul></li><li><p>OPTIONS：       用于请求获得由<code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项</p><ul><li>通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</li></ul><p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p><ul><li><p>获取服务器对该资源支持的所有HTTP请求方法；</p><p>该方法会用’*’来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。</p></li><li><p>用来检查访问权限。例如：JS 的 XMLHttpRequest对象在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</p></li></ul></li><li><p>DELETE：          请求服务器删除对应所标识的资源</p></li><li><p>TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断</p></li><li><p>CONNECT：      建立连接隧道，用于代理服务器</p></li></ul><h4 id="2、谈一谈GET-和-POST-的区别"><a href="#2、谈一谈GET-和-POST-的区别" class="headerlink" title="2、谈一谈GET 和 POST 的区别"></a>2、谈一谈GET 和 POST 的区别</h4><p>本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。</p><p>从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册</p><p>想装逼请参考 <a href="https://zhuanlan.zhihu.com/p/22536382">https://zhuanlan.zhihu.com/p/22536382</a></p><h5 id="1、缓存角度"><a href="#1、缓存角度" class="headerlink" title="1、缓存角度"></a>1、缓存角度</h5><ul><li>GET 请求后浏览器会主动缓存，POST 默认情况下不能</li></ul><h5 id="2、参数角度"><a href="#2、参数角度" class="headerlink" title="2、参数角度"></a>2、参数角度</h5><ul><li>GET请求一般放在URL中，因此不太安全，因为请求的 url 会被保留在历史记录中</li><li>POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的</li></ul><h5 id="3、编码角度"><a href="#3、编码角度" class="headerlink" title="3、编码角度"></a>3、编码角度</h5><ul><li>GET请求只能进行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。</li></ul><h5 id="3-2、请求长度："><a href="#3-2、请求长度：" class="headerlink" title="3.2、请求长度："></a>3.2、请求长度：</h5><ul><li><p>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</p><p><strong>为什么会限制长度？</strong></p><ul><li>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。</li><li>get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET的长度值 = URL（<span class="number">2083</span>）- （你的Domain+Path）-<span class="number">2</span>（<span class="number">2</span>是get请求中?=两个字符的长度）</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、请求幂等"><a href="#4、请求幂等" class="headerlink" title="4、请求幂等"></a>4、请求幂等</h5><ul><li>GET请求幂等</li><li>POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致</li></ul><h5 id="5、请求时"><a href="#5、请求时" class="headerlink" title="5、请求时"></a>5、请求时</h5><ul><li>GET请求会一次性发送请求报文</li><li>POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分</li></ul><h4 id="3、POST与PUT的区别"><a href="#3、POST与PUT的区别" class="headerlink" title="3、POST与PUT的区别"></a>3、POST与PUT的区别</h4><ul><li>PUT不会产生新数据，只是覆盖老数据，是幂等的</li><li>POST请求一次就产生一个新数据，是非幂等的</li></ul><h3 id="请求头、响应头"><a href="#请求头、响应头" class="headerlink" title="请求头、响应头"></a>请求头、响应头</h3><h4 id="HTTP-Request-Header-常见的请求头："><a href="#HTTP-Request-Header-常见的请求头：" class="headerlink" title="HTTP Request Header 常见的请求头："></a><strong>HTTP Request Header 常见的请求头：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Accept:浏览器能够处理的内容类型</span><br><span class="line">* Accept-Charset:浏览器能够显示的字符集</span><br><span class="line">* Accept-Encoding：浏览器能够处理的压缩编码</span><br><span class="line">* Accept-Language：浏览器当前设置的语言</span><br><span class="line">* Connection：浏览器与服务器之间连接的类型</span><br><span class="line">* Cookie：当前页面设置的任何Cookie</span><br><span class="line">* Host：发出请求的页面所在的域</span><br><span class="line">* Referer：发出请求的页面的URL</span><br><span class="line">* User-Agent：浏览器的用户代理字符串</span><br></pre></td></tr></table></figure><h4 id="响应头："><a href="#响应头：" class="headerlink" title="响应头："></a>响应头：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP Responses Header 常见的响应头：</span><br><span class="line"></span><br><span class="line">Date：表示消息发送的时间，时间的描述格式由rfc822定义</span><br><span class="line">server:服务器名称</span><br><span class="line">Connection：浏览器与服务器之间连接的类型</span><br><span class="line">Cache-Control：控制HTTP缓存</span><br><span class="line">content-type:表示后面的文档属于什么MIME类型</span><br></pre></td></tr></table></figure><h4 id="常见的-Content-Type-属性值有四种："><a href="#常见的-Content-Type-属性值有四种：" class="headerlink" title="常见的 Content-Type 属性值有四种："></a>常见的 Content-Type 属性值有四种：</h4><p>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><p>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。</p><p>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p><h3 id="7、对URL组成"><a href="#7、对URL组成" class="headerlink" title="7、对URL组成"></a>7、对URL组成</h3><h4 id="1、URL与URI"><a href="#1、URL与URI" class="headerlink" title="1、URL与URI"></a>1、URL与URI</h4><ul><li><p>URI：统一资源标识符         </p><p>父类        表示请求服务器资源，定位这个资源</p></li><li><p>URL：统一资源定位符，常常被称为网址，是因特网上标准的资源地址</p><p>子类       而URL还要表示如何访问这个资源</p><p>通用的格式：scheme://host[:port]/path/…/?query#anchor</p></li></ul><h4 id="2、组成格式："><a href="#2、组成格式：" class="headerlink" title="2、组成格式："></a>2、组成格式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.aspxfans.com:8080/news/index.…</span><br></pre></td></tr></table></figure><ul><li><p><strong>协议：</strong>访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等后面一定接上://</p></li><li><p><strong>域名：</strong>该URL的域名部分为“<a href="http://www.aspxfans.com”/">www.aspxfans.com”</a></p></li><li><p><strong>port：</strong>跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。</p><ul><li>端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li></ul></li><li><p>（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</p></li><li><p><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</p></li><li><p><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分</p><ul><li>如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分</li><li>如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。</li><li>本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li></ul></li><li><p><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例的锚部分是“name”。锚部分也不是一个URL必须的部分；</p></li><li><p><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。</p><p>本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ul><h4 id="3、URL-编码"><a href="#3、URL-编码" class="headerlink" title="3、URL 编码"></a>3、URL 编码</h4><ul><li>URL 只能使用 <a href="https://link.juejin.cn/?target=https://www.w3school.com.cn/tags/html_ref_ascii.asp">ASCII 字符集</a>来通过因特网进行发送。</li><li>由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</li><li>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</li><li>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">天天`转换为有效的ASCII格式就是`%CC%EC%CC%EC</span><br></pre></td></tr></table></figure><h3 id="8、队头阻塞问题"><a href="#8、队头阻塞问题" class="headerlink" title="8、队头阻塞问题"></a>8、队头阻塞问题</h3><h4 id="1、什么是队头阻塞？"><a href="#1、什么是队头阻塞？" class="headerlink" title="1、什么是队头阻塞？"></a>1、什么是队头阻塞？</h4><ul><li>对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的</li><li>一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<code>HTTP队头阻塞</code>问题</li></ul><h4 id="2、解决1：并发连接"><a href="#2、解决1：并发连接" class="headerlink" title="2、解决1：并发连接"></a>2、解决1：并发连接</h4><ul><li>我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务</li><li>在<code>RFC规范</code>中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。</li></ul><h4 id="3、解决2：域名分片"><a href="#3、解决2：域名分片" class="headerlink" title="3、解决2：域名分片"></a>3、解决2：域名分片</h4><ul><li>可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器</li><li>就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题</li></ul><p>比如<code>TianTian.com</code>，可以分出很多二级域名，比如<code>Day1.TianTian.com</code>，<code>Day2.TianTian.com</code>,<code>Day3.TianTian.com</code>,这样子就可以有效解决队头阻塞问题</p><h3 id="9、谈一谈HTTP数据传输"><a href="#9、谈一谈HTTP数据传输" class="headerlink" title="9、谈一谈HTTP数据传输"></a>9、谈一谈HTTP数据传输</h3><p>大概遇到的情况就分为<strong>「定长数据」</strong> 与 <strong>「不定长数据」</strong>的处理吧。</p><h4 id="1、定长数据"><a href="#1、定长数据" class="headerlink" title="1、定长数据"></a>1、定长数据</h4><ul><li>发送端在发送数据的过程中，需要设置<code>Content-Length</code>,来指明发送数据的长度。如果采用了Gzip压缩的话，Content-Length设置的就是压缩后的传输长度</li></ul><p>【注意】：</p><ul><li>Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。</li><li>如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。</li><li>那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。</li><li>在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于<code>Content-Length</code>,若是非Keep-alive，跟前面情况一样，Content-Length可有可无</li></ul><h4 id="2、不定长数据"><a href="#2、不定长数据" class="headerlink" title="2、不定长数据"></a>2、不定长数据</h4><p>现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>通过chunked机制，可以完成对不定长数据的处理，当然了，你需要知道的是</p><ul><li>如果头部信息中有<code>Transfer-Encoding</code>,优先采用Transfer-Encoding里面的方法来找到对应的长度。</li><li>如果设置了Transfer-Encoding，那么Content-Length将被忽视。</li><li>使用长连接的话，会持续的推送动态内容。</li></ul><p>那我们来模拟一下吧👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const server = require(&#x27;http&#x27;).createServer();</span><br><span class="line">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  if(req.url === &#x27;/index&#x27;) &#123;</span><br><span class="line">   // 设置数据类型</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);</span><br><span class="line">    res.setHeader(&#x27;Content-Length&#x27;, 10);</span><br><span class="line">    res.setHeader(&#x27;Transfer-Encoding&#x27;, &#x27;chunked&#x27;);</span><br><span class="line">    </span><br><span class="line">    res.write(&quot;你好，使用的是Transfer-Encoding设置传输数据形式&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输数据给您&lt;br/&gt;&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    res.write(&quot;骚等一下&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输数据给您&quot;);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;成功启动--TinaTian&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的进程、线程</title>
      <link href="/2021/12/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/12/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h3><h4 id="1、什么是进程"><a href="#1、什么是进程" class="headerlink" title="1、什么是进程"></a>1、什么是进程</h4><ul><li><code>CPU</code>是计算机的核心，承担所有的计算任务，<code>CPU</code> 可以有很多进程，<code>进程</code>是<code>CPU</code>资源分配的最小单位</li><li><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源<ul><li>我们的电脑每打开一个软件就会产生一个或多个 <code>进程</code> ，为什么电脑运行的软件多就会卡，是因为 <code>CPU</code> 给每个 <code>进程</code> 分配资源空间，但是一个 <code>CPU</code> 一共就那么多资源，分出去越多，越卡</li><li>每个<code>进程</code>之间是相互独立的， <code>CPU</code> 在运行一个 <code>进程</code> 时，其他的进程处于非运行状态，<code>CPU</code> 使用 <a href="https://link.juejin.cn/?target=undefined">时间片轮转调度算法</a> 来实现同时运行多个进程</li></ul></li></ul><h4 id="2、什么是线程"><a href="#2、什么是线程" class="headerlink" title="2、什么是线程"></a>2、什么是线程</h4><ul><li><p><code>线程</code> 是 <code>CPU</code> 调度的最小单位</p></li><li><p>线程 是建立在 <code>进程</code> 的基础上的一次程序运行单位，通俗点解释 <code>线程</code> 就是程序中的一个执行流，一个 <code>进程</code> 可以有多个 <code>线程</code></p></li><li><p>一个 <code>进程</code> 中只有一个执行流称作 <code>单线程</code> ，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行</p></li><li><p>一个 <code>进程</code> 中有多个执行流称作 <code>多线程</code>，即在一个程序中可以同时运行多个不同的 <code>线程</code> 来执行不同的任务， 也就是说允许单个程序创建多个并行执行的 <code>线程</code> 来完成各自的任务</p></li></ul><h4 id="3、进程和线程的区别"><a href="#3、进程和线程的区别" class="headerlink" title="3、进程和线程的区别"></a>3、进程和线程的区别</h4><ol><li><p>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位</p></li><li><p>一个 <code>进程</code> 由一个或多个 <code>线程</code> 组成，<code>线程</code> 可以理解为是一个进程中代码的不同执行路线</p></li><li><p><code>进程</code> 之间相互独立，但同一进程下的各个 <code>线程</code> 间共享程序的内存空间 (包括代码段、数据集、堆等) 及一些进程级的资源 (如打开文件和信号)</p></li><li><p>调度和切换：线程上下文切换比进程上下文切换要快得多</p></li></ol><h4 id="4、多进程和多线程"><a href="#4、多进程和多线程" class="headerlink" title="4、多进程和多线程"></a>4、多进程和多线程</h4><ul><li><h4 id="多进程："><a href="#多进程：" class="headerlink" title="多进程："></a>多进程：</h4><ul><li><p>同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态</p></li><li><p>多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰</p></li></ul></li><li><h4 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h4><ul><li><p>指程序中包含多个执行流</p></li><li><p>即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</p></li></ul></li></ul><h3 id="2、JS为什么是单线程"><a href="#2、JS为什么是单线程" class="headerlink" title="2、JS为什么是单线程"></a>2、JS为什么是单线程</h3><h4 id="1、与它的用途有关："><a href="#1、与它的用途有关：" class="headerlink" title="1、与它的用途有关："></a>1、与它的用途有关：</h4><ul><li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题</li><li>假定 <code>JS</code> 同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</li></ul><h4 id="2、-js-还有-Worker-线程"><a href="#2、-js-还有-Worker-线程" class="headerlink" title="2、 js 还有 Worker 线程"></a>2、 <code>js</code> 还有 <code>Worker</code> 线程</h4><ul><li>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许 <code>JavaScript</code> 脚本创建多个线程</li><li>但是子线程是完全受主线程控制的，而且不得操作DOM</li><li>所以，这个标准并没有改变JavaScript是单线程的本质</li></ul><h3 id="3、浏览器是多进程的"><a href="#3、浏览器是多进程的" class="headerlink" title="3、浏览器是多进程的"></a>3、浏览器是多进程的</h3><h4 id="1、浏览器包含哪些进程"><a href="#1、浏览器包含哪些进程" class="headerlink" title="1、浏览器包含哪些进程"></a>1、浏览器包含哪些进程</h4><h5 id="1、Browser进程"><a href="#1、Browser进程" class="headerlink" title="1、Browser进程"></a>1、Browser进程</h5><ul><li>浏览器的主进程(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul><h5 id="2、第三方插件进程"><a href="#2、第三方插件进程" class="headerlink" title="2、第三方插件进程"></a>2、第三方插件进程</h5><ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul><h5 id="3、GPU进程"><a href="#3、GPU进程" class="headerlink" title="3、GPU进程"></a>3、GPU进程</h5><ul><li>该进程也只有一个，用于3D/动画绘制等等</li></ul><h5 id="4、渲染进程-重"><a href="#4、渲染进程-重" class="headerlink" title="4、渲染进程(重)"></a>4、渲染进程(重)</h5><ul><li>即通常所说的浏览器内核(Renderer进程，内部是多线程)</li><li>每个Tab页面都有一个渲染进程，互不影响</li><li>主要作用为页面渲染，脚本执行，事件处理等</li></ul><h4 id="2、为什么浏览器要多进程"><a href="#2、为什么浏览器要多进程" class="headerlink" title="2、为什么浏览器要多进程"></a>2、为什么浏览器要多进程</h4><ul><li>避免单个page崩溃影响整个浏览器</li><li>避免第三方插件崩溃影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li><li>浏览器进程有很多，每个进程又有很多线程，都会占用内存,内存等资源消耗会很大，有点拿空间换时间的意思</li></ul><h3 id="4、渲染进程"><a href="#4、渲染进程" class="headerlink" title="4、渲染进程"></a>4、渲染进程</h3><p>渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程</p><h4 id="1、GUI渲染线程"><a href="#1、GUI渲染线程" class="headerlink" title="1、GUI渲染线程"></a>1、GUI渲染线程</h4><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等<ul><li>解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree</li><li>解析css，生成CSSOM(CSS规则树)</li><li>把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)</li></ul></li><li>当修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)</li><li>当修改元素的尺寸，页面就会回流(Reflow)</li><li>当页面需要Repaing和Reflow时<strong>GUI线程执行</strong>，绘制页面</li><li>回流比重绘的成本要高，要尽量避免Reflow和Repaint</li><li><strong>GUI渲染线程与JS引擎线程是互斥的</strong><ul><li>当JS引擎执行时GUI线程会被挂起(相当于被冻结了)</li><li>GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</li></ul></li></ul><h4 id="2、JS引擎线程"><a href="#2、JS引擎线程" class="headerlink" title="2、JS引擎线程"></a>2、JS引擎线程</h4><ul><li>JS引擎线程就是JS内核，负责(例如V8引擎)解析Javascript脚本，运行代码</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的</li><li>一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序</li></ul></li><li><strong>GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程</strong><ul><li>就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)   结合React15、16的变迁</li><li>例如浏览器渲染的时候遇到<code>script</code>标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容</li><li>所以如果js执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h4 id="3、事件触发线程"><a href="#3、事件触发线程" class="headerlink" title="3、事件触发线程"></a>3、事件触发线程</h4><ul><li>属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)</li><li>当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理</li></ul><h4 id="4、定时触发器线程"><a href="#4、定时触发器线程" class="headerlink" title="4、定时触发器线程"></a>4、定时触发器线程</h4><p><code>setInterval</code> 与 <code>setTimeout</code> 所在线程：</p><ol><li>浏览器定时计数器并不是由JS引擎计数的 (因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li>通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms</li></ol><h4 id="5、异步http请求线程"><a href="#5、异步http请求线程" class="headerlink" title="5、异步http请求线程"></a>5、异步http请求线程</h4><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行</li><li>简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应 (准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行</li></ul><h3 id="5、Browser进程、渲染进程的通信"><a href="#5、Browser进程、渲染进程的通信" class="headerlink" title="5、Browser进程、渲染进程的通信"></a>5、Browser进程、渲染进程的通信</h3><ul><li><p>打开任务管理器，然后打开一个浏览器，就可以看到：<strong>任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）</strong></p><img src="https://segmentfault.com/img/remote/1460000012925881" alt="img" style="zoom:50%;" /></li><li><p>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</p></li><li><p>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</p><ul><li><p>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</p></li><li><p>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</p></li><li><p>最后Render进程将结果传递给Browser进程</p></li><li><p>Browser进程接收到结果并将结果绘制出来</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/2021/12/13/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2021/12/13/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><p><a href="https://juejin.cn/post/6981673766178783262#heading-13">写给中高级前端关于性能优化的9大策略和6大指标 | 网易四年实践 - 掘金 (juejin.cn)</a></p><h3 id="1、九大策略"><a href="#1、九大策略" class="headerlink" title="1、九大策略"></a>1、九大策略</h3><h4 id="1、网络层面"><a href="#1、网络层面" class="headerlink" title="1、网络层面"></a>1、网络层面</h4><p><strong>网络层面</strong>的性能优化，无疑是如何让资源<code>体积更小加载更快</code>，四方面：</p><ul><li><p><strong>构建策略</strong>：基于构建工具(<code>Webpack/Rollup/Parcel/Esbuild/Vite/Gulp</code>)</p><p>围绕<code>webpack</code>的<code>性能优化</code>，从<code>时间层面</code>和<code>体积层面</code></p><ul><li><strong>减少打包时间</strong>：<code>缩减范围</code>、<code>缓存副本</code>、<code>定向搜索</code>、<code>提前构建</code>、<code>并行构建</code>、<code>可视结构</code></li><li><strong>减少打包体积</strong>：<code>分割代码</code>、<code>摇树优化</code>、<code>动态垫片</code>、<code>按需加载</code>、<code>作用提升</code>、<code>压缩资源</code></li></ul></li><li><p><strong>图像策略</strong>：基于图像类型(<code>JPG/PNG/SVG/WebP/Base64</code>)</p><ul><li><strong>图像选型</strong>：了解所有图像类型的特点及其何种应用场景最合适</li><li><strong>图像压缩</strong>：在部署到生产环境前使用工具或脚本对其压缩处理</li></ul></li><li><p><strong>分发策略</strong>：基于内容分发网络(<code>CDN</code>)</p><ul><li><strong>所有静态资源走CDN</strong>：开发阶段确定哪些文件属于静态资源</li><li><strong>把静态资源与主页面置于不同域名下</strong>：避免请求带上<code>Cookie</code></li></ul></li><li><p><strong>缓存策略</strong>：基于浏览器缓存(<code>强缓存/协商缓存</code>)</p><ul><li><strong>考虑拒绝一切缓存策略</strong>：<code>Cache-Control:no-store</code></li><li><strong>考虑资源是否每次向服务器请求</strong>：<code>Cache-Control:no-cache</code></li><li><strong>考虑资源是否被代理服务器缓存</strong>：<code>Cache-Control:public/private</code></li><li><strong>考虑资源过期时间</strong>：<code>Expires:t/Cache-Control:max-age=t,s-maxage=t</code></li><li><strong>考虑协商缓存</strong>：<code>Last-Modified/Etag</code></li></ul></li></ul><h4 id="2、渲染层面"><a href="#2、渲染层面" class="headerlink" title="2、渲染层面"></a>2、渲染层面</h4><p><strong>渲染层面</strong>的性能优化，无疑是如何让代码<code>解析更好执行更快</code>。因此笔者从以下五方面做出建议。</p><ul><li><strong>CSS策略</strong>：基于CSS规则<ul><li>避免出现超过三层的<code>嵌套规则</code></li><li>避免为<code>ID选择器</code>添加多余选择器</li><li>避免使用<code>标签选择器</code>代替<code>类选择器</code></li><li>避免使用<code>通配选择器</code>，只对目标节点声明规则</li><li>避免重复匹配重复定义，关注<code>可继承属性</code></li></ul></li><li><strong>DOM策略</strong>：基于DOM操作<ul><li>缓存<code>DOM计算属性</code></li><li>避免过多<code>DOM操作</code></li><li>使用<code>DOMFragment</code>缓存批量化<code>DOM操作</code></li></ul></li><li><strong>阻塞策略</strong>：基于脚本加载<ul><li>脚本与<code>DOM/其它脚本</code>的依赖关系很强：对设置<code>defer</code></li><li>脚本与<code>DOM/其它脚本</code>的依赖关系不强：对设置<code>async</code></li></ul></li><li><strong>回流重绘策略</strong>：基于回流重绘<ul><li>缓存<code>DOM计算属性</code></li><li>使用类合并样式，避免逐条改变样式</li><li>使用<code>display</code>控制<code>DOM显隐</code>，将<code>DOM离线化</code></li></ul></li><li><strong>异步更新策略</strong>：基于异步更新<ul><li>在<code>异步任务</code>中修改<code>DOM</code>时把其包装成<code>微任务</code></li></ul></li></ul><h3 id="2、六大指标"><a href="#2、六大指标" class="headerlink" title="2、六大指标"></a>2、六大指标</h3><p><code>六大指标</code>基本囊括大部分<code>性能优化</code>细节，可作为<code>九大策略</code>的补充。分为以下六方面</p><h4 id="1、-加载优化：资源在加载时可做的性能优化"><a href="#1、-加载优化：资源在加载时可做的性能优化" class="headerlink" title="1、 加载优化：资源在加载时可做的性能优化"></a>1、 <strong>加载优化</strong>：资源在加载时可做的性能优化</h4><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a890d76ed4a748b1b745e85dde126989~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-加载优化.png" style="zoom: 33%;" /><h4 id="2、执行优化：资源在执行时可做的性能优化"><a href="#2、执行优化：资源在执行时可做的性能优化" class="headerlink" title="2、执行优化：资源在执行时可做的性能优化"></a>2、<strong>执行优化</strong>：资源在执行时可做的性能优化</h4><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5898aa8a121b40e896c457d9e95ac6f6~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-执行优化.png" style="zoom:33%;" /><h4 id="3、渲染优化：资源在渲染时可做的性能优化"><a href="#3、渲染优化：资源在渲染时可做的性能优化" class="headerlink" title="3、渲染优化：资源在渲染时可做的性能优化"></a>3、渲染优化：资源在渲染时可做的性能优化</h4><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57664767785349ca8d00c712de02989d~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-渲染优化.png" style="zoom:33%;" /><h4 id="4、样式优化：样式在编码时可做的性能优化"><a href="#4、样式优化：样式在编码时可做的性能优化" class="headerlink" title="4、样式优化：样式在编码时可做的性能优化"></a>4、<strong>样式优化</strong>：样式在编码时可做的性能优化</h4><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/589007e1d9c144629803dc242b69861e~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-样式优化.png" style="zoom:33%;" /><h4 id="5、脚本优化：脚本在编码时可做的性能优化"><a href="#5、脚本优化：脚本在编码时可做的性能优化" class="headerlink" title="5、脚本优化：脚本在编码时可做的性能优化"></a>5、<strong>脚本优化</strong>：脚本在编码时可做的性能优化</h4><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a2c1427695424e8a274ee747950bee~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-脚本优化.png" style="zoom:50%;" /><h4 id="6、V8引擎优化：针对V8引擎特征可做的性能优化"><a href="#6、V8引擎优化：针对V8引擎特征可做的性能优化" class="headerlink" title="6、V8引擎优化：针对V8引擎特征可做的性能优化"></a>6、<strong>V8引擎优化</strong>：针对<code>V8引擎</code>特征可做的性能优化</h4><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae8786a5bac5483f9589b0494604705b~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-V8引擎优化.png" style="zoom:33%;" /><h2 id="补充CDN"><a href="#补充CDN" class="headerlink" title="补充CDN"></a>补充CDN</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><ul><li>CDN 是 内容分发网络，本质利用缓存技术，将数据快速可靠从源站传递给用户。用户获取数据，不需要直接从源站获取，而是通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。</li><li><strong>优势：</strong><ul><li><strong>CDN可以加速用户访问速度，减少源站中心负载压力</strong>。如果网络上的数据都使用从源站直接交付到用户的方法，那么极有可能会出现访问拥塞的情况</li><li>CDN是将数据缓存在离用户最近的地方，使用户以最快的速度获取，对于减少网站的出口带宽压力，减少网络传输的拥堵情况</li></ul></li></ul><h3 id="2-CDN的原理"><a href="#2-CDN的原理" class="headerlink" title="2. CDN的原理"></a>2. CDN的原理</h3><p>用户在通过浏览器访问数据时</p><ul><li><p>未使用CDN加速网站的大致过程：</p><img src="https://img-blog.csdnimg.cn/20201104183734785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTY4NDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 50%;" /><p>①用户在浏览器中输入要访问的域名。<br>②浏览器向DNS服务器请求对该域名的解析。<br>③DNS服务器返回该域名的IP地址给浏览器。<br>④浏览器使用该IP地址向服务器请求内容。<br>⑤服务器将用户请求的内容返回给浏览器。</p></li><li><p>使用了CDN:</p><img src="https://img-blog.csdnimg.cn/20201104184159165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTY4NDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 50%;" /><p>①用户在浏览器中输入要访问的域名。<br>②浏览器向DNS服务器请求对域名进行解析。而DNS服务器将域名的解析权交给 CDN专用DNS服务器<br>③CDN专用DNS服务器 将CDN负载均衡设备的IP地址返回给用户。<br>④用户向 CDN负载均衡设备 发起内容URL访问请求。</p><ul><li><p>CDN负载均衡设备会为用户选择一台合适的 CDN缓存服务器 提供服务，选择的依据包括：</p><ul><li>根据用户IP地址，判断哪一台服务器距离用户最近；</li><li>根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；</li><li>查询各个服务器的负载情况，判断哪一台服务器的负载较小。</li></ul><p>基于以上这些依据的综合分析之后，负载均衡设置会把缓存服务器的IP地址返回给用户。</p></li></ul><p>⑤负载均衡设置会把缓存服务器的IP地址返回给用户</p><p>⑥用户向缓存服务器发出请求。<br>⑦缓存服务器响应用户请求，将用户所需内容传送到用户。</p><ul><li>如果这台缓存服务器上并没有用户想要的内容，而负载均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉取到本地</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的DOM+BOM</title>
      <link href="/2021/12/13/JS%E7%9A%84DOM-BOM/"/>
      <url>/2021/12/13/JS%E7%9A%84DOM-BOM/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="1、DOM概念、组成"><a href="#1、DOM概念、组成" class="headerlink" title="1、DOM概念、组成"></a>1、DOM概念、组成</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><ul><li>文档对象模型，是W3C的标准，该标准中，定义了页面的结构、表现、行为；DOM是独于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式</li><li>它是针对xml经过扩展用于html的应用程序编程接口，我们又叫API；</li><li>DOM把整个页面映射为一个多层的节点结构，html或xml页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据</li></ul><h4 id="2、为什么操作DOM昂贵"><a href="#2、为什么操作DOM昂贵" class="headerlink" title="2、为什么操作DOM昂贵"></a>2、为什么操作DOM昂贵</h4><ul><li><p>ES和 DOM是两种东西，每次连接都需要消耗性能：</p><p>浏览器中通常把二者独立实现，使得<strong>二者相互独立</strong>，<strong>JS与DOM每次连接都需要消耗性能</strong></p><p>所以有了<strong>每操作一次DOM就多做点事</strong>的理念，尽可能以最少的次数处理最多的DOM操作</p></li><li><p>而修改DOM更昂贵，因为首先得访问Dom</p><p>操作DOM会导致重排和重绘，重排会占用、消耗<strong>CPU</strong>; 重绘会占用、消耗<strong>GPU</strong></p></li></ul><h4 id="3-智能“节流”操作DOM"><a href="#3-智能“节流”操作DOM" class="headerlink" title="3. 智能“节流”操作DOM"></a>3. 智能“节流”操作DOM</h4><ul><li><p>实现队列化修改，批量执行：</p><ul><li>浏览器会有一个“队列”，用以存放（攒着）需要操作DOM的js程序。每当执行一次js操作dom的代码，这个队列里就先暂存一个程序。</li><li>等到一段时间后，浏览器再集中、批量的链接一次”ES岛”和”DOM岛”（就是让JS引擎去链接渲染引擎），进而触发一次DOM操作。“过一段时间发一班车”</li></ul></li><li><p>但我们如果误操作打断浏览器的“节流”步骤。迫使浏览器中断当前的“等待”，去赶紧、立马进行一次dom操作。让浏览器赶紧执行完他攒在“队列”里的JS操作DOM的程序后返回最新的DOM位置信息给我们</p></li><li><p><strong>减少在循环内进行DOM操作，在循环外部进行DOM缓存</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化前代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.time(<span class="string">&quot;loop1&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; <span class="number">15000</span>; count++) &#123;</span><br><span class="line">       <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>).innerHTML += <span class="string">&#x27;dom&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.timeEnd(<span class="string">&quot;loop1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loop2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&quot;loop2&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; <span class="number">15000</span>; count++) &#123;</span><br><span class="line">        content += <span class="string">&#x27;dom&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text2&#x27;</span>).innerHTML += content;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&quot;loop2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>只控制DOM节点的显示或隐藏，而不是直接去改变DOM结构</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;staff-list&quot;</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;staff-list-ul&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in staffList&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow($index)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span>item.staff_name | addSpace <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;staff_phone&quot;</span>&gt;</span>item.phone_no <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">上面代码的优化原理即先生成所有DOM节点，但是所有节点均不显示出来，利用vue.js中的v-show，根据计算的随机数来控制显示某个&lt;li&gt;，来达到文字滚动效果。</span><br></pre></td></tr></table></figure></li><li><p><strong>操作DOM前，先把DOM节点删除或隐藏</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = $(<span class="string">&quot;.list1&quot;</span>);</span><br><span class="line">list1.hide();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    item.append(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    list1.append(item);</span><br><span class="line">&#125;</span><br><span class="line">list1.show();</span><br></pre></td></tr></table></figure><p>display属性值为none的元素不在渲染树中，因此对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行多次DOM操作，可以先将其隐藏，操作完成后再显示。这样只在隐藏和显示时触发2次重排，而不会是在每次进行操作时都出发一次重排。</p></li><li><p><strong>最小化重绘和重排</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//优化前代码：每对element进行一次样式更改都会影响该元素的集合结构，最糟糕情况下会触发三次重排。</span><br><span class="line">var element = document.getElementById(&#x27;mydiv&#x27;);</span><br><span class="line">element.style.height = &quot;100px&quot;;  </span><br><span class="line">element.style.borderLeft = &quot;1px&quot;;  </span><br><span class="line">element.style.padding = &quot;20px&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//优化后代码：利用js对该元素的class重新赋值，获得新的样式，这样减少了多次的DOM操作</span><br><span class="line">//js操作</span><br><span class="line">.newStyle &#123;  </span><br><span class="line">    height: 100px;  </span><br><span class="line">    border-left: 1px;  </span><br><span class="line">    padding: 20px;  </span><br><span class="line">&#125;  </span><br><span class="line">element.className = &quot;newStyle&quot;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、文档类型历史"><a href="#2、文档类型历史" class="headerlink" title="2、文档类型历史"></a>2、文档类型历史</h3><h4 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h4><ul><li><strong>SGML ：</strong>标准通用标记语言，是所有电子文档标记语言的起源    1985</li><li><strong>HTML：</strong>超文本标记语言，它定义了网页内容的含义和结构。用途：结构化信息（段落、表格），描述文档的外观、语义                     1993</li><li><strong>XML：</strong>可扩展标记语言，和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限                 1998</li><li><strong>XHTML ：</strong>基于 XML 的标记语言，他与 HTML 没什么本质的区别，但他更严格</li></ul><h4 id="2、XHTML"><a href="#2、XHTML" class="headerlink" title="2、XHTML"></a>2、XHTML</h4><p>为了规范 HTML，W3C 结合 XML 制定了 XHTML1.0 标准，与 HTML 4.01 几乎是相同的，按照 XML 的要求来规范 HTML，两者最主要的区别：</p><ul><li>文档顶部 doctype 声明不同，XHTML 的 doctype 顶部声明中明确规定了xhtml DTD的写法</li><li>XHTML 元素必须被正确地嵌套。</li><li>XHTML 元素必须被关闭。</li><li>标签名必须用小写字母，标签必须成双成对：标签名和属性对大小写敏感</li><li>XHTML 文档必须拥有根元素：所有的 XHTML 元素必须被嵌套于 <html> 根元素中</li><li>属性值必须用双引号 <code>&quot;&quot;</code> 括起来</li></ul><h3 id="3、DOM节点"><a href="#3、DOM节点" class="headerlink" title="3、DOM节点"></a>3、DOM节点</h3><h4 id="1、节点的概念"><a href="#1、节点的概念" class="headerlink" title="1、节点的概念"></a>1、节点的概念</h4><ul><li>可以将任何HTML描绘成一个由多层节点构成的结构，节点分为12种不同类型</li><li>每种类型分别表示文档中不同的信息及标记，每个节点都拥有各自的特点、数据和方法，也与其他节点存在某种关系</li><li>节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构</li></ul><h4 id="2、HTML的DOM节点"><a href="#2、HTML的DOM节点" class="headerlink" title="2、HTML的DOM节点"></a>2、HTML的DOM节点</h4><ol><li>元素节点：<html>、<body>、<p>等都是元素节点，即标签。</li><li>文本节点:向用户展示的内容，如<li>…</li>中的JavaScript、DOM、CSS等文本。</li><li>属性节点:元素属性，如<a>标签的链接属性href</li></ol><h4 id="3、节点类型"><a href="#3、节点类型" class="headerlink" title="3、节点类型"></a>3、节点类型</h4><ul><li>DOM1级定义了一个Node接口，它在javascript中是作为Node类型来实现的；</li><li>每个节点都有一个nodeType属性，用于表明节点的类型</li><li>通过定义数值常量和字符常量两种方式来表示，IE只支持数值常量</li><li>节点类型一共有12种，常用7种：</li></ul><p>​    <a href="https://link.juejin.cn/?target=https://camo.githubusercontent.com/0c63f3fd6ccb91445ac1149b2ad3c109135c87c6/687474703a2f2f7777312e73696e61696d672e636e2f6d773639302f6165343962613537677931666539727a316c6b32776a323068613037327462772e6a7067"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/c09202a794fc92f73181eaa8aab51d95~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /></a><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/b0622da786234b4efda4820c4bc6d57a~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 50%;" /></p><h5 id="1、Element-元素"><a href="#1、Element-元素" class="headerlink" title="1、Element(元素)"></a>1、Element(元素)</h5><ul><li><p>它表示了html、xml文档中的元素。通常元素因为有<strong>子元素</strong>、<strong>文本节点</strong>或者两者的结合；</p></li><li><p>元素节点是唯一能够拥有属性的节点类型</p></li><li><p><strong><code>html</code>、<code>head</code>、<code>meta</code>、<code>title</code>、<code>body</code>、<code>div</code>、<code>ul</code>、<code>li</code>、<code>script</code>都属于Element(元素节点);</strong></p></li><li><h4 id="操作元素属性："><a href="#操作元素属性：" class="headerlink" title="操作元素属性："></a>操作元素属性：</h4><ul><li>getAttribute()：实际中主要用于获取自定义属性<ul><li>元素的style属性，自定义属性，返回的是css文本</li><li>元素的事件属性：onclick事件处理程序，属性值是一段JS代码，返回代码字符串</li></ul></li><li>setAttribute(A,B)：设置特性</li><li>removeAttribute()：删除特性</li></ul></li><li><h4 id="所有节点类型共享了两个方法："><a href="#所有节点类型共享了两个方法：" class="headerlink" title="所有节点类型共享了两个方法："></a>所有节点类型共享了两个方法：</h4><ul><li><p>克隆节点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.cloneNode(false/true)</span><br><span class="line">//返回改调用节点的副本。括号内参数为true是深度拷贝，为空格或false则是浅拷贝。</span><br></pre></td></tr></table></figure><ul><li>参数true：表示深复制，复制节点及整个子DOM树</li><li>false：浅复制，只复制该节点，没有子节点，没有指定父节点，称作孤儿节点</li><li>该方法只复制HTML属性，而不复制事件处理程序，但IE会，这是个bug，它复制前要先删除事件</li></ul></li><li><p>normolize()：处理文档子树中的文本节点，相邻同胞节点合为一个文本节点，删除空文本节点等</p></li></ul></li></ul><h5 id="2、Attr-属性"><a href="#2、Attr-属性" class="headerlink" title="2、Attr(属性)"></a>2、Attr(属性)</h5><ul><li>代表了元素中的属性；</li><li>因为属性实际上是附属于元素的，因此属性节点不能被看做是元素的子节点，因而在DOM中属性没有被认为是文档树的一部分</li><li>也就是说：属性节点其实被看做是包含它的元素节点的一部分，它并不作为单独的一个节点在文档树中出现</li><li><code>lang</code>、<code>charset</code>、<code>id</code>、<code>class</code>都属于Attr(属性节点);</li></ul><h5 id="3、Text-文本"><a href="#3、Text-文本" class="headerlink" title="3、Text(文本)"></a>3、Text(文本)</h5><ul><li>是只包含文本内容的节点；</li><li>它可以由更多的信息组成，也可以只包含空白。</li><li>在文档树中元素的文本内容和属性的文本内容都是由文本节点来表示的</li><li><code>DocumentFragment文档片段节点</code>、<code>test1</code>、<code>test2</code>、<code>元素节点之后的空白区域</code>都属于Text(文本节点)</li></ul><h5 id="4、Comment-注释-略"><a href="#4、Comment-注释-略" class="headerlink" title="4、Comment(注释)  略"></a>4、Comment(注释)  略</h5><h5 id="5、DocumentType-文档类型"><a href="#5、DocumentType-文档类型" class="headerlink" title="5、DocumentType(文档类型)"></a>5、DocumentType(文档类型)</h5><ul><li>每一个Document都有一个DocumentType属性，它的值或者是null，或者是DocumentType对象。比如声明文档类型时<!doctype html>就是文档类型节点</li><li>！**<code>DOCTYPE html</code>** 就属于DocumentType(文档类型节点);</li></ul><h5 id="6、DocumentFragment-文档片段"><a href="#6、DocumentFragment-文档片段" class="headerlink" title="6、DocumentFragment(文档片段)"></a>6、DocumentFragment(文档片段)</h5><ul><li> 是轻量级的或最小的Document对象，它表示文档的一部分或者是一段，不属于文档树</li><li>它有一个特殊的行为：<ol><li>把一个DocumentFragment节点插入到文档的时候，插入的不是DocumentFragment自身，而是它的所有的子孙节点</li><li>这使得DocumentFragment成了有用的占位符，暂时存放那些一次插入文档的节点，同时它还有利于实现文档的剪切、复制和粘贴等操作</li></ol></li><li> <strong>例子中的:<code>var frag = document.createDocumentFragment();</code>就属于DocumentFragment(文档片段节点);</strong></li></ul><h4 id="4、特殊的文档节点document"><a href="#4、特殊的文档节点document" class="headerlink" title="4、特殊的文档节点document"></a>4、特殊的文档节点document</h4><h5 id="位置：是文档树的根节点，是文档中其他所有节点的父节点；"><a href="#位置：是文档树的根节点，是文档中其他所有节点的父节点；" class="headerlink" title="位置：是文档树的根节点，是文档中其他所有节点的父节点；"></a>位置：是文档树的根节点，是文档中其他所有节点的父节点；</h5><ol><li><p>在浏览器中，文档对象 document 是HTMLdocument的一个实例，表示<strong>整个HTML页面</strong></p></li><li><p>也是<strong>window对象的一个属性</strong>，因此是一个全局对象</p></li><li><p>!Doctype html、html作为Document(文档节点)的子节点出现;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.documentElement：指向&lt;html&gt;元素</span><br><span class="line">document.body：指向&lt;body&gt;元素</span><br><span class="line">document.doctype获取到文档中独立的部分：&lt;!doctype&gt;</span><br></pre></td></tr></table></figure></li></ol><h5 id="2、【注意】"><a href="#2、【注意】" class="headerlink" title="2、【注意】"></a>2、【注意】</h5><ol><li>文档节点并不是html、xml文档的根元素，因为在xml文档中，处理指令、注释等内容可以出现在根元素之外</li><li>所以我们在构造DOM树的时候，根元素并不适合作为根节点，因此就有了文档节点，而根元素是作为文档节点的子节点出现的</li></ol><ul><li>Document 类型的节点有以下特征：<ul><li>nodeType 等于 9； </li><li>nodeName 值为”#document”； </li><li>nodeValue 、parentNode 、ownerDocument值为 null；</li><li>值为 null； </li><li>子节点可以是 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment 类型</li></ul></li></ul><h5 id="功能1：提供文档信息"><a href="#功能1：提供文档信息" class="headerlink" title="功能1：提供文档信息"></a>功能1：提供文档信息</h5><ul><li>提供浏览器所加载网页的信息，所有这些信息都可以在请求的 HTTP 头部信息中获取，只是在 JS 中通过这几个属性暴露出来<ul><li>title：过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改 title 属性无效</li><li>URL：包含当前页面的完整 URL（地 址栏中的 URL）</li><li>domain ：含页面的域名（唯一可设置的）</li><li>referrer：包含链接到当前页面的那个页面的 URL，如 果当前页面没有来源，则 referrer 属性包含空字符串</li></ul></li></ul><h5 id="功能2：查找元素节点"><a href="#功能2：查找元素节点" class="headerlink" title="功能2：查找元素节点"></a>功能2：查找元素节点</h5><h5 id="功能3：文档写入"><a href="#功能3：文档写入" class="headerlink" title="功能3：文档写入"></a>功能3：文档写入</h5><p>document对象有向<strong>网页输出流</strong>写入内容的能力，write()、 writeln()、open()和 close()</p><ul><li>document.write():向一个已经加载，并且没有调用过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/open"><code>document.open()</code></a> 的文档写入数据时，会自动调用 <code>document.open</code>。一旦完成了数据写入，建议调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/close"><code>document.close()</code></a>，以告诉浏览器当前页面已经加载完毕。写入的数据会被解析到文档结构模型（DOM）里。</li><li>document.onload()：<strong>页面包含图片等文件在内的所有元素都加载完成</strong>，即页面加载完毕执行的事，会有覆盖性</li></ul><h5 id="功能4：创建元素"><a href="#功能4：创建元素" class="headerlink" title="功能4：创建元素"></a>功能4：创建元素</h5><ul><li><h5 id="document-createElement-："><a href="#document-createElement-：" class="headerlink" title="document.createElement()："></a>document.createElement()：</h5><p>创建元素节点，参数为要创建元素的标签名，div、h2等,要把元素，通过appendChild等操作节点的方式添加到文档树上，才能在浏览器中渲染出来</p></li></ul><ul><li><h5 id="document-createTextNode-："><a href="#document-createTextNode-：" class="headerlink" title="document.createTextNode()："></a>document.createTextNode()：</h5><p>创建文本节点，参数为要插入的字符串</p></li></ul><h3 id="4、增删改查元素节点"><a href="#4、增删改查元素节点" class="headerlink" title="4、增删改查元素节点"></a>4、增删改查元素节点</h3><h4 id="4-1、通过选择器查找"><a href="#4-1、通过选择器查找" class="headerlink" title="4.1、通过选择器查找"></a>4.1、通过选择器查找</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据CSS选择器去页面中查询一个元素，如果匹配到的元素有多个，则它会返回查询到的第一个元素：</span><br><span class="line">document.querySelector(&#x27;selector&#x27;) </span><br><span class="line"></span><br><span class="line">根据CSS选择器去页面中查询一组元素，会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个</span><br><span class="line">document.querySelectorAll(&#x27;selector)</span><br><span class="line"></span><br><span class="line">获取或设置HtmL</span><br><span class="line">elem.innerHTML(HTML片段)</span><br><span class="line">elem.textContent(纯文本内容)</span><br></pre></td></tr></table></figure><h4 id="4-2-通过document对象调用"><a href="#4-2-通过document对象调用" class="headerlink" title="4.2 通过document对象调用"></a>4.2 通过document对象调用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html  docunment.documentElement   获取页面中html根元素</span><br><span class="line">head  document.head</span><br><span class="line">body  document.body = document.getElementsByTagName(&quot;body&quot;)[0];  </span><br><span class="line">document.all  =  document.getElementsByTagName(&quot;*&quot;) 获取页面中的所有元素</span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;id&#x27;)</span><br><span class="line">document.getElementsByTagName(&#x27;p&#x27;)</span><br><span class="line">document.getelementsByName(&#x27;text&#x27;)</span><br><span class="line">document.getElementsByClassName(&#x27;userClass&#x27;)</span><br></pre></td></tr></table></figure><h4 id="4-3、通过元素节点关系"><a href="#4-3、通过元素节点关系" class="headerlink" title="4.3、通过元素节点关系"></a>4.3、通过元素节点关系</h4><ul><li><p>节点的层次关系：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/4ed4cb033ac7ecd2b1f921d896eff506~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 67%;" /></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找节点：</span><br><span class="line">elem.parentNode 查找elem的父节点</span><br><span class="line">elem.childNodes 找elem的所有直接子节点</span><br><span class="line">elem.firstChild 找elem的第一个直接子节点</span><br><span class="line">elem.lastChild 找elem的最后一个直接子节点</span><br><span class="line">elem.previousSibling 找elem的前一个兄弟</span><br><span class="line">elem.nextSibling 找elem的下一个兄弟</span><br><span class="line">查找元素：</span><br><span class="line">elem.parentElement 找父元素</span><br><span class="line">elem.children 找所有直接子元素</span><br><span class="line">elem.firstElementChild 第一个直接子元素</span><br><span class="line">elem.lastElementChild 最后一个直接子元素</span><br><span class="line">elem.previousElementSibling 前一个兄弟元素</span><br><span class="line">elem.nextElementSibling 下一个兄弟元素</span><br></pre></td></tr></table></figure><h4 id="4-4、增加、删除、修改元素节点"><a href="#4-4、增加、删除、修改元素节点" class="headerlink" title="4.4、增加、删除、修改元素节点"></a>4.4、增加、删除、修改元素节点</h4><p><strong>先获取父节点，并有子节点，再操作其子节点</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、创建节点</span><br><span class="line">document.creatElement(&#x27;tagName&#x27;)</span><br><span class="line">document.createTextNode(&quot;xxx&quot;)创建文本节点</span><br><span class="line"></span><br><span class="line">2、增加节点</span><br><span class="line">1. 尾部添加：node.appendChild(A)：</span><br><span class="line">2. 插入添加：node.insertBefore(新节点,旧节点)；在node的孩子节点B前面，插入A节点</span><br><span class="line"></span><br><span class="line">3、删除节点</span><br><span class="line">node.removeChild(子节点)：移除node的A节点</span><br><span class="line">推荐方式：子节点.parentNode.removeChild(子节点)**  </span><br><span class="line"></span><br><span class="line">4、替换节点</span><br><span class="line">node.replaceChild(新节点,旧节点)：用A节点替换B节点</span><br></pre></td></tr></table></figure><h3 id="5、JS操作Dom修改样式属性"><a href="#5、JS操作Dom修改样式属性" class="headerlink" title="5、JS操作Dom修改样式属性"></a>5、JS操作Dom修改样式属性</h3><h4 id="1、读取、修改内联样式："><a href="#1、读取、修改内联样式：" class="headerlink" title="1、读取、修改内联样式："></a>1、读取、修改内联样式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取：元素节点.style.样式名 </span><br><span class="line">修改：元素.style.样式名 = 样式值</span><br></pre></td></tr></table></figure><p>【注意】：</p><ol><li> <strong>通过style修改和读取的样式都是内联样式</strong>，由于内联样式的优先级比较高，所以通过JS来修改的样式，往往会立即生效</li><li> <strong>但是如果样式中设置了!important，则内联样式将不会生效。</strong></li></ol><h4 id="2、读取元素的当前样式"><a href="#2、读取元素的当前样式" class="headerlink" title="2、读取元素的当前样式"></a>2、读取元素的当前样式</h4><ul><li><h4 id="getComputedStyle-元素节点，-一般null"><a href="#getComputedStyle-元素节点，-一般null" class="headerlink" title="getComputedStyle(元素节点， 一般null)"></a>getComputedStyle(元素节点， 一般null)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getComputedStyle(box, null)[&quot;width&quot;]; </span><br></pre></td></tr></table></figure><ul><li>是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式</li><li>该方法读取到样式都是只读的不能修改</li></ul></li><li><h4 id="window对象的方法"><a href="#window对象的方法" class="headerlink" title="window对象的方法"></a>window对象的方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert</span><br><span class="line"><span class="built_in">setInterval</span>、<span class="built_in">setTimeout</span>、<span class="built_in">clearInterval</span>、<span class="built_in">clearTimeout</span></span><br><span class="line">scrollBy、scrollTo、resizeBy、resizeTo</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、样式相关属性"><a href="#3、样式相关属性" class="headerlink" title="3、样式相关属性"></a>3、样式相关属性</h4><p>以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clientHeight、clientWidth： 元素的可见高/宽度，包括元素的内容区和内边距的高度  </span><br><span class="line"></span><br><span class="line">scrollHeight、scrollWidth：  获取元素滚动区域的高度和宽度 </span><br><span class="line">scrollTop、scrollLeft：      获取元素垂直和水平滚动条滚动的距离 </span><br><span class="line"></span><br><span class="line">offsetHeight、offfsetWidth：  整个元素的高度，包括内容区、内边距、边框</span><br><span class="line">offsetLeft、offsetTop： 当前元素和定位父元素之间的偏移量</span><br><span class="line"></span><br><span class="line">offsetParent：  当前元素的定位父元素、离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断滚动条是否滚动到底  </span><br><span class="line"> 垂直滚动条  </span><br><span class="line">scrollHeight -scrollTop = clientHeight  </span><br><span class="line">  </span><br><span class="line"> 水平滚动  </span><br><span class="line">scrollWidth -scrollLeft = clientWidth</span><br></pre></td></tr></table></figure><h3 id="6、DomReady"><a href="#6、DomReady" class="headerlink" title="6、DomReady"></a>6、DomReady</h3><h4 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h4><ul><li><strong>domReady</strong>：<ol><li>操作DOM的时候，要先确保HTML解析工作已经完成，否则，拿不到DOM节点；</li><li>指的是DOM树构建完毕，也就是HTML解析第一步完成。节点是以树的形式组织的，当页面上所有的html都转换为节点以后，就叫做domReady；</li></ol></li></ul><h4 id="2、实现策略"><a href="#2、实现策略" class="headerlink" title="2、实现策略"></a>2、实现策略</h4><h5 id="1、body标签最后"><a href="#1、body标签最后" class="headerlink" title="1、body标签最后"></a>1、body标签最后</h5><ul><li><p>浏览器是从上到下，从左向右渲染元素的，这样实例中的js代码一定在domReady之后去执行的</p></li><li><p>但为什么很少用？</p><p>在实际项目中，js文件往往非常多，而且之间会相互调用，大多数都是外部引用的，不把js代码直接写在页面上。</p><p>这时候就不能自由地去调用jS了，就需要一个domReady，不管逻辑代码写在哪里，都是等到domReady之后去执行的</p></li></ul><h5 id="2、window-onload方法："><a href="#2、window-onload方法：" class="headerlink" title="2、window.onload方法："></a>2、window.onload方法：</h5><ul><li>表示当页面<strong>所有的元素</strong>都加载完毕，并且<strong>所有要请求的资源也加载完毕</strong>才触发执行；</li><li>在文档外部资源不多的情况下不会有什么问题，但当页面中有<strong>大量远程图片或要请求的远程资源时</strong>：<ol><li>需要让js在点击每张图片时，进行相应的操作；</li><li>如果此时外部资源还没有加载完毕，点击图片是不会有任何反应的，大大降低了用户体验。</li></ol></li></ul><h5 id="3、DOMContentLoaded-事件："><a href="#3、DOMContentLoaded-事件：" class="headerlink" title="3、DOMContentLoaded 事件："></a>3、DOMContentLoaded 事件：</h5><p>为了解决window.onload的短板，w3c 新增了一个 DOMContentLoaded 事件。</p><ul><li><p>不支持的就用来自Diego Perini发现的著名Hack兼容。兼容原理大概就是通过IE中的document，<br>documentElement.doScroll(‘left’)来判断DOM树是否创建完毕</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReady</span>(<span class="params">fn</span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//对于现代浏览器，对DOMContentLoaded事件的处理采用标准的事件绑定方式  </span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">document</span>.addEventListener ) &#123;  </span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, fn, <span class="literal">false</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        IEContentLoaded(fn);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//IE模拟DOMContentLoaded  </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">IEContentLoaded</span> (<span class="params">fn</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> d = <span class="built_in">window</span>.document;  </span><br><span class="line">        <span class="keyword">var</span> done = <span class="literal">false</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//只执行一次用户的回调函数init()  </span></span><br><span class="line">        <span class="keyword">var</span> init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> (!done) &#123;  </span><br><span class="line">                done = <span class="literal">true</span>;  </span><br><span class="line">                fn();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// DOM树未创建完之前调用doScroll会抛出错误  </span></span><br><span class="line">                d.documentElement.doScroll(<span class="string">&#x27;left&#x27;</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;  </span><br><span class="line">                <span class="comment">//延迟再试一次~  </span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="built_in">arguments</span>.callee, <span class="number">50</span>);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 没有错误就表示DOM树创建完毕，然后立马执行用户回调  </span></span><br><span class="line">            init();  </span><br><span class="line">        &#125;)();  </span><br><span class="line">        <span class="comment">//监听document的加载状态  </span></span><br><span class="line">        d.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">            <span class="comment">// 如果用户是在domReady之后绑定的函数，就立马执行  </span></span><br><span class="line">            <span class="keyword">if</span> (d.readyState == <span class="string">&#x27;complete&#x27;</span>) &#123;  </span><br><span class="line">                d.onreadystatechange = <span class="literal">null</span>;  </span><br><span class="line">                init();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7、DOM节点继承层次"><a href="#7、DOM节点继承层次" class="headerlink" title="7、DOM节点继承层次"></a>7、DOM节点继承层次</h3><h4 id="1、DOM节点继承层次"><a href="#1、DOM节点继承层次" class="headerlink" title="1、DOM节点继承层次"></a>1、DOM节点继承层次</h4><ul><li><h4 id="为什么操作DOM耗费性能？"><a href="#为什么操作DOM耗费性能？" class="headerlink" title="为什么操作DOM耗费性能？"></a>为什么操作DOM耗费性能？</h4><p>对DOM节点每一个属性的访问，有时候可能会向上向上溯寻到N多个原型链，因此DOM操作是个非常耗性能的操作；</p><p>前端框架提出了虚拟DOM的概念，合并和屏蔽了很多无效的DOM操作</p></li></ul><h4 id="2、元素节点（Element）的创建过程"><a href="#2、元素节点（Element）的创建过程" class="headerlink" title="2、元素节点（Element）的创建过程"></a>2、元素节点（Element）的创建过程</h4><p>举例<strong>创建一个p元素一共溯寻了7层原型链：</strong></p><ol><li><p>使用document.createElement(“p”)创建p元素</p></li><li><p>document.createElement(“p”)是HTMLParagraphElement的一个实例；</p></li><li><p>HTMLParagraphElement的父类是HTMLElement</p></li><li><p>HTMLElement的父类是Element</p></li><li><p>Element的父类是Node</p></li><li><p>Node的父类是EventTarget</p></li><li><p>EventTarget的父类是Function</p></li><li><p>Function的父类是Object</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/4c794f63d00b456f059056c4d3db3fa3~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /></li></ol><ul><li><h4 id="查看document-createElement-“p”-自身属性："><a href="#查看document-createElement-“p”-自身属性：" class="headerlink" title="查看document.createElement(“p”)自身属性："></a>查看document.createElement(“p”)自身属性：</h4><h5 id="遍历对象属性方法3种："><a href="#遍历对象属性方法3种：" class="headerlink" title="遍历对象属性方法3种："></a>遍历对象属性方法3种：</h5><ol><li>for-in循环:会遍历对象自身的属性,以及原型属性,包括enumerable 为 false(不可枚举属性);</li><li>Object.keys():可以得到自身可枚举的属性，但得不到原型链上的属性;</li><li>Object.getOwnPropertyNames():可以得到**自身所有的属性(**包括不可枚举),但得不到原型链上的属性,Symbols属性</li></ol></li></ul><h4 id="3、文本节点（Text）的创建过程"><a href="#3、文本节点（Text）的创建过程" class="headerlink" title="3、文本节点（Text）的创建过程"></a>3、文本节点（Text）的创建过程</h4><p>举例<strong>创建一个文本节点一共溯寻了6层原型链</strong>：</p><ol><li>使用document.createTextNode(“xxx”)创建文本节点；</li><li>document.createTextNode(“xxx”)是Text的一个实例</li><li>而Text的父类是CharactorData — CharactorData的父类是Node</li><li>Node的父类是EventTarget  —- EventTarget的父类是Function</li><li>Function的父类是Object</li></ol><p>​    <a href="https://link.juejin.cn/?target=https://camo.githubusercontent.com/562ed479af47c93aa1579ab297326c74bec35e7d/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f6165343962613537677931666561347368657332676a32306979306b38646b332e6a7067"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/23bec759f6a82d45f491c8d96ca36406~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /></a></p><p>【注意】：所有节点的继承层次都不简单，但相比较而言，元素节点是更可怕的。从HTML1升级到HTML3.2，再升级到HTML4.1，再到HTML5。除了不断地增加新类型、新的嵌套规则以外，每个元素也不断的添加新属性。</p><h4 id="4、空的div元素的自有属性"><a href="#4、空的div元素的自有属性" class="headerlink" title="4、空的div元素的自有属性"></a>4、空的div元素的自有属性</h4><ul><li><p>空的div元素，并且没有插入到DOM里边，看它有多少自有属性（不包括原型链继承来的属性）</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/b8a4c92310facfc3b40671b9f8e7db18~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:25%;" /></li><li><p>在新的HTML规范中，许多元素的固有属性（比如value）都放到了原型链当中，数量就更加庞大了</p></li><li><p>而框架：比如MVVM框架，将所有的DOM操作都转交给框架内部做精细处理，包括虚拟DOM</p></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="1、事件、事件流"><a href="#1、事件、事件流" class="headerlink" title="1、事件、事件流"></a>1、事件、事件流</h3><ul><li>事件三要素：事件源、事件类型、事件处理程序</li><li>事件流：事件传递时在元素节点之间按照特定的顺序传播，描述了页面接收事件的顺序。IE（事件冒泡）和网景（事件捕获）提出了相反的事件流方案</li></ul><h3 id="2、事件对象"><a href="#2、事件对象" class="headerlink" title="2、事件对象"></a>2、事件对象</h3><h4 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h4><ol><li><p>在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 <strong>event</strong> 的对象中</p></li><li><p>这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型等；</p></li><li><p>event 对象<strong>只在事件处理程序执行期间存在</strong>，一旦执行完毕，就会被销毁</p></li></ol><h4 id="2、属性："><a href="#2、属性：" class="headerlink" title="2、属性："></a>2、属性：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e.target                        //返回触发事件的对象 标准</span><br><span class="line">e.srcElement;                   //返回触发事件的对象 非标准</span><br><span class="line">e.type;                         //返回事件的类型 ，如click</span><br><span class="line">eventPhase 属性可用于确定事件流当前所处的阶段</span><br><span class="line">    捕获阶段被调用，则 eventPhase 等于 1；</span><br><span class="line">    目标上被调用，则 eventPhase 等于 2；</span><br><span class="line">    冒泡阶段被调用，则 eventPhase 等于 3</span><br></pre></td></tr></table></figure><h4 id="3、currentTarget-、target区别"><a href="#3、currentTarget-、target区别" class="headerlink" title="3、currentTarget 、target区别"></a>3、currentTarget 、target区别</h4><ol><li><p>事件处理程序内部this始终等于 currentTarget 的值，而 target 只包含事件的实际目标；</p></li><li><p>如果事件处理直接添加在了意图的目标，则3者一致；</p></li><li><p>如果这个事件处理程序是添加到外层：</p><p>this 和 currentTarget 都等于<strong>注册事件</strong>处理程序的元素</p><p> target 属性等于按钮本身，这是因为那<strong>才是 click 事件真正的目标</strong>。由于按钮本身并没有注册事件处理程序，因此 click 事件冒泡到外层，从而触发了在它上面注册的处理程序</p></li></ol><h4 id="4、方法："><a href="#4、方法：" class="headerlink" title="4、方法："></a>4、方法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preventDefault()方法：用于阻止特定事件的默认动作。比如，链接的默认行为</span><br><span class="line">stopPropagation()方法：用于立即阻止事件流在DOM结构中传播，取消后续事件捕获或冒泡</span><br></pre></td></tr></table></figure><h3 id="3、事件绑定、解除"><a href="#3、事件绑定、解除" class="headerlink" title="3、事件绑定、解除"></a>3、事件绑定、解除</h3><h4 id="1、添加事件属性-基本不用"><a href="#1、添加事件属性-基本不用" class="headerlink" title="1、添加事件属性   基本不用"></a>1、添加事件属性   基本不用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(&#x27;Clicked&#x27;)&quot;/&gt; </span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot;/&gt; </span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(event.type)&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(this.value)&quot;&gt; </span><br></pre></td></tr></table></figure><ul><li>this 值相当于事件的目标元素；</li><li>这个函数有一个特殊的局部变量 event，其中保存的就是 event 对象。有了这个对象，就不用开发者另外定义其他变量，也不用从包装函数的参数列表中去取了</li></ul><p><strong>缺点：</strong></p><ul><li><p>时差问题：有可能 HTML 元素已经显示在页面上，用户都与其交互了，而事件处理程序的代码还无法执行。比如函数定义放在后面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;try&#123;showMessage();&#125;catch(ex) &#123;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>为此，大多数 HTML 事件处理程序会封装在 try/catch 块中，错误在浏览器收到之前已经被拦截了，就不会发生 JavaScript 错误了</li></ul></li><li><p>HTML 与 JavaScript 强耦合：如果要更换事件处理程序，就要改动两个地方:HTML代码和JS代码，这非常不利于后期代码的维护</p></li></ul><h4 id="2、DOM0-函数赋值"><a href="#2、DOM0-函数赋值" class="headerlink" title="2、DOM0  函数赋值"></a>2、DOM0  函数赋值</h4><ul><li><p>做法：把一个函数赋值给（DOM 元素的）一个事件处理程序属性，要使用 JavaScript 指定事件处理程序，必须先取得要操作对象的引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let btn = document.getElementById(&quot;myBtn&quot;); </span><br><span class="line">// 赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即 this 等于元素</span><br><span class="line">btn.onclick = function() &#123;  </span><br><span class="line"> console.log(this.id); // &quot;myBtn&quot; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>事件处理程序会在元素的作用域中运行，即 this 等于元素。通过 this 可以访问元素的任何属性和方法</p><ul><li>以这种方式添加事件处理程序是注册在事件流的<strong>冒泡阶段</strong>的。</li></ul></li><li><p><strong>缺点：</strong></p><ul><li>只能给该元素绑定一个事件，会覆盖</li></ul></li></ul><h4 id="3、DOM2"><a href="#3、DOM2" class="headerlink" title="3、DOM2"></a>3、DOM2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addEventListener(事件名，事件处理函数，布尔值)</span><br><span class="line"></span><br><span class="line">true 表示在捕获阶段调用事件处理程序</span><br><span class="line">false（默认值）表示在冒泡阶段调用事件处理程序</span><br></pre></td></tr></table></figure><ul><li>优点：为同一个事件添加<strong>多个</strong>事件处理程序，以添加<strong>顺序</strong>来触发</li><li>注意：大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好</li></ul><h4 id="4、解除绑定"><a href="#4、解除绑定" class="headerlink" title="4、解除绑定"></a>4、解除绑定</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移除通过 DOM0 方式添加的事件处理程序</span></span><br><span class="line">btn.onclick = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">removeEventListener(事件名，事件处理函数，布尔值)</span><br><span class="line">-- <span class="literal">true</span> 表示在捕获阶段调用事件处理程序</span><br><span class="line">-- <span class="literal">false</span>（默认值）表示在冒泡阶段调用事件处理程序</span><br><span class="line">-- 添加的匿名函数无法移除，因为移除方式与添加一样</span><br></pre></td></tr></table></figure><ul><li>添加的匿名函数无法移除，因为移除方式与添加一样</li></ul><h4 id="性能问题："><a href="#性能问题：" class="headerlink" title="性能问题："></a>性能问题：</h4><ul><li><p>删除时带来的问题：由于无用的事件处理程序长驻内存导致Web 应用性能不佳</p><ul><li><p>第一个是删除带有事件处理程序的元素。比如通过真正的 DOM方法 removeChild()或 replaceChild()删除节点</p></li><li><p>使用 innerHTML 整体替换页面的 某一部分。这时候，被 innerHTML 删除的元素上如果有事件处理程序，就不会被垃圾收集程序正常清理。很有可能元素的引用和事件处理程序的引用都会残留在内存中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btn.onclick = null; // 删除事件处理程序    推荐</span><br></pre></td></tr></table></figure></li><li><p>另一个可能导致内存中残留引用的问题是页面卸载。浏览器每次加载和卸载页面（比如通过前进、后退或刷新），内存中残留对象的数量都会增加，这是因为事件处理程序不会被回收</p><p>记住：onload 事件处理程序中做了什么，最好在 onunload 事件处理程序中恢复</p></li></ul></li><li><p>删除会阻止事件冒泡。只有事件目标仍然存在于文档中时，事件才会冒泡</p></li></ul><h3 id="4、事件传播3个阶段"><a href="#4、事件传播3个阶段" class="headerlink" title="4、事件传播3个阶段"></a>4、事件传播3个阶段</h3><h4 id="1、事件冒泡-√"><a href="#1、事件冒泡-√" class="headerlink" title="1、事件冒泡         √"></a>1、事件冒泡         √</h4><ul><li><p>概念：事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发</p></li><li><p>优点：<strong>事件委托</strong>，大多是有益的</p></li><li><p>缺点：有时候我们需要<strong>阻止冒泡</strong></p><p>需求：比如存在这么一个页面A–&gt;B–&gt;C，c是最内层元素，如果用户点击c，则跳转页面，点击b，无反应，点击a，关闭页面；</p><p>做法：我们给A加一个点击事件关闭，给C加一个单击跳转事件，这时候如果点B，会产生冒泡就会关闭页面</p><p>解决：如果不想关闭页面，那么就需要给B绑定一个单击响应事件，添加上阻止冒泡函数**event.stopPropagation();**即可</p></li><li><p><strong>阻止事件冒泡的方式：</strong></p><ul><li><p>方式1：事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（执行超链接的跳转）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://www.csdn.net/&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式2：连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式3：阻止事件冒泡也会阻止默认事件；</p><p>可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2、目标阶段"><a href="#2、目标阶段" class="headerlink" title="2、目标阶段"></a>2、目标阶段</h4><p>​         事件捕获到目标元素，捕获结束开始在目标元素上触发事件  </p><h4 id="3、事件捕获"><a href="#3、事件捕获" class="headerlink" title="3、事件捕获"></a>3、事件捕获</h4><p>​        最不具体的节 点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。</p><ul><li>如果希望在捕获阶段就触发事件，可以将<strong>addEventListener()<strong>的第三个参数设置为true<br>一般情况下我们</strong>不会希望在捕获阶段触发事件</strong>，所以这个参数一般都是false</li></ul><h3 id="5、事件委托-√"><a href="#5、事件委托-√" class="headerlink" title="5、事件委托     √"></a>5、事件委托     √</h3><ul><li><p>作用：解决“事件处理程序过多”的办法，利用<strong>事件冒泡</strong>，只指定一个事件处理程序，就可以管理某一类型的所有事件</p><ul><li>首先，每个函数都是对象，都<strong>占用内存空间</strong>，对象越多，性能越差。</li><li>其次，为指定事件处理程序所需<strong>访问 DOM 的次数会先期造成整个页面交互的延迟</strong></li></ul></li><li><p>做法：一般把事件绑定到父级元素或者更外层元素，当子元素发生该事件，由于事件冒泡，事件会被父级元素监听到，从而触发事件处理程序</p></li><li><p>优点：</p><ul><li>document 对象随时可用，任何时候都可以给它添加事件处理程序，这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用</li><li>节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也 可以节省时间。</li><li>减少整个页面所需的内存，提升整体性能</li></ul></li><li><p>缺点：</p><ul><li>1.部分事件如 focus、blur 等无冒泡机制，所以无法委托。<br>2.事件委托有对子元素的查找过程，委托层级过深，可能会有性能问题<br>3.频繁触发的事件如 mousemove、mouseout、mouseover等，经常需要计算元素位置，不适合事件委托</li></ul></li></ul><h3 id="6、事件类型"><a href="#6、事件类型" class="headerlink" title="6、事件类型"></a>6、事件类型</h3><ul><li><p>DOM3 Events 定义了如下事件类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 用户界面事件：load、scroll、resize</span><br><span class="line"></span><br><span class="line">* 焦点事件：在元素获得和失去焦点时触发</span><br><span class="line"></span><br><span class="line">* 鼠标事件：鼠标在页面上执行某些操作时触发</span><br><span class="line"></span><br><span class="line">* 滚轮事件：使用鼠标滚轮（或类似设备）时触发</span><br><span class="line"></span><br><span class="line">* 输入事件：向文档中输入文本时触发</span><br><span class="line"></span><br><span class="line">* 键盘事件：键盘在页面上执行某些操作时触发</span><br></pre></td></tr></table></figure></li></ul><h4 id="1、用户界面事件"><a href="#1、用户界面事件" class="headerlink" title="1、用户界面事件"></a>1、用户界面事件</h4><ul><li><p>load：会在整个页面（包括 所有外部资源如图片、JavaScript 文件和 CSS 文件）加载完成后触发</p><ul><li>第一种是 JavaScript 方式：  √</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&quot;load&quot;, (event) =&gt; &#123; </span><br><span class="line"> console.log(&quot;Loaded!&quot;); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><ul><li>第二种指定 load 事件处理程序的方式是向元素添加 onload 属性</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body onload=&quot;console.log(&#x27;Loaded!&#x27;)&quot;&gt; </span><br></pre></td></tr></table></figure></li><li><p>scroll：虽然 scroll 事件发生在 window 上，但实际上反映的是页面中相应元素的变化</p></li><li><p>resize：窗口的尺寸缩放到新高度/新宽度时，这个事件在 window 上触发，因此 可以通过 JavaScript 在 window 上或者为元素添加 onresize 属性来指定事件处理程序</p></li></ul><h4 id="2、鼠标事件："><a href="#2、鼠标事件：" class="headerlink" title="2、鼠标事件："></a>2、鼠标事件：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">click、mouseover、mouseout</span><br></pre></td></tr></table></figure><ul><li><p>由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。 </p><p>比如，click 事件触发的前提是 mousedown 事件触发后，紧接着又在同一个元素上触发了 mouseup 事件。如果 mousedown 和 mouseup 中的任意一个事件被取消，那么 click 事件就不会触发。</p><p>这 4 个事件永远会按照如下顺序触发：</p><p> (1) mousedown  (2) mouseup (3)  click (4) mousedown (5) mouseup (6) click (7) dblclick</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e.pageX、e.pageY                  //返回鼠标相对于浏览器可视窗口的X、Y坐标</span><br><span class="line">e.clientX、e.clientY              //返回鼠标相对于文档页面的X、Y坐标</span><br><span class="line">e.screenX、e.screenY              //返回鼠标相对于电脑屏幕的X、Y坐标</span><br></pre></td></tr></table></figure><ul><li><p>页面坐标</p><p>事件发生时鼠标光标在页 面上的坐标，通过 event 对象的 pageX 和 pageY 可以获取</p><p>在页面没有滚动时，pageX 和 pageY 与 clientX 和 clientY 的值相同</p></li><li><p>客户端坐标</p><p>事件发生时鼠标光标在视口中的坐标，通过 event 对象的 clientX 和clientY 获取</p><p>注意客户端坐标不考虑页面滚动，因此这两个值并不代表鼠标在页面 上的位置</p></li><li><p>屏幕坐标</p><p>可以通过 event 对象的 screenX 和 screenY 属性获取鼠标光标在屏幕上的坐标</p></li></ul><h4 id="3、键盘事件"><a href="#3、键盘事件" class="headerlink" title="3、键盘事件"></a>3、键盘事件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onkeydown、onkeyup</span><br><span class="line">keyCode  获取按键的编码，判断哪个按键被按下</span><br><span class="line">altKey、ctrlKey、shiftKey  这个三个用来判断alt ctrl 和 shift是否被按下  </span><br></pre></td></tr></table></figure><h4 id="4、触摸事件"><a href="#4、触摸事件" class="headerlink" title="4、触摸事件"></a>4、触摸事件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* touchstart：手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。</span><br><span class="line">* touchmove：手指在屏幕上滑动时连续触发。在这个事件中调用 preventDefault()可以阻止 滚</span><br><span class="line">* touchend：手指从屏幕上移开时触发。 </span><br><span class="line">* touchcancel：系统停止跟踪触摸时触发。文档中并未明确什么情况下停止跟踪</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提供的一些属性：clientX、clientY、screenX、screenY</span><br></pre></td></tr></table></figure><p><strong>用于跟踪触点的3个属性：</strong></p><ol><li><strong>touches</strong>：Touch 对象的数组，表示当前屏幕上的每个触点。touchend 事件触发时 touches 集合中什么也没有，这是因为没有滚动的触点了。此时必须使用 changedTouches 集合</li><li><strong>targetTouches：</strong>Touch 对象的数组，表示特定于事件目标的触点</li><li><strong>changedTouches：</strong>Touch 对象的数组，表示自上次用户动作之后变化的触点</li></ol><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="1、BOM的定义、与DOM的区别"><a href="#1、BOM的定义、与DOM的区别" class="headerlink" title="1、BOM的定义、与DOM的区别"></a>1、BOM的定义、与DOM的区别</h3><ul><li><p>BOM ：浏览器对象模型，它代表浏览器的一个实例，BOM可以使我们通过JS来操作浏览器</p><ul><li><p>BOM的核心对象是 window，它是用于与浏览器窗口进行交互对象</p></li><li><p>window对象包含了DOM：可以console.dir(window)查看window的属性和方法 </p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c42ebb19c64402ebbfa210374122e3a~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210801105424814的副本.png" style="zoom:33%;" /></li><li><p>所以，BOM当然也就包含了DOM</p></li></ul></li></ul><h3 id="2、Navigator"><a href="#2、Navigator" class="headerlink" title="2、Navigator"></a>2、Navigator</h3><ul><li>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 </li></ul><h3 id="3、Location"><a href="#3、Location" class="headerlink" title="3、Location"></a>3、Location</h3><ul><li><p>代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</p><table><thead><tr><th><strong>属性</strong></th><th></th></tr></thead><tbody><tr><td>location.href</td><td>返回完整的URL</td></tr><tr><td>location.host</td><td>返回域名</td></tr><tr><td>location.search</td><td>返回一个URL的查询部分</td></tr><tr><td><strong>方法</strong></td><td></td></tr><tr><td>location.assign()</td><td>用来跳转到其他的页面，作用和直接修改location一样</td></tr><tr><td>location.reload()</td><td>用于重新加载当前页面，作用和刷新按钮一样<br />如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面</td></tr><tr><td>location.replace()</td><td>可以使用一个新的页面替换当前页面，调用完毕也会跳转页面  <br/>    不会生成历史记录，不能使用回退按钮回退</td></tr></tbody></table></li></ul><h3 id="4、History"><a href="#4、History" class="headerlink" title="4、History"></a>4、History</h3><ul><li><p>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录</p><p>由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页</p><p>而且该操作只在当次访问时有效 </p><table><thead><tr><th><strong>属性</strong></th><th></th></tr></thead><tbody><tr><td>history.length</td><td>返回历史列表中的网址数</td></tr><tr><td><strong>方法</strong></td><td></td></tr><tr><td>history.forward()</td><td>加载 history 列表中的前一个 URL</td></tr><tr><td>history.back()</td><td>加载 history 列表中的下一个 URL</td></tr><tr><td>history.go()</td><td>加载 history 列表中的某个具体页面</td></tr></tbody></table></li></ul><h3 id="5、Screen"><a href="#5、Screen" class="headerlink" title="5、Screen"></a>5、Screen</h3><ul><li>代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</li></ul><h3 id="6、Window"><a href="#6、Window" class="headerlink" title="6、Window"></a>6、Window</h3><ul><li><p>整个浏览器的窗口，同时window也是网页中的全局对象</p></li><li><p>在浏览器中，window有着双重的角色，这些BOM对象在浏览器中都是作为window对象的属性保存的</p><ol><li>是JS访问浏览器窗口的接口，又是ES标准规定的Global对象</li><li>这也就是说“在网页定义的任何对象、变量、函数都以window作为其Global对象</li></ol></li></ul><h4 id="1、循环定时器"><a href="#1、循环定时器" class="headerlink" title="1、循环定时器"></a>1、循环定时器</h4><ul><li><h4 id="setInterval-，-返回值："><a href="#setInterval-，-返回值：" class="headerlink" title="setInterval() ， 返回值："></a>setInterval() ， 返回值：</h4></li></ul><ol><li>返回一个Number类型的数据，这个数字用来作为定时器的唯一标识</li><li>每次调用间隔的时间，单位是毫秒</li></ol><ul><li><h4 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval()"></a>clearInterval()</h4><p>需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 </p><p>如果参数不是一个有效的标识，则什么也不做</p></li></ul><h4 id="2、延时调用"><a href="#2、延时调用" class="headerlink" title="2、延时调用"></a>2、延时调用</h4><ul><li><strong>setTimeout</strong>   </li><li>延时调用一个函数不马上执行，隔一段时间以后在执行，而且只会执行一次</li></ul><p> 返回值：</p><ol><li>返回一个Number类型的数据，这个数字用来作为定时器的唯一标识</li><li>每次调用间隔的时间，单位是毫秒</li></ol><ul><li>clearTimeout(timer);  关闭一个延时调用 </li></ul><h4 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h4><p>轮播图</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="1、语法规则"><a href="#1、语法规则" class="headerlink" title="1、语法规则"></a>1、语法规则</h3><ol><li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li><li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</li><li>字符串<strong>必须使用双引号表示</strong>，不能使用单引号。</li><li>对象的键名必须放在双引号里面。</li><li>数组或对象最后一个成员的后面，不能加逗号。</li><li>JSON和JS对象的格式一样，只不过<strong>JSON字符串中的属性名必须加双引号</strong></li></ol><ul><li><h4 id="分类：对象-、数组"><a href="#分类：对象-、数组" class="headerlink" title="分类：对象 {} 、数组 []"></a>分类：对象 {} 、数组 []</h4></li><li><p>转换：</p><p>JSON.parse（）：将一个JS对象转换为JSON字符串</p><p>JSON.stringify（）：将JSON字符串转换为JS对象</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue监听数组和对象</title>
      <link href="/2021/12/13/Vue%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/12/13/Vue%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue监听对象和数组"><a href="#Vue监听对象和数组" class="headerlink" title="Vue监听对象和数组"></a>Vue监听对象和数组</h2><h3 id="1、initData-2件事"><a href="#1、initData-2件事" class="headerlink" title="1、initData  2件事"></a>1、initData  2件事</h3><p>initData 里面的 observe劫持 是响应式数据核心：</p><ol><li><p>对定义 <code>data</code> 函数返回数据的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上</p></li><li><p>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式</p><p>对于<strong>数组</strong>会调用 <code>observeArray</code> 方法：遍历数组再次调用 <code>observe</code> 方法</p><p>对<strong>纯对象</strong>调用 <code>walk</code> 方法：遍历对象的 key 调用 <code>defineReactive</code> 方法</p></li></ol><h3 id="2、这样的劫持方式对对象有什么影响？"><a href="#2、这样的劫持方式对对象有什么影响？" class="headerlink" title="2、这样的劫持方式对对象有什么影响？"></a>2、这样的劫持方式对对象有什么影响？</h3><p>对象新增或者删除的属性无法被 set 监听到 只有对象本身存在的属性修改才会被劫持，因为：</p><ul><li><p>必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。否则就不是响应式的；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>   <span class="comment">// `vm.a` 是响应式的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.b = <span class="number">2</span>   <span class="comment">// `vm.b` 是非响应式的     数据发生了变化，但不会响应在视图上</span></span><br></pre></td></tr></table></figure></li><li><p>解决：<code>Vue.set(object, propertyName, value)</code> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.set(vm.someObject, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.someObject,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、这样的劫持方式对数组有什么影响？"><a href="#3、这样的劫持方式对数组有什么影响？" class="headerlink" title="3、这样的劫持方式对数组有什么影响？"></a>3、这样的劫持方式对数组有什么影响？</h3><h4 id="1、影响：Vue-不能检测以下变动的数组："><a href="#1、影响：Vue-不能检测以下变动的数组：" class="headerlink" title="1、影响：Vue 不能检测以下变动的数组："></a>1、影响：<code>Vue</code> 不能检测以下变动的数组：</h4><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure><h4 id="2、原因："><a href="#2、原因：" class="headerlink" title="2、原因："></a>2、原因：</h4><ol><li><code>Object.defineProperty</code>对数组检测是有缺陷的，不能检测到数组长度的变化，准确的说是<strong>通过改变length</strong>而增加的长度不能监测到</li><li>性能代价和获得的用户体验收益不成正比<ol><li>如果一个数组里面有上千上万个元素 每一个元素下标都添加 get 和 set 方法 。当给数组某一项赋值的时候，触发了setter的时候，数据更新又会调用一遍getter函数，如果数组长度很大也会造成性能问题</li><li>如果你知道数组的长度，理论上是可以预先给所有的索引设置getter/setter的，很多场景下我们是不知道的</li></ol></li></ol><h4 id="3、解决Array变化监听"><a href="#3、解决Array变化监听" class="headerlink" title="3、解决Array变化监听"></a>3、解决Array变化监听</h4><p><strong>思路：</strong>我们知道，改变数组的方法有很多，比如说<code>push</code>方法吧，如果我们能拦截到原型上的<code>push</code>方法，是不是就可以做一些事情呢？</p><p>实现过程：</p><ol><li>先获取原生 <code>Array</code> 的原型方法</li><li>对 <code>Array</code> 的原型方法做一些拦截操作：使用<code>Object.defineProperty</code> 的writable配合value，进行重写覆盖</li><li>把需要被拦截的 <code>Array</code> 类型的数据原型指向改造后原型</li></ol><h4 id="4、源码分析-数组变异实现"><a href="#4、源码分析-数组变异实现" class="headerlink" title="4、源码分析 数组变异实现"></a>4、源码分析 数组变异实现</h4><h5 id="1、重写"><a href="#1、重写" class="headerlink" title="1、重写"></a>1、重写</h5><p><code>Vue</code>在<code>array.js</code>中重写了<code>methodsToPatch</code>中七个方法，并将重写后的原型暴露出去：pop push shift unshift splice  sort  reverse</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义属性函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj: <span class="built_in">Object</span>, key: string, val:any,enumerable?:boolean</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">value</span>: val,</span><br><span class="line">    <span class="attr">enumerable</span>: !!enumerable,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.defineProperty的封装</span></span><br><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得原型上的方法</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype </span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue拦截的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上面的方法重写</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;method&#x27;</span>, method); <span class="comment">// 获取方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;args&#x27;</span>, args); <span class="comment">// 获取参数</span></span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">            inserted = args</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">            inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...功能如上述，监听到某个方法执行后，做一些对应的操作</span></span><br><span class="line">      <span class="comment">// 1、将开发者的参数传给原生的方法，保证数组按照开发者的想法被改变</span></span><br><span class="line">        <span class="comment">// 2、视图更新等通过notify更新视图。inserted代表新数据插入，需要对新数据进行obsserve</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br></pre></td></tr></table></figure><h5 id="2、observer"><a href="#2、observer" class="headerlink" title="2、observer"></a>2、observer</h5><ul><li>在进行数据<code>observer</code>绑定的时候，我们先判断是否<code>hasProto</code>，如果存在<code>__proto__</code>，就直接将<code>value</code> 的 <code>__proto__</code>指向重写过后的原型</li><li>如果不能使用 <code>__proto__</code>，就直接循环 <code>arrayMethods</code>把它身上的这些方法直接装到 <code>value</code> 身上好了。毕竟调用某个方法是先去自身查找，当自身找不到这关方法的时候，才去原型上查找</li><li>没有直接修改 <code>Array.prototype</code>，而是直接把 <code>arrayMenthods</code> 赋值给 <code>value</code> 的 <code>__proto__</code> 。因为这样不会污染全局的Array， <code>arrayMenthods</code> 只对 <code>data</code>中的<code>Array</code> 生效</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否有__proto__，因为部分浏览器是没有__proto__</span></span><br><span class="line"><span class="keyword">const</span> hasProto = <span class="string">&#x27;__proto__&#x27;</span> <span class="keyword">in</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 重写后的原型</span></span><br><span class="line"><span class="keyword">import</span> &#123; arrayMethods &#125; <span class="keyword">from</span> <span class="string">&#x27;./array&#x27;</span></span><br><span class="line"><span class="comment">// 方法名</span></span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observeArray</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有__proto__，直接覆盖                </span></span><br><span class="line">    <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有__proto__就把方法加到属性自身上</span></span><br><span class="line">        copyAugment(value, arrayMethods, )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型的赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src</span>) </span>&#123;</span><br><span class="line">    target.__proto__ = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target, src, keys</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[i]</span><br><span class="line">        def(target, key, src[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 响应式更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的虚拟DOM</title>
      <link href="/2021/12/13/React%E7%9A%84%E8%99%9A%E6%8B%9FDOM/"/>
      <url>/2021/12/13/React%E7%9A%84%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<h2 id="5、虚拟DOM"><a href="#5、虚拟DOM" class="headerlink" title="5、虚拟DOM"></a>5、虚拟DOM</h2><h3 id="1、what、how"><a href="#1、what、how" class="headerlink" title="1、what、how"></a>1、what、how</h3><ul><li><p>虚拟DOM是什么？</p><p>虚拟Dom本质上是JS和Dom之间的一个映射缓存，在形态上表现为：一个能够描述Dom结构及其属性信息的JS对象。</p><p>是JS对象 2.是对Dom的描述</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122012139311.png" alt="image-20211122012139311" style="zoom:33%;" /></li><li><h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><p>React将结合JSX的描述，构建出虚拟的Dom树，然后通过ReactDom.render()将虚拟DOM映射到真实Dom（触发渲染流水线）</p></li><li><h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>页面的变化会先作用于虚拟Dom，虚拟Dom将在JS层借助算法先对比出具体有哪些真实Dom需要做改变，然后再将这些改变作用于真实Dom</p></li></ul><h3 id="2、why"><a href="#2、why" class="headerlink" title="2、why"></a>2、why</h3><p>为什么需要虚拟Dom，虚拟Dom是否伴随着更好的性能？虚拟Dom的优势何在？</p><p>虚拟Dom在历史开发场合的位置：</p><ol><li><p>人肉可见的Dom时期：原生JS支配下的“展示”属性远远强于其“交互”的属性</p><p>这就导致了JS的定位只能是“辅助”，在很长时间里，开发者花费很多时间实现静态的Dom，待结束后再补充少量的JS，简单的业务需求不需要做过多的Dom操作</p></li><li><p>jquery时期：大量Dom操作需求带来的前端开发量激增</p><p>简单的交互效果已无法满足用户体验，与之而来的是大量Dom操作需求带来的前端开发量激增。原生JS提供的API不好使，jquery解决了这个问题，将DomAPI封装成了简单优雅的形式，同时做掉了浏览器的兼容工作，并且提供了链式API调用、插件扩展等一系列能力用于进一步解决生产力。</p><ul><li>jquery并不能从根本上解决Dom操作量过大情况下前端一侧的压力；</li></ul></li><li><p>模板引擎方案，它更倾向于点对点解决繁琐DOM操作的问题，它在能力、定位上既不能够、也不打算替换掉jquery，两者和谐共存的。因此，并不存在模板引擎时期，只有模板引擎方案</p><ol><li>读取HTML模板并解析它，分离出其中的JS信息；</li><li>将解析出的内容拼接成字符串，动态生成JS代码</li><li>运行动态生成的JS代码，吐出“目标HTML”</li><li>将目标HTML赋值给innerHtml，触发渲染流水线，完成真实DOM渲染</li></ol><ul><li>这种方案只需要关注：数据和数据变化本身，Dom层面的改变会帮我们做；</li><li>可惜的是：它实际应用场局限在，实现高效的字符串拼接这个点上而不能去做太复杂的事情。对真实Dom的修改过于大刀阔斧，也没有缓冲这些概念，存在糟糕的性能</li><li>他是虚拟DOM思想推广之前的一种方案。</li></ul></li><li><p>数据驱动视图：操作假DOM</p><p>传统时期、虚拟DOM时期的：</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122012152399.png" alt="image-20211122012152399" style="zoom: 20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122012205531.png" alt="image-20211122012205531" style="zoom:20%;" /></p><p>这里并不是一定是模板，比如reatc中使用的JSX。</p><ul><li><p>JSX本质不是模板，而是一种使用体验跟模板接近的JS语法糖，区别在于多出了一个虚拟DOm作为中间的缓冲层。缓冲层带来的优点是：当DOM操作频繁时，它会现将前后两次的Dom树记性对比，定位出具体需要更新的部分，生成补丁集，再将补丁打在需要更新的真实Dom上，实现精准更新</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122012306949.png" alt="image-20211122012306949" style="zoom:20%;" /></li></ul></li></ol><h3 id="3、用虚拟Dom是为了更好的性能吗"><a href="#3、用虚拟Dom是为了更好的性能吗" class="headerlink" title="3、用虚拟Dom是为了更好的性能吗"></a>3、用虚拟Dom是为了更好的性能吗</h3><ul><li>虚拟Dom是前端开发者为了追求更好的研发体验、研发效率而创造出来的高阶产物；</li><li>它也不是React的卖点。</li><li>性能问题是比较复杂的，在量化的时候要结合各阶段、各种要素来分情况讨论。</li></ul><h4 id="1、对比渲染步骤对比："><a href="#1、对比渲染步骤对比：" class="headerlink" title="1、对比渲染步骤对比："></a>1、对比渲染步骤对比：</h4><ol><li>本质是字符换的拼接，对性能的消耗是有限的；</li><li>而虚拟DOm的构建、diff算法过程比较复杂，不可避免的涉及递归、遍历耗时操作；</li><li>这一步，都是更新的行为，因此模板渲染是全量更新、虚拟~是差量更新。</li></ol><ul><li>但是，当数据内容变化很大，二者差量计算相近，而虚拟~会有更多的性能消耗。</li><li>所以虚拟Dom的劣势主要在于<strong>JS计算耗时</strong>，而Dom操作的能耗、JS计算的能耗不再一个量级。少量的Dom操作就能抵大量的JS计算。</li><li>在实际场景中，setState修改少量的数据。</li></ul><h4 id="2、虚拟Dom的价值不在于性能，而在于别处"><a href="#2、虚拟Dom的价值不在于性能，而在于别处" class="headerlink" title="2、虚拟Dom的价值不在于性能，而在于别处"></a>2、虚拟Dom的价值不在于性能，而在于别处</h4><p>它解决了什么问题呢？</p><ol><li><p>研发效率、研发体验的追求；</p><p>它的出现为数据驱动视图这一思想提供了落地的载体，对前端能够基于函数式的编程方式实现高效的声明式编程；</p></li><li><p>跨平台的问题</p><p>虚拟~是对真实内容的一种抽象，如果没有这一层抽象，那么视图层会和渲染平台紧密耦合在一起，为了描述同样的视图内容，需要在web端和native端写完全不同的两套、代码；</p><p>同一套虚拟Dom可以对接多套渲染平台，多端运行，这同样是提高开发效率的一种体现</p></li><li><p>性能方面的：批量更新</p><p>在通用虚拟Dom库里是由batch函数处理的,缓存每次生成的补丁集，再将最终的补丁集进行渲染到真实Dom</p></li></ol><h3 id="4、15栈调和–diff"><a href="#4、15栈调和–diff" class="headerlink" title="4、15栈调和–diff"></a>4、15栈调和–diff</h3><ul><li><p>调和：也叫协调。Virtual Dom是一种编程概念，在这个概念里，UI以一种理想化的或者说<strong>“虚拟的”</strong>表现形式存在于内存中，并通过如ReactDom等类库使之与<strong>真实的Dom</strong>同步，这一过程叫做<strong>“调和”</strong>。因此，调和也是把虚拟dom映射为真实Dom的过程。</p></li><li><p>React15的栈调和、React16的Fiber调和</p></li><li><p><strong>diff是找不同的过程，二者不是一个概念。</strong>它是调和过程中的一环。</p></li><li><p>React将源码划分为了3部分：</p><p>core：</p><p>render：</p><p>reconciler：（调和器），这一路径中调和器所做的工作，包括组件的挂载、卸载、更新（涉及diff）过程等</p></li><li><p>diff是调和过程中重要的一环，因此很多人也将调和过程默认为diff过程</p></li></ul><h4 id="1、diff策略的设计思想"><a href="#1、diff策略的设计思想" class="headerlink" title="1、diff策略的设计思想"></a>1、diff策略的设计思想</h4><p>要想找出两个树结构之间的不同：</p><ul><li><strong>传统的方法</strong>是通过循环递归进行树节点的一一对比。O(N^3)</li><li>为了将复杂度降低至o(N)，React确定了两个大前提：<ol><li>若组件属于同一类型，他们将拥有相同的Dom树形结构</li><li>处于同一层级的一组子节点，可用通过设置key作为唯一标识，从而维护各个节点在不同渲染过程中的稳定性</li><li>React实践的规律：Dom节点之间的跨层级操作并不多，同层级操作是主流</li></ol></li></ul><h4 id="2、Diff逻辑拆分解读"><a href="#2、Diff逻辑拆分解读" class="headerlink" title="2、Diff逻辑拆分解读"></a>2、Diff逻辑拆分解读</h4><ol><li><p>Diff算法性能突破的关键点在于“分层对比”</p><p>只需要完成从上到下的一次遍历，就可以完成对比，降低复杂度的重要量级对比</p><p>虽然栈调和将传统的树对比算法优化为了分层对比，但整个算法仍然是以递归的形式运转，分层递归也是递归，如果真的发生了跨层级操作，这种非主流操作，React并不能判断行为，要销毁+重建，因此react官方也要求开发者不要做跨层级的操作，尽量保持层级的稳定性。</p></li><li><p>类型一致的节点才有继续diff的必要性</p><p>一刀切。抓主要矛盾，只有确认类型相同，才会在更深层次做对比，减少diff过程中的冗余操作</p></li><li><p>key属性的设置，可以帮我们尽可能重用同一层级的节点</p><p>key是帮助react识别哪些内容被更改、添加或删除的。key需要写在用数组渲染出来的元素内部，并需要给其一个稳定的值。稳定很重要，因为如果key值发生了改变，React会触发UI重渲染</p></li></ol><h3 id="5、batch-批处理机制-—-setState"><a href="#5、batch-批处理机制-—-setState" class="headerlink" title="5、batch 批处理机制 — setState"></a>5、batch 批处理机制 — setState</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;increment setState前的count&#x27;</span>, <span class="built_in">this</span>.state.count); <span class="comment">// 0</span></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;increment setState后的count&#x27;</span>, <span class="built_in">this</span>.state.count); <span class="comment">//0 </span></span><br><span class="line">&#125;</span><br><span class="line">triple = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;triple setState前的count&#x27;</span>, <span class="built_in">this</span>.state.count); <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;triple setState后的count&#x27;</span>, <span class="built_in">this</span>.state.count);<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduce = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reduce setState前的count&#x27;</span>, <span class="built_in">this</span>.state.count);<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reduce setState后的count&#x27;</span>, <span class="built_in">this</span>.state.count); <span class="comment">//1</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.increment&#125;</span>&gt;</span>点我增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.triple&#125;</span>&gt;</span>点我增加3倍<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.reduce&#125;</span>&gt;</span>点我减少<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、setState异步的动机和原理"><a href="#1、setState异步的动机和原理" class="headerlink" title="1、setState异步的动机和原理"></a>1、setState异步的动机和原理</h4><ul><li>state到底是哪个环节发生变化的呢？到底同步还是异步的呢？</li></ul><ol><li><p>一般的更新流程，render本身涉及dom操作，带来性能开销</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122133334696.png" alt="image-20211122133334696" style="zoom:25%;" /></li><li><p>假如每次setState都触发一次完整的更新流程，视图可能没刷新几次就卡死了</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122133348906.png" alt="image-20211122133348906" style="zoom:25%;" /></li></ol><p><strong>所以setState异步的动机就来源于 避免频繁的renrender</strong>：</p><ul><li>它的实现机制就类似于Vue中的nextTick和浏览器的EventLoop。每来一个setState。就把它塞入一个队列里<strong>攒起来</strong>，<strong>等时机成熟</strong>，再将攒起来的state结果做合并。最后只针对最新的State值走一次更新流程</li></ul><p>因此，即使100次，也之后增加入队次数，并不会带来频繁的renderer。当100次调用完毕之后，也只是100次任务队列的内容发生了变化，而count本身并不会立刻改变</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">test =<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;循环100次 setState前的count：&#x27;</span>, <span class="built_in">this</span>.state.count);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="built_in">this</span>.setState.count+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;循环100次 setState后的count：&#x27;</span>, <span class="built_in">this</span>.state.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122133403091.png" alt="image-20211122133403091" style="zoom:25%;" /><h4 id="2、setState工作流-—-批量更新"><a href="#2、setState工作流-—-批量更新" class="headerlink" title="2、setState工作流 — 批量更新"></a>2、setState工作流 — 批量更新</h4><p>在setTimeout的保护下，它似乎有了同步的现象。为什么会这样呢？</p><p>并不是因为setTimeout改变了setState，<strong>而是setTimeout帮助setState逃脱了React对它的管控</strong>，只要是在React管控下的setState，一定是异步的。</p><p>源码分析（围绕15展开，关于16Fiber带来的改变后续再讲解）:读源码应该带着问题去读，主流程</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35dce2754bb844808bf65fcc12cd1b24~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 25%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122134505874.png" alt="image-20211122134505874" style="zoom: 25%;" /><h5 id="1、入口函数setState："><a href="#1、入口函数setState：" class="headerlink" title="1、入口函数setState："></a>1、入口函数setState：</h5><p>充当分发的角色，根据入参的不同，将其分发到不同的函数中去。</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122134838045.png" alt="image-20211122134838045" style="zoom:25%;" /><ol><li>假如传入的是对象：<strong>enqueueSetState做了两件事：</strong><ol><li>将新的state放入组件的状态队列里</li><li>用enqueueUpdate处理将要更新的实例对象</li></ol></li></ol><ul><li><p>获取组件实例：instance；</p></li><li><p>判断是否存在**_pendingStateQueue**</p><p>有—&gt; 将传入的partialState存储push进去，没有创建空数组，push进去;</p></li><li><p>如果存在callback就调用<strong>enqueueCallback</strong>将其存入一个**_pendingCallbacks**队列中存起来</p></li><li><p>调用<strong>enqueueUpdate</strong>，并传入当前组件实例；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enqueueSetState: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, partialState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据this拿到对应的组件实例</span></span><br><span class="line">  <span class="keyword">var</span> internalInstance = getInternalInstanceReadyForUpdate(</span><br><span class="line">    publicInstance,</span><br><span class="line">    <span class="string">&#x27;setState&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// queue 对应一个组件实例的 state 数组</span></span><br><span class="line">  <span class="keyword">var</span> queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);</span><br><span class="line">  queue.push(partialState); <span class="comment">// 将 partialState 放入待更新 state 队列</span></span><br><span class="line">  <span class="comment">// 处理当前的组件实例</span></span><br><span class="line">  enqueueUpdate(internalInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、enqueueUpdate的具体实现：直接决定了是等待还是直接走更新流程"><a href="#2、enqueueUpdate的具体实现：直接决定了是等待还是直接走更新流程" class="headerlink" title="2、enqueueUpdate的具体实现：直接决定了是等待还是直接走更新流程"></a>2、enqueueUpdate的具体实现：<strong>直接决定了是等待还是直接走更新流程</strong></h5><ul><li><p>调用<strong>ensureInjected</strong>，对batchingStrategy进行赋值，</p></li><li><p>判断<strong>batchingStrategy.isBatchingUpdates</strong>，【注意】：开启事务前会将它设置为了true，事务结束会将它设为false</p><p>为true —&gt; 将当前组件实例添加到<strong>dirtyComponents</strong>数组中</p><p>为false —-&gt; 执行<strong>batchingStrategy</strong>的<strong>batchedUpdates</strong>方法，【注意】：事务开启的时候也会调用这个方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected() </span><br><span class="line">  <span class="comment">// isBatchingUpdates 标识着当前是否处于批量创建/更新组件过程</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    <span class="comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span></span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要批量更新，则先把组件塞入 dirtyComponents 队列</span></span><br><span class="line">  dirtyComponents.push(component)</span><br><span class="line">  <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3、batchingStrategy是什么-—锁管理器"><a href="#3、batchingStrategy是什么-—锁管理器" class="headerlink" title="3、batchingStrategy是什么 —锁管理器"></a>3、batchingStrategy是什么 —锁管理器</h5><ul><li>从上面的流程可以看出： <code>batchingStrategy</code>该对象的<code>isBatchingUpdates</code>属性直接决定了是马上要走更新流程，还是应该进入队列等待；</li><li>所以大概可以得知<code>batchingStrategy</code>用于管控批量更新的对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0. transition是ReactDefaultBatchingStrategyTransaction的实例，它代表了其中一类事务的执行</span></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  <span class="comment">// 1. 初始值为 false 表示当前并未进行任何批量更新操作：全局唯一的锁标识</span></span><br><span class="line">  <span class="attr">isBatchingUpdates</span>: <span class="literal">false</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 发起更新动作的方法batchedUpdates：</span></span><br><span class="line">      先把锁锁上，表明现在正处于批量更新过程中，此期间任何批量更新都只能暂时进入dirtyComponents排队等候下一次批量更新，而不能随意插队，这是一种任务锁的思想</span><br><span class="line">  <span class="attr">batchedUpdates</span>: <span class="function"><span class="keyword">function</span> (<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.1 第一次调用时，alreadyBatchingUpdates设置为false,就会执行perform</span></span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//2.2 perform启动事务，同时将 callback 放进事务里执行</span></span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    进入事务transation，执行method方法，开启了组件的首次装载</span><br><span class="line"><span class="comment">// 3. 当组件装载完毕会调用componentDidMount(注意，此时还是在执行method方法，事务还没结束，事务只有在执行完method后执行一系列close才会结束)</span></span><br></pre></td></tr></table></figure><h5 id="4、transaction-perform-—-Transaction（事务）机制"><a href="#4、transaction-perform-—-Transaction（事务）机制" class="headerlink" title="4、transaction.perform — Transaction（事务）机制"></a>4、transaction.perform — Transaction（事务）机制</h5><ul><li><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><ul><li>Transaction 是创建一个黑盒，该黑盒能够封装任何的方法，在React源码表现为一个核心类；</li><li>一个 Transaction 就是将需要执行的 method 使用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，再通过 Transaction 提供的 perform 方法执行</li><li>在React中就是调用perform方法进入一个事务，该方法中会传入一个method参数。执行perform时：<ul><li>先执行所有 wrapper 中的 initialize 方法，例如一些初始化操作</li><li>然后执行传入的method — perform真正</li><li>perform 完成之后（即 method 执行后）再执行所有的 close 方法，例如执行批量更新或者将isBatchingUpdates变回false等等</li></ul></li></ul></li></ul><h5 id="5、batchingStrategy-批量更新策略"><a href="#5、batchingStrategy-批量更新策略" class="headerlink" title="5、batchingStrategy 批量更新策略"></a>5、batchingStrategy 批量更新策略</h5><ul><li><p>ReactDefaultBatchingStrategy 这个对象，其实就是一个批量更新策略事务，它的 wrapper 有两个：<code>FLUSH_BATCHED_UPDATES</code> 和 <code>RESET_BATCHED_UPDATES</code></p></li><li><p>在<strong>perform</strong>中的method执行完毕后，会按照数组的顺序**[FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]<strong>依次调用其</strong>close**方法</p><ul><li><strong>FLUSH_BATCHED_UPDATES</strong>执行批量更新操作，会循环所有dirtyComponents，调用updateComponent执行所有的生命周期方法，实现组件的更新</li><li><strong>RESET_BATCHED_UPDATES</strong>将isBatchingUpdates变回false，即意味着事务结束</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  <span class="attr">initialize</span>: emptyFunction,</span><br><span class="line">  <span class="comment">//2 将isBatchingUpdates设置为false，代表本次事务结束。后续再调用setState就不会push到dirtyComponents里面</span></span><br><span class="line">  <span class="attr">close</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flushBatchedUpdates 将所有的临时 state 合并并计算出最新的 props 及 state</span></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  <span class="attr">initialize</span>: emptyFunction,</span><br><span class="line">  <span class="comment">// 1 批量更新操作</span></span><br><span class="line">  <span class="attr">close</span>: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.reinitializeTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、setState为何会表现为同步？"><a href="#3、setState为何会表现为同步？" class="headerlink" title="3、setState为何会表现为同步？"></a>3、setState为何会表现为同步？</h4><p> <code>batchedUpdates</code> 这个方法不仅仅会在setState之后才被调用，在首次渲染组件时执行内部会调用一次：</p><h5 id="1、componentDidMount："><a href="#1、componentDidMount：" class="headerlink" title="1、componentDidMount："></a>1、componentDidMount：</h5><ol><li>实例化组件；</li><li>内部调用了一次 <code>batchedUpdates</code> 方法（将 isBatchingUpdates 设为 true）</li><li>在组件的渲染过程中，会按照顺序调用各个生命周期(钩子)函数。开发者可能在生命周期函数里面调用 setState，因此需要开启batch来确保所有的更新都能够进入 dirtyComponents 里去，进而确保初始初始渲染流程中，所有的state都是生效的</li></ol><h5 id="componentWillUpdate、componentDidUpdate"><a href="#componentWillUpdate、componentDidUpdate" class="headerlink" title="componentWillUpdate、componentDidUpdate"></a>componentWillUpdate、componentDidUpdate</h5><ul><li>这两个生命周期中不能调用<code>setState</code>。在它们里面调用<code>setState</code>会造成死循环，导致程序崩溃</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line"><span class="attr">_renderNewRootComponent</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> nextElement, container, shouldReuseMarkup, context </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化组件</span></span><br><span class="line">  <span class="keyword">var</span> componentInstance = instantiateReactComponent(nextElement);</span><br><span class="line">  <span class="comment">// 调用 batchedUpdates 方法</span></span><br><span class="line">  ReactUpdates.batchedUpdates(</span><br><span class="line">    batchedMountComponentIntoNode,</span><br><span class="line">    componentInstance,</span><br><span class="line">    container,</span><br><span class="line">    shouldReuseMarkup,</span><br><span class="line">    context</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、事件："><a href="#2、事件：" class="headerlink" title="2、事件："></a>2、事件：</h5><p>当我们在React绑定了事件后，事件中也有可能触发setState</p><ul><li>为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新</li><li><code>react</code>仍然处于他的更新机制中，这时<code>isBranchUpdate</code>为true；</li><li>这时无论调用多少次<code>setState</code>，都不会执行更新，而是将要更新的<code>state</code>存入<code>_pendingStateQueue</code>，将要更新的组件存入<code>dirtyComponent</code></li><li>事物结束后，会设置为false</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactEventListener.js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dispatchEvent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">topLevelType, nativeEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理事件：batchedUpdates会将 isBatchingUpdates设为true</span></span><br><span class="line">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【总结】：<code>isBatchingUpdates</code> 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 改为 true，这时我们所做的 setState 操作自然不会立即生效 </p><h4 id="4、回到之前的例子："><a href="#4、回到之前的例子：" class="headerlink" title="4、回到之前的例子："></a>4、回到之前的例子：</h4><ul><li>isBatchingUpdates对setTimeout内部的执行逻辑完全没有约束力，因为isBatchingUpdates是在同步代码变化，setTimeout是异步执行的，当this.setState真正运行时，isBatchingUpdates已经被重置为false了。</li><li>这就使得 setTimeout 里面的 setState 具备了立刻发起同步更新的能力。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// isBatchingUpdates = true; 先锁上</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;increment setState前的count&#x27;</span>, <span class="built_in">this</span>.state.count); <span class="comment">// 0</span></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;increment setState后的count&#x27;</span>, <span class="built_in">this</span>.state.count); <span class="comment">//0 </span></span><br><span class="line">   <span class="comment">// isBatchingUpdates = false;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduce = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// isBatchingUpdates = true;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reduce setState前的count&#x27;</span>, <span class="built_in">this</span>.state.count);<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reduce setState后的count&#x27;</span>, <span class="built_in">this</span>.state.count); <span class="comment">//1</span></span><br><span class="line">     <span class="comment">// isBatchingUpdates = false;</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p>setState 同步异步的表现会因调用场景的不同而不同：</p><ul><li>在 React 钩子函数及合成事件中，它表现为异步；</li><li>而在 setTimeout/setInterval 函数，DOM 原生事件中，它都表现为同步。这是由 React 事务机制和批量更新机制的工作方式来决定的</li></ul><p>【备注】：16以后，整个React核心算法被重写，setState也不可避免地被“Fiber”化，之后会展开讲</p><h4 id="6、整体执行流程"><a href="#6、整体执行流程" class="headerlink" title="6、整体执行流程"></a>6、整体执行流程</h4><ul><li>1.将setState传入的<code>partialState</code>参数存储在当前组件实例的state暂存队列中。</li><li>2.判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。</li><li>3.如果未处于批量更新状态，将批量更新状态标识设置为true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。</li><li>4.调用事务的<code>waper</code>方法，遍历待更新组件队列依次执行更新。</li><li>5.执行生命周期<code>componentWillReceiveProps</code>。</li><li>6.将组件的state暂存队列中的<code>state</code>进行合并，获得最终要更新的state对象，并将队列置为空。</li><li>7.执行生命周期<code>componentShouldUpdate</code>，根据返回值判断是否要继续更新。</li><li>8.执行生命周期<code>componentWillUpdate</code>。</li><li>9.执行真正的更新，<code>render</code>。</li><li>10.执行生命周期<code>componentDidUpdate</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的双向绑定</title>
      <link href="/2021/12/13/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/2021/12/13/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>总结：Vue 内部通过 <code>Object.defineProperty</code>方法属性拦截的方式，把 <code>data</code> 对象里每个数据的读写转化成 <code>getter</code>/<code>setter</code>，当数据变化时通知视图更新</p><img src="https://user-gold-cdn.xitu.io/2019/8/1/16c4a3ce0cc709da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="4.png" style="zoom:50%;" /><h2 id="一、什么是-MVVM-数据双向绑定"><a href="#一、什么是-MVVM-数据双向绑定" class="headerlink" title="一、什么是 MVVM 数据双向绑定"></a>一、什么是 MVVM 数据双向绑定</h2><p><code>MVVM</code> 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据</p><ul><li>输入框内容变化时，<code>Data</code> 中的数据同步变化。即 <code>View</code> =&gt; <code>Data</code> 的变化。  <strong>事件监听</strong></li><li><code>Data</code> 中的数据变化时，文本节点的内容同步变化。即 <code>Data</code> =&gt; <code>View</code> 的变化</li></ul><p>我们会通过实现以下 4 个步骤，来实现数据的双向绑定：</p><img src="https://user-gold-cdn.xitu.io/2019/8/1/16c4a3ce0bcb0d91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="3.png" style="zoom:50%;" /><p>1、实现一个监听器 <code>Observer</code> ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；</p><p>2、实现一个订阅器 <code>Dep</code>，用来收集订阅者，对监听器 <code>Observer</code> 和 订阅者 <code>Watcher</code> 进行统一管理；</p><p>3、实现一个订阅者 <code>Watcher</code>，可以收到属性的变化通知并执行相应的方法，从而更新视图；</p><p>4、实现一个解析器 <code>Compile</code>，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。</p><h2 id="二、监听器-Observer-实现"><a href="#二、监听器-Observer-实现" class="headerlink" title="二、监听器 Observer 实现"></a>二、监听器 Observer 实现</h2><p>监听器 <code>Observer</code> 的实现，主要是指让数据对象变得“可观测”，即每次数据读或写时，我们能感知到数据被读取了或数据被改写了。<code>Vue 2.0</code> 源码中用到 <code>Object.defineProperty()</code> 来劫持各个数据属性的 <code>setter / getter</code></p><h3 id="2-1、Object-defineProperty-语法"><a href="#2-1、Object-defineProperty-语法" class="headerlink" title="2.1、Object.defineProperty() 语法"></a>2.1、Object.defineProperty() 语法</h3><p><strong>（1）参数</strong></p><ul><li><code>obj</code>：要在其上定义属性的对象</li><li><code>prop</code>：要定义或修改的属性的名称</li><li><code>descriptor</code>：将被定义或修改的属性描述符</li></ul><p>**（2）返回值 ** 被传递给函数的对象</p><p><strong>（3）属性描述符</strong></p><p><code>Object.defineProperty()</code> 为对象定义属性，分 数据描述符 和 存取描述符 ，两种形式不能混用</p><p><strong>数据描述符和存取描述符均具有以下可选键值：</strong></p><ul><li><p><code>configurable</code>：当且仅当该属性的 <code>configurable</code> 为 <code>true</code> 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。<strong>默认为 false</strong></p></li><li><p><code>enumerable</code>：当且仅当该属性的 <code>enumerable</code> 为 <code>true</code> 时，该属性才能够出现在对象的枚举属性中。<strong>默认为 false</strong></p></li></ul><p><strong>数据描述符具有以下可选键值</strong>：</p><ul><li><p><code>value</code>：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<strong>默认为 undefined</strong></p></li><li><p><code>writable</code>：当且仅当该属性的 <code>writable</code> 为 <code>true</code> 时，<code>value</code>才能被赋值运算符改变。<strong>默认为 false</strong></p></li></ul><p><strong>存取描述符具有以下可选键值</strong>：</p><ul><li><p><code>get</code>：一个给属性提供 <code>getter</code> 的方法，如果没有 <code>getter</code> 则为 <code>undefined</code>。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入<code>this</code>对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。默认为 <code>undefined</code>。</p></li><li><p><code>set</code>：一个给属性提供 <code>setter</code> 的方法，如果没有 <code>setter</code> 则为 <code>undefined</code>。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 <code>undefined</code>。</p></li></ul><h3 id="2-2、监听器-Observer-实现"><a href="#2-2、监听器-Observer-实现" class="headerlink" title="2.2、监听器 Observer 实现"></a>2.2、监听器 Observer 实现</h3><ul><li><h4 id="梳理："><a href="#梳理：" class="headerlink" title="梳理："></a>梳理：</h4><p>完成了数据的’可观测’，即我们知道了数据在什么时候被读或写了，那么，我们就可以在数据被读或写的时候通知那些依赖该数据的视图更新了</p></li><li><p>**遍历+Object.defineProperty() **：让数据对象的所有属性都变得可观测：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环遍历数据对象的每个属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    keys.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将对象的属性用 Object.defineProperty() 进行设置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被读取了...`</span>);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被修改了...`</span>);</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、订阅器-Dep-实现"><a href="#三、订阅器-Dep-实现" class="headerlink" title="三、订阅器 Dep 实现"></a>三、订阅器 Dep 实现</h2><h3 id="1、梳理："><a href="#1、梳理：" class="headerlink" title="1、梳理："></a>1、梳理：</h3><ol><li><p>创建一个依赖收集容器，也就是消息订阅器 <code>Dep</code>，用来容纳所有的“订阅者”</p></li><li><p>当数据变化的时候后执行对应订阅者的更新函数</p></li></ol><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><h4 id="Dep的构成"><a href="#Dep的构成" class="headerlink" title="Dep的构成"></a>Dep的构成</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    <span class="attr">addSub</span>: <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">notify</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li><h4 id="Dep添加的时机"><a href="#Dep添加的时机" class="headerlink" title="Dep添加的时机"></a>Dep添加的时机</h4></li></ul><p>再将 <strong><code>defineReactive</code> 函数进行改造一下，向其植入订阅器</strong>：</p><ul><li><p>设计了一个订阅器 <code>Dep</code> 类，该类里面定义了一些属性和方法</p></li><li><p>特别注意的是它有一个静态属性 <code>Dep.target</code>，这是一个全局唯一 的<code>Watcher</code>，因为在同一时间只能有一个全局的 <code>Watcher</code> 被计算，另外它的自身属性 <code>subs</code> 也是 <code>Watcher</code> 的数组</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">defineReactive: <span class="function"><span class="keyword">function</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">getter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">dep.addSub(Dep.target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">setter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">val = newVal;</span><br><span class="line">dep.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、订阅者-Watcher-实现"><a href="#四、订阅者-Watcher-实现" class="headerlink" title="四、订阅者 Watcher 实现"></a>四、订阅者 Watcher 实现</h2><ol><li><p>订阅者 <code>Watcher</code> 是一个 类，在它的构造函数中，定义了一些属性：</p><ul><li><strong>vm：</strong>一个 Vue 的实例对象；</li><li><strong>exp：</strong>是 <code>node</code> 节点的 <code>v-model</code> 等指令的属性值 或者插值符号中的属性。如 <code>v-model=&quot;name&quot;</code>，<code>exp</code> 就是<code>name</code>;</li><li><strong>cb：</strong>是 <code>Watcher</code> 绑定的更新函数;</li></ul></li><li><p>运行过程：3个过程</p><ol><li><p>当我们去实例化一个渲染 <code>watcher</code> 的时候，首先进入 <code>watcher</code> 的构造函数逻辑，就会执行它的 <code>this.get()</code> 方法，进入 <code>get</code> 函数，实际上就是把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dep.target = this;  // 将自己赋值为全局的订阅者</span><br></pre></td></tr></table></figure></li><li><p>触发数据对象的 <code>getter</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let value = this.vm.data[this.exp]  // 强制执行监听器里的get函数</span><br></pre></td></tr></table></figure><p>每个对象值的 <code>getter</code> 都持有一个 <code>dep</code>，在触发 <code>getter</code> 的时候会调用 <code>dep.depend()</code> 方法，也就会执行<code>this.addSub(Dep.target)</code>，即把当前的 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>watchers</code> 中，至此完成了一个依赖收集的过程</p></li><li><p>完成依赖收集后，还需要把 <code>Dep.target</code> 恢复成上一个状态，即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dep.target = null; </span><br></pre></td></tr></table></figure></li></ol></li><li><p>而 <code>update()</code> 函数是用来当数据发生变化时调用 <code>Watcher</code> 自身的更新函数进行更新的操作。先通过 <code>let value = this.vm.data[this.exp];</code> 获取到最新的数据,然后将其与之前 <code>get()</code> 获得的旧数据进行比较，如果不一样，则调用更新函数 <code>cb</code> 进行更新。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, cb</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="built_in">this</span>.exp = exp;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();  <span class="comment">// 将自己添加到订阅器的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    <span class="attr">update</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.run();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">run</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="built_in">this</span>.vm.data[<span class="built_in">this</span>.exp];</span><br><span class="line">        <span class="keyword">var</span> oldVal = <span class="built_in">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        Dep.target = <span class="built_in">this</span>; <span class="comment">// 全局变量 订阅者 赋值</span></span><br><span class="line">        <span class="keyword">var</span> value = <span class="built_in">this</span>.vm.data[<span class="built_in">this</span>.exp]  <span class="comment">// 强制执行监听器里的get函数</span></span><br><span class="line">        Dep.target = <span class="literal">null</span>; <span class="comment">// 全局变量 订阅者 释放</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="五、解析器-Compile-实现"><a href="#五、解析器-Compile-实现" class="headerlink" title="五、解析器 Compile 实现"></a>五、解析器 Compile 实现</h2><h3 id="1、梳理"><a href="#1、梳理" class="headerlink" title="1、梳理"></a>1、梳理</h3><p>将来这个节点的这个数据改变了，你要执行这个函数</p><ol><li>解析模板指令，并替换模板数据，初始化视图</li><li>实例化watcher，将模板指令对应的节点绑定对应的更新函数</li></ol><h3 id="2、实现-1"><a href="#2、实现-1" class="headerlink" title="2、实现"></a>2、实现</h3><ul><li><p>下面对 ‘‘ 这种形式的指令处理的关键代码进行分析，感受解析器 <code>Compile</code> 的处理逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compileText: <span class="function"><span class="keyword">function</span>(<span class="params">node, exp</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">var</span> initText = <span class="built_in">this</span>.vm[exp]; <span class="comment">// 获取属性值</span></span><br><span class="line"><span class="built_in">this</span>.updateText(node, initText); <span class="comment">// dom 更新节点文本值</span></span><br><span class="line">    <span class="comment">// 将这个指令初始化为一个订阅者，后续 exp 改变时，就会触发这个更新回调，从而更新视图</span></span><br><span class="line"><span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, exp, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; </span><br><span class="line">self.updateText(node, value);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="六、源码分析"><a href="#六、源码分析" class="headerlink" title="六、源码分析"></a>六、源码分析</h2><p>从 <code>Vue</code> 源码层面分析监听器 <code>Observer</code> 、订阅器 <code>Dep</code> 、订阅者 <code>Watcher</code> 的实现</p><h3 id="6-1、监听器-Observer-实现"><a href="#6-1、监听器-Observer-实现" class="headerlink" title="6.1、监听器 Observer 实现"></a>6.1、监听器 Observer 实现</h3><p>核心就是利用 <code>Object.defineProperty</code> 给数据添加了 <code>getter</code> 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑 。</p><h4 id="（1）initState"><a href="#（1）initState" class="headerlink" title="（1）initState"></a>（1）initState</h4><ul><li><p>在 <code>Vue</code> 的初始化阶段，<code>_init</code> 方法执行的时候，会执行 <code>initState(vm)</code> 方法，它的定义在 <code>src/core/instance/state.js</code> 中，分别对<code>data</code>、<code>prop</code>、<code>computed</code>进行初始化，让其变成响应式</p></li><li><h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4><ul><li>初始化<code>props</code>：对所有<code>props</code>进行遍历，Observe调用<code>defineReactive</code>函数，将每个 prop 属性值变成响应式，然后将其挂载到<code>_props</code>中，然后通过代理，把<code>vm.xxx</code>代理到<code>vm._props.xxx</code>实例中</li><li>初始化<code>data</code>时：与<code>prop</code>相同，对所有<code>data</code>进行遍历，调用<code>defineReactive</code>函数，将每个 data 属性值变成响应式，然后将其挂载到<code>_data</code>中，然后通过代理，把<code>vm.xxx</code>代理到<code>vm._data.xxx</code>中</li><li>初始化<code>computed</code>，首先创建一个观察者对象<code>computed-watcher</code>，然后遍历<code>computed</code>的每一个属性，对每一个属性值调用<code>defineComputed</code>方法，使用<code>Object.defineProperty</code>将其变成响应式的同时，将其代理到组件实例上，即可通过<code>vm.xxx</code>访问到<code>xxx</code>计算属性</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）initData-2件事"><a href="#（2）initData-2件事" class="headerlink" title="（2）initData  2件事"></a>（2）initData  2件事</h4><ol><li>对定义 <code>data</code> 函数返回对象的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上</li><li>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）observe"><a href="#（3）observe" class="headerlink" title="（3）observe"></a><strong>（3）observe</strong></h4><ul><li><strong>功能：</strong>监测数据的变化，它的定义在 <code>src/core/observer/index.js</code> 中：</li><li>做法：给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）Observer"><a href="#（4）Observer" class="headerlink" title="（4）Observer"></a><strong>（4）Observer</strong></h4><ul><li><p>是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新：</p></li><li><p><code>Observer</code> 的构造函数逻辑：</p><ol><li><p>首先实例化 <code>Dep</code> 对象， <code>Dep</code> 对象</p></li><li><p>接下来会对 <code>value</code> 做判断：</p><p>对于<strong>数组</strong>会调用 <code>observeArray</code> 方法：遍历数组再次调用 <code>observe</code> 方法</p><p>对<strong>纯对象</strong>调用 <code>walk</code> 方法：遍历对象的 key 调用 <code>defineReactive</code> 方法</p></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xport <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="attr">value</span>: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: any</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（5）defineReactive"><a href="#（5）defineReactive" class="headerlink" title="（5）defineReactive"></a>（5）defineReactive</h4><ul><li><strong>功能：</strong>定义一个响应式对象，给对象动态添加 <code>getter</code> 和 <code>setter</code>，它的定义在 <code>src/core/observer/index.js</code> 中：</li><li><strong>做法：</strong>最开始初始化 <code>Dep</code> 对象的实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，这样就保证了无论 <code>obj</code> 层级多深，访问或修改 <code>obj</code> 中一个嵌套较深的属性，也能触发 getter 和 setter</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  obj: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: string,</span></span></span><br><span class="line"><span class="params"><span class="function">  val: any,</span></span></span><br><span class="line"><span class="params"><span class="function">  customSetter?: ?<span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  shallow?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2、订阅器-Dep-实现"><a href="#6-2、订阅器-Dep-实现" class="headerlink" title="6.2、订阅器 Dep 实现"></a>6.2、订阅器 Dep 实现</h3><ul><li><p>订阅器<code>Dep</code> 是整个 <code>getter</code> 依赖收集的核心，它的定义在 <code>src/core/observer/dep.js</code> 中：</p></li><li><p>特别注意的是它有一个静态属性 <code>target</code>，这是一个全局唯一 <code>Watcher</code>，这是一个非常巧妙的设计，因为在同一时间只能有一个全局的 <code>Watcher</code> 被计算，</p></li><li><p>另外它的自身属性 <code>subs</code> 也是 <code>Watcher</code> 的数组。<code>Dep</code> 实际上就是对 <code>Watcher</code> 的一种管理，<code>Dep</code> 脱离 <code>Watcher</code> 单独存在是没有意义的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3、订阅者-Watcher-实现"><a href="#6-3、订阅者-Watcher-实现" class="headerlink" title="6.3、订阅者 Watcher 实现"></a>6.3、订阅者 Watcher 实现</h3><ul><li><p>订阅者<code>Watcher</code> 的一些相关实现，它的定义在 <code>src/core/observer/watcher.js</code> 中</p></li><li><h4 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h4><p><code>Watcher</code> 是一个 <code>Class</code>，在它的构造函数中，定义了一些和 <code>Dep</code> 相关的属性 ，其中，<code>this.deps</code> 和 <code>this.newDeps</code> 表示 <code>Watcher</code> 实例持有的 <code>Dep</code> 实例的数组；而 <code>this.depIds</code> 和 <code>this.newDepIds</code> 分别代表 <code>this.deps</code> 和 <code>this.newDeps</code> 的 <code>id</code> Set 。当我们去实例化一个渲染 <code>watcher</code> 的时候</p><ol><li><p>首先进入 <code>watcher</code> 的构造函数逻辑，然后会执行它的 <code>this.get()</code> 方法，进入 <code>get</code> 函数，首先会执行：把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code> 并压栈（为了恢复用）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushTarget(this)</span><br></pre></td></tr></table></figure></li><li><p>触发了数据对象的 <code>getter</code> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value = this.getter.call(vm, vm)</span><br></pre></td></tr></table></figure></li><li><p>每个对象值的 <code>getter</code> 都持有一个 <code>dep</code>，在触发 <code>getter</code> 的时候会调用 <code>dep.depend()</code> 方法，也就会执行 <code>Dep.target.addDep(this)</code>。这个时候 <code>Dep.target</code> 已经被赋值为渲染 <code>watcher</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  const id = dep.id</span><br><span class="line">  if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">    this.newDepIds.add(id)</span><br><span class="line">    this.newDeps.push(dep)</span><br><span class="line">    if (!this.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，那么就会执行 <code>this.subs.push(sub)</code></li><li>所以在 <code>vm._render()</code> 过程中，会触发所有数据的 <code>getter</code>，这样实际上已经完成了一个依赖收集的过程。</li></ul></li><li><p>当我们在组件中对响应的数据做了修改，就会触发 <code>setter</code> 的逻辑，最后调用 <code>watcher</code> 中的 <code>update</code> 方法：对于 <code>Watcher</code> 的不同状态，会执行不同的更新逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="3类watcher："><a href="#3类watcher：" class="headerlink" title="3类watcher："></a>3类watcher：</h4><ol><li><p><code>normal-watcher</code>：在组件钩子函数<code>watch</code>中定义，即监听的属性改变了，都会触发定义好的回调函数</p></li><li><p><code>computed-watcher</code>：在组件钩子函数<code>computed</code>中定义的，每一个<code>computed</code>属性，最后都会生成一个对应的<code>Watcher</code>对象</p><p>特点：当计算属性依赖的数据改变时，才会重新计算，即具备<code>lazy</code>（懒计算）特性</p></li><li><p><code>render-watcher</code>：每一个组件都会有一个<code>render-watcher</code>, 当<code>data/computed</code>中的属性改变的时候，会调用该<code>Watcher</code>来更新组件的视图。</p></li></ol><p><strong>执行顺序：</strong>computed-render ———&gt; normal-watcher ——&gt; render-watcher</p><ul><li>目的：尽可能的保证，在更新组件视图的时候，computed 属性已经是最新值了，如果 render-watcher 排在 computed-render 前面，就会导致页面更新的时候 computed 值为旧数据</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="attr">vm</span>: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: <span class="built_in">Function</span>;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?<span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component,</span></span><br><span class="line"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="built_in">this</span>.user = !!options.user</span><br><span class="line">      <span class="built_in">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="built_in">this</span>.before = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="built_in">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="built_in">this</span>.deps = []</span><br><span class="line">    <span class="built_in">this</span>.newDeps = []</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.expression = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">   。。。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的虚拟DOM</title>
      <link href="/2021/12/13/Vue%E7%9A%84%E8%99%9A%E6%8B%9FDOM/"/>
      <url>/2021/12/13/Vue%E7%9A%84%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><ul><li><h3 id="脉络：从初始化-Vue-到最终渲染的整个过程"><a href="#脉络：从初始化-Vue-到最终渲染的整个过程" class="headerlink" title="脉络：从初始化 Vue 到最终渲染的整个过程"></a>脉络：从初始化 <code>Vue</code> 到最终渲染的整个过程</h3><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e2486c7e0ed7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 67%;" /></li><li><p>什么是<code>Virtual DOM</code></p></li><li><p>为什么需要 <code>Virtual DOM</code></p></li><li><p>以及 <code>Virtual DOM</code>的具体实现</p></li></ul><h2 id="一、真实DOM和其解析流程"><a href="#一、真实DOM和其解析流程" class="headerlink" title="一、真实DOM和其解析流程"></a>一、真实<code>DOM</code>和其解析流程</h2><p>下图为 <code>webkit</code> 渲染引擎工作流程图</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e10922325215?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p> 所有的浏览器渲染引擎工作流程大致分为5步：创建 <code>DOM</code> 树 —&gt; 创建 <code>Style Rules</code> -&gt; 构建 <code>Render</code> 树 —&gt; 布局 <code>Layout</code> -—&gt; 绘制 <code>Painting</code>。</p><ul><li>第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；</li><li>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；</li><li>第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；</li><li>第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；</li><li>第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。</li></ul><p><strong>注意点：</strong></p><p><strong>1、<code>DOM</code> 树的构建是文档加载完成开始的？</strong> </p><p>​    构建 <code>DOM</code> 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 <code>HTML</code> 文档解析完成之后才开始构建 <code>render</code> 树和布局。</p><p><strong>2、<code>Render</code> 树是 <code>DOM</code> 树和 <code>CSS</code> 样式表构建完毕后才开始构建的？</strong> </p><p>​    这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。</p><p><strong>3、<code>CSS</code> 的解析注意点？</strong> </p><p>​    <code>CSS</code> 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。</p><p><strong>4、<code>JS</code> 操作真实 <code>DOM</code> 的代价？</strong>             </p><ul><li>传统的开发模式：原生 <code>JS</code> 操作 <code>DOM</code> 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 <code>DOM</code> 节点，浏览器收到第一个 <code>DOM</code> 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。</li><li>例如，第一次计算完，紧接着下一个 <code>DOM</code> 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 <code>DOM</code> 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 <code>DOM</code> 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验</li></ul><h2 id="二、Virtual-DOM-基础"><a href="#二、Virtual-DOM-基础" class="headerlink" title="二、Virtual-DOM 基础"></a>二、<code>Virtual-DOM</code> 基础</h2><h3 id="2-1、虚拟-DOM-的好处"><a href="#2-1、虚拟-DOM-的好处" class="headerlink" title="2.1、虚拟 DOM 的好处"></a>2.1、虚拟 <code>DOM</code> 的好处</h3><ul><li>为了解决浏览器性能问题而被设计出来的</li><li>若一次操作中有 10 次更新 <code>DOM</code> 的动作，虚拟 <code>DOM</code> 不会立即操作 <code>DOM</code>，而是将这 10 次更新的 <code>diff</code> 内容保存到本地一个 <code>JS</code> 对象中，最终将这个 <code>JS</code> 对象一次性 <code>attch</code> 到 <code>DOM</code> 树上，再进行后续操作，避免大量无谓的计算量</li><li>好处是，页面的更新可以先全部反映在 <code>JS</code> 对象(虚拟 <code>DOM</code> )上，操作内存中的 <code>JS</code> 对象的速度显然要更快，等更新完成后，再将最终的 <code>JS</code> 对象映射成真实的 <code>DOM</code>，交由浏览器去绘制。</li></ul><h3 id="2-2、算法实现"><a href="#2-2、算法实现" class="headerlink" title="2.2、算法实现"></a>2.2、算法实现</h3><h4 id="2-2-1、用-JS-对象模拟-DOM-树"><a href="#2-2-1、用-JS-对象模拟-DOM-树" class="headerlink" title="2.2.1、用 JS 对象模拟 DOM 树"></a>2.2.1、用 <code>JS</code> 对象模拟 <code>DOM</code> 树</h4><h5 id="（1）如何用-JS-对象模拟-DOM-树？"><a href="#（1）如何用-JS-对象模拟-DOM-树？" class="headerlink" title="（1）如何用 JS 对象模拟 DOM 树？"></a><strong>（1）如何用 <code>JS</code> 对象模拟 <code>DOM</code> 树？</strong></h5><ul><li><p><strong>做法：</strong>调用<strong>createElement</strong>函数：内部实例化<strong>Element</strong>类，并在实例化时将参数传入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.tagName = tagName</span><br><span class="line">    <span class="built_in">this</span>.props = props</span><br><span class="line">    <span class="built_in">this</span>.children = children</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(props.key)&#123;  <span class="comment">// dom 元素的 key 值，用作唯一标识符</span></span><br><span class="line">       <span class="built_in">this</span>.key = props.key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            count += child.count</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            children[i] = <span class="string">&#x27;&#x27;</span> + child</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 子元素个数</span></span><br><span class="line">    <span class="built_in">this</span>.count = count</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName, props, children</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createElement;</span><br></pre></td></tr></table></figure></li><li><p>例如：一个真实的 <code>DOM</code> 节点如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;virtual-dom&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Virtual DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure><p>根据 <code>element</code> 对象的设定，则上面的 <code>DOM</code> 结构就可以简单表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">&quot;./element.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ul = el(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="attr">id</span>:<span class="string">&#x27;virtual-dom&#x27;</span>&#125;,[</span><br><span class="line">  el(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">  el(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;list&#x27;</span> &#125;, [</span><br><span class="line">el(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">el(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">el(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  el(<span class="string">&#x27;div&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">]) </span><br></pre></td></tr></table></figure><p>现在 <code>ul</code> 就是我们用 <code>JavaScript</code> 对象表示的 <code>DOM</code> 结构，我们输出查看 <code>ul</code> 对应的数据结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e14fcff074f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><h5 id="（2）渲染用-JS-表示的-DOM-对象"><a href="#（2）渲染用-JS-表示的-DOM-对象" class="headerlink" title="（2）渲染用 JS 表示的 DOM 对象"></a><strong>（2）渲染用 <code>JS</code> 表示的 <code>DOM</code> 对象</strong></h5><p>此时页面上并没有这个结构，如何将 <code>ul</code> 渲染成页面上真实的 <code>DOM</code> 结构？</p><ul><li><p><strong>做法：</strong>调用Element原型上面的render函数，会根据 <code>tagName</code> 构建一个真正的 <code>DOM</code> 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render 将virdual-dom 对象渲染为实际 DOM 元素</span></span><br><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="built_in">this</span>.tagName)</span><br><span class="line">    <span class="keyword">var</span> props = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="keyword">var</span> propValue = props[propName]</span><br><span class="line">        el.setAttribute(propName, propValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> children = <span class="built_in">this</span>.children || []</span><br><span class="line">    children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> childEl = (child <span class="keyword">instanceof</span> Element)</span><br><span class="line">            ? child.render() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">            : <span class="built_in">document</span>.createTextNode(child) <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">        el.appendChild(childEl)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>接上面的例子：将构建好的 <code>DOM</code> 结构添加到页面 <code>body</code> 上面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ulRoot = ul.render();</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ulRoot);</span><br></pre></td></tr></table></figure><p>这样，页面 <code>body</code> 里面就有真正的 <code>DOM</code> 结构，效果如下图所示：</p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e179a748d425?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /></li></ul><h4 id="2-2-2、比较两棵虚拟-DOM-树的差异-—-diff-算法"><a href="#2-2-2、比较两棵虚拟-DOM-树的差异-—-diff-算法" class="headerlink" title="2.2.2、比较两棵虚拟 DOM 树的差异 — diff 算法"></a>2.2.2、比较两棵虚拟 <code>DOM</code> 树的差异 — <code>diff</code> 算法</h4><ul><li><p>复杂度：</p><ul><li><p>如果需要两棵树的完全比较，时间复杂度为<code>O(n^3)</code>。</p></li><li><p>但是在前端当中，你很少会跨越层级地移动 <code>DOM</code> 元素，所以 <code>Virtual DOM</code> 只会对同一个层级的元素进行对比</p></li><li><p>这样算法复杂度就可以达到 <code>O(n)</code>。</p></li></ul></li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e26a5ecf086e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 33%;" /><h5 id="（1）深度优先遍历，记录差异"><a href="#（1）深度优先遍历，记录差异" class="headerlink" title="（1）深度优先遍历，记录差异"></a><strong>（1）深度优先遍历，记录差异</strong></h5><ul><li>对<strong>新旧两棵树</strong>进行一个深度优先的遍历，每遍历到一个节点就把该节点和新的的树进行对比，如果有差异的话就记录到一个对象里面。这样每个节点都会有一个唯一的标记：</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2873e42b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dfs-walk" style="zoom: 33%;" /><ul><li><p><strong>diff函数 —&gt; dfsWalk函数：</strong></p><ol><li><p>判断新旧节点是否都是string类型：是，比较新旧文本内容是否相等？</p><ul><li>否：currentPatch数组中push一个对象，它内部标记为Text类型，实现替换文本内容</li></ul></li><li><p>否则，标签名+key值是否均相同：是，调用diffProps比较节点属性是否相等？</p><ul><li>否：currentPatch里push一个对象(将新节点的属性替换旧节点属性)</li><li>是（相等）：比较没有ignore属性的子节点：diffChildren，传入节点的children</li></ul></li><li><p>否则，如果新节点不为空：</p><p>currentPatch数组中push一个对象，类型为REPLACE，将来直接替换</p></li><li><p>函数最后：</p><p>将currentPatch数组赋值给patches对象上，patches这个对象就记录了所有节点的差异</p></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diff 函数，对比两棵树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span> <span class="comment">// 当前节点的标志</span></span><br><span class="line">  <span class="keyword">var</span> patches = &#123;&#125; <span class="comment">// 用来记录每个节点差异的对象</span></span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  <span class="keyword">return</span> patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两棵树进行深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span>(<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentPatch = []</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (oldNode) === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> (newNode) === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 文本内容改变</span></span><br><span class="line">    <span class="keyword">if</span> (newNode !== oldNode) &#123;</span><br><span class="line">      currentPatch.push(&#123; <span class="attr">type</span>: patch.TEXT, <span class="attr">content</span>: newNode &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode!=<span class="literal">null</span> &amp;&amp; oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) &#123;</span><br><span class="line">    <span class="comment">// 节点相同，比较属性</span></span><br><span class="line">    <span class="keyword">var</span> propsPatches = diffProps(oldNode, newNode)</span><br><span class="line">    <span class="keyword">if</span> (propsPatches) &#123;</span><br><span class="line">      currentPatch.push(&#123; <span class="attr">type</span>: patch.PROPS, <span class="attr">props</span>: propsPatches &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较子节点，如果子节点有&#x27;ignore&#x27;属性，则不需要比较</span></span><br><span class="line">    <span class="keyword">if</span> (!isIgnoreChildren(newNode)) &#123;</span><br><span class="line">      diffChildren(</span><br><span class="line">        oldNode.children,</span><br><span class="line">        newNode.children,</span><br><span class="line">        index,</span><br><span class="line">        patches,</span><br><span class="line">        currentPatch</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(newNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 新节点和旧节点不同，用 replace 替换</span></span><br><span class="line">    currentPatch.push(&#123; <span class="attr">type</span>: patch.REPLACE, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatch.length) &#123;</span><br><span class="line">    patches[index] = currentPatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从以上可以得出，<code>patches[1]</code> 表示 <code>p</code> ，<code>patches[3]</code> 表示 <code>ul</code> ，以此类推。</p><h5 id="（2）差异类型"><a href="#（2）差异类型" class="headerlink" title="（2）差异类型"></a><strong>（2）差异类型</strong></h5><p><code>DOM</code> 操作导致的差异类型包括以下几种：</p><ul><li>节点替换：节点改变了，例如将上面的 <code>div</code> 换成 <code>h1</code>;</li><li>顺序互换：移动、删除、新增子节点，例如上面 <code>div</code> 的子节点，把 <code>p</code> 和 <code>ul</code> 顺序互换；</li><li>属性更改：修改了节点的属性，例如把上面 <code>li</code> 的 <code>class</code> 样式类删除；</li><li>文本改变：改变文本节点的文本内容，例如将上面 <code>p</code> 节点的文本内容更改为 “<code>Real Dom</code>”；</li></ul><p>以上描述的几种差异类型在代码中定义如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var REPLACE = 0 // 替换原先的节点</span><br><span class="line">var REORDER = 1 // 重新排序</span><br><span class="line">var PROPS = 2 // 修改了节点的属性</span><br><span class="line">var TEXT = 3 // 文本内容改变 </span><br></pre></td></tr></table></figure><h5 id="（3）列表对比算法-不要主动提"><a href="#（3）列表对比算法-不要主动提" class="headerlink" title="（3）列表对比算法                   不要主动提"></a><strong>（3）列表对比算法</strong>                   不要主动提</h5><ul><li><p><strong>问题：</strong>同层级交换了位置，如何更高效的对比？</p><p>如果按照同层级的话，会全部被替换掉，开销大，实际只需要移动即可。 </p><ul><li>将这个问题抽象出来其实就是<strong>字符串的最小编辑距离问题</strong>，最常见的解决方法是 <code>Levenshtein Distance</code> 。它是一个度量两个字符序列之间差异的字符串度量标准，通过<strong>动态规划</strong>求解，时间复杂度为 <code>O(M*N)</code></li></ul></li><li><p>具体求解过程：</p></li></ul><h5 id="（4）实例输出"><a href="#（4）实例输出" class="headerlink" title="（4）实例输出"></a><strong>（4）实例输出</strong></h5><ul><li>两个虚拟 <code>DOM</code> 对象如下图所示，其中 <code>ul1</code> 表示原有的虚拟 <code>DOM</code> 树，<code>ul2</code> 表示改变后的虚拟 <code>DOM</code> 树</li><li>通过差异对象patches，两个虚拟 <code>DOM</code> 对象之间进行了哪些变化，从而更改原先的真实 <code>DOM</code> 结构，从而将页面的 <code>DOM</code> 结构进行更改</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul1 = el(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;virtual-dom&#x27;</span>&#125;,[</span><br><span class="line">  el(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">  el(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;list&#x27;</span> &#125;, [</span><br><span class="line">el(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">el(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">el(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  el(<span class="string">&#x27;div&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">]) </span><br><span class="line"><span class="keyword">var</span> ul2 = el(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;virtual-dom&#x27;</span>&#125;,[</span><br><span class="line">  el(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">  el(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;list&#x27;</span> &#125;, [</span><br><span class="line">el(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 21&#x27;</span>]),</span><br><span class="line">el(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 23&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  el(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">]) </span><br><span class="line"><span class="keyword">var</span> patches = diff(ul1,ul2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;patches:&#x27;</span>,patches);</span><br></pre></td></tr></table></figure><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e1a5bff0b71a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /><h4 id="2-2-3、将两个虚拟-DOM-对象的差异应用到真正的-DOM-树"><a href="#2-2-3、将两个虚拟-DOM-对象的差异应用到真正的-DOM-树" class="headerlink" title="2.2.3、将两个虚拟 DOM 对象的差异应用到真正的 DOM 树"></a>2.2.3、将两个虚拟 <code>DOM</code> 对象的差异应用到真正的 <code>DOM</code> 树</h4><h5 id="（1）深度优先遍历-DOM-树"><a href="#（1）深度优先遍历-DOM-树" class="headerlink" title="（1）深度优先遍历 DOM 树"></a><strong>（1）深度优先遍历 <code>DOM</code> 树</strong></h5><p>​    遍历的时候从步骤二生成的 <code>patches</code> 对象中找出当前遍历的节点差异，如下相关代码所示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">node, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> walker = &#123;<span class="attr">index</span>: <span class="number">0</span>&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">node, walker, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line">  <span class="keyword">var</span> currentPatches = patches[walker.index]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = node.childNodes</span><br><span class="line">    ? node.childNodes.length</span><br><span class="line">    : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 深度遍历子节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="（2）对原有-DOM-树进行-DOM-操作"><a href="#（2）对原有-DOM-树进行-DOM-操作" class="headerlink" title="（2）对原有 DOM 树进行 DOM 操作"></a><strong>（2）对原有 <code>DOM</code> 树进行 <code>DOM</code> 操作</strong></h5><ul><li>根据不同类型的差异对当前节点进行不同的 <code>DOM</code> 操作</li><li>如果进行了节点替换，就进行节点替换 <code>DOM</code> 操作；如果节点文本发生了改变，则进行文本替换的 <code>DOM</code> 操作；以及子节点重排、属性改变等 <code>DOM</code> 操作</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span> (<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="params">currentPatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        <span class="keyword">var</span> newNode = (<span class="keyword">typeof</span> currentPatch.node === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">          ? <span class="built_in">document</span>.createTextNode(currentPatch.node)</span><br><span class="line">          : currentPatch.node.render()</span><br><span class="line">        node.parentNode.replaceChild(newNode, node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown patch type &#x27;</span> + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="（3）DOM结构改变"><a href="#（3）DOM结构改变" class="headerlink" title="（3）DOM结构改变"></a><strong>（3）DOM结构改变</strong></h5><ul><li>通过将第 2.2.2 得到的两个 <code>DOM</code> 对象之间的差异，应用到第一个（原先）<code>DOM</code> 结构中，我们可以看到 <code>DOM</code> 结构进行了预期的变化，如下图所示：</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e1ae714e9779?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 67%;" /><h3 id="2-3、总结流程"><a href="#2-3、总结流程" class="headerlink" title="2.3、总结流程"></a>2.3、总结流程</h3><p><code>Virtual DOM</code> 算法主要实现上面三个步骤来实现：</p><ul><li><p>用 <code>JS</code> 对象模拟 <code>DOM</code> 树 — <code>element.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;virtual-dom&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Virtual DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure></li><li><p>比较两棵虚拟 <code>DOM</code> 树的差异 — <code>diff.js</code></p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e1bb518a2951?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /></li></ul><ul><li><p>将两个虚拟 <code>DOM</code> 对象的差异应用到真正的 <code>DOM</code> 树 — <code>patch.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span> (<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="params">currentPatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        <span class="keyword">var</span> newNode = (<span class="keyword">typeof</span> currentPatch.node === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">          ? <span class="built_in">document</span>.createTextNode(currentPatch.node)</span><br><span class="line">          : currentPatch.node.render()</span><br><span class="line">        node.parentNode.replaceChild(newNode, node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown patch type &#x27;</span> + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h2 id="三、Virtual-DOM-源码简析"><a href="#三、Virtual-DOM-源码简析" class="headerlink" title="三、Virtual-DOM  源码简析"></a>三、<code>Virtual-DOM</code>  源码简析</h2><h3 id="3-1、VNode-模拟-DOM-树"><a href="#3-1、VNode-模拟-DOM-树" class="headerlink" title="3.1、VNode 模拟 DOM 树"></a>3.1、<code>VNode</code> 模拟 <code>DOM</code> 树</h3><h4 id="3-1-1、VNode-类简析"><a href="#3-1-1、VNode-类简析" class="headerlink" title="3.1.1、VNode 类简析"></a><strong>3.1.1、<code>VNode</code> 类简析</strong></h4><ul><li><p>在 <code>Vue.js</code> 中，<code>Virtual DOM</code> 是用 <code>VNode</code> 这个 <code>Class</code> 去描述，它定义在 <code>src/core/vdom/vnode.js</code> 中 </p></li><li><p>实际上 <code>Vue.js</code> 中 <code>Virtual DOM</code> 是借鉴了一个开源库  <a href="https://link.juejin.cn/?target=https://github.com/snabbdom/snabbdom">snabbdom</a> 的实现，然后加入了一些 <code>Vue.js</code> 的一些特性。</p></li><li><h4 id="核心属性："><a href="#核心属性：" class="headerlink" title="核心属性："></a>核心属性：</h4><ul><li><code>tag</code> 属性即这个<code>vnode</code>的标签属性</li><li><code>data</code> 属性包含了最后渲染成真实<code>dom</code>节点后，节点上的<code>class</code>，<code>attribute</code>，<code>style</code>以及绑定的事件</li><li><code>children</code> 属性是<code>vnode</code>的子节点</li><li><code>text</code> 属性是文本属性</li><li><code>elm</code> 属性为这个<code>vnode</code>对应的真实<code>dom</code>节点</li><li><code>key</code> 属性是<code>vnode</code>的标记，在<code>diff</code>过程中可以提高<code>diff</code>的效率</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="attr">tag</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  data: VNodeData | <span class="keyword">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: string | <span class="keyword">void</span>;</span><br><span class="line">  elm: Node | <span class="keyword">void</span>;</span><br><span class="line">  ns: string | <span class="keyword">void</span>;</span><br><span class="line">  context: Component | <span class="keyword">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  key: string | number | <span class="keyword">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="keyword">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态属性非常多，此处省略</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    tag?: string,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">    text?: string,</span></span><br><span class="line"><span class="params">    elm?: Node,</span></span><br><span class="line"><span class="params">    context?: Component,</span></span><br><span class="line"><span class="params">    componentOptions?: VNodeComponentOptions,</span></span><br><span class="line"><span class="params">    asyncFactory?: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.children = children</span><br><span class="line">    <span class="built_in">this</span>.text = text</span><br><span class="line">    <span class="built_in">this</span>.elm = elm</span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">   <span class="comment">// 省略属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2、创建-VNode-过程"><a href="#3-1-2、创建-VNode-过程" class="headerlink" title="3.1.2、创建 VNode 过程"></a>3.1.2、创建 <code>VNode</code> 过程</h4><h5 id="（1）初始化vue"><a href="#（1）初始化vue" class="headerlink" title="（1）初始化vue"></a>（1）初始化vue</h5><ul><li> <code>new Vue( )</code> 时，实际上是执行 <code>src/core/instance/index.js</code> 中定义的 <code>Function</code> 函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内部调用 <code>this._init</code> 方法，该方法在 <code>src/core/instance/init.js</code> 中定义</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略一系列其它初始化的代码</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;vm.$options.el:&#x27;</span>,vm.$options.el);</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）Vue-实例挂载"><a href="#（2）Vue-实例挂载" class="headerlink" title="（2）Vue 实例挂载"></a><strong>（2）<code>Vue</code> 实例挂载</strong></h5><ul><li><code>Vue</code> 中是通过 <code>$mount</code> 实例方法去挂载 <code>dom</code> 的，下面我们通过分析 <code>compiler</code> 版本的 <code>mount</code> 实现，相关源码在目录 <code>src/platforms/web/entry-runtime-with-compiler.js</code> 文件中定义：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line"><span class="comment">// 重写</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  el?: string | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 省略一系列初始化以及逻辑判断代码  </span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现最终还是调用用原先原型上的 <code>$mount</code> 方法挂载 ，原先原型上的 <code>$mount</code> 方法在 <code>src/platforms/web/runtime/index.js</code> 中定义 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  el?: string | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现<code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，这个方法定义在 <code>src/core/instance/lifecycle.js</code> 文件中：</p><ul><li><code>mountComponent</code> 核心就是先实例化一个渲染<code>Watcher</code>，在它的回调函数中会调用 <code>updateComponent</code> 方法</li><li>在此方法中调用 <code>vm._render</code> 方法先生成虚拟 Node，最终调用 <code>vm._update</code> 更新 <code>DOM</code>。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el: ?Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// 省略一系列其它代码</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成虚拟 vnode   </span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      <span class="comment">// 更新 DOM</span></span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）创建虚拟-Node"><a href="#（3）创建虚拟-Node" class="headerlink" title="（3）创建虚拟 Node"></a><strong>（3）创建虚拟 Node</strong></h5><ul><li><code>Vue</code> 的 <code>_render</code> 方法是实例的一个私有方法，**它用来把实例渲染成一个虚拟 <code>Node</code>**。它的定义在 <code>src/core/instance/render.js</code> 文件中：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> vm: Component = <span class="built_in">this</span>;</span><br><span class="line">   <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options;</span><br><span class="line">   <span class="keyword">let</span> vnode</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 省略一系列代码  </span></span><br><span class="line">     currentRenderingInstance = vm;</span><br><span class="line">     <span class="comment">// 调用 createElement 方法来返回 vnode</span></span><br><span class="line">     vnode = render.call(vm._renderProxy, vm.$createElement);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="function"><span class="title">handleError</span>(<span class="params">e, vm, <span class="string">`render`</span></span>)</span>&#123;&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// set parent</span></span><br><span class="line">   vnode.parent = _parentVnode;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;vnode...:&quot;</span>,vnode);</span><br><span class="line">   <span class="keyword">return</span> vnode</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>Vue.js</code> 利用 <code>_createElement</code> 方法创建 <code>VNode</code>，它定义在 <code>src/core/vdom/create-elemenet.js</code> 中：<code>_createElement</code> 方法有 5 个参数:<ul><li><code>context</code> 表示 VNode 的上下文环境，它是 <code>Component</code> 类型；</li><li><code>tag</code>表示标签，它可以是一个字符串，也可以是一个 <code>Component</code>；</li><li><code>data</code> 表示 VNode 的数据，它是一个 <code>VNodeData</code> 类型，可以在 <code>flow/vnode.js</code> 中找到它的定义；</li><li><code>children</code> 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 <code>VNode</code> 数组；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  tag?: string | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  data?: VNodeData,</span></span></span><br><span class="line"><span class="params"><span class="function">  children?: any,</span></span></span><br><span class="line"><span class="params"><span class="function">  normalizationType?: number</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略一系列非主线代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    <span class="comment">// 场景是 render 函数不是编译生成的</span></span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    <span class="comment">// 场景是 render 函数是编译生成的</span></span><br><span class="line">    children = simpleNormalizeChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// 创建虚拟 vnode</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3、实例查看"><a href="#3-1-3、实例查看" class="headerlink" title="3.1.3、实例查看"></a><strong>3.1.3、实例查看</strong></h4><ul><li><h5 id="例如，实例化一个-Vue-实例："><a href="#例如，实例化一个-Vue-实例：" class="headerlink" title="例如，实例化一个 Vue 实例："></a>例如，实例化一个 <code>Vue</code> 实例：</h5></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">        <span class="attr">class</span>: <span class="string">&quot;class_box&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;, <span class="built_in">this</span>.message)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>我们打印出其对应的 <code>VNode</code> 表示：</p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e23b7481b16f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /></li></ul><h3 id="3-2、diff-过程"><a href="#3-2、diff-过程" class="headerlink" title="3.2、diff 过程"></a>3.2、<code>diff</code> 过程</h3><h4 id="3-2-1、Vue-js-源码的-diff-调用逻辑"><a href="#3-2-1、Vue-js-源码的-diff-调用逻辑" class="headerlink" title="3.2.1、Vue.js 源码的 diff 调用逻辑"></a>3.2.1、<code>Vue.js</code> 源码的 <code>diff</code> 调用逻辑</h4><ul><li><code>Vue.js</code> 源码实例化了一个 <code>watcher</code>，这个 ~ 被添加到了在模板当中所绑定变量的依赖当中，一旦 <code>model</code> 中的响应式的数据发生了变化，这些响应式的数据所维护的 <code>dep</code> 数组便会调用 <code>dep.notify()</code> 方法完成所有依赖遍历执行的工作，这包括视图的更新，即 <code>updateComponent</code> 方法的调用。</li><li><code>watcher</code> 和 <code>updateComponent</code>方法定义在  <code>src/core/instance/lifecycle.js</code> 文件中 </li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el: ?Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// 省略一系列其它代码</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成虚拟 vnode   </span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      <span class="comment">// 更新 DOM</span></span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完成视图的更新工作事实上就是调用了<code>vm._update</code>方法，这个方法接收的第一个参数是刚生成的<code>Vnode</code>，调用的<code>vm._update</code>方法定义在 <code>src/core/instance/lifecycle.js</code>中</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// 第一个参数为真实的node节点，则为初始化</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果需要diff的prevVnode存在，那么对prevVnode和vnode进行diff</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  restoreActiveInstance()</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个方法当中最为关键的就是 <code>vm.__patch__</code> 方法，这也是整个 <code>virtual-dom</code> 当中最为核心的方法，定义在 <code>src/core/vdom/patch.js</code> 中</li><li>主要完成了<code>prevVnode</code> 和 <code>vnode</code> 的 <code>diff</code> 过程并根据需要操作的 <code>vdom</code> 节点打 <code>patch</code>，最后生成新的真实 <code>dom</code> 节点并完成视图的更新工作。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当oldVnode不存在时，创建新的节点</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对oldVnode和vnode进行diff，并对oldVnode打patch  </span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">      &#125; </span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>patch</code> 方法中，我们看到会分为两种情况：<ol><li>当 <code>oldVnode</code> 不存在时，会创建新的节点；</li><li>已经存在 <code>oldVnode</code> ，那么会对 <code>oldVnode</code> 和 <code>vnode</code> 进行 <code>diff</code> 及 <code>patch</code> 的过程</li></ol></li><li><code>patch</code> 过程中会调用 <code>sameVnode</code> 方法来对对传入的2个 <code>vnode</code> 进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个<code>vnode</code> 只是局部发生了更新，然后才会对这2个 <code>vnode</code> 进行 <code>diff</code>，</li><li>如果2个 <code>vnode</code> 的基本属性存在不一致的情况，那么就会直接跳过 <code>diff</code> 的过程，进而依据 <code>vnode</code> 新建一个真实的 <code>dom</code>，同时删除老的 <code>dom</code>节点</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp;</span><br><span class="line">    a.tag === b.tag &amp;&amp;</span><br><span class="line">    a.isComment === b.isComment &amp;&amp;</span><br><span class="line">    isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">    sameInputType(a, b)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>diff</code> 过程中主要是通过调用 <code>patchVnode</code> 方法进行的:</p><h5 id="老的有，新的没有，直接干掉；老的没有。新的有，添加；老的新的都有，对比子"><a href="#老的有，新的没有，直接干掉；老的没有。新的有，添加；老的新的都有，对比子" class="headerlink" title="老的有，新的没有，直接干掉；老的没有。新的有，添加；老的新的都有，对比子"></a>老的有，新的没有，直接干掉；老的没有。新的有，添加；老的新的都有，对比子</h5><p>分了好几种情况，<code>oldCh</code> 为 <code>oldVnode</code>的子节点，<code>ch</code> 为 <code>Vnode</code>的子节点：</p><ul><li>首先进行文本节点的判断，若 <code>oldVnode.text !== vnode.text</code>，那么就会直接进行文本节点的替换；</li><li>在<code>vnode</code> 没有文本节点的情况下，进入子节点的 <code>diff</code>；</li><li>当 <code>oldCh</code> 和 <code>ch</code> 都存在且不相同的情况下，调用 <code>updateChildren</code> 对子节点进行 <code>diff</code>；</li><li>若 <code>oldCh</code>不存在，<code>ch</code> 存在，首先清空 <code>oldVnode</code> 的文本节点，同时调用 <code>addVnodes</code> 方法将 <code>ch</code> 添加到<code>elm</code>真实 <code>dom</code> 节点当中；</li><li>若 <code>oldCh</code>存在，<code>ch</code>不存在，则删除 <code>elm</code> 真实节点下的 <code>oldCh</code> 子节点；</li><li>若 <code>oldVnode</code> 有文本节点，而 <code>vnode</code> 没有，那么就清空这个文本节点。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly</span>) </span>&#123;</span><br><span class="line">  ...... </span><br><span class="line">  <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">  <span class="comment">// 如果vnode没有文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode的children属性存在且vnode的children属性也存在  </span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// updateChildren，对子节点进行diff  </span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        checkDuplicateKeys(ch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果oldVnode的text存在，那么首先清空text的内容,然后将vnode的children添加进去  </span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 删除elm下的oldchildren</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// oldVnode有子节点，而vnode没有，那么就清空这个节点  </span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2、子节点-diff-流程分析"><a href="#3-2-2、子节点-diff-流程分析" class="headerlink" title="3.2.2、子节点 diff 流程分析"></a>3.2.2、子节点 <code>diff</code> 流程分析</h4><h5 id="（1）Vue-js-源码"><a href="#（1）Vue-js-源码" class="headerlink" title="（1）Vue.js 源码"></a><strong>（1）<code>Vue.js</code> 源码</strong></h5><ul><li><code>updateChildren</code>方法，它也是整个 <code>diff</code> 过程中最重要的环节，以下为 <code>Vue.js</code> 的源码过程</li><li><strong>做法：</strong>在开始遍历 <code>diff</code> 前，首先给 <code>oldCh</code>和 <code>newCh</code> 分别分配一个 <code>startIndex</code> 和 <code>endIndex</code> 来作为遍历的索引，当<code>oldCh</code> 或者 <code>newCh</code> 遍历完后(遍历完的条件就是 <code>oldCh</code> 或者 <code>newCh</code> 的 <code>startIndex &gt;= endIndex</code> )，就停止<code>oldCh</code> 和 <code>newCh</code> 的 <code>diff</code> 过程。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为oldCh和newCh分别建立索引，为之后遍历的依据</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到oldCh或者newCh被遍历完后跳出循环</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      idxInOld = isDef(newStartVnode.key)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）无-key-的-diff-过程"><a href="#（2）无-key-的-diff-过程" class="headerlink" title="（2）无 key 的 diff 过程"></a><strong>（2）无 <code>key</code> 的 <code>diff</code> 过程</strong></h5><ul><li>首先从第一个节点开始比较，不管是 <code>oldCh</code> 还是 <code>newCh</code> 的起始或者终止节点都不存在 <code>sameVnode</code> ，同时节点属性中是不带 <code>key</code>标记的，因此第一轮的 <code>diff</code> 完后，<code>newCh</code>的 <code>startVnode</code> 被添加到 <code>oldStartVnode</code>的前面，同时 <code>newStartIndex</code>前移一位；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2878c44dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /><ul><li>第二轮的 <code>diff</code>中，满足 <code>sameVnode(oldStartVnode, newStartVnode)</code>，因此对这2个 <code>vnode</code> 进行<code>diff</code>，最后将 <code>patch</code> 打到 <code>oldStartVnode</code> 上，同时 <code>oldStartVnode</code>和 <code>newStartIndex</code> 都向前移动一位 ；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e28889eaff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /><ul><li>第三轮的 <code>diff</code> 中，满足 <code>sameVnode(oldEndVnode, newStartVnode)</code>，那么首先对 <code>oldEndVnode</code>和<code>newStartVnode</code> 进行 <code>diff</code>，并对 <code>oldEndVnode</code>进行 <code>patch</code>，并完成 <code>oldEndVnode</code> 移位的操作，最后<code>newStartIndex</code>前移一位，<code>oldStartVnode</code> 后移一位；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e289a351b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 50%;" /><ul><li>第四轮的 <code>diff</code>中，过程同步骤3；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e289f9213e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><ul><li>第五轮的 <code>diff</code> 中，同过程1；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e28aee99a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><ul><li>遍历的过程结束后，<code>newStartIdx &gt; newEndIdx</code>，说明此时 <code>oldCh</code> 存在多余的节点，那么最后就需要将这些多余的节点删除。</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2ca893b49?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><h5 id="（3）有-key-的-diff-流程"><a href="#（3）有-key-的-diff-流程" class="headerlink" title="（3）有 key 的 diff 流程"></a><strong>（3）有 <code>key</code> 的 <code>diff</code> 流程</strong></h5><ul><li><p>在 <code>vnode</code> 不带 <code>key</code> 的情况下，每一轮的 <code>diff</code> 过程当中都是<code>起始</code>和<code>结束</code>节点进行比较，直到 <code>oldCh</code> 或者<code>newCh</code> 被遍历完</p></li><li><p>当为 <code>vnode</code> 引入 <code>key</code> 属性后，在每一轮 <code>diff</code> 过程中，当<code>起始</code>和<code>结束</code>节点都没有找到<code>sameVnode</code> 时，然后判断在 <code>newStartVnode</code> 的属性中是否有 <code>key</code>，且是否在 <code>oldKeyToIndx</code> 中找到对应的节点：</p><ul><li>如果不存在这个 <code>key</code>，那么就将这个 <code>newStartVnode</code>作为新的节点创建且插入到原有的 <code>root</code> 的子节点中；</li><li>如果存在这个 <code>key</code>，那么就取出 <code>oldCh</code> 中的存在这个 <code>key</code> 的 <code>vnode</code>，然后再进行 <code>diff</code> 的过；</li></ul></li><li><p>所以：遍历 <code>diff</code> 的过程中，当<strong>起始点</strong>，<strong>结束点</strong>的<strong>搜寻</strong>及 <code>diff</code> 出现还是无法匹配的情况下时，就会用 <code>key</code> 来作为唯一标识，来进行 <code>diff</code>，这样就可以提高 <code>diff</code> 效率</p><p>带有 <code>Key</code>属性的 <code>vnode</code>的 <code>diff</code> 过程可见下图：</p><ol><li><p>首先从第一个节点开始比较，不管是 <code>oldCh</code> 还是 <code>newCh</code> 的起始或者终止节点都不存在 <code>sameVnode</code>，但节点属性中是带 <code>key</code> 标记的， 然后在 <code>oldKeyToIndx</code> 中找到对应的节点，这样第一轮 <code>diff</code> 过后 <code>oldCh</code> 上的<code>B节点</code>被删除了，但是 <code>newCh</code> 上的<code>B节点</code>上 <code>elm</code> 属性保持对 <code>oldCh</code> 上 <code>B节点</code> 的<code>elm</code>引用</p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2db1c4812?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /></li><li><p>第二轮的 <code>diff</code> 中，满足 <code>sameVnode(oldStartVnode, newStartVnode)</code>，因此对这2个 <code>vnode</code> 进行<code>diff</code>，最后将 <code>patch</code> 打到 <code>oldStartVnode</code>上，同时 <code>oldStartVnode</code> 和 <code>newStartIndex</code> 都向前移动一位 ；</p></li></ol></li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2d7df4fbf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /><p>​    3. 第三轮的 <code>diff</code>中，满足 <code>sameVnode(oldEndVnode, newStartVnode)</code>，那么首先对 <code>oldEndVnode</code> 和<code>newStartVnode</code> 进行 <code>diff</code>，并对 <code>oldEndVnode</code> 进行 <code>patch</code>，并完成 <code>oldEndVnode</code> 移位的操作，最后<code>newStartIndex</code> 前移一位，<code>oldStartVnode</code>后移一位；</p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2e2a2835e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /><ol start="4"><li>第四轮的<code>diff</code>中，过程同步骤2；</li></ol><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2e507aec0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><ol start="5"><li>第五轮的<code>diff</code>中，因为此时 <code>oldStartIndex</code> 已经大于 <code>oldEndIndex</code>，所以将剩余的 <code>Vnode</code> 队列插入队列最后。</li></ol><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e3178398fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><h3 id="3-3、patch-过程"><a href="#3-3、patch-过程" class="headerlink" title="3.3、patch 过程"></a>3.3、<code>patch</code> 过程</h3><p>通过3.2章节介绍的 <code>diff</code> 过程中，我们会看到 <code>nodeOps</code> 相关的方法对真实 <code>DOM</code> 结构进行操作，<code>nodeOps</code> 定义在 <code>src/platforms/web/runtime/node-ops.js</code> 中，其为基本 <code>DOM</code> 操作，这里就不在详细介绍。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElementNS</span> (<span class="params">namespace: string, tagName: string</span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElementNS(namespaceMap[namespace], tagName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextNode</span> (<span class="params">text: string</span>): <span class="title">Text</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComment</span> (<span class="params">text: string</span>): <span class="title">Comment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createComment(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertBefore</span> (<span class="params">parentNode: Node, newNode: Node, referenceNode: Node</span>) </span>&#123;</span><br><span class="line">  parentNode.insertBefore(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</span><br><span class="line">  node.removeChild(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目4:B实习：问题总结篇</title>
      <link href="/2021/12/13/%E9%A1%B9%E7%9B%AE4%EF%BC%9A%E7%99%BE%E5%BA%A6%E5%AE%9E%E4%B9%A0%EF%BC%9A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2021/12/13/%E9%A1%B9%E7%9B%AE4%EF%BC%9A%E7%99%BE%E5%BA%A6%E5%AE%9E%E4%B9%A0%EF%BC%9A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ul><li>这部分文档脱敏处理后再更新吧。。。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目3：购物街项目:问题总结</title>
      <link href="/2021/12/13/%E9%A1%B9%E7%9B%AE3%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%A1%97%E9%A1%B9%E7%9B%AE-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/13/%E9%A1%B9%E7%9B%AE3%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%A1%97%E9%A1%B9%E7%9B%AE-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2020年11月-12月大概</li><li>项目背景： 给师姐做的（首页功能+购物车）</li><li>问题总结篇，比较啰嗦</li></ul><h3 id="1-吸顶效果"><a href="#1-吸顶效果" class="headerlink" title="1. 吸顶效果"></a>1. 吸顶效果</h3><p>position属性的特性：5种定位方式</p><ul><li><p><strong>static：</strong>        默认值  正常文档流的位置（从上到下，从左到右）</p><ul><li>浏览器会按照源码的顺序，决定每个元素的位置，这称为”正常的页面流”（normal flow）。每个块级元素占据自己的区块（block），元素与元素之间不产生重叠，这个位置就是元素的默认位置。</li><li><code>static</code>定位所导致的元素位置，是浏览器自主决定的，所以这时<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性无效。</li></ul></li><li><p><strong>relative：</strong>     不脱标， 相对于原本占据的位置，且占用原位置</p></li><li><p><strong>absolute</strong>       脱标   相对于第一个不是static的父元素定位，如果没有，就以html元素为基准</p></li><li><p><strong>fixed：</strong>          脱标        相对于浏览器窗口</p></li><li><p><strong>sticky：</strong>  基于用户的滚动位置来定位，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换</p><ul><li>一般它的行为就像 <strong>position:relative</strong></li><li>而当页面滚动超出目标区域（跨越特定阈值top, right, bottom 或 left 之一）时，它的表现就像 **position:fixed;**它会固定在目标位置</li><li>指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同</li></ul><p>一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的<code>overflow</code> 是 <code>hidden</code>, <code>scroll</code>, <code>auto</code>, 或 <code>overlay</code>时），即便这个祖先不是最近的真实可滚动祖先</p></li></ul><h4 id="1-尝试1："><a href="#1-尝试1：" class="headerlink" title="1. 尝试1："></a>1. 尝试1：</h4><ul><li><p><strong>做法：</strong>position属性为sticky，BScroll的出现让绝对定位失效</p></li><li><p><strong>失效原因：</strong>bscroll容器内的fixed定位元素就全乱套了</p><ul><li><p>fixed固定定位的元素，如果父亲有transform样式，值不为none，那么fixed就会失效，比如：scale、translate等</p></li><li><p>Better-scroll在滚动中的过程中，会往content上加transform属性。其中Translate属性在滚动的过程中，会不断地改变，所以滚动是通过修改Translate实现的</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">element<span class="selector-class">.style</span> &#123;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">0ms</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>) <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">translateZ</span>(<span class="number">0px</span>);</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.165</span>, <span class="number">0.84</span>, <span class="number">0.44</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bscroll的滚动是用<code>transform</code>的<code>translate</code>来进行偏移，但是父元素设置了transform，所有子元素的position: fixed都不再相对于视口，而是相对于这个transform父元素！这不是什么bug，而是规范中规定。一直以为fixed定位霸道至极，没想到transform可以改变它的定位</p></li><li><p>三种可以修改fixed上文基准的样式属性：</p><ul><li>transform 属性不为 none 的元素<br>perspective 的值不为 none 的元素<br>在 will-change 中指定了任意 css 属性</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#home &#123;</span><br><span class="line">    <span class="comment">/* 如果这里没有44px,轮播图会跑到最上面，他的一部分就会被导航栏遮盖 */</span></span><br><span class="line">   padding-top: 44px;</span><br><span class="line">  &#125;</span><br><span class="line">  .home-nav &#123;</span><br><span class="line">    <span class="comment">/* 首页上面的导航栏，向下滚动的时候他不要滚动。采用固定定位，一直在最上面 */</span></span><br><span class="line">    <span class="attr">position</span>: fixed;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    right: <span class="number">0</span>;</span><br><span class="line">    z-index: <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tab-control &#123;</span><br><span class="line">    <span class="comment">/* 想实现的功能是：页面向下滑，滑到一定高度后，顶部固定 */</span></span><br><span class="line">    <span class="attr">position</span>: sticky;</span><br><span class="line">    <span class="comment">// 距离顶部44px的时候，会变成fixed定位</span></span><br><span class="line">    top: 44px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-得出总结："><a href="#2-得出总结：" class="headerlink" title="2. 得出总结："></a>2. 得出总结：</h4><p>只要组件仍在better-scroll内，就不能由定位实现吸顶</p><h4 id="3-尝试2："><a href="#3-尝试2：" class="headerlink" title="3. 尝试2："></a>3. 尝试2：</h4><ul><li><p>复制tab-control2组件，到scroll外面。并用isTabFixed控制这个组件的显隐（v-show），吸顶效果出现的时：true、其他false。<strong>至此吸顶效果实现</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tab-control :titles = &quot;titles&quot; </span><br><span class="line">              class=&quot;tab-control&quot; </span><br><span class="line">              @tabClick= &quot;tabClick&quot;</span><br><span class="line">              :class = &quot;&#123;fixed:isTabFixed&#125;&quot;</span><br><span class="line">              v-show = &quot;isTabFixed&quot;&gt;</span><br><span class="line">&lt;/tab-cotrol&gt;</span><br></pre></td></tr></table></figure></li><li><p>要解决的问题：</p><ol><li><p>如何获取组件2号出现的<strong>位置</strong>：<code>this.$refs.tabcontrol.$el.offsetTop</code></p></li><li><p><strong>何时获取这个数值？</strong></p><p>created不行，dom尚未挂载；mouted也不行，dom挂载但是网络请求的数据可能还没收到，所以要等所有图片数据都加载完毕再获取这个数值。在swiper加载完毕后，监听swiper组件emit的imgload事件，然后回调函数获取offsettop数据</p></li><li><p><strong>位置怎么计算？</strong></p><p>通过scroll组件的emit的scroll事件，回调函数判断position的y值，大于offsettop时，2号组件动态绑定class生效，显示出来</p></li></ol></li></ul><h3 id="2-Vuex管理购物车"><a href="#2-Vuex管理购物车" class="headerlink" title="2. Vuex管理购物车"></a>2. <strong>Vuex</strong>管理购物车</h3><h4 id="1-加购逻辑："><a href="#1-加购逻辑：" class="headerlink" title="1. 加购逻辑："></a>1. 加购逻辑：</h4><ul><li><strong>用户点击后：</strong>在回调函数中将点击商品的信息携带，并commit到mutation中</li><li><strong>在commit中：</strong><ul><li>取出state中的carList遍历，判断传入的product的iid是否已存在，<ul><li>存在：说明之前已经加购过，此时只需改变对应的数量</li><li>不存在：将这项product对象push到cartList数组中，且count属性赋值1，checked属性为true（这个用于全选购物车商品用，默认添加进购物车就被选中）</li></ul></li></ul></li></ul><h4 id="2-优化"><a href="#2-优化" class="headerlink" title="2. 优化"></a>2. 优化</h4><ul><li><p>为了让mutations能够跟踪</p></li><li><p>为了逻辑不要混合在一起</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&#x27;addCart&#x27;,product)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">   AddCounter(state, payload) &#123;</span><br><span class="line">     payload.count++;</span><br><span class="line">   &#125;,</span><br><span class="line">   AddToCar(state, payload)&#123;</span><br><span class="line">     state.carList.push(payload)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    addCart(context, payload)&#123;</span><br><span class="line">      // 查找，传入参数是函数</span><br><span class="line">      let oldProduct = context.state.carList.find(function(item)&#123;</span><br><span class="line">        return item.iid === payload.iid</span><br><span class="line">      &#125;)</span><br><span class="line">      if (oldProduct) &#123;</span><br><span class="line">        context.commit(&#x27;AddCounter&#x27;, oldProduct)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        payload.count = 1</span><br><span class="line">        context.commit(&#x27;AddToCar&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>选中商品总价计算</strong></li></ul><ul><li><strong>价格：</strong>申明<strong>计算属性totalPrice</strong>，过滤cartList中所有checked属性为true的商品对象，对返回的数组调用reduce方法计算这些商品的总价，对总价数字调用toFixed方法保留两位数，然后‘¥’字符串拼<ul><li><strong>数量：</strong>申明<strong>checkLength计算属性</strong>，对cartList调用filter方法先筛选出checked属性为true的商品，返回的是数组取length属性就OK了<h3 id="3-图片滚动卡顿EventBus"><a href="#3-图片滚动卡顿EventBus" class="headerlink" title="3. 图片滚动卡顿EventBus"></a>3. 图片滚动卡顿EventBus</h3></li></ul></li></ul><h4 id="1-问题："><a href="#1-问题：" class="headerlink" title="1. 问题："></a>1. 问题：</h4><ul><li><p><strong>需求：</strong>当滚到底的时候会发一次请求，新的图片会过来，可以继续向下滚动，不断展示新数据</p></li><li><p><strong>问题：</strong></p><ul><li>当100张图片的数据请求过来后，新的data会concat到data数组中，数据改变Vue页面自动会更新展示新的数据。</li><li>Vue中数据更新是异步的，在数据还没有加载完之前，BScroll是无法获取目标内容容器的高度的</li><li>但是Better-scroll插件并没有refresh，此时当前组件的可滚动区域content变长了，但better-scroll仍然按照原本的高度去计算，出现了滚动卡顿的现象</li></ul></li></ul><h4 id="2-解决过程："><a href="#2-解决过程：" class="headerlink" title="2. 解决过程："></a>2. 解决过程：</h4><ul><li><p><strong>所以根本原因：</strong>BScroll的刷新时机问题，所以应该在图片加载完毕后去重新去refresh，内部重新计算高度</p></li><li><p><strong>解决：</strong>监听图片加载完，回调函数中，拿到srcoll对象调用refresh方法进行刷新，此时真实可滚动高度   图片的load事件后，刷新</p></li><li><p><strong>问题：</strong>如何50张图片加载完成与refresh对应起来？    节流</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//home组件：等组件创建完成之后就要监听你的图片是不是加载完成了</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 这里的refresh变量不会被销毁，因为被闭包引用</span></span><br><span class="line">   <span class="keyword">const</span> refresh = <span class="built_in">this</span>.debounce(<span class="built_in">this</span>.$refs.scroll.refresh, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">//等组件创建完成之后就要监听你的图片是不是加载完成了</span></span><br><span class="line">   <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;itemImageLoad&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$refs.scroll &amp;&amp; <span class="built_in">this</span>.$refs.scroll.refresh();</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、优化点—并发解决"><a href="#3、优化点—并发解决" class="headerlink" title="3、优化点—并发解决"></a>3、优化点—并发解决</h4><p>这种判断方法过于依赖每个图片本身的加载情况，可以用promise来优化这个过程，通过promise.all来拿到这个加载完成的消息：</p><ul><li><p>在请求完成后，拿到这个数据，也就是url的数组。遍历图片数组，每个都用promise包裹。当图片加载完成，resolve这个promsie</p></li><li><p>在promise.all中拿到这个promise数组的结果</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;/static/img/123.png&quot;</span>,<span class="string">&quot;/static/img/123.png&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> callBack = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;加载完毕做点啥吧&quot;</span>)</span><br><span class="line">&#125;    </span><br><span class="line"><span class="built_in">this</span>.handleImgLoad(arr, callBack)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加载图片事件</span></span><br><span class="line"><span class="function"><span class="title">handleImgLoad</span>(<span class="params">arr, callBack</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> brr = []</span><br><span class="line">   arr.forEach(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123;</span><br><span class="line">    brr[index] = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> imgReady = <span class="keyword">new</span> Image</span><br><span class="line">        imgReady.src = item</span><br><span class="line">        imgReady.onload=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          resolve(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all(brr).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(result &amp;&amp; callBack) callBack()</span><br><span class="line">   &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;加载图片-----&quot;</span>, error)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、图片加载的方式单一"><a href="#4、图片加载的方式单一" class="headerlink" title="4、图片加载的方式单一"></a>4、图片加载的方式单一</h4><ol><li>load事件</li><li>readystatechange事件</li><li>轮询不断监测img的complete属性，如果为true则表明图片已经加载完毕，停止轮询。该属性所有浏览器都支持</li></ol><h2 id="better-scroll的原理-☆☆☆☆"><a href="#better-scroll的原理-☆☆☆☆" class="headerlink" title="better-scroll的原理     ☆☆☆☆"></a>better-scroll的原理     ☆☆☆☆</h2><p><a href="https://zhuanlan.zhihu.com/p/27407024">https://zhuanlan.zhihu.com/p/27407024</a></p><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h4><ul><li><strong>介绍：</strong>重点解决移动端（已支持 PC）各种滚动场景需求的插件</li><li><strong>浏览器的滚动原理：</strong><ul><li>当页面内容的高度超过视口高度的时候，会出现纵向滚动条；</li><li>当页面内容的宽度超过视口宽度的时候，会出现横向滚动条。</li><li>也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。</li></ul></li></ul><h4 id="2-滚动原理："><a href="#2-滚动原理：" class="headerlink" title="2. 滚动原理："></a><strong>2. 滚动原理：</strong></h4><img src="http://static.galileo.xiaojukeji.com/static/tms/shield/scroll-4.png" alt="布局" style="zoom:33%;" /><ul><li><p>绿色部分为 wrapper，也就是父容器，它会有<strong>固定的高度</strong>，并且溢出隐藏</p></li><li><p>黄色部分为 content，它是父容器的<strong>第一个子元素</strong>（其他的元素会被忽略，如果里面需要滚动的部分有好几部分。一定要拿一个元素把他包裹起来），它的高度会随着内容的大小而撑高</p></li><li><p>当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，就可以滚动内容区了</p></li><li><p>通过滑动的距离动态改变translate的值来实现，<strong>让它相对于父级移动</strong>，就有了一种滚动的效果，但是这里就又有了下一个坑</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">element<span class="selector-class">.style</span> &#123;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">0ms</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>) <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">translateZ</span>(<span class="number">0px</span>);</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.165</span>, <span class="number">0.84</span>, <span class="number">0.44</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-使用："><a href="#3-使用：" class="headerlink" title="3. 使用："></a><strong>3. 使用：</strong></h4><ul><li>better-scroll 提供了一个类，实例化的第一个参数是一个原生的 DOM 对象，如果传递的是一个字符串，better-scroll 内部会尝试调用 querySelector 去获取这个 DOM 对象，初始化只需要 new 一个类的实例即可</li><li><strong>better-scroll初始化的时机</strong>很重要：better-scroll 不能滚动的原因多半是初始化 better-scroll 的时机不对，或者是当 DOM 结构变化的时候并没有重新计算 better-scroll<ul><li>因为它在初始化的时候，会计算父元素和子元素的高度和宽度，来决定是否可以纵向和横向滚动</li><li>我们在初始化它的时候，必须确保父元素和子元素的内容已经正确渲染了。如果子元素或者父元素 DOM 结构发生改变的时候，必须重新调用 </li><li>因此，scroll.refresh() 方法重新计算来确保滚动效果的正常</li></ul></li></ul><h4 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h4><h5 id="场景1：基础列表滚动"><a href="#场景1：基础列表滚动" class="headerlink" title="场景1：基础列表滚动"></a><strong>场景1：基础列表滚动</strong></h5><ul><li><p><strong>vm.$refs</strong> 和<strong>this.$nextTick</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    mounted() &#123;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">1. this.$refs.wrapper拿到这个 DOM 对象</span><br><span class="line">2. 在 mounted钩子函数里，this.$nextTick 的回调函数中初始化 better-scroll</span><br><span class="line">3. 此时wrapper的最新DOM已渲染，可以正确计算它以及它内层 content 的高度，以确保滚动正常</span><br><span class="line">4. 也可以将this.$nextTick换成setTimeout(fn, 20) 也是可以的，每一个 Tick 约为 17 ms，对用户体验而言都是无感知的</span><br></pre></td></tr></table></figure></li></ul><h5 id="场景2：异步数据的处理"><a href="#场景2：异步数据的处理" class="headerlink" title="场景2：异步数据的处理"></a><strong>场景2：异步数据的处理</strong></h5><ul><li><p>实际工作中，列表的数据往往都是异步获取的，因此初始化 better-scroll 的时机需要在数据获取后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  requestData().then((res) =&gt; &#123;</span><br><span class="line">    this.data = res.data</span><br><span class="line">    this.$nextTick(() =&gt; &#123;</span><br><span class="line">      this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>获取到数据后，通过异步的方式再去初始化 better-scroll</p></li><li><p>因为 Vue 是数据驱动的， Vue 数据发生变化（this.data = res.data）到页面重新渲染是一个异步的过程，我们的初始化时机是要在 DOM 重新渲染后，所以这里用到了 this.$nextTick，当然替换成 setTimeout(fn, 20) 也是可以的</p></li><li><p>为什么这里在 created 这个钩子函数里请求数据而不是放到 mounted 的钩子函数里？</p><p>为 requestData 是发送一个网络请求，这是一个异步过程，当拿到响应数据的时候，Vue 的 DOM 早就已经渲染好了</p><p>但是数据改变 —&gt; DOM 重新渲染仍然是一个异步过程，所以即使在我们拿到数据后，也要异步初始化 better-scroll</p></li></ul></li></ul><h5 id="场景3：数据的动态更新"><a href="#场景3：数据的动态更新" class="headerlink" title="场景3：数据的动态更新"></a><strong>场景3：数据的动态更新</strong></h5><ul><li><p>实际开发中，除了数据异步获取，还有一些场景可以<strong>动态更新列表中的数据</strong>，比如常见的下拉加载，上拉刷新</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  this.loadData()</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  loadData() &#123;</span><br><span class="line">    requestData().then((res) =&gt; &#123;</span><br><span class="line">      this.data = res.data.concat(this.data)</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        if (!this.scroll) &#123;</span><br><span class="line">          this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span><br><span class="line">          this.scroll.on(&#x27;touchend&#x27;, (pos) =&gt; &#123;</span><br><span class="line">            // 下拉动作</span><br><span class="line">            if (pos.y &gt; 50) &#123;</span><br><span class="line">              this.loadData()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.scroll.refresh()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>滑动列表松开手指时，better-scroll 会对外派发一个 touchend 事件，我们监听了这个事件，并且判断了 pos.y &gt; 50（我们把这个行为定义成一次下拉的动作）</li><li>如果是下拉的话我们会重新请求数据，并且把新的数据和之前的 data 做一次 concat，也就更新了列表的数据，数据的改变就会映射到 DOM 的变化</li><li>这里我们对 this.scroll 做了判断，如果没有初始化过我们会通过 new BScroll 初始化，并且绑定一些事件，否则我们会调用 this.scroll.refresh 方法重新计算，来确保滚动效果的正常。</li></ul></li></ul><h4 id="5-封装"><a href="#5-封装" class="headerlink" title="5. 封装"></a>5. 封装</h4><p>目的解耦合。每个组件都用，对这个框架依赖性太强了。所以先封装，需要的组件只需要引入封装就可以。框架改变时，只需要修改封装就可以，而不需要每个组件都修改。</p><ul><li><p>scroll 组件本质上就是一个可滚动的列表组件，至于列表的 DOM 结构，用什么标签，都不是 scroll 组件关心的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;slot&gt;   &lt;/slot&gt;         //插槽</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>对 better-scroll 做一层 Vue 的封装，通过 props 的形式，把一些对 better-scroll 定制化的控制权交给父组件；</li><li>通过 methods 暴露的一些方法对 better-scroll 的方法做一层代理；</li><li>通过 watch 传入的 data，当 data 发生改变的时候，在适当的时机调用 refresh 方法重新计算 better-scroll 确保滚动效果正常；</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/ecmascript-6&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">&#x27;better-scroll&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1 滚动的时候会派发scroll事件，会截流。</span></span><br><span class="line"><span class="comment">       * 2 滚动的时候实时派发scroll事件，不会截流。</span></span><br><span class="line"><span class="comment">       * 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">probeType</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 点击列表是否派发click事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">click</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否开启横向滚动</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">scrollX</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否派发滚动事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">listenScroll</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 列表的数据</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Array</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">null</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否派发滚动到底部的事件，用于上拉加载</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">pullup</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否派发顶部下拉的事件，用于下拉刷新</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">pulldown</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否派发列表滚动开始的事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">beforeScroll</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 当数据更新后，刷新scroll的延时。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">refreshDelay</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 保证在DOM渲染完毕后初始化better-scroll</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._initScroll()</span><br><span class="line">      &#125;, <span class="number">20</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">_initScroll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.$refs.wrapper) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// better-scroll的初始化</span></span><br><span class="line">        <span class="built_in">this</span>.scroll = <span class="keyword">new</span> BScroll(<span class="built_in">this</span>.$refs.wrapper, &#123;</span><br><span class="line">          <span class="attr">probeType</span>: <span class="built_in">this</span>.probeType,</span><br><span class="line">          <span class="attr">click</span>: <span class="built_in">this</span>.click,</span><br><span class="line">          <span class="attr">scrollX</span>: <span class="built_in">this</span>.scrollX</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否派发滚动事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.listenScroll) &#123;</span><br><span class="line">          <span class="built_in">this</span>.scroll.on(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">(<span class="params">pos</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;scroll&#x27;</span>, pos)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否派发滚动到底部事件，用于上拉加载</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.pullup) &#123;</span><br><span class="line">          <span class="built_in">this</span>.scroll.on(<span class="string">&#x27;scrollEnd&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 滚动到底部</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.scroll.y &lt;= (<span class="built_in">this</span>.scroll.maxScrollY + <span class="number">50</span>)) &#123;</span><br><span class="line">              <span class="built_in">this</span>.$emit(<span class="string">&#x27;scrollToEnd&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否派发顶部下拉事件，用于下拉刷新</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.pulldown) &#123;</span><br><span class="line">          <span class="built_in">this</span>.scroll.on(<span class="string">&#x27;touchend&#x27;</span>, <span class="function">(<span class="params">pos</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 下拉动作</span></span><br><span class="line">            <span class="keyword">if</span> (pos.y &gt; <span class="number">50</span>) &#123;</span><br><span class="line">              <span class="built_in">this</span>.$emit(<span class="string">&#x27;pulldown&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否派发列表滚动开始的事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.beforeScroll) &#123;</span><br><span class="line">          <span class="built_in">this</span>.scroll.on(<span class="string">&#x27;beforeScrollStart&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;beforeScroll&#x27;</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">refresh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 代理better-scroll的refresh方法</span></span><br><span class="line">        <span class="built_in">this</span>.scroll &amp;&amp; <span class="built_in">this</span>.scroll.refresh()</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">scrollTo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 代理better-scroll的scrollTo方法</span></span><br><span class="line">        <span class="built_in">this</span>.scroll &amp;&amp; <span class="built_in">this</span>.scroll.scrollTo.apply(<span class="built_in">this</span>.scroll, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">scrollToElement</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 代理better-scroll的scrollToElement方法</span></span><br><span class="line">        <span class="built_in">this</span>.scroll &amp;&amp; <span class="built_in">this</span>.scroll.scrollToElement.apply(<span class="built_in">this</span>.scroll, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="comment">// 监听数据的变化，延时refreshDelay时间后调用refresh方法重新计算，保证滚动效果正常</span></span><br><span class="line">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.refresh()</span><br><span class="line">        &#125;, <span class="built_in">this</span>.refreshDelay)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>使用：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">scroll</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">:pulldown</span>=<span class="string">&quot;pulldown&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          @<span class="attr">pulldown</span>=<span class="string">&quot;loadData&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in data&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loading-wrapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">scroll</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">&#x27;better-scroll&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">data</span>: [],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">pulldown</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.loadData()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="title">loadData</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        requestData().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">this</span>.data = res.data.concat(<span class="built_in">this</span>.data)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="toast插件封装"><a href="#toast插件封装" class="headerlink" title="toast插件封装"></a>toast插件封装</h2><h3 id="1-index-js定义"><a href="#1-index-js定义" class="headerlink" title="1. index.js定义"></a>1. index.js定义</h3><ul><li>导入对应的组件</li><li>创建当前的插件对象</li><li>定义装载方法install</li><li>暴露插件对象</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//导入组件</span><br><span class="line">import Toast from &#x27;./Toast&#x27;</span><br><span class="line"></span><br><span class="line">const obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// install方法：main.js里面的Vue.use(toast)本质会来调用这里的install方法，执行这个函数</span><br><span class="line">obj.install = function(Vue) &#123;</span><br><span class="line">    // 1.创建组件构造器</span><br><span class="line">    const toastConstructor = Vue.extend(Toast)</span><br><span class="line"></span><br><span class="line">    // 2.new一个组件对象</span><br><span class="line">    const toast = new toastConstructor()</span><br><span class="line"></span><br><span class="line">    // 3.toast.$mount函数将组件对象手动挂载到某个元素上</span><br><span class="line">    toast.$mount(document.createElement(&#x27;div&#x27;))</span><br><span class="line"></span><br><span class="line">    // 4.将挂载了组件对象的元素添加到body，toast.$el对应的是div</span><br><span class="line">    document.body.appendChild(toast.$el)</span><br><span class="line"></span><br><span class="line">    // 5.将组件对象挂载到Vue的原型上</span><br><span class="line">    Vue.prototype.$toast = toast</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 暴露当前插件</span><br><span class="line">export default obj</span><br></pre></td></tr></table></figure><h3 id="2-main-js使用"><a href="#2-main-js使用" class="headerlink" title="2. main.js使用"></a>2. main.js使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import toast from &#x27;./toast/index&#x27;</span><br><span class="line">Vue.use(toast)   // 会去执行index.js里面的install方法</span><br></pre></td></tr></table></figure><h3 id="3-toast组件"><a href="#3-toast组件" class="headerlink" title="3. toast组件"></a>3. toast组件</h3><ul><li><p>定义数据data：message：显示内容，isShow： 是否显示</p></li><li><p>定义方法：控制是否显示、显示持续时间。（延迟定时器,时间一到，清空message，isShow变为false）</p></li><li><p>定义样式：显示时候的样式，位置</p></li><li><p>使用的地方用：this.$toast.show(‘hahaha’, 2000)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目3：购物街项目:学习笔记</title>
      <link href="/2021/12/13/%E9%A1%B9%E7%9B%AE3%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%A1%97%E9%A1%B9%E7%9B%AE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/12/13/%E9%A1%B9%E7%9B%AE3%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%A1%97%E9%A1%B9%E7%9B%AE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2020年11月-12月大概</li><li>项目背景： 给师姐做的（首页功能+购物车）</li><li>项目记录篇，比较啰嗦</li></ul><h2 id="项目首页Home笔记"><a href="#项目首页Home笔记" class="headerlink" title="项目首页Home笔记"></a>项目首页Home笔记</h2><h3 id="项目相关配置：项目的目录结构划分（主要是Src）"><a href="#项目相关配置：项目的目录结构划分（主要是Src）" class="headerlink" title="项目相关配置：项目的目录结构划分（主要是Src）"></a>项目相关配置：项目的目录结构划分（主要是Src）</h3><ul><li><p>去掉public里面的index.hml 的 favicon图标，去掉初始化的hellworld.vue</p></li><li><p>assets</p><ul><li>img<ul><li>cart</li><li>common</li><li>detail</li><li>home</li><li>profile</li><li>tabbar</li></ul></li><li>css<ul><li>normalize.css</li><li>base.css</li></ul></li></ul></li><li><p>components</p><ul><li>common （这里放不仅仅当前项目可以用的，完全抽离的，还可以在将来的组件中应用）<ul><li>tabbar 文件夹: TabBar.vue    TabBarItem.vue</li><li>navbar文件夹: NavBar.vue</li><li>scroll文件夹:    Scroll.vue</li><li>swiper文件夹 ：  index.js    Swiper.vue    SwiperItem.vue</li><li>toast文件夹 :        index.js    Toast.vue</li></ul></li><li>content（和业务相关的公共组件，只针对当前项目）<ul><li>maintabbar 文件夹:  MainTabBar.vue  （该组件实现了对底部4个模块的封装）</li><li>backTop文件夹:   BackTop.vue</li></ul></li><li>goods文件夹：    GoodsList.vue    GoodsListItem.vue  <ul><li>tabcontrol文件夹：  TabControl.vue  </li></ul></li></ul></li><li><p>views (我不希望把所有的组件全写在一起。整个页面业务相关的组件都放在这里)</p><ul><li><p>home文件夹： Home.vue   和  childComps文件夹<br>childComps：</p><ul><li><p>FeatureView.vue</p></li><li><p>homeswiper.vue</p></li><li><p>RecommendView.vue</p></li></ul></li><li><p>cart文件夹:  Cart.vue 和   childComps文件夹<br>childComps文件夹:</p><ul><li>CartBottomBar</li><li>CartList</li><li>CartListItem</li><li>CheckButton</li></ul></li><li><p>detail文件夹： Detail组件  +   childComps文件夹<br>childComps文件夹：</p><ul><li>DetailImageInfo</li><li>DetailBaseInfo</li><li>DetailBottomBar</li><li>DetailCommentInfo</li><li>DetailGoodsInfo</li><li>DetailNavBar</li><li>DetailParamInfo</li><li>DetailShopInfo</li><li>DeatailSwiper</li></ul></li><li><p>category文件夹  (无)</p></li><li><p>profile文件夹    （无）</p></li></ul></li><li><p>router</p><ul><li>index.js   （这里存放的是路由配置信息）</li></ul></li><li><p>store</p><ul><li>index.js </li><li>mutation-type.js</li><li>actions.js</li><li>mutation.js</li><li>getters.js</li></ul></li><li><p>network   (网络请求的封装)</p><ul><li>request.js</li><li>home.js    这里封装了对首页数据的请求</li><li>detail.js</li></ul></li><li><p>common</p><ul><li>const.js   （抽出的常量）</li><li>util.js   （公共的方法或函数）</li><li>mixin.js    (混入)</li></ul></li></ul><h4 id="3-normalize-css和base-css"><a href="#3-normalize-css和base-css" class="headerlink" title="3.normalize.css和base.css"></a>3.normalize.css和base.css</h4><ul><li>去github上面下载normalize.css</li><li>放入相应的文件夹中，在base.css中引入它</li><li>将base.css在app.vue中使用</li></ul><h4 id="4-vue-config-js文件和-editorconfig"><a href="#4-vue-config-js文件和-editorconfig" class="headerlink" title="4.vue.config.js文件和.editorconfig"></a>4.vue.config.js文件和.editorconfig</h4><ul><li>目的是为了配置路径别名的问题  cli2中，自动生成的base.config里面可以尽心更改。但cli3中是没有的，我们在项目下新建 vue.config.js文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        &#x27;assets&#x27;: &#x27;@/assets&#x27;,</span><br><span class="line">        &#x27;common&#x27;: &#x27;@/common&#x27;,</span><br><span class="line">        &#x27;components&#x27;: &#x27;@/components&#x27;,</span><br><span class="line">        &#x27;network&#x27;: &#x27;@/network&#x27;,</span><br><span class="line">        &#x27;views&#x27;: &#x27;@/views&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cli2中，自动生成的.editorconfig里面可以尽行更改。这里主要对整个项目的代码风格的统一<br>而cli3中没有的，我们可以把之前的拿过来。比如一个公司的不同项目代码风格基本是一致的</li></ul><h4 id="5-配置之前写好的MainBar组件"><a href="#5-配置之前写好的MainBar组件" class="headerlink" title="5.配置之前写好的MainBar组件"></a>5.配置之前写好的MainBar组件</h4><ul><li>设置common里的文件tabbar 文件夹和maintabbar文件夹。并更改maintabbar里面的图片src</li><li>因为这是我们从上一个项目里拿出来的，所以路径是要注意匹配的，方式参考vue.config.js</li><li>将MainBar组件导入到App.vue里面</li></ul><h4 id="6-项目模块的划分与路由配置信息"><a href="#6-项目模块的划分与路由配置信息" class="headerlink" title="6.项目模块的划分与路由配置信息"></a>6.项目模块的划分与路由配置信息</h4><ul><li><p>在views文件夹下创建4个子文件夹，每个文件夹下的组件只与你当前的页面相关</p></li><li><p>router文件夹下的index.js里。。在main.js里面导入+注册</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">//路由的懒加载</span><br><span class="line">const Home = () =&gt; import(&#x27;views/home/Home&#x27;)</span><br><span class="line">const Profile = () =&gt; import(&#x27;views/profile/Profile&#x27;)</span><br><span class="line">const Cart = () =&gt; import(&#x27;views/cart/Cart&#x27;)</span><br><span class="line">const Category = () =&gt; import(&#x27;views/category/Category&#x27;)</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;&#x27;,</span><br><span class="line">    redirect: &#x27;/home&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/profile&#x27;,</span><br><span class="line">    component: Profile</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/cart&#x27;,</span><br><span class="line">    component: Cart</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/category&#x27;,</span><br><span class="line">    component: Category</span><br><span class="line">  &#125;]</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: &#x27;history&#x27;,</span><br><span class="line">&#125;)</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure></li><li><p>我在这里遇到了问题：<br>在点击首页之后，相应的页面没有显示？</p><ul><li>因为我在App.vue里没有加router-view，导致每个按钮点击后相关的组件全显示不出来</li></ul></li></ul><p>购物车页面又显示不出来????</p><ul><li><p>模板里的每个标签绑定了一个to属性。它告诉子组件，我现在在这个路径，你去router的配置里面，找跟我路径匹配的路由对象，并把它在我的页面展示出来。</p><ul><li>to属性上的跟每个路由对象里的path是必须一致的。原来的/shopcart  而路由里面/cart。。他根本就没有建立联系，所以也不会显示内容</li></ul><p>第三个疑惑问题：为什么Home组件并没有在APP中进行引入，却可以在页面中显示呢？</p><ul><li>这其实跟上面的原理都是一致的。因为页面展示出来的内容是通过路由配置信息找到的组件，再由router-view将这部分组件的内容进行展示。<br>路由相关知识总结：<a href="https://www.cnblogs.com/samweb/p/6610733.html">https://www.cnblogs.com/samweb/p/6610733.html</a></li></ul></li></ul><h3 id="1-导航栏开发"><a href="#1-导航栏开发" class="headerlink" title="1. 导航栏开发"></a>1. 导航栏开发</h3><ul><li><p>显示效果<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201202204147460.png" alt="image-20201202204147460"></p></li><li><p>NavBar组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;nav-bar&quot;&gt;</span><br><span class="line">    &lt;!-- 1.注意这里不要对slot进行直接布局，而是用div给他包起来，给div布局 --&gt;</span><br><span class="line">    &lt;!-- 2.插槽必须要有名字，这样我们插得时候才能对应起来，指定替换的是哪一个 --&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;&lt;slot name=&quot;center&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;NavBar&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  /* 为插槽设置样式，使用flex布局 */</span><br><span class="line">  .nav-bar &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    /* 导航栏的高度一般是44.如果是有导航栏高度是64 */</span><br><span class="line">    height: 44px;</span><br><span class="line">    line-height: 44px;</span><br><span class="line">    box-shadow: 0 1px 1px rgba(100, 100, 100, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  /* 一般左边插槽时固定的，右边也是，中间占用剩余的 */</span><br><span class="line">  .left,</span><br><span class="line">  .right &#123;</span><br><span class="line">    width: 60px;</span><br><span class="line">  &#125;</span><br><span class="line">  .center &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>```</p><pre><code>&lt;nav-bar class=&quot;home-nav&quot;&gt;  &lt;div slot = &quot;center&quot;&gt;购物街&lt;/div&gt;&lt;/nav-bar&gt;导入+注册&lt;style scoped&gt;  .home-nav &#123;    background-color: var(--color-tint);    color: #fff;  &#125;</code></pre><p></style></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 分析： </span><br><span class="line"></span><br><span class="line">  + 容易忘记在Home里面导入，最易犯错的是没有在components里面注册就使用</span><br><span class="line"></span><br><span class="line">  + 首先这个组件有左、中、右三部分。这三个位置设置了插槽，通过Home组件里v-slot，和子组件里的插槽name，我们可以随意指定哪一个位置的内容是什么。如果我们不想用哪个插槽，只要Home组件里没有与它对应的标签即可</span><br><span class="line">  + 插槽里面的内容如何实现定制呢？</span><br><span class="line">    在Home组件里，我们通过导入和注册的子组件里，把想插入的元素用div之类的包裹即可。注意slot名字要与子组件名字对应</span><br><span class="line"></span><br><span class="line">### 2.网络数据的请求封装 ###</span><br><span class="line"></span><br><span class="line">+ 网络请求文件是在network下面进行的。我们不要在每个子组件下都进行网络请求。一来，容易服务器拥挤</span><br><span class="line"></span><br><span class="line">  二来，当我有一天服务器借口进行改变时，所有的子组件都要进行更高。这对于项目开发来说是非常灾难的。所以不要这样做，不易维护</span><br><span class="line"></span><br><span class="line">+ 首先是request.js文件</span><br><span class="line"></span><br><span class="line">  ```vue</span><br><span class="line">  //首先要安装axios：npm install axios@0.18.0 --save    再导入axios</span><br><span class="line">  import axios from &#x27;axios&#x27;</span><br><span class="line">  export function request(config) &#123;</span><br><span class="line">    // 1.创建axios的实例</span><br><span class="line">    const instance = axios.create(&#123;</span><br><span class="line">      //换掉端口地址</span><br><span class="line">      baseURL: &#x27;http://152.136.185.210:8000/api/w6&#x27;,</span><br><span class="line">      timeout: 5000</span><br><span class="line">    &#125;)</span><br><span class="line">    // 2.axios的拦截器</span><br><span class="line">    // 2.1.请求拦截的作用</span><br><span class="line">    instance.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">      return config</span><br><span class="line">    &#125;, err =&gt; &#123;&#125;)</span><br><span class="line">    // 2.2.响应拦截</span><br><span class="line">    instance.interceptors.response.use(res =&gt; &#123;</span><br><span class="line">      return res.data</span><br><span class="line">    &#125;, err =&gt; &#123;&#125;)</span><br><span class="line">    // 3.发送真正的网络请求</span><br><span class="line">    return instance(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>home.js文件</p><ul><li>为什么还要进行一个封装？难道request不够吗？<ul><li>这种封装的意义在于，home组件面向home.js开发。home组件里所有需要获取的内容，你只需要调用这个函数，而不需要关心数据请求中url之类的配置.因为调用的封装函数已经设置过这些</li><li>当有一天借口发生了变化，我们只需要在这里进行修改，对应的home组件的数据自动发生相应的更新。如果我们去home组件里进行网络请求，则会造成，所有url的地方都需要修改。当项目组件很多的时候，这是很恐怖的</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对首页数据的封装请求写在这里。而不是在request中完成对所有数据的封装</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import &#123; request &#125; from &#x27;./request&#x27;</span><br><span class="line">//封装的是一个函数，他的名字叫getHomeMultidata</span><br><span class="line">export function getHomeMultidata () &#123;</span><br><span class="line">  //这里返回的是一个promise对象，在那边进行.then拿到结果</span><br><span class="line">  return request(&#123;</span><br><span class="line">    url: &#x27;/home/multidata&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Home组件：拿到了待会要用的数据，并进行了初次的保存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//因为那边没有default导出，所以不能去掉大括号！！！！</span><br><span class="line">import &#123;getHomeMultidata&#125; from &#x27;network/home&#x27;</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      result: null,</span><br><span class="line">      banners: [],</span><br><span class="line">      recommends: [],</span><br><span class="line">      keywords: [],</span><br><span class="line">      dKeywords: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //当首页组件创建完成之后，赶紧进行网络请求，待会要进行展示</span><br><span class="line">  created () &#123;</span><br><span class="line">    //1.请求多个数据    getHomeMultidata()调用函数，进行数据请求   .then()拿到请求后的结果</span><br><span class="line">    getHomeMultidata().then( res =&gt; &#123;</span><br><span class="line">      this.result = res;</span><br><span class="line">    //这个函数调用的时候会有函数执行栈，在调用结束后执行栈里面的数据会被全部销毁掉，所以我们要对他进行一个保存</span><br><span class="line">    </span><br><span class="line">    //垃圾回收机制：时间---等到没有引用指向他的时候进行垃圾回收。res指向的是一个对象，当执行完之后，</span><br><span class="line">    //会销毁掉变量res。此时rs指向的那个数据里面就没有被引用了，孤零零，最后垃圾回收机制会将它也销毁掉，</span><br><span class="line">    //result对res赋值，其实是内存地址。而此时的数据对象有了reult来引用他，所以这个数据不会被销毁掉</span><br><span class="line">    //其实这跟堆栈相关，以及执行上下文栈</span><br><span class="line">    //可以通过devtool插件里面的vue的HOME结构下看到result里面已经保存了数据</span><br><span class="line">    </span><br><span class="line">    //改进。从数据对象里面取出来每一项</span><br><span class="line">    this.banners = res.data.banner.list</span><br><span class="line">    this.recommends = res.data.recommend.list</span><br><span class="line">    //注意这里请求过来的数据里就是复数</span><br><span class="line">    this.keywords = res.data.keywords</span><br><span class="line">    this.dKeywords = res.data.dKeywords</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补充两个知识点：</p><ul><li><h5 id="模块的导入导出方式："><a href="#模块的导入导出方式：" class="headerlink" title="模块的导入导出方式："></a>模块的导入导出方式：</h5><ul><li><p>commandJs方式（导入导出对象）：modules.exports = {}    var aa = require(‘路径文件’)</p></li><li><p>ES6方式：</p><ul><li><p>直接导入变量：import  {a}  from ‘~~’ ，必须有花括号</p></li><li><p>统一全部导入：import  {a,b,c}  from ‘~~’ (函数，类，变量都可以)</p></li><li><p>导出函数/类：export function aa(){}       export class bb{}</p></li><li><p>默认导出：export default {}   只能有一个默认导出，在对这种进行导入的时候可以随意起名字<br>例如：import  AA  from  ‘路径文件’ </p></li></ul></li></ul></li><li><h5 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a><strong>Vue的生命周期</strong></h5><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p><p><strong>实例生命周期钩子</strong></p><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。对应的8个生命周期钩子函数：</p><ul><li><strong>beforeCreate、created</strong>、</li><li><strong>beforeMount、mounted</strong>、</li><li><strong>beforeUpdate、updated</strong>、</li><li><strong>beforeDestroy、destroyed</strong></li></ul><p><strong>Vue的生命周期图示（官方中文文档）</strong></p><img src="https://img-blog.csdnimg.cn/20200418104137666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX1RvZ2V0aGVy,size_16,color_FFFFFF,t_70" alt="官方图示" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20200418101911580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX1RvZ2V0aGVy,size_16,color_FFFFFF,t_70" alt="图片转自coderwhy老师" style="zoom: 50%;" /><p><strong>Vue的生命周期过程详解（主要以钩子函数为主线）</strong></p><p><strong>1、beforeCreate：</strong><br>实例组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行 beforeCreate 钩子函数，<strong>数据和 dom 都未初始化</strong>（取不到），一般不做任何操作。</p><p><strong>2、created：</strong><br><strong>挂载数据，绑定事件已完成</strong>，然后执行created函数，这个时候已经可以操作数据, 而且不会触发 updated 函数，一般在这里做初始数据的获取（相比在 beforeMount 获取数据页面渲染速度较快）。</p><p><strong>3、beforeMount：</strong><br>执行这个函数前，<strong>虚拟dom 创建完成，真实 dom未完成挂载</strong>。这里更改数据不会触发 updated ，在这里也可以做初始数据的获取。</p><p><strong>4、mounted：</strong><br>执行 mounted 钩子函数前，<strong>数据、真实dom都已经处理好了</strong>,事件也挂载好了，一般在这里初始化一些操作真实 dom 的方法。</p><p><strong>5、beforeUpdate：</strong><br>当组件或实例的数据更改，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。可以监听到 <strong>data 变化，但view层的数据还没有变化</strong>。一般不做任何操作。</p><p><strong>6、updated：</strong><br>view层的数据重新渲染完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</p><p><strong>7、beforeDestroy：</strong><br>当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、数据和事件的监听等。</p><p><strong>8、destroyed：</strong><br>组件的数据绑定、事件监听清除后只剩下dom空壳，这个时候，执行 destroyed 彻底销毁实例，如果在 beforeDestroy 没有做善后工作，在这里做善后工作也可以。</p><p><strong>注</strong>：掌握各个钩子函数执行时的环境，并在项目开发中正确使用显得尤为重要，能避免一些基础的bug。</p></li></ul></li></ul><h3 id="3-首页轮播图"><a href="#3-首页轮播图" class="headerlink" title="3.首页轮播图"></a>3.首页轮播图</h3><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201202204213590.png" alt="image-20201202204213590"></p><ul><li><p>Home组件</p><ul><li>轮播图是放在首页导航栏的下面的。但是这一部分我们不要直接在Home组件里写。Home组件下面还有要显示的内容，如果我们都写在这里最后，Home会越来越多。所以只要是个独立的一块，我们都要进行封装</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;home-swiper :banners = &quot;banners&quot;&gt;&lt;/home-swiper&gt;</span><br><span class="line">import HomeSwiper from &#x27;./homeswiper/HomeSwiper&#x27;</span><br></pre></td></tr></table></figure></li><li><p>在homeswiper下的HomeSwiper组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- home里面放主要的逻辑，组件里面怎么封装的，我并不关心。所以不要把swiper直接写在这里，抽离到home的新文件下，放他的子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;swiper&gt;</span><br><span class="line">    &lt;!-- 轮播的每一项用swiper-item  SwiperItem的组件里面预留了插槽，所以我们可以往里面插入我想插入的东西--&gt;</span><br><span class="line">    &lt;!-- 这里不要创建4个项，而是循环起来 从banners里面取出数据，取代插槽里面的内容--&gt;</span><br><span class="line">    &lt;swiper-item v-for=&quot;item in banners&quot; :key=&quot;item.index&quot;&gt;</span><br><span class="line">      &lt;!-- 因为图片是可以点击的，所以这里我们要给他包装一个标签a --&gt;</span><br><span class="line">      &lt;!-- 链接中href属性是获取数据banners里面有一个link --&gt;</span><br><span class="line">      &lt;a :href=&quot;item.link&quot;&gt;</span><br><span class="line">        &lt;!-- item.image是不对的，要动态绑定，所以要绑定到image里面的src上面--&gt;</span><br><span class="line">        &lt;img :src=&quot;item.image&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/swiper-item&gt;</span><br><span class="line">  &lt;/swiper&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//因为index.js文件对导出组件进行同一导出，所以这里我们不需要再一个一个地导入了</span><br><span class="line"> //因为那边没有default导出，所以不能去掉大括号！！！！</span><br><span class="line">import &#123;Swiper, SwiperItem&#125; from &#x27;components/common/swiper&#x27;</span><br><span class="line">    //等价于：// import Swiper from &#x27;components/common/swiper/Swiper&#x27;</span><br><span class="line">// import SwiperItem from &#x27;components/common/swiper/SwiperItem&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;HomeSwiper&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      banners: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Swiper,</span><br><span class="line">      SwiperItem</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>Swiper组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;hy-swiper&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;swiper&quot; @touchstart=&quot;touchStart&quot; @touchmove=&quot;touchMove&quot; @touchend=&quot;touchEnd&quot;&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;slot name=&quot;indicator&quot;&gt;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">      &lt;div class=&quot;indicator&quot;&gt;</span><br><span class="line">        &lt;slot name=&quot;indicator&quot; v-if=&quot;showIndicator &amp;&amp; slideCount&gt;1&quot;&gt;</span><br><span class="line">          &lt;div v-for=&quot;(item, index) in slideCount&quot; class=&quot;indi-item&quot; :class=&quot;&#123;active: index === currentIndex-1&#125;&quot; :key=&quot;index.id&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &quot;Swiper&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      interval: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">        default: 3000</span><br><span class="line">      &#125;,</span><br><span class="line">      animDuration: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">        default: 300</span><br><span class="line">      &#125;,</span><br><span class="line">      moveRatio: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 0.25</span><br><span class="line">      &#125;,</span><br><span class="line">      showIndicator: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">        slideCount: 0, // 元素个数</span><br><span class="line">        totalWidth: 0, // swiper的宽度</span><br><span class="line">        swiperStyle: &#123;&#125;, // swiper样式</span><br><span class="line">        currentIndex: 1, // 当前的index</span><br><span class="line">        scrolling: false, // 是否正在滚动</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: function () &#123;</span><br><span class="line">      // 1.操作DOM, 在前后添加Slide</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        this.handleDom();</span><br><span class="line"></span><br><span class="line">        // 2.开启定时器</span><br><span class="line">        this.startTimer();</span><br><span class="line">      &#125;, 100)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">  /*** 定时器操作*/</span><br><span class="line">      startTimer: function () &#123;</span><br><span class="line">    this.playTimer = window.setInterval(() =&gt; &#123;</span><br><span class="line">      this.currentIndex++;</span><br><span class="line">      this.scrollContent(-this.currentIndex * this.totalWidth);</span><br><span class="line">        &#125;, this.interval)</span><br><span class="line">      &#125;,</span><br><span class="line">      stopTimer: function () &#123;</span><br><span class="line">        window.clearInterval(this.playTimer);</span><br><span class="line">      &#125;,</span><br><span class="line">      /*** 滚动到正确的位置*/</span><br><span class="line">      scrollContent: function (currentPosition) &#123;</span><br><span class="line">        // 0.设置正在滚动</span><br><span class="line">        this.scrolling = true;// 1.开始滚动动画</span><br><span class="line">        this.swiperStyle.transition =&#x27;transform &#x27;+ this.animDuration + &#x27;ms&#x27;;</span><br><span class="line">        this.setTransform(currentPosition);</span><br><span class="line"></span><br><span class="line">        // 2.判断滚动到的位置</span><br><span class="line">        this.checkPosition();</span><br><span class="line"></span><br><span class="line">        // 4.滚动完成</span><br><span class="line">        this.scrolling = false</span><br><span class="line">      &#125;,</span><br><span class="line">      //校验正确的位置</span><br><span class="line">      checkPosition: function () &#123;</span><br><span class="line">        window.setTimeout(() =&gt; &#123;</span><br><span class="line">          // 1.校验正确的位置</span><br><span class="line">          this.swiperStyle.transition = &#x27;0ms&#x27;;</span><br><span class="line">          if (this.currentIndex &gt;= this.slideCount + 1) &#123;</span><br><span class="line">            this.currentIndex = 1;</span><br><span class="line">            this.setTransform(-this.currentIndex * this.totalWidth);</span><br><span class="line">          &#125; else if (this.currentIndex &lt;= 0) &#123;</span><br><span class="line">            this.currentIndex = this.slideCount;</span><br><span class="line">            this.setTransform(-this.currentIndex * this.totalWidth);</span><br><span class="line">          &#125;</span><br><span class="line">          // 2.结束移动后的回调</span><br><span class="line">          this.$emit(&#x27;transitionEnd&#x27;, this.currentIndex-1);</span><br><span class="line">        &#125;, this.animDuration)</span><br><span class="line">      &#125;,</span><br><span class="line">      //设置滚动的位置</span><br><span class="line">      </span><br><span class="line">      setTransform: function (position) &#123;</span><br><span class="line">        this.swiperStyle.transform = `translate3d($&#123;position&#125;px, 0, 0)`;</span><br><span class="line">        this.swiperStyle[&#x27;-webkit-transform&#x27;] = `translate3d($&#123;position&#125;px), 0, 0`;</span><br><span class="line">        this.swiperStyle[&#x27;-ms-transform&#x27;] = `translate3d($&#123;position&#125;px), 0, 0`;</span><br><span class="line">      &#125;,</span><br><span class="line">       //操作DOM, 在DOM前后添加Slide</span><br><span class="line">       </span><br><span class="line">  handleDom: function () &#123;</span><br><span class="line">        // 1.获取要操作的元素</span><br><span class="line">        let swiperEl = document.querySelector(&#x27;.swiper&#x27;);</span><br><span class="line">        let slidesEls = swiperEl.getElementsByClassName(&#x27;slide&#x27;);</span><br><span class="line">        // 2.保存个数</span><br><span class="line">        this.slideCount = slidesEls.length;</span><br><span class="line">        // 3.如果大于1个, 那么在前后分别添加一个slide</span><br><span class="line">        if (this.slideCount &gt; 1) &#123;</span><br><span class="line">          let cloneFirst = slidesEls[0].cloneNode(true);</span><br><span class="line">          let cloneLast = slidesEls[this.slideCount - 1].cloneNode(true);</span><br><span class="line">          swiperEl.insertBefore(cloneLast, slidesEls[0]);</span><br><span class="line">          swiperEl.appendChild(cloneFirst);</span><br><span class="line">          this.totalWidth = swiperEl.offsetWidth;</span><br><span class="line">          this.swiperStyle = swiperEl.style;</span><br><span class="line">        &#125;</span><br><span class="line">        // 4.让swiper元素, 显示第一个(目前是显示前面添加的最后一个元素)</span><br><span class="line">        this.setTransform(-this.totalWidth);</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 拖动事件的处理</span><br><span class="line">       */</span><br><span class="line">      touchStart: function (e) &#123;</span><br><span class="line">        // 1.如果正在滚动, 不可以拖动</span><br><span class="line">        if (this.scrolling) return;</span><br><span class="line">        // 2.停止定时器</span><br><span class="line">        this.stopTimer();</span><br><span class="line">        // 3.保存开始滚动的位置</span><br><span class="line">        this.startX = e.touches[0].pageX;</span><br><span class="line">      &#125;,</span><br><span class="line">      touchMove: function (e) &#123;</span><br><span class="line">        // 1.计算出用户拖动的距离</span><br><span class="line">        this.currentX = e.touches[0].pageX;</span><br><span class="line">        this.distance = this.currentX - this.startX;</span><br><span class="line">        let currentPosition = -this.currentIndex * this.totalWidth;</span><br><span class="line">        let moveDistance = this.distance + currentPosition;</span><br><span class="line">        // 2.设置当前的位置</span><br><span class="line">        this.setTransform(moveDistance);</span><br><span class="line">      &#125;,</span><br><span class="line">      touchEnd: function (e) &#123;</span><br><span class="line">        // 1.获取移动的距离</span><br><span class="line">        let currentMove = Math.abs(this.distance);</span><br><span class="line">        // 2.判断最终的距离</span><br><span class="line">        if (this.distance === 0) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125; else if (this.distance &gt; 0 &amp;&amp; currentMove &gt; this.totalWidth * this.moveRatio) &#123; // 右边移动超过0.5</span><br><span class="line">          this.currentIndex--</span><br><span class="line">        &#125; else if (this.distance &lt; 0 &amp;&amp; currentMove &gt; this.totalWidth * this.moveRatio) &#123; // 向左移动超过0.5</span><br><span class="line">          this.currentIndex++</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.移动到正确的位置</span><br><span class="line">        this.scrollContent(-this.currentIndex * this.totalWidth);</span><br><span class="line">        // 4.移动完成后重新开启定时器</span><br><span class="line">        this.startTimer();</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 控制上一个, 下一个</span><br><span class="line">       */</span><br><span class="line">      previous: function () &#123;</span><br><span class="line">        this.changeItem(-1);</span><br><span class="line">      &#125;,</span><br><span class="line">      next: function () &#123;</span><br><span class="line">        this.changeItem(1);</span><br><span class="line">      &#125;,</span><br><span class="line">      changeItem: function (num) &#123;</span><br><span class="line">        // 1.移除定时器</span><br><span class="line">        this.stopTimer();</span><br><span class="line">        // 2.修改index和位置</span><br><span class="line">        this.currentIndex += num;</span><br><span class="line">        this.scrollContent(-this.currentIndex * this.totalWidth);</span><br><span class="line">        // 3.添加定时器</span><br><span class="line">        this.startTimer();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  #hy-swiper &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .swiper &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .indicator &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 100%;</span><br><span class="line">    bottom: 8px;</span><br><span class="line">  &#125;</span><br><span class="line">  .indi-item &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    width: 8px;</span><br><span class="line">    height: 8px;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    line-height: 8px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    margin: 0 5px;</span><br><span class="line">  &#125;</span><br><span class="line">  .indi-item.active &#123;</span><br><span class="line">    background-color: rgba(212,62,46,1.0);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>SwiperItem组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;slide&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &quot;Slide&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .slide &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    flex-shrink: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  .slide img &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>这块的难点与任务：</p><ul><li><p>那么点这两个组件时如何完成封装的，你会写出原生封装吗？</p></li><li><p>学习一个插件：vue-awesome-swiper  踏实如何实现轮播效果的呢？？组件图的封装，github上进行了封装‘，这些库学习的时候不建议随便用UI库，而是自己封装，自己才能明白是怎么封装的。。。。。</p></li></ul></li></ul><h3 id="4-首页推荐信息"><a href="#4-首页推荐信息" class="headerlink" title="4.首页推荐信息"></a>4.首页推荐信息</h3><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201202204250774.png" alt="image-20201202204250774"></p><ul><li><p>Home组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;home-recommend :recommends = &quot;recommends&quot;&gt;&lt;/home-recommend&gt;</span><br><span class="line">导入+注册</span><br></pre></td></tr></table></figure></li><li><p>HomeRecommend组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home-recommend&quot;&gt;</span><br><span class="line">    &lt;!-- 对轮播图里面的数据进行展示 --&gt;</span><br><span class="line">    &lt;div v-for=&quot;item in recommends&quot; </span><br><span class="line">        :key = &quot;item.index&quot;</span><br><span class="line">        class=&quot;recommend-item&quot;</span><br><span class="line">        &gt;</span><br><span class="line">      &lt;!-- 每个都是有标签的 ,数据中的link属性对应的就是每个图片点击后的超链接地址--&gt;</span><br><span class="line">      &lt;a :href=&quot;item.link&quot;&gt;</span><br><span class="line">        &lt;img :src=&quot;item.image&quot; alt=&quot;&quot; class=&quot;img&quot;&gt;</span><br><span class="line">        &lt;!-- 每个小图片有文字 --&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;item.title&#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;HomeRecommend&quot;,</span><br><span class="line">    //数据在首页里面，所以我们要接收，不然哪儿来的数据。而且父组件也要把数据传过来</span><br><span class="line">    //这两点总是爱忽略，遗漏</span><br><span class="line">    props: &#123;</span><br><span class="line">      recommends: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .home-recommend &#123;</span><br><span class="line">    /* 水平布局，flex，因为盒子全部在一列排列 */</span><br><span class="line">    display: flex;</span><br><span class="line">    width: 100%;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    /* 居中显示 */</span><br><span class="line">    text-align: center;</span><br><span class="line">    /* 让他与上面和下面拉开一点距离*/</span><br><span class="line">    padding: 10px 0 20px;</span><br><span class="line">    border-bottom: 8px solid #eee;</span><br><span class="line">  &#125;</span><br><span class="line">  .recommend-item &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">  &#125;</span><br><span class="line">  .recommend-item .img &#123;</span><br><span class="line">  /* 此时图片太大了。对图片进行限制 */</span><br><span class="line">  /* 与老师不同，我对这里的图片用的是百分比，不是定的px */</span><br><span class="line">    width: 80%;</span><br><span class="line">    height: 80%;</span><br><span class="line">    /* 图片和文字距离拉开 */</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-本周流行"><a href="#5-本周流行" class="headerlink" title="5. 本周流行"></a>5. 本周流行</h3><ul><li><p>这块只有一个图片，虽然看起来像很多个小图标。但我们还是将它封装成一个组件Feature</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203175355996.png" alt="image-20201203175355996"></p></li><li><p>FeatureView组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;feature&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;~assets/img/home/recommend_bg.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      //注意这里的src是有波浪线的</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;FeatureView&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.feature img&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>Home组件   导入+注册+使用该组件即可</p></li></ul><h3 id="6-控制栏"><a href="#6-控制栏" class="headerlink" title="6.控制栏"></a>6.控制栏</h3><ul><li><p>需求：点击这三个任一个，哪一个颜色改变，有下面的线，并展示相应的页面<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203180154105.png" alt="image-20201203180154105"></p><ul><li><p>分析：这种需求似乎跟之前的TabBar组件很像，但是这里我们并没有采用那种封装思想</p></li><li><p>TabBar的封装思想是：每一项都是文字+图标的形式，他们的展示形式也是一样的。将每一项抽离成一个组件进行封装，而组件里我们预留了插槽。我们将来用的时候，可以在插槽的位置填入想要定制化的内容。可以改变每次插入的文字，甚至可以改变个数，这时候就需要预留插槽</p></li><li><p>首先这个组件我是可以在第二页面进行复用的，他们都是一样的，只是文字不一样。如果这里我们也要这样做，带来的问题就是你用的时候组件里这样，他用的时候组件也这样。插槽的形式都是一样的，代码是重复的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不推荐 &lt;tab-bar&gt;&lt;span&gt;aa&lt;/span&gt;&lt;/tab-bar&gt;</span><br><span class="line">      &lt;tab-bar&gt;&lt;span&gt;bb&lt;/span&gt;&lt;/tab-bar&gt;</span><br><span class="line">      &lt;tab-bar&gt;&lt;span&gt;cc&lt;/span&gt;&lt;/tab-bar&gt;</span><br><span class="line">      &lt;tab-bar&gt;&lt;span&gt;dd&lt;/span&gt;&lt;/tab-bar&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>TabControl组件</p><ul><li><p>组件复用问题：</p><p>当我切换流行，时尚，详情时，组件页面并没有发生改变：</p><p>原因组件复用的问题。原来的图片。类似于之前的input复用问题。解决办法：绑定key</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;tab-control&quot;&gt;</span><br><span class="line">       &lt;!-- 点击哪一个，下面添加样式。样式的动态绑定 --&gt;</span><br><span class="line">       &lt;!-- 里面有几个span，是根据title有几项数据决定跟的 --&gt;</span><br><span class="line">     &lt;div v-for=&quot;(item, index) in titles&quot; </span><br><span class="line">          :key=&quot;(item, index)&quot;</span><br><span class="line">          class=&quot;tab-control-item&quot;</span><br><span class="line">          :class = &quot;&#123;active: index === currentIndex&#125;&quot;</span><br><span class="line">          @click = &quot;btnClick(index)&quot;&gt;</span><br><span class="line">      &lt;!-- 添加点击事件，点击哪一个，为其添加acive的class类 --&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;TabControl&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      //传进来title,告诉别人我用的时候你只需要给我传文字就可以了。</span><br><span class="line">      titles: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      //return 返回的是一个对象，不是函数！！！</span><br><span class="line">      return &#123;</span><br><span class="line">        currentIndex: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      btnClick(index) &#123;</span><br><span class="line">        this.currentIndex = index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .tab-control &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab-control .tab-control-item &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    height: 40px;</span><br><span class="line">    line-height: 40px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab-control-item span &#123;</span><br><span class="line">    /* 撑开一下便捷，左边和下边都会有一些距离 */</span><br><span class="line">    padding: 5px;</span><br><span class="line">  &#125;</span><br><span class="line">  .active &#123;</span><br><span class="line">    color: #ff5777;</span><br><span class="line">  &#125;</span><br><span class="line">  .active span &#123;</span><br><span class="line">    /* 不要整个部分全显示，而是现实span短横 */</span><br><span class="line">    border-bottom: 3px solid var(--color-tint);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>Home组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导入+注册</span><br><span class="line">   data里定义titles的内容： titles:[&#x27;流行&#x27;,&#x27;新款&#x27;,&#x27;精选&#x27;],</span><br><span class="line">   &lt;tab-control :titles = &quot;titles&quot; class=&quot;tab-control&quot;&gt;&lt;/tab-control&gt;</span><br><span class="line">   //这里为什么还有个class,跟下面的需求有关</span><br></pre></td></tr></table></figure></li></ul><ul><li>此时我们要实现一个需求：<ul><li>首页上面的导航栏，用户向下滚动的时候他不要跟着滚动，用定住最上面（固定定位），我这个组件也也同样固定在导航栏的下面（粘连定位）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.home-nav &#123;</span><br><span class="line">  background-color: var(--color-tint);</span><br><span class="line">  color: #fff;</span><br><span class="line">  /* 首页上面的导航栏，向下滚动的时候他不要滚动。采用固定定位，一直在最上面 */</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  z-index: 9;</span><br><span class="line">&#125;</span><br><span class="line">  #home &#123;</span><br><span class="line">  /* 如果这里没有44px,轮播图会跑到最上面，他的一部分就会被导航栏遮盖 */</span><br><span class="line"> padding-top: 44px;</span><br><span class="line">&#125;</span><br><span class="line">.tab-control &#123;</span><br><span class="line">  /* 想实现的功能是：页面向下滑，滑到一定高度后，顶部固定 */</span><br><span class="line">  /* 方法1：用定位做。方法2：后续用插件做 */</span><br><span class="line">  position: sticky;</span><br><span class="line">  // 距离顶部44px的时候，会变成fixed定位</span><br><span class="line">  top: 44px;</span><br><span class="line">  background-color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-控制栏点击之后的数据请求"><a href="#7-控制栏点击之后的数据请求" class="headerlink" title="7.控制栏点击之后的数据请求"></a>7.控制栏点击之后的数据请求</h3><ul><li><p>分析：</p><p>我们对这部分封装在content里，与业务逻辑有关,不是完全独立，又可以应用在该项目其他页面的某些地方</p><p>点击之后请求过来的数据是什么形式的呢?我们又如何保存？</p><ul><li><p>我们需要一个变量，这个变量不仅存储着流行 新款 精选 的数据  当用户点击对应的某一项时，就展示那一项的数据。所以我们会一次把数据都请求过来。这种思想其实跟tabbar一样一样的。但有一个问题：</p><p>流行的数据有很多页。数据量很大。？？？怎么保存</p></li><li><p>数据保存模型：</p><ul><li><p>拿到整体的数据goods,保存着三类数据，每一类数据对应着一个对象。</p></li><li><p>list对象里面存放的展示数据。page因为要展示的图片很多，他会显示我们当前浏览到第几页了</p><p>流行页面已经浏览了第5页，此时我点击新款页面，他应该是第1页。page就是记录这个页</p></li><li><p>当我点击流行按钮的时候，就要把pop对象里面的数据请求过来，点击新款时，把news里面的数据请求过来点击详情时，把sell里面的数据请求过来，展示他里面的数据。取数据是通过key实现的。</p></li><li><p>如果用户产生了上拉加载更多的操作，我们还应该改page.还需要list展示已经展示了多少条数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> goods: &#123;</span><br><span class="line">    &#x27;pop&#x27;: &#123;page： 1， list： []&#125;，每个数据对象 默认page，还有key和value记录当前模型加载到第几页的</span><br><span class="line">‘news&#x27;: &#123;&#125;,</span><br><span class="line">    &#x27;sell&#x27;: &#123;&#125;</span><br><span class="line"> &#125;//这个数据模型会帮我们把请求的数据保存下来</span><br></pre></td></tr></table></figure></li><li><p>第二种保存数据的方法：Map数据结构，？？？学习一下？？</p></li></ul></li></ul><ul><li><h5 id="数据请求操作："><a href="#数据请求操作：" class="headerlink" title="数据请求操作："></a>数据请求操作：</h5><p>同样我们要在network里面的home.js里完成请求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function getHomeGoods(type, page) &#123;</span><br><span class="line">  //这个函数跟上面不同，因为要针对不同的情况请求不同的数据，</span><br><span class="line">  //所以我们要传入参数一个时type，每一类你还要告诉我对应的页码，我有了页码采取请求对应的数据</span><br><span class="line">  return request (&#123;</span><br><span class="line">    url: &#x27;/home/data&#x27;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      type,</span><br><span class="line">      page</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Home组件里调用</p><ul><li>Level1   跟之前轮播图数据一样，在created里面调用home.js里的数据请求函数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//   getHomeGoods(type, 1).then(res =&gt; &#123;</span><br><span class="line">   //     console.log(res)</span><br><span class="line">   //   &#125;)</span><br></pre></td></tr></table></figure><p>但并不推荐这样做。因为避免created里面每个函数调用后我们在里面做较多的保存工作，我们要对这部分进一步封装在methods里面。至于created里面是怎么保存的我不关心。我只关心你的数据请求，所以最好只写主要逻辑</p><ul><li><p>把这部分功能放在methods里封装成函数，在created里面调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// getHomeGoods(type, page) &#123;</span><br><span class="line"> //   getHomeGoods(type, 1).then(res =&gt; &#123;</span><br><span class="line"> //     console.log(res)</span><br><span class="line"> //   &#125;)</span><br><span class="line"> // &#125;</span><br></pre></td></tr></table></figure></li><li><p>改进问题： 这样写page是死的，为了提升代码的复用性。当我浏览完第一个页面的第一页数据后，用户上拉加载更多，这时候要请求第二个数据了，但是我们将page固定位1，问题是我们还需要写新的函数来解决这个需求<br>解决：通过传入的type，获取到page。page初始化为0，我们希望3个页面在开始的时候都是请求第一页</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  this.getHomeMultidata()</span><br><span class="line">  //我们希望3个页面在开始的时候都是请求第一页</span><br><span class="line">  this.getHomeGoods(&#x27;pop&#x27;)</span><br><span class="line">  this.getHomeGoods(&#x27;new&#x27;)</span><br><span class="line">  this.getHomeGoods(&#x27;sell&#x27;)</span><br><span class="line">//注意这两个地方的调用必须写this。如果不写this，其实还是在调用home.js里面的函数</span><br><span class="line">//而我们实际想要调用的是methods里面的.他里面对数据进行了保存</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   getHomeGoods(type) &#123;</span><br><span class="line">      const page = this.goods[type].page + 1</span><br><span class="line">      getHomeGoods(type, page).then(res =&gt; &#123;</span><br><span class="line">        //获取到请求结果res，得到res.data我们要进行一个保存。存储数据的模型是goods</span><br><span class="line">        //问题：如何将一个数组的所有数据保存在另一个数组里面？</span><br><span class="line">        //第一种对第2个数据每一项进行遍历，然后每一项push塞进第一个数组</span><br><span class="line">        //方法2： 使用push方法  num2.push(...num1)</span><br><span class="line">        //相当于也是一种解析，会将数组中每个元素解析出来放入数组2</span><br><span class="line">        //更深的理解：利用push函数，它可以传入可变参数，可以传入很多个</span><br><span class="line">        this.goods[type].list.push(...res.data.list)</span><br><span class="line">        //现在的pop类型多了一组数据，我们要将页码+1</span><br><span class="line">        this.goods[type].list.page +=1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//data里面的数据初始化</span><br><span class="line">      goods: &#123;</span><br><span class="line">        //现将数据设置好，然后去请求数据。将请求回来的数据在这里面放</span><br><span class="line">        &#x27;pop&#x27;: &#123;page: 0, list: []&#125;,</span><br><span class="line">        &#x27;new&#x27;: &#123;page: 0, list: []&#125;,</span><br><span class="line">        &#x27;sell&#x27;: &#123;page: 0, list: []&#125;,</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="8-商品数据展示"><a href="#8-商品数据展示" class="headerlink" title="8. 商品数据展示"></a>8. 商品数据展示</h3><ul><li><h5 id="请求的数据保存后，如何显示在页面上呢？-组件GoodsItem和GoodsList"><a href="#请求的数据保存后，如何显示在页面上呢？-组件GoodsItem和GoodsList" class="headerlink" title="请求的数据保存后，如何显示在页面上呢？ 组件GoodsItem和GoodsList"></a>请求的数据保存后，如何显示在页面上呢？ 组件GoodsItem和GoodsList</h5><p>思路：Home组件将数据传给GoodsList，GoodsList进行遍历，然后将遍历出来的每一项传给他的GoodsListItem，它接收数据中，进行展示 -</p><p>Home组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;goods-list :goods = &quot;goods[&#x27;pop&#x27;].list&quot;&gt;&lt;/goods-list&gt;</span><br><span class="line">导入+注册</span><br></pre></td></tr></table></figure><p>GoodsList组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;goods-item&quot;&gt;</span><br><span class="line">    &lt;goods-list-item v-for = &#x27;item in goods&#x27; </span><br><span class="line">                    :key=&quot;item.index&quot;</span><br><span class="line">                    :goodsitem = &quot;item&quot;&gt;</span><br><span class="line">    &lt;!-- 将遍历出来的每一个对象，传到子组件中进行显示 --&gt;</span><br><span class="line">    &lt;/goods-list-item&gt;</span><br><span class="line">  &lt;!-- 每个小组件就是遍历的每个对象 --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import GoodsListItem from &#x27;./GoodsListItem&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;GoodsList&#x27;,</span><br><span class="line">    components: &#123; GoodsListItem &#125;,</span><br><span class="line">    //这个位置接受的就是穿过来的list，进行展示</span><br><span class="line">    props: &#123;</span><br><span class="line">      goods: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .goods-item &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    /* 目的是不要让图片占满一整行，注意子元素这是必须给宽度，否则，它会全往一行塞 */</span><br><span class="line">    /* 而且光给宽度还不行，flex-wrap会wrap进行换行，配合子元素的宽度，它会自动进行换行</span><br><span class="line">    默认是nowrap，是不换行的*/</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>GoodsListItem组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;goods-item&quot;&gt;</span><br><span class="line">    &lt;img :src = &quot;goodsitem.show.img&quot;/&gt;</span><br><span class="line">    &lt;!-- 图片下方还有一个标题+价格+收藏collect favorite --&gt;</span><br><span class="line">    &lt;div class=&quot;goods-info&quot;&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;goodsitem.title&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;span class=&quot;price&quot;&gt;&#123;&#123;goodsitem.price&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;collect&quot;&gt;&#123;&#123;goodsitem.cfav&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;GoodsListItem&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">    goodsitem: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .goods-item &#123;</span><br><span class="line">    padding-bottom: 40px;</span><br><span class="line">    position: relative;</span><br><span class="line">    /* 父元素右flex这里要给宽度 */</span><br><span class="line">    width: 46%;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-item img &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info &#123;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 5px;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info p &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    margin-bottom: 3px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info .price &#123;</span><br><span class="line">    color: var(--color-high-text);</span><br><span class="line">    margin-right: 20px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info .collect &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info .collect::before &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: -15px;</span><br><span class="line">    top: -1px;</span><br><span class="line">    width: 14px;</span><br><span class="line">    height: 14px;</span><br><span class="line">    background: url(&quot;~assets/img/common/collect.svg&quot;) 0 0/14px 14px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><p>遇到的问题1：如果子元素不给宽度的结果，全网一行塞<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203205335489.png" alt="image-20201203205335489"></p><p>为了不要让图片占满一整行，注意子元素必须给宽度，否则，它会全往一行塞 。而且光给宽度还不行，flex-wrap会wrap进行换行，配合子元素的宽度，它会自动进行换行<br>默认是nowrap，是不换行的默认是nowrap，是不换行的*/flex-wrap: wrap;</p></li><li><p>问题2：一行的图片并不是均等分的  ： justify-content: space-around;</p><p>​    <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203205855794.png" alt="image-20201203205855794" style="zoom:67%;" /></p></li><li><p>问题3：下滑的过程中，流行，新款的导航栏会被覆盖掉，</p><p>解决：去TabControl组件添加z-index：9</p></li></ul></li><li><h5 id="Home组件中如何实现数据动态传给子组件？？"><a href="#Home组件中如何实现数据动态传给子组件？？" class="headerlink" title="Home组件中如何实现数据动态传给子组件？？"></a>Home组件中如何实现数据动态传给子组件？？</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;goods-list :goods = &quot;goods[&#x27;pop&#x27;].list&quot;&gt;&lt;/goods-list&gt;</span><br><span class="line">这个传数据时，直接是写死的这样肯定是不行的。我们点击详情，新款时他就不能动态展示当前选择的类型里面的内容。</span><br></pre></td></tr></table></figure><p>实现的思路：在TabControl组件中的每一项被点击时，告诉Home组件当前被点击的是哪个index。Home组件根据index就知道了他应该切换为pop还是new还是sell里面的数据</p><p>在TabControl的方法中修改：</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203230845680.png" alt="image-20201203230845680"></p><p>父组件监听这个自定义事件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;tab-control :titles = &quot;titles&quot; </span><br><span class="line">               class=&quot;tab-control&quot; </span><br><span class="line">               @tabClick=&quot;tabClick&quot;&gt;&lt;/tab-control&gt;   </span><br><span class="line"> //后续借助计算属性对这部分优化</span><br><span class="line"> &lt;goods-list :goods = &quot;goods[currentType].list&quot;&gt;&lt;/goods-list&gt;</span><br><span class="line">               </span><br><span class="line"> /*2.这是事件监听类的方法*/</span><br><span class="line">方法里： tabClick(index) &#123;</span><br><span class="line">   console.log(index)</span><br><span class="line">   console.log(&#x27;haha&#x27;);</span><br><span class="line">   </span><br><span class="line">   switch (index) &#123;</span><br><span class="line">     case 0: this.currentType = &#x27;pop&#x27;</span><br><span class="line">     break</span><br><span class="line">     case 1: this.currentType = &#x27;new&#x27;</span><br><span class="line">     break</span><br><span class="line">     case 2: this.currentType = &#x27;sell&#x27;</span><br><span class="line">     break</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> 数据里： 初始化类型</span><br><span class="line">   currentType: &#x27;pop&#x27;,</span><br></pre></td></tr></table></figure><ul><li>犯错1： @tabClick = “tabClick(index)”父组件中这个监听事件应该绑定到TabControl里面，不是goodlist上面</li><li>犯错2：这里@tabClick = “tabClick(index)”不要传参数，会导致index打印出是无效的，这是为什么呢？</li></ul><ul><li><p>遇到的问题：Home.vue?76f2:158 Uncaught (in promise) TypeError: Cannot read property ‘data’ of undefined at eval Error: timeout of 5000ms exceeded<br>at createError (createError.js?2d83:16)at XMLHttpRequest.handleTimeout (xhr.js?b50d:95)一直显示data没有定义，数据请求不过来<br>解决：报错data没有定义,原因是我在request.js里面设置了5000ms，也就是超过5秒就超时，这时候还没有达到数据，我们用数据是有问题的。</p><p>我尝试了修改timeout的数值，发现控制台没有再报错，同时请求的3条数据也显示出来。不再像之前那样部分显示，部分报错</p></li><li><p>接上一个问题：另一个问题：为什么我只执行了一次打印，却会打印出三条请求数据的结果呢？</p><p>因为我们在上面的生命周期created里面调用了3种</p></li></ul></li><li><h5 id="Home中计算属性优化"><a href="#Home中计算属性优化" class="headerlink" title="Home中计算属性优化"></a>Home中计算属性优化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;goods-list :goods = &quot;goods[currentType].list&quot;&gt;&lt;/goods-list&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  showGoods() &#123;</span><br><span class="line">   return this.goods[this.currentType].list</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>犯错：注意return this.goods[this.currentType].list这里面是要加this的，在之前写在组件里不同加this，现在是写在下面，不加this，根本不认识它。没加会报错的！！！这个地方极容易犯错</li></ul></li></ul><h3 id="9-关于Better-scroll"><a href="#9-关于Better-scroll" class="headerlink" title="9.关于Better-scroll"></a>9.关于Better-scroll</h3><p>问题： 当前项目部署到服务器，只有用手机端请求网页，这个网页样式是没有问题的。我想往上滚，它是不会像PC浏览器里面自带的原生滚动一样  内容超过当前窗口的页面，可以自动滚动  。手机端会非常卡顿，还没有动态滚动效果的。</p><p><strong>解决：早期适配框架  iscroll 但这个框架已经不再维护了  有人参考了这个框架写了 better-scroll   有人维护，依赖于原生JS, 不依赖于其他框架</strong></p><ul><li><p>小技巧：开源框架的源码怎么找，</p><ul><li>如果官方网站没有下载，去github上面，找到tag版本进行下载，dist文件夹里esm.js里面。</li><li>直接用命令行。版本是1.13.2</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install better-scroll@1.13.2 --save</span><br></pre></td></tr></table></figure></li><li><h5 id="在Category组件里这样做（实验），局部区域滚动的原生做法"><a href="#在Category组件里这样做（实验），局部区域滚动的原生做法" class="headerlink" title="在Category组件里这样做（实验），局部区域滚动的原生做法"></a>在Category组件里这样做（实验），局部区域滚动的原生做法</h5><ul><li>首先整体的原生滚动：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">此处用ul包裹100个li</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li><p>可以实现滚动的，这是原生的。如果我想实现局部区域滚动，应该怎么做？</p><ul><li> 方法1：给父标签最外层的div一个高度，再让整个区域overflow-y: scroll;   此时超过height之后的内容隐藏了,并且高度之内的可以实行滚动，局部滚动实现 。但原生滚动非常卡顿，框架的滚动怎么做呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height: 100px;</span><br><span class="line">   background-color: red;</span><br><span class="line">   overflow-y: scroll;  </span><br></pre></td></tr></table></figure><ul><li>方法2：用框架来做<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204154344774.png" alt="image-20201204154344774" style="zoom: 50%;" /></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">//最外层需要包裹一个东西，并且有高度。之后往里面放入内容。但是content只能再放一个标签，一个！！</span><br><span class="line">  &lt;div class=&quot;wrapper&quot; ref = &quot;aaa&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">此处用ul包裹100个li</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .wrapper &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">    height: 200px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    //此处只是将溢出的地方进行隐藏</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import BScroll from &#x27;better-scroll&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Category&#x27;,</span><br><span class="line">  // created() &#123;</span><br><span class="line">  //   组件创建完之后调用，但是还没有进行模板的挂载，</span><br><span class="line">  //   所以这里的第一个参数是拿不到的。我们可以打印一下undifined/null</span><br><span class="line">  //   console.log(this.$refs.aaa)</span><br><span class="line">  //   console.log(document.querySelector(&#x27;.wrapper&#x27;))</span><br><span class="line">  //   this.scroll = new BScroll(&#x27;.wrapper&#x27;)</span><br><span class="line">  // &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      scroll: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>犯错1：</p><ul><li><p>我们加了一个wrapper的div。把之前的高度样式给wrapper。这样还是不行</p></li><li><p>导入安装的框架，并在created函数中new BSroll (参数1)，参数1是获取的dom节点。还是不行</p></li><li><p>在data里初始化scroll，用于对new出来的数据进行保存，还是不行。</p></li><li><p>wrapper的那个标签添加 ref = “aaa”，更改new Scroll</p></li></ul><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204155650488.png" alt="image-20201204155650488"></p></li><li><p>犯错原因：在created里创建BScroll对象，这时拿不到dom节点，改在mounted里实现<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204155743073.png" alt="image-20201204155743073"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    // 改为在mounted函数里去实现</span><br><span class="line">    console.log(this.$refs.aaa)</span><br><span class="line">    //这里可以写.类名，也可以用获取dom节点，插件会自动找到的</span><br><span class="line">    console.log(document.querySelector(&#x27;.wrapper&#x27;))</span><br><span class="line">    this.scroll = new BScroll(&#x27;.wrapper&#x27;),&#123;&#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="Better-scroll的进一步拓展"><a href="#Better-scroll的进一步拓展" class="headerlink" title="Better-scroll的进一步拓展"></a>Better-scroll的进一步拓展</h5><ul><li><p>拿到better-scroll下载打包之后的文件，使用它。也可以这样做，到node_modules里面的better-scoll 拿到dist文件夹下面的bscroll.js文件，粘贴过来</p></li><li><p>随便一个地方新建index.html,导入这个JS文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .content&#123;</span><br><span class="line">    height: 500px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script src = &#x27;./bscroll.js&#x27;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204161344411.png" alt="image-20201204161344411"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">//这里也放100个li</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 里面有个叫做 BScroll  的类 ，打印结结果显示他是一个构造函数</span><br><span class="line">  // console.log(BScroll);</span><br><span class="line">  //哪个元素挂载上去实行滚动，就把他挂载上去。wrapper里面只能有一个元素。</span><br><span class="line">  const bscroll = new BScroll(document.querySelector(&#x27;.content&#x27;), &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>想要实时监听用户滚动到哪个位置了，滚动多少了？？怎么做，</p><ul><li>必须知道滚动到哪一个位置，详情，流行那个栏目才停留。拿到better-scoll对象后，通过on功能进行监听。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第一个参数是要监听的类型，第二个参数是function，可以用箭头函数，函数的参数是position</span><br><span class="line">bscroll.on(&#x27;scroll&#x27;, (position) =&gt; &#123;</span><br><span class="line">  //position 是实时位置</span><br><span class="line">  console.log(position)</span><br><span class="line">&#125;)</span><br><span class="line">//但是并没有打印出来，这是为什么呢？默认情况下，better-scroll是不可以实时监听滚动位置的。</span><br><span class="line">  //想要做到，在new一个BScroll时还要传参数。重要属性：probeType  </span><br></pre></td></tr></table></figure><p>解决：修改传入的参数2，属性probeType</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const bscroll = new BScroll(document.querySelector(&#x27;.content&#x27;), &#123;</span><br><span class="line">//要不要实时侦测  0或1--不侦测  </span><br><span class="line">//2--侦测 手指滚动的过程中个侦测，但手指离开后的惯性滚动不侦测，其他情况，手指离开的滚动也可监听到</span><br><span class="line">    probeType: 3,</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204163108700.png" alt="image-20201204163108700" style="zoom:50%;" /><ul><li><p>属性2： 在better-scroll里面的如果是button，无论Click是true还是false都是可以点击的，但div那些组件就必须设置true才能添加监听事件</p></li><li><p>上拉加载更多思路：属性3：pullUpLoad<br>效果，我滚动到底，会进行打印</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const bscroll = new BScroll(document.querySelector(&#x27;.content&#x27;), &#123;</span><br><span class="line"> probeType: 3,</span><br><span class="line">   // 监听已经拉到第一页最低部了，我们要做上拉加载更多的功能pullUpLoad</span><br><span class="line">   pullUpLoad: true</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>但有一个问题：只能监听一次，只能加载一次，怎么办<br>先去发送网络请求，请求更多页的数据。等你数据请求完成并且将新的数据存储在list里展示出来后<br>调调用一个函数，告诉它这一次的上拉加载已经做完了。进行下一次的上拉加载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bscroll.on(&#x27;pullingUp&#x27;, () =&gt; &#123;</span><br><span class="line">  //这个函数没有参数，只是这里需要进行上拉加载更多了</span><br><span class="line">  console.log(&#x27;上啦加载更多&#x27;)</span><br><span class="line">  //为了不那么频繁进行下一次，设置一个定时器</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;我延迟了4秒&#x27;);</span><br><span class="line">    bscroll.finishPullUp()</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>我容易犯错的地方：<br>这些属性的使用不够熟练，默写容易露着漏那</p></li></ul></li><li><h5 id="对Better-scrolld进一步封装"><a href="#对Better-scrolld进一步封装" class="headerlink" title="对Better-scrolld进一步封装"></a>对Better-scrolld进一步封装</h5><ul><li><p>进一步的封装与抽离。首先将Scroll的功能封装在组件Scroll.vue里，目的解耦合。每个组件都用，对这个框架依赖性太强了。所以先封装，需要的组件只需要引入封装就可以。框架改变时，只需要修改封装就可以，而不需要每个组件都修改。这种公司向跟网络请求的封装也是一样的。</p><p>封装操作思想：  封装在components里面，因为它能在多个地方进行使用的。common里面scroll</p><p>文件夹，下一个项目中只要是滚动相关的项目，他也是可以拿来用的。Scroll.vue</p><ul><li><p>首先他也要有外层包裹，并满足包裹里面只能有一个；</p></li><li><p>在mounted里面不建议用document.querySelector(‘.wrapper)</p><pre><code>// 通过选择器拿到的，如果有重复类名，没有办法区分拿到的是哪一个，结果可能不准确，// 因此造成bug，Vue 也不建议去直接操作Dom。怎么办呢？绑定ref,传入this.$refs.wrapper ref如果是绑定在组件中的，通过$refs.名字拿到的是一个组件对象。</code></pre><p>ref如果是绑定在普通标签中的，通过$refs.名字拿到的是一个元素对象。跟document.querySelector一样</p></li><li><p>此外为了其他子组件调用的时候可以自由决定要不要实时刷新功能、要不要上拉加载更多的功能。我们对BScroll对象里面要传入的参数不是像之前写死的。而是从父组件接收过来的数据来决定</p></li><li><p>在实时监听和上拉加载更多事件中，采用向外触发$emit事件，根据需要决定是否携带参数传出去。</p><p>告诉要监听的组件，以便他们进行需要的处理和信息</p></li><li><p>在methods里面，对我们创建的scroll对象里面自带的方法进行了封装，这样做是多此一举吗？<br>1.封装思想；  2.为了简化父组件获取子组件中的scroll对象，再获取他的方法</p></li></ul></li><li><p>```</p><template>  <div class="wrapper" ref = "wrapper">    <!-- 以前的ref 父组件获取某一个子组件 -->    <!-- 必须有包裹，因为better-scroll里面只能有一个 -->    <div class="content">      <!-- 这里设置插槽的目的：方便首页 -->      <slot></slot>    </div>  </div></template><script>  import BScroll from 'better-scroll'  export default {    name: 'Scroll',    data() {      return {        scroll: null      }    },    props: {      probeType: {        type: Number,        default() {          return 0        }      },      pullUpLoad: {        type: Boolean,        default() {          return true        }      }    },    mounted(){      //创建BScroll对象      this.scroll = new BScroll(this.$refs.wrapper, {        //根据传入的来决定是否实时监听        probeType: this.probeType,        pullUpLoad: this.pullUpLoad,      })      this.scroll.on('scroll', (position) => {        // 子组件向外发送位置信息，和事件        this.$emit('scroll', position)      })      this.scroll.on('pullingUp', () => {        this.$emit('pullingUp')      })     },    methods: {     scrollTo(x, y, time) {       this.scroll.scrollTo(x, y, time)     },     //对完成上拉加载更多进行封装     finishPullUp() {       this.scroll.finishPullUp();     }    }  }</script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ Home组件中，滚动区域高度的确定，上面留44和下面高度留49</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  .content {</p><pre><code>height: 300px;position: absolute;top: 44px;bottom: 49px;right: 0;left: 0;</code></pre><p>   }</p><pre><code>#home &#123;/* 如果这里没有44px,轮播图会跑到最上面，他的一部分就会被导航栏遮盖 */padding-top: 44px;position: relative;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 遇到的问题： 图片被循环滚动？怎么解决、？？</span><br><span class="line">  &lt;img src=&quot;C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204215545273.png&quot; alt=&quot;image-20201204215545273&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  原因： 在Scroll.vue里面我用了4次插槽，这会导致将scroll包裹的东西重复了4次</p>  <template>    <div class="wrapper" ref = "wrapper">      <!-- 以前的ref 父组件获取某一个子组件 -->      <!-- 必须有包裹，因为better-scroll里面只能有一个 -->      <div class="content">        <!-- 这里设置插槽的目的：方便首页 -->        <slot></slot>        <slot></slot>        <slot></slot>        <slot></slot>        <slot></slot>      </div>    </div>  </template>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    + 新产生的问题： 就是TabControl组件的粘连定位效果已经失效了，为什么呢？怎么解决？</span><br><span class="line"></span><br><span class="line">      better-scroll在滚动的时候，系统没有办法检测现在滚到哪里了，所以sticky失效了。待解决</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">+ 需求1： 底部增加回到顶部的按钮，封装在components的content里面BackTop.vue</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204201503011.png&quot; alt=&quot;image-20201204201503011&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  ​    往下拉轮播图，为什么图标在没有布局时会跑到这里，因为从轮播图开始下面的东西是脱标的，图标就会被覆盖掉。而且我们顶部导航栏有一个padding-bottom  所以图标从下面导航栏下面开始占据位置。但我希望他在右下角，fixed布局。而且很多个页面这个图标都是在右下角这个位置，我们在这个组件里提前设置好</span><br><span class="line"></span><br></pre></td></tr></table></figure><template><!-- 这里面封装的就是一个返回顶部的小图片 --><div class="backtop">  <img src="~assets/img/common/top.png" alt="" ></div></template></li></ul><script>  export default {    name: "BackTop",  }</script><style scoped>  .backtop {    position: fixed;    right: 6px;    bottom: 60px;  }  .backtop img {    width: 43px;    height: 43px;  }</style>><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 需求2：如何完成位置跳转：拿到Better-scroll对象，里面有一个scrollTo(x, y)方法，传入参数就可以跳转到我们想要的位置。在哪个组件里实现这个功能，</span><br><span class="line"></span><br><span class="line">  + 方案1：不要在图标组件里完成跳转到顶部，因为顶部是父组件Home里的，而图标组件和Scroll组件都是Home组件的子组件。此时需要图标组件触发，Home那边组件监听，再用methods想办法拿到Srcoll组件里的Bette-scroll对象，再去调用这个方法。这样做很麻烦</span><br><span class="line">  + 更好的做法： 直接监听Home里面的back-top组件的点击事件，这在普通标签上是当然可以的，但组件是否可以直接不通过子组件向外触发事件，父组件监听的方式，而是父组件直接监听呢？？</span><br><span class="line">    答案是：不可以直接监听点击，必须借助.native修饰符，才可以监听组件根元素的原生事件。如果不加，只能按照方案1，但是方案1比较麻烦</span><br><span class="line"></span><br><span class="line">+ 问题2： 如何获取到scroll对象，给scroll根组件绑定ref，再通过this.$refs.Scroll()拿到组件对象，再拿到组件对象的属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Home组件中：</p><scroll class="content" ref="scroll" :probe-type = "3" ><back-top @click.native="backTop" v-show = "isBackTop"></back-top>data里：isBackTop: false方法里：backTop() {      // //拿到scroll组件上的scroll对象，调用他的scrollTo方法,第三个参数是多长时间回位置      // this.$refs.scroll.scroll.scrollTo(0, 0, 500)      // 这样写是拿到scroll组件，直接调用组件的方法，这个方法内部做了什么，在Scroll中已经定义了      this.$refs.scroll.scrollTo(0, 0, 500)    },<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 需求3：达到某个临界值时，图标显示，没到某个临界值，图片隐藏。所以我们需要实现监听图片滚动了多少，怎么监听呢？？？</span><br><span class="line"></span><br></pre></td></tr></table></figure>Home组件进一步修改：<scroll class="content" ref="scroll" :probe-type = "3"           @scroll = "contentScroll"> 方法里：            contentScroll(position) {      //从position里取出y值，与1000对比，大于显示图标，小于隐藏图标      //y默认是负值，要转换成正值，跟1000对比      this.isBackTop = (-position.y) > 1000 ?true: false      }<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 需求4： 上拉加载更多图片，此时我们需要再进行数据请求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 首页Better-scroll可滚动区域问题：</span><br><span class="line"></span><br><span class="line">现象：图片异步加载，每一项组件的高度被撑开了，可滚动区域突然变得更大了，但是这个插件并不知道，他还是按照没有图片时的可滚动区域。这时再往下滚就滚动。所以，我们要1.监听图片加载完，进行刷新。2.拿到srcoll对象调用refresh方法。一旦调用refresh就是真实可滚动高度</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">  打印new BScroll出来的 scroll对象，控制台查看里面有个属性叫scrollerHeight，根据放在better-scroll的cntent在子组件的高度决定当前有多少区域是可滚动的。这个高度没有计算加载图片的高度。所以我们滑到最后会有一片空白。图片异步加载，每一项组件的高度被撑开了，可滚动区域突然变得更大了，但是这个插件并不知道，他还是按照没有图片时的可滚动区域。这时再往下滚就滚动。所以，我们要</span><br><span class="line"></span><br><span class="line">+ 1.监听每张图片加载完，进行一次刷新。图片绑定加载事件，一旦图片加载完成就会执行这个函数</span><br><span class="line"></span><br><span class="line">问题怎么知道30张图片已经加载完成了呢？也就是如何图片加载完成与refresh对应起来</span><br><span class="line">![image-20201205185556938](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201205185556938.png)</span><br><span class="line"></span><br><span class="line">2.拿到srcoll对象调用refresh方法。一旦调用refresh就是真实可滚动高度。但是这个refresh是scroll对象的方法，现在在GoodListItem子组件里，是不能直接调用另一个组件的方法的。解决办法：GoodListItem先传给GoodList，再传给首页，首页再给Scroll组件。但这样很麻烦。</span><br><span class="line"></span><br><span class="line">方法2：搞一个Vuex,每次图片加载完之后，就改变Vuex里面的属性。再让首页引用这个属性并监听这个属性的改变。</span><br><span class="line"></span><br><span class="line">方法3：事件总线。与Vuex很像，但是他不是管理公共状态的，是用来管理事件的。this.$bus.$emit(&#x27;aa&#x27;),可以往Bus里面发送一个事件aa，之后在想要监听的位置写 this.$bus.$on(&#x27;aaa&#x27;, 函数)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>  methods: {    imageLoad() {      this.$bus.$emit('itemImageLoad')    }  }<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Home组件中监听：</span><br><span class="line"></span><br></pre></td></tr></table></figure>created () {  this.getHomeMultidata()  //我们希望3个页面在开始的时候都是请求第一页  this.getHomeGoods('pop')  this.getHomeGoods('new')  this.getHomeGoods('sell')<p>  //等组件创建完成之后就要监听你的图片是不是加载完成了<br>  this.$bus.$on(‘itemImageLoad’, () =&gt; {</p><pre><code>console.log(&#39;我知道你的图片加载完成啦&#39;)</code></pre><p>  })</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 但是会报错： 因为bus不存在。必须在原型里面加上。去main.js里面，给Vue原型方法上加上$bus</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//此时$bus就是事件总线<br>Vue.prototype.$bus = new Vue()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">图片加载完后，给总线触发了事件，Home组件在created中监听。监听到后调用scroll组件里面的refres方法。但是scroll对象的创建在Scroll.vue组件里在mounted的时候创建的。这是后拿到的scroll可能是空的。对Scroll方法进行修改，</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   scrollTo(x, y, time) {</p><pre><code> //在这里先做判断，scroll是不是有值//  this.scroll &amp;&amp; this.scroll.scrollTo(a,y,time)//  this.scroll.scrollTo(x, y, time)</code></pre><p>   },<br>   refresh() {</p><pre><code> this.scroll &amp;&amp; this.scroll.refresh();//  this.scroll.refresh();</code></pre><p>  },</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在Home组件里也做同样修改。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mounted() {<br>  //等组件创建完成之后就要监听你的图片是不是加载完成了<br>  this.$bus.$on(‘itemImageLoad’, () =&gt; {</p><pre><code>this.$refs.scroll &amp;&amp; this.$refs.scroll.refresh();</code></pre><p>  })<br>},</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">防抖动/debounce：防抖函数，在用户输入一个值，等待50ms，看是否还输入值，若继续输入，将上一次准备像服务器发送的请求取消掉。将这两个东西收集起来，若500ms之后没有继续输入。这就防止了短时间内向服务器发送多次请求，缓解服务器的压力。</span><br><span class="line"></span><br><span class="line">这里每次加载图片都进行刷新refresh，所以也应该做防抖处理。这样加载一次要刷新30次。通过debounce函数将refresh函数传入到debounce中生成一个新的函数。</span><br><span class="line"></span><br><span class="line">this.debounce ()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  debounce(func, time) {</p><pre><code>let timer = null;//这里剩余参数，可以传多个参数return function(...args) &#123;  if (timer) &#123;clearTimeout(timer)&#125;   timer = setTimeout(() =&gt; &#123;   //改变this指向，拿到当前函数的参数     func.apply(this, args)   &#125;)&#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.判断是否有timer，第一次没有值，null。延迟500ms执行。但是图片加载调用很频繁。所以延迟的过程中第二次来到这个函数。此时timer不是空的了，看赋值表达式。所以会将timer1清空掉。再给timer重新赋值。到第29次一样。但是第30次之后，因为没有31次了，不会再来到这个函数里面了，定时器时间一到。拿到function了。执行函数里面的函数，applay拿到当前的所有传入参数</span><br><span class="line">为什么不传参数delay，也能试下防抖呢？</span><br><span class="line">事件循环机制：因为只要实现setTimeOUt是异步函数，即使没有延迟时间，会放到事件队列的尾部等到执行栈里执行完成之后才执行时间队列里的任务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mounted() {</p><pre><code>  //传入的是函数，不是函数返回值  // 这里的refresh变量不会被销毁，因为被闭包引用</code></pre><p>  const refresh = this.debounce(this.$refs.scroll.refresh, 10)<br>  //等组件创建完成之后就要监听你的图片是不是加载完成了<br>  this.$bus.$on(‘itemImageLoad’, () =&gt; {</p><pre><code> this.$refs.scroll &amp;&amp; this.$refs.scroll.refresh();   //在这里调用refresh的过程：</code></pre><p>  })<br>},</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">节流函数/throttle：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对节流函数封装在common文件夹中，起名字Utils.js，并导入Home组件，则使用时就不需要加this了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>export function debounce(func, time) {<br>let timer = null;<br>//这里剩余参数，可以传多个参数<br>return function(…args) {<br>  if (timer) {clearTimeout(timer)}<br>   timer = setTimeout(() =&gt; {<br>   //改变this指向，拿到当前函数的参数</p><pre><code> func.apply(this, args)</code></pre><p>   })<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>import {debounce} from ‘common/Utils.js’</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ ##### 需求5：上拉加载更多 #####</span><br><span class="line"></span><br><span class="line">  + 监听什么时候滚到底部，scroll组件中的pullUpLOad属性值是外部决定的，让外界传入一个属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    pullUpLoad: &#123;      type: Boolean,      default() &#123;        return false      &#125;    &#125;  &#125;,</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Home组件中对scrol添加绑定属性：</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>  &lt;scroll class=&quot;content&quot; ref=&quot;scroll&quot; :probe-type = &quot;3&quot;                @scroll = &quot;contentScroll&quot;   :pull-up-load = &quot;true&quot;    &lt;/scroll&gt; </code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在mounted里面监听 </span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    if (this.pullUpLoad)&#123;      this.scroll.on(&#39;pullingUp&#39;, () =&gt; &#123;      this.$emit(&#39;pullingUp&#39;)    &#125;)    &#125;</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因为上拉到底时，我们首页要将即将加载的数据请求过来，所以首页Home组件要监听这个事件，并进行数据请求。currentType记录了当前选中的类型pop，根据pop取出pop当前页码。里面会将第二页数据拿到。放到list里面。并加页码</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>  &lt;scroll class=&quot;content&quot; ref=&quot;scroll&quot; :probe-type = &quot;3&quot;           @scroll = &quot;contentScroll&quot;   :pull-up-load = &quot;true&quot;          @pullingUp = &quot;loadMore&quot;          &gt;</code></pre><p>  methods里面：</p><pre><code>  loadMore() &#123;    //currentType记录了当前是哪一项。我们就获取哪一项的数据。取出当前的页码并加上1，    // 如果继续上拉加载更多，页码继续增多    console.log(&#39;首页知道你到达底部啦&#39;)    this.getHomeGoods(this.currentType)  &#125;</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 问题：pullUpLoad默认只加载一次，还需要finish函数。在数据加载完之后，告诉他已经完成了上拉加载更多</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>  getHomeGoods(type) &#123;    // 这个+1，这是告诉他要请求的是哪个页码的数据    const page = this.goods[type].page + 1    getHomeGoods(type, page).then(res =&gt; &#123;       console.log(res);      this.goods[type].list.push(...res.data.list);      // 而这个地方的+1，则是我们已经有两页数据了，当前页码应该更新到2了，而不是之前的1      this.goods[type].list.page +=1;      // //调用scroll里面的方法      this.$refs.scroll.finishPullUp();    &#125;)</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>  Scroll组件中，    //对完成上拉加载更多进行封装</p><pre><code>   finishPullUp() &#123;     this.scroll.finishPullUp();   &#125;,</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 9.TabControl的吸顶效果 ###</span><br><span class="line"></span><br><span class="line">#### 之前有sticky实现，但是在后面改需求后，又失效了。现在怎么解决呢？ ####</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201210195522021.png&quot; alt=&quot;image-20201210195522021&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">1.判断向上滚动的距离，如果大于某个距离，就开始吸顶（改布局fixed等）</span><br><span class="line"></span><br><span class="line">+ 怎么确定这个阈值呢？获取TabControl的offtop属性。一般情况下轮播图加载完了，他就拿到的是一个比较正确的值。</span><br><span class="line">  项目中经常需要监听图片是否加载完，否则他的加载会对你获取的数据有影响。</span><br><span class="line">  去HomeSwiper组件里，为图片绑定@load事件监听，，并向外$emit触发事件</span><br><span class="line"></span><br><span class="line">![image-20201206221918886](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201206221918886.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   绑定对HomeSwiper组件上的监听： swiperImageLoad<br>   swiperImageLoad() {</p><pre><code>  //打印结果  // this.$refs.scroll &amp;&amp; this.$refs.scroll.refresh();  // 右侧拿到的是组件对象，组件有没有属性叫offsetTop呢？答案是没有  // 所以我们应该去拿组件里的模板，是元素里面才有这个属性  // 所有的组件都有一个属性叫$el，这个属性是用于获取组件中的元素的  // this.tabOffsetTop = this.$refs.tabControl;  this.tabOffsetTop = this.$refs.tabControl.$el.offsetTop;  // 但这样数值结果是不对的，因为mounted里挂载以为这组件都挂载上面了，  //但是图片未必都加载完了.等上面的图片都加载完毕再去拿这个offsetTop才是对的&#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">每张轮播图加载后都会取一次offsetTop，其实只需拿一次就可以拿到高度。我就知道高度了。你后面图片的加载就不要再发送这个事件告诉HOME组件了，因为有第一次的发送能拿到offsetTop。HomeSwiper修改：</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>methods: &#123;  imageLoad() &#123;    //若图片还没有加载     if (!isLoad) &#123;       this.$emit(&#39;swiperImageLoad&#39;);      //  这样在第二次加载的时候他就不会来到这个函数里面了       this.isLoad = true     &#125;  &#125;&#125;,添加：data() &#123;  return &#123;    isLoad: false  &#125;&#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2.在Home组件里面contentScroll里，决定要不要吸顶</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>contentScroll(position) &#123;  //从position里取出y值，与1000对比，大于显示图标，小于隐藏图标  //y默认是负值，要转换成正值，跟1000对比  this.isBackTop = (-position.y) &gt; 1000 ?true: false  //决定是否吸顶，当前滚动距离是否大于tabControl距离顶部的高度，就吸顶  this.isTabFixed = (-position.y) &gt; this.tabOffsetTop&#125;,</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><pre><code>帮上新属性class,动态决定要不要加一个fixed：        &lt;tab-control :titles = &quot;titles&quot;                   class=&quot;tab-control&quot;                   @tabClick=&quot;tabClick&quot;                  :class = &quot;&#123;fixed:isTabFixed&#125;&quot;&gt;    &lt;/tab-control&gt;</code></pre><p>  .fixed {</p><pre><code>position: fixed;top: 0;right: 0;left: 0;</code></pre><p>  }</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 新问题： TabControl一下子往上面跑一下，因为它脱标了，所以下面的东西一下子跑上面去了。继续往下滑，这个栏目消失了。Better-scroll在滚动中的过程中，会往content上加很多属性。其中Translate属性在滚动的过程中，会不断地改变，所以滚动是通过修改Translate实现的。里面有一个fixed的东西是可以修改translate的。所以，Better-scroll里面的停留效果不好做，粘贴tab-control，到nav后面，scroll外面。并添加v-show = &quot;isTabFixed&quot;  isTabFixed默认值是false</span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">      &lt;tab-control :titles = &quot;titles&quot; </span><br><span class="line">                    class=&quot;tab-control&quot; </span><br><span class="line">                    @tabClick= &quot;tabClick&quot;</span><br><span class="line">                    :class = &quot;&#123;fixed:isTabFixed&#125;&quot;</span><br><span class="line">                    v-show = &quot;isTabFixed&quot;&gt;</span><br><span class="line">      &lt;/tab-cotrol&gt;</span><br></pre></td></tr></table></figure></li></ul><p>  默认情况下，他是false的，当滚到要显示那个地方，他就出现。并将原有的覆盖。用户看起来好像停留在这里了。</p><ul><li><p>新问题：点击新款，并没有更新，说明这两个TabControl并没有保持一致<br>我们只需要拿到tabControl，它里面的currentIndex记录了当前选中的是哪个类型。所以 两个tabControl设置不同的tabControl2。在监听点击的位置，等点击完成之后，this.$refs.tabControl1.currentIndex</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tabClick(index) &#123;</span><br><span class="line">  // console.log(index)</span><br><span class="line">  switch (index) &#123;</span><br><span class="line">    case 0: this.currentType = &#x27;pop&#x27;</span><br><span class="line">    break</span><br><span class="line">    case 1: this.currentType = &#x27;new&#x27;</span><br><span class="line">    break</span><br><span class="line">    case 2: this.currentType = &#x27;sell&#x27;</span><br><span class="line">    break</span><br><span class="line">  &#125;</span><br><span class="line">  //index 是最新点击的。更新index</span><br><span class="line">  this.$refs.tabControl1.currentIndex = index;</span><br><span class="line">  this.$refs.tabControl2.currentIndex = index;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>一直困扰我的问题：首次进入页面：轮播图没有效果。但切换其他页面再切换回来，又显示了？？？？</p></li><li><p>为什么加载底部会有大片空白？？为什么切换是，没有对应图片展示？？有时出现，大多数时候没</p></li><li><p>没有办法切换 流行，首页，数据，但是组件在scroll外面可以，里面就可以(原因是上面代码中两个index赋值都给了tabControl1，写错了)</p></li><li><h4 id="遇到的问题：当我们离开首页后，再回来，如果很快就回来，会保持离开时的浏览位置。但如果稍微慢一点，再进来就回到了最开始。"><a href="#遇到的问题：当我们离开首页后，再回来，如果很快就回来，会保持离开时的浏览位置。但如果稍微慢一点，再进来就回到了最开始。" class="headerlink" title="遇到的问题：当我们离开首页后，再回来，如果很快就回来，会保持离开时的浏览位置。但如果稍微慢一点，再进来就回到了最开始。"></a>遇到的问题：当我们离开首页后，再回来，如果很快就回来，会保持离开时的浏览位置。但如果稍微慢一点，再进来就回到了最开始。</h4><ul><li><p>原因：这些组件都是通过路由来实现管理的，当跳转到分类页，首页就销毁了。所以我们再进入的时候Home又重新创建。解决：对App.vue里面的router-view包裹一层keep-alive。但还是有问题，</p><ul><li><p>1.虽然Home组件没有被销毁，但better-scroll内部的问题导致效果并没有生效（安卓手机生效了）。</p></li><li><p>2.我们要让Home中的内容保持原来滚动的位置。离开时保持一个位置信息，再进入的时候设置成之间的位置</p></li><li><p>3.监听什么时候离开，activated和deactivated。一个是在进来，一个是在拉开的时候调用。</p></li></ul></li><li><p>Home组件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  activated() &#123;</span><br><span class="line">  //进入的时候设置高度,x不需要滚动，也不需要几秒之内,应该是迅速回到原位置</span><br><span class="line">      this.$refs.scroll.scrollTo(0, this.saveY, 0)</span><br><span class="line">  //还要进行刷新，不然有时候会出问题。但我们在进来的时候滚动到原来的位置，并进行一次属性</span><br><span class="line">      this.$refs.scroll.refresh();</span><br><span class="line">&#125;,</span><br><span class="line">    deactivated() &#123;</span><br><span class="line">  // 离开的时候拿到高度进行保存</span><br><span class="line">      // this.saveY = this.$refs.scroll.scroll.y  对这个获取做一层封装</span><br><span class="line">  this.saveY = this.$refs.scroll.getScrollY() </span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>在scroll组件中：methods中封装函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getScrollY()&#123;</span><br><span class="line">   return this.scroll ? this.scroll.y : 0;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目2-去哪儿网：项目记录篇</title>
      <link href="/2021/12/13/%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%EF%BC%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/12/13/%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%EF%BC%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2020年10月</li><li>项目背景： 慕课网的项目学习时做的笔记</li><li>项目记录篇，比较啰嗦</li></ul><h2 id="去哪儿项目记录梳理"><a href="#去哪儿项目记录梳理" class="headerlink" title="去哪儿项目记录梳理"></a>去哪儿项目记录梳理</h2><p>Axios–进行Ajax数据的获取</p><p>Vue Router–来做多页面之间的路由</p><p>Vuex–来做各个组件之间的数据共享</p><p>异步组件–来让我们代码上线，性能更优</p><p>Stylus–编写前端的样式</p><p>递归组件–实现组件调用自己的效果</p><p>插件–比Swiper插件来实现页面上的轮播效果</p><h3 id="6-1-Vue项目预热-环境配置"><a href="#6-1-Vue项目预热-环境配置" class="headerlink" title="6-1  Vue项目预热-环境配置"></a>6-1  Vue项目预热-环境配置</h3><ol><li><h5 id="cmd输入git-–version报错解决办法："><a href="#cmd输入git-–version报错解决办法：" class="headerlink" title="cmd输入git –version报错解决办法："></a>cmd输入git –version报错解决办法：</h5></li></ol><p>①配置环境变量(分行已经是代表分号【;】间隔了)；</p><p>②安装的时候选择git和cmd一起的选项…(自动帮你配置好环境变量)</p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="clipboard.png" style="zoom:50%;" /><ol start="2"><li><h5 id="打通线上-git码云-线下……SSH公钥："><a href="#打通线上-git码云-线下……SSH公钥：" class="headerlink" title="打通线上(git码云)-线下……SSH公钥："></a>打通线上(git码云)-线下……SSH公钥：</h5><ul><li><p>设置-&gt;SSH公钥-&gt;生成/添加SSH公钥</p></li><li><p>在Git Bash(在windows小型的Linux操作系统)运行Linux命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;2211016493@qq.com&quot; cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>生成公钥粘贴到网站上,[网站上有公钥，然后其实本地有一个私钥，公钥和私钥做匹配]</p></li></ul></li><li><h5 id="git码云克隆-下载-gt-SSH复制"><a href="#git码云克隆-下载-gt-SSH复制" class="headerlink" title="git码云克隆/下载-&gt;SSH复制"></a>git码云克隆/下载-&gt;SSH复制</h5><ul><li>Git Bash：cd切换到想要把代码存放的地方</li><li>git clone SSH复制的内容</li></ul></li><li><h5 id="创建一个Vue项目"><a href="#创建一个Vue项目" class="headerlink" title="创建一个Vue项目"></a>创建一个Vue项目</h5><ul><li><p>大型项目Vue.js是不够的，需要使用命令行工具(CLI)：</p></li><li><p>全局安装vue-cli</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --global vue-cli </span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个基于webpack模板的新项目(my-project是你的项目文件夹名字)</span><br><span class="line">vue init webpack my-project   （这是基于cli2的创建项目的做法）</span><br><span class="line">standardlone√，vue-router√，ESLint√，ESLint Standard√，unit×，e2e×，use NPM√</span><br><span class="line">cd my-project</span><br><span class="line"> npm run dev</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="6-3-Vue项目预热-项目代码介绍"><a href="#6-3-Vue项目预热-项目代码介绍" class="headerlink" title="6-3  Vue项目预热-项目代码介绍"></a>6-3  Vue项目预热-项目代码介绍</h3><ul><li><p>路由的配置都放在router文件夹的index.js里面;路由就是根据网址的不同，返回不同的内容给用户</p></li><li><p>APP.vue是整个应用的根组件，在APP.vue里<router-view>显示的内容就是当前路由地址所对应的路由内容，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default new Router(</span><br><span class="line">&#123;  routes:[</span><br><span class="line">&#123;path: &#x27;/&#x27;,</span><br><span class="line"> name: &#x27;HelloWorld&#x27;, </span><br><span class="line"> component: HelloWorld   </span><br><span class="line">&#125;] </span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>路由内容在router文件夹的index.js配置项找到，当访问根路径的时候(path:’/‘)，展示的是HelloWorld单文件组件。</p></li><li><p>import Home from ‘@/pages/home/Home.vue’  @表示src目录下，Home.vue不写后缀.vue也会帮你去找到它</p></li></ul><h3 id="6-4-Vue项目预热-单文件组件与Vue中的路由"><a href="#6-4-Vue项目预热-单文件组件与Vue中的路由" class="headerlink" title="6-4  Vue项目预热-单文件组件与Vue中的路由"></a>6-4  Vue项目预热-单文件组件与Vue中的路由</h3><ol start="5"><li><h5 id="Vue中做页面跳转一般不用a标签，用："><a href="#Vue中做页面跳转一般不用a标签，用：" class="headerlink" title="Vue中做页面跳转一般不用a标签，用："></a>Vue中做页面跳转一般不用a标签，用：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/list&quot; class=&quot;home&quot;&gt;列表页&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="template模板只能向外暴露一个根标签"><a href="#template模板只能向外暴露一个根标签" class="headerlink" title="template模板只能向外暴露一个根标签"></a>template模板只能向外暴露一个根标签</h5><p>所以里面的内容必须有一个div进行包裹</p></li><li><h5 id="【多页面应用】：页面跳转→返回HTML"><a href="#【多页面应用】：页面跳转→返回HTML" class="headerlink" title="【多页面应用】：页面跳转→返回HTML"></a>【<strong>多页面应用</strong>】：页面跳转→返回HTML</h5><ul><li><p>特点：打开项目页面，点开控制台里的network，选择Doc,选择刷新页面。当访问首页的时候，会请求一个首页的html文件。进入列表页面，又会返回城市列表的页面html(没有home的html)。</p><p>每次页面跳转的时候，后台都会给我们返回一个新的html文档。这种类型的网站就叫做<strong>多页面应用</strong></p></li><li><p>优点：</p><ul><li><p>首屏时间快<br>首屏时间：页面首个屏幕内容展现出来的时间，为什么会快呢？访问一个页面的时候，服务器返回一个html。然后页面就会被展示出来，这个过程只经历了一个http请求，请求回来了页面也就展示出来了，所以页面展示的速度非常的快)</p></li><li><p>SEO效果好<br>搜索引擎在做网页排名的时候需要知道网页的内容，才能给网页权重来进行网页的排名，搜索引擎可以识别html的内容，而我们网页所有的内容都放在html之中，所以SEO效果好</p></li></ul></li><li><p>缺点：</p><ul><li>页面切换慢<br>每一次页面切换都需要发送一个http请求，假设网速比较慢的时候，页面来回切换会出现明显的卡顿</li></ul></li></ul></li><li><h5 id="【单页面应用】：页面跳转→Js渲染"><a href="#【单页面应用】：页面跳转→Js渲染" class="headerlink" title="【单页面应用】：页面跳转→Js渲染"></a>【<strong>单页面应用</strong>】：页面跳转→Js渲染</h5><ul><li><p>特点（前端路由渲染）</p><p>第一次进入页面home的时候会请求一个html文件，从home(<a href="http://localhost:8081/#/)%E8%B7%B3%E8%BD%AClist(http://localhost:8081/#/list)%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%B8%8D%E8%AF%B7%E6%B1%82html%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%B8%8D%E8%AF%B7%E6%B1%82html%E6%96%87%E4%BB%B6%E4%BD%86%E6%98%AF%E9%A1%B5%E9%9D%A2%E4%BC%9A%E8%B7%9F%E7%9D%80%E5%8F%98%E5%91%A2%EF%BC%9F">http://localhost:8081/#/)跳转list(http://localhost:8081/#/list)并没有不请求html文件，如何做到不请求html文件但是页面会跟着变呢？</a><br>原理：JS会感知到url的变化，js动态地把当前页面内容清除掉再把下一个页面的内容挂载到页面上(把新的页面的DOM结构渲染出来)，这个时候路由不是后端来做而是前端，判断是显示哪一个组件把以前的组件清除掉就可以。这时候就不会每次跳转，都去请求页面了</p></li><li><p>优点</p><ul><li>页面切换快：因为不请求→当页面之间做跳转不需要做html文件的请求，节约了很多http请求发送的时延，使页面切换的过程变得非常快</li></ul></li><li><p>缺点</p><ul><li>首屏时间稍慢<br>单页首屏展示出来需要请求一次html，同时还需要发一个js的请求，2个请求都回来了首屏才会展示出来</li><li>SEO(搜索引擎优化)差<br>搜索引擎认识html中的内容，不认识js的内容，单页页面所有内容都是靠JS渲染生成的，搜索引擎不识别这一块的内容，它就不给你的网页一个好的排名</li></ul></li></ul></li><li><h5 id="有缺点为什么要使用Vue开发单页应用？"><a href="#有缺点为什么要使用Vue开发单页应用？" class="headerlink" title="有缺点为什么要使用Vue开发单页应用？"></a>有缺点为什么要使用Vue开发单页应用？</h5><p>其实，Vue之中还提供了其他的技术(比如服务器端渲染这样的技术)，通过这些技术我们可以完美地解决单页应用的问题。解决了这些问题后，实际上单页应用对前端来说是一套非常完美的解决方案。</p></li></ol><h3 id="6-5-Vue项目预热-项目代码初始化"><a href="#6-5-Vue项目预热-项目代码初始化" class="headerlink" title="6-5  Vue项目预热-项目代码初始化"></a>6-5  Vue项目预热-项目代码初始化</h3><ol start="11"><li><h5 id="添加第二行代码：在移动端的设备，用户用手指放大缩小是无效的，页面的比例始终是1-1"><a href="#添加第二行代码：在移动端的设备，用户用手指放大缩小是无效的，页面的比例始终是1-1" class="headerlink" title="添加第二行代码：在移动端的设备，用户用手指放大缩小是无效的，页面的比例始终是1:1"></a>添加第二行代码：在移动端的设备，用户用手指放大缩小是无效的，页面的比例始终是1:1</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="reset-css-重置页面的样式表"><a href="#reset-css-重置页面的样式表" class="headerlink" title="reset.css(重置页面的样式表)"></a>reset.css(重置页面的样式表)</h5><p>不同的手机浏览器上默认的样式是不统一的，把初始化样式作一个统一。</p></li><li><h5 id="border-css：该文件可以收藏起来以后直接用"><a href="#border-css：该文件可以收藏起来以后直接用" class="headerlink" title="border.css：该文件可以收藏起来以后直接用"></a>border.css：该文件可以收藏起来以后直接用</h5><ul><li><p>解决移动端1像素边框问题<br>border-bottom:1px solid green,指的是css像素。有的手机屏幕分辨率比较高，它是一个2倍屏或者3倍屏。在2倍屏实际上不是1个物理像素的高度，可能是2个或者3个物理像素的高度。为了解决多倍屏中一像素边框会被显示成多倍屏的问题。</p></li><li><p>项目入口文件main.js里面引入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#x27;./assets/styles/reset.css&#x27;</span><br><span class="line">import &#x27;./assets/styles/border.css&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="引入fastClick库，解决移动端300毫秒延迟的问题"><a href="#引入fastClick库，解决移动端300毫秒延迟的问题" class="headerlink" title="引入fastClick库，解决移动端300毫秒延迟的问题"></a>引入fastClick库，解决移动端300毫秒延迟的问题</h5><ul><li><p>在移动端开发中，某些机型某些浏览器上使用click事件时会延迟300ms才执行</p></li><li><p>把fastclick安装到项目的依赖中，（package.json中的”dependencies”）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install fastclick --save　</span><br><span class="line">save意思是不管在开发环境或者是打包生成线上版本的代码都需要使用fastclick</span><br></pre></td></tr></table></figure></li><li><p>在main.js里面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import fastClick from &#x27;fastclick&#x27;</span><br><span class="line">fastClick.attach(document.body)</span><br><span class="line">//attach是fastClick自带的方法 　</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="iconfont：创建一个项目-Travel项目图标"><a href="#iconfont：创建一个项目-Travel项目图标" class="headerlink" title="iconfont：创建一个项目-Travel项目图标"></a>iconfont：创建一个项目-Travel项目图标</h5></li><li><h5 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add.     //把本地的修改提交到git的缓存区</span><br><span class="line">git commit -m &#x27;project init&#x27; //把缓冲区的内容提交到本地仓库(线上的代码还没有任何改变)</span><br><span class="line">git push     //把本地仓库的代码推到线上去，git码云官网代码更新 </span><br></pre></td></tr></table></figure></li></ol><h3 id="7-1-Vue项目首页-header区域开发"><a href="#7-1-Vue项目首页-header区域开发" class="headerlink" title="7-1  Vue项目首页-header区域开发"></a>7-1  Vue项目首页-header区域开发</h3><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image016.gif" alt="clipboard.png"></p><ol start="18"><li>【CSS 预处理器】定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用”。<br><a href="https://www.cnblogs.com/yanxiaoge/p/11078843.html">https://www.cnblogs.com/yanxiaoge/p/11078843.html</a></li></ol><p>CSS预处理器的出现大大的提高了前端开发的效率和逼格，它让CSS可编程化。LESS和Sass/SCSS/Stylus是为常见的预处理器。</p><ul><li><p>安装stylus依赖包 npm install  stylus –save  （0.54.5）</p></li><li><p>安装stylus-loader npm install stylus-loader –save  （3.0.1）</p></li><li><p>重新启动项目 npm run start</p><p>用stylus来写样式,scoped限制只对当前组件有效，在这个组件中写的样式不对其他组件产生影响：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><ol start="19"><li>移动端的布局一般采用rem的布局方式</li></ol><p>reset.css的html里font-size设置成了50px，rem是相对与50px的这个尺寸，设计师给的是2倍尺寸的图片，86px应该写成43px，1rem=html的font-size=50px，那么43px=.86rem。</p><h3 id="7-2-Vue项目首页-iconfont的使用和代码优化"><a href="#7-2-Vue项目首页-iconfont的使用和代码优化" class="headerlink" title="7-2  Vue项目首页-iconfont的使用和代码优化"></a>7-2  Vue项目首页-iconfont的使用和代码优化</h3><ol start="21"><li><p>定义一个伪类实现[倒三角形]：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     &lt;div class=&quot;nabla&quot;&gt;&lt;/div&gt;</span><br><span class="line">.nabla&#123; </span><br><span class="line">      width:0; height: 0px; </span><br><span class="line">      border-top:10px solid black; </span><br><span class="line">      border-left:10px solid white; </span><br><span class="line">      border-right:10px solid white; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif" alt="clipboard.png"></p><ol start="22"><li>iconfont的使用</li></ol><p>①官网下载</p><p>②下载的文件压缩包中需要使用的文件</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif" alt="clipboard.png"></p><p>③修改iconfont.css文件</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif" alt="clipboard.png"></p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image012.gif" alt="clipboard.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconfont.css最后位置有提供一些类，汉语拼音的形式的类，我们可以通过64位或者16进制的一个码来直接使用这些图标(官网上复制代码)  </span><br><span class="line">.icon-jiantou:before&#123;content:&quot;\e64a&quot;&#125;  </span><br><span class="line">.icon-fanhui  ..icon--sousou</span><br></pre></td></tr></table></figure><p>④main.js引入iconfont.css：import ‘./assets/styles/iconfont.css’</p><ol start="23"><li><p>代码的优化：</p><ul><li><p>varibles.styl。background:#00bcd4，整个网页地方很多用到这个颜色(主题颜色)，#00bcd4用一个变量来表示，如果以后想要改变网页的主题，只要改变那个变量，全局就可以跟着改变，可维护性可以得到非常大的提升。</p><ul><li>src/assets/styles下创建一个文件varibles.styl：$bgColor=#00bcd4</li><li>在style标签里引入：@import ‘../../../assets/styles/varibles.styl’   <pre><code>background:$bgColor</code></pre></li></ul></li><li><p>对 [ 多处import ‘../../../assets/styles/varibles.styl’ ] 长路径的优化</p><ul><li><p>打开build目录&gt;-webpack.base.conf.js&gt;-添加对应的代码(@可以代替src使用的意思)</p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image014.gif" alt="clipboard.png" style="zoom:67%;" /></li><li><p>此时，@import ‘~@/assets/styles/varibles.styl’，注意：</p><p>如果在CSS中引入其他的CSS，使用【@】符号需要在前面加【<del>】符号。<br>Header.vue的<style></style>里示例：@import ‘</del>styles/varibles.styl’</p><p>main.js示例：import ‘styles/reset.css’</p></li></ul></li></ul></li></ol><h3 id="7-3-Vue项目首页-首页轮播图"><a href="#7-3-Vue项目首页-首页轮播图" class="headerlink" title="7-3  Vue项目首页-首页轮播图"></a>7-3  Vue项目首页-首页轮播图</h3><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image040.gif" alt="clipboard.png"></p><ol start="24"><li><h5 id="建立git分支–【index-swiper】"><a href="#建立git分支–【index-swiper】" class="headerlink" title="建立git分支–【index-swiper】"></a>建立git分支–【index-swiper】</h5><p>在企业开发当中每创建一个新的功能需要新建一个git分支来进行代码的开发，代码开发完成把分支上的代码合并到master主分支上。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先切换目录至项目文件夹 cd xxx</span><br><span class="line">git码云网新建分支【index-swiper】</span><br><span class="line">把线上的分支拉到本地 git pull</span><br><span class="line">git checkout index-swiper    切换到index-swiper分支进行代码的开发 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status 命令用于显示工作目录和暂存区的状态.使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。</span><br><span class="line">git log.   git status不显示已经commit到项目历史中去的信息。看项目历史的信息要使用</span><br></pre></td></tr></table></figure></li><li><h5 id="制作轮播图借助第三方插件——vue-awesome-swiper（github搜索）"><a href="#制作轮播图借助第三方插件——vue-awesome-swiper（github搜索）" class="headerlink" title="制作轮播图借助第三方插件——vue-awesome-swiper（github搜索）"></a>制作轮播图借助第三方插件——vue-awesome-swiper（github搜索）</h5><ul><li><p>安装 ：npm install <a href="mailto:&#118;&#x75;&#x65;&#x2d;&#x61;&#x77;&#101;&#115;&#111;&#x6d;&#x65;&#x2d;&#115;&#x77;&#x69;&#112;&#x65;&#114;&#64;&#50;&#x2e;&#54;&#x2e;&#55;">&#118;&#x75;&#x65;&#x2d;&#x61;&#x77;&#101;&#115;&#111;&#x6d;&#x65;&#x2d;&#115;&#x77;&#x69;&#112;&#x65;&#114;&#64;&#50;&#x2e;&#54;&#x2e;&#55;</a> –save</p></li><li><p>引入：入口文件main.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueAwesomeSwiper from &#x27;vue-awesome-swiper&#x27;</span><br><span class="line">Vue.use(VueAwesomeSwiper)</span><br><span class="line">import &#x27;swiper/dist/css/swiper.css&#x27;</span><br></pre></td></tr></table></figure></li><li><p>src/pages/home/components创建Swiper.vue……</p></li><li><p>Swiper.vue组件里（原本github上面的代码）</p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image020.gif" alt="clipboard.png" style="zoom:67%;" /></li><li><p>在Swiper.vue组件里定义这个数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data () &#123;   </span><br><span class="line">  return &#123;    </span><br><span class="line">swiperOption: &#123;&#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Home组件中引入、注册、使用</p></li></ul></li></ol><ul><li><h5 id="根据需求，对Swiper组件作修改"><a href="#根据需求，对Swiper组件作修改" class="headerlink" title="根据需求，对Swiper组件作修改"></a>根据需求，对Swiper组件作修改</h5><ul><li><p>删除轮播图的左右箭头div（swiper-button-prev和swiper-button-next）</p></li><li><p>删除灰色滚动条div（swiper-scrollbar）</p></li><li><p>删除文字、插入图片：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;swiper-slide&gt;</span><br><span class="line">  &lt;img class=&quot;swiper-img&quot; src=&quot;http://mp-piao-admincp.qunarzz.com/mp_piao_admin_mp_piao_admin/admin/20191/37a42ce34dc16cd43bad17570bf6ab31.jpg_750x200_65d24bd7.jpg&quot; /&gt;</span><br><span class="line">&lt;/swiper-slide&gt;   </span><br><span class="line">&lt;swiper-slide&gt;</span><br><span class="line">  &lt;img class=&quot;swiper-img&quot; src=&quot;http://img1.qunarzz.com/piao/fusion/1811/31/da037478f37cf202.jpg_750x200_fe28d396.jpg&quot; /&gt;</span><br><span class="line">&lt;/swiper-slide&gt;</span><br></pre></td></tr></table></figure></li><li><p>对图片宽高进行调整：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.swiper-img       width:100% </span><br></pre></td></tr></table></figure></li></ul></li><li><p>调整代码：Home.vue插入test的div</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">    &lt;div&gt;   </span><br><span class="line">    &lt;home-header&gt;&lt;/home-header&gt;   </span><br><span class="line">        &lt;home-swiper&gt;&lt;/home-swiper&gt;   </span><br><span class="line">    &lt;div&gt;test·······&lt;/div&gt; </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h5 id="F12的network改成fast-3G，刷新页面test文本有明显的抖动"><a href="#F12的network改成fast-3G，刷新页面test文本有明显的抖动" class="headerlink" title="F12的network改成fast 3G，刷新页面test文本有明显的抖动"></a>F12的network改成fast 3G，刷新页面test文本有明显的抖动</h5><p>[原因]：图片没有加载的时候高度是0，test在图片位置。图片加载完了才把图片撑开，test才跑到图片下面</p><p>[解决]：<swiper></swiper>外层加一个div标签wrapper，设置样式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.wrapper   </span><br><span class="line">overflow:hidden   </span><br><span class="line">width:100%   </span><br><span class="line">height:0   </span><br><span class="line">padding-bottom:26.67%   </span><br><span class="line">background: #eee   //图片大小是375(W)×100(H)   //100/375≈26.67%</span><br><span class="line"> 注：height:26.67%是错的，相对的不是width的26.67%，而是父级元素的26.67%。</span><br><span class="line"></span><br><span class="line">也可以这样写(但可能有些浏览器的兼容性有问题)：</span><br><span class="line">.wrapper  width:100%  height:26.67vw</span><br></pre></td></tr></table></figure><p>解决后，test一直在那个位置，没有抖动</p></li><li><h5 id="添加轮播图的点"><a href="#添加轮播图的点" class="headerlink" title="添加轮播图的点"></a>添加轮播图的点</h5><ul><li><p>加一个配置项，传swiper-pagination进去<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image022.gif" alt="clipboard.png"></p></li><li><h5 id="把轮播图的点改成白色无效"><a href="#把轮播图的点改成白色无效" class="headerlink" title="把轮播图的点改成白色无效 ,"></a>把轮播图的点改成白色无效 ,</h5><p>（swiperOption 是传递给swiper组件的options里的，Swiper内部拿到这些数据，改变样式）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.swiper-pagination-bullet-active     </span><br><span class="line">background:#fff!important</span><br></pre></td></tr></table></figure></li><li><h5 id="解决办法：把轮播图的点改成白色有效-（样式穿透，不受scoped限制）"><a href="#解决办法：把轮播图的点改成白色有效-（样式穿透，不受scoped限制）" class="headerlink" title="解决办法：把轮播图的点改成白色有效  （样式穿透，不受scoped限制）"></a>解决办法：把轮播图的点改成白色有效  （样式穿透，不受scoped限制）</h5><p>.wrapper所有子组件只要出现.swiper-pagination-bullet-active  变成白色<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image024.gif" alt="clipboard.png"></p></li></ul></li></ul><p>☐ 思考：</p><p>用了<swiper></swiper>，可以理解成第三方组件，实际上是通过slot插槽的形式把页面具体的数据传给swiper</p><p>slot插槽：有的时候我们在用组件的时候，我们希望组件的一部分内容可以被父组件去定制的时候，采用slot形式往组件里传递可以被自己定制的内容</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image026.gif" alt="clipboard.png"></p><ul><li>修改代码使轮播图的图片循环输出：loop：true<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image028.gif" alt="clipboard.png"></li></ul><ol start="26"><li><p>Git的使用——分支内容提交&amp;合并</p><ul><li><p>把本地index-swiper分支的内容提交到了线上index-swiper分支      index-swiper -&gt; index-swiper<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image034.gif" alt="clipboard.png"></p></li><li><p>把index-swiper分支的内容合并到master分支：</p></li><li><p>切换到master分支：  git checkout master  ;  </p></li><li><p>把index-swiper分支新增的内容合并到本地的master分支：  git merge origin/index-swiper</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif" alt="clipboard.png"></p></li><li><p>最后git push把本地的master分支的内容提交到线上</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image038.gif" alt="clipboard.png"></p></li></ul></li></ol><h3 id="7-4-Vue项目首页-图标区域页面布局"><a href="#7-4-Vue项目首页-图标区域页面布局" class="headerlink" title="7-4  Vue项目首页-图标区域页面布局"></a>7-4  Vue项目首页-图标区域页面布局</h3><ol start="27"><li><h5 id="新建【index-icons分支】"><a href="#新建【index-icons分支】" class="headerlink" title="新建【index-icons分支】"></a>新建【index-icons分支】</h5></li><li><p>src/pages/home/components文件夹创建Icons.vue</p></li></ol><p>导出组件→Home引入、注册组件→<home-icons></home-icons><br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image046.gif" alt="clipboard.png"></p><ol start="29"><li><h5 id="先实现一个小图标占位"><a href="#先实现一个小图标占位" class="headerlink" title="先实现一个小图标占位"></a>先实现一个小图标占位</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.icons   </span><br><span class="line">overflow:hidden   </span><br><span class="line">height:0   </span><br><span class="line">padding-bottom:50%   </span><br><span class="line">  .icon    </span><br><span class="line">float:left    </span><br><span class="line">width:25%    </span><br><span class="line">padding-bottom:25%</span><br></pre></td></tr></table></figure><ul><li><p>图标区域布局：</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image042.gif" alt="clipboard.png"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    overflow:hidden      </span><br><span class="line">    height:0      </span><br><span class="line">    padding-bottom:50%  </span><br><span class="line">相当于：      </span><br><span class="line">overflow:hidden      </span><br><span class="line">width:100%      </span><br><span class="line">height:0      </span><br><span class="line">padding-bottom:50%</span><br></pre></td></tr></table></figure></li></ol><ul><li>小图标布局<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image044.gif" alt="clipboard.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.icon     </span><br><span class="line">float:left     </span><br><span class="line">width:25%     </span><br><span class="line">padding-bottom:25%</span><br></pre></td></tr></table></figure><ul><li>布局问题：<ul><li>图片放上去太大：.icon→overflow:hidden→给<img>一个div→.icon-image-content [ height:100% ]</li><li>img+p超过高度50%：.icon&gt;-height:0</li><li>图片居中：.icon-img-content [ display:block;margin:0 auto ]</li><li>间距：.icon-img [ box-sizing:border-box;padding:.1rem ]</li><li>box-sizing:border-box，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</li><li>字体颜色：$darkTextColor=#333→@import ‘~styles/varibles.styl’;</li></ul></li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image048.gif" alt="clipboard.png"></td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image050.gif" alt="clipboard.png"></td></tr></tbody></table><h3 id="7-5-Vue项目首页-图标区域逻辑实现"><a href="#7-5-Vue项目首页-图标区域逻辑实现" class="headerlink" title="7-5  Vue项目首页-图标区域逻辑实现"></a>7-5  Vue项目首页-图标区域逻辑实现</h3><table><thead><tr><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image064.gif" alt="clipboard.png"></th><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image066.gif" alt="clipboard.png"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><ol start="30"><li><h5 id="Swiper组件实现区域图标轮播：需求：两层图标只有上面一层轮播，实现上下两层图标都可以轮播"><a href="#Swiper组件实现区域图标轮播：需求：两层图标只有上面一层轮播，实现上下两层图标都可以轮播" class="headerlink" title="Swiper组件实现区域图标轮播：需求：两层图标只有上面一层轮播，实现上下两层图标都可以轮播"></a>Swiper组件实现区域图标轮播：需求：两层图标只有上面一层轮播，实现上下两层图标都可以轮播</h5></li></ol><p>（原来icons的overflow:hidden去掉，因为swiper-container自带overflow）</p><p> .icons &gt;&gt;&gt; .swiper-container   height:0   padding-bottom:50%</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;    </span><br><span class="line">    &lt;div class=&quot;icons&quot;&gt;        </span><br><span class="line">        &lt;swiper&gt;         </span><br><span class="line">            &lt;swiper-slide&gt;             </span><br><span class="line">                &lt;div class=&quot;icon&quot; v-for=&quot;item of iconList&quot;  :key=&quot;item.id&quot;&gt; </span><br><span class="line">                &lt;div class=&#x27;icon-img&#x27;&gt;                 </span><br><span class="line">                &lt;img class=&#x27;icon-img-content&#x27; :src=&quot;item.imgUrl&quot; /&gt;</span><br><span class="line">                &lt;/div&gt;                 </span><br><span class="line">            &lt;p class=&quot;icon-desc&quot;&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt;             </span><br><span class="line">            &lt;/div&gt;         </span><br><span class="line">           &lt;/swiper-slide&gt;        </span><br><span class="line">        &lt;/swiper&gt;    </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ol start="31"><li><h5 id="实现图片循环写法"><a href="#实现图片循环写法" class="headerlink" title="实现图片循环写法:"></a>实现图片循环写法:</h5></li></ol><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image052.gif" alt="clipboard.png" style="zoom:67%;" /><ol start="32"><li><h5 id="一个页面8个图标，实现第九个图标开始轮播"><a href="#一个页面8个图标，实现第九个图标开始轮播" class="headerlink" title="一个页面8个图标，实现第九个图标开始轮播"></a>一个页面8个图标，实现第九个图标开始轮播</h5></li></ol><p>使用【计算属性computed】实现：</p><ul><li>不需要循环变更数据，key值可以写index，div循环的不是iconList了，是page<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image054.gif" alt="clipboard.png"></li><li>index=8时代表第九个图标(一个页面8个图标)，page=1，表示在第二页<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image056.gif" alt="clipboard.png"></li></ul><ol start="33"><li><h5 id="代码优化：当图标下面的文字过长显示省略号…"><a href="#代码优化：当图标下面的文字过长显示省略号…" class="headerlink" title="代码优化：当图标下面的文字过长显示省略号…"></a>代码优化：当图标下面的文字过长显示省略号…</h5></li></ol><table><thead><tr><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image058.gif" alt="clipboard.png"></th><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image060.gif" alt="clipboard.png"></th></tr></thead><tbody><tr><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image062.gif" alt="clipboard.png"></td><td></td></tr></tbody></table><ol start="34"><li>Git—分支内容提交&amp;合并</li></ol><h3 id="7-6-Vue项目首页-热销推荐组件开发"><a href="#7-6-Vue项目首页-热销推荐组件开发" class="headerlink" title="7-6  Vue项目首页-热销推荐组件开发"></a>7-6  Vue项目首页-热销推荐组件开发</h3><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image084.gif" alt="clipboard.png" style="zoom: 67%;" /><ol start="35"><li><p>新建[index-recommend分支]</p></li><li><p>新建recommend.vue文件→export导出→Home.vue引入import</p></li><li><p><img>宽和高定死的话不用外层包裹div</p></li><li><li></li>下面使用【1像素边框】：<p>li标签加上类：  border-bottom  （之前引入了scr/assets/styles/border.css）<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image068.gif" alt="clipboard.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &#x27;~styles/mixins.styl&#x27;;</span><br></pre></td></tr></table></figure><ul><li>省略号显示：光用ellipsis()还不行，接下面min-width:0技巧实现</li></ul></li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image076.gif" alt="clipboard.png"><br /><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image074.gif" alt="clipboard.png"></td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image078.gif" alt="clipboard.png" style="zoom:150%;" /></td></tr></tbody></table><ol start="39"><li>实现热销推荐三个<li></li>循环：</li></ol><table><thead><tr><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image080.gif" alt="clipboard.png"></th></tr></thead><tbody><tr><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image082.gif" alt="clipboard.png"></td></tr></tbody></table><h3 id="7-7-Vue项目首页-开发周末游组件"><a href="#7-7-Vue项目首页-开发周末游组件" class="headerlink" title="7-7  Vue项目首页-开发周末游组件"></a>7-7  Vue项目首页-开发周末游组件</h3><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image088.gif" alt="clipboard.png"></p><ol start="41"><li>新建Weekend.vue</li></ol><p>l 复制Recommend.vue的内容进行修改→导出export→Home.vue引入</p><ol start="42"><li><p>修改： 要在<img />外面包裹一层div，不给图片具体的宽、高，而是width:100%</p><p>删除flex布局，删除查看详情按钮，相应的缩进修改</p></li><li><p>见<strong>7-3Vue****项目首页-首页轮播图</strong>的思考：slot插槽</p></li><li><p>不小心先push到了master分支解决办法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先在主分支上执行： git log  </span><br><span class="line">找到你想要同步的commit的ID，切换到分支以后执行</span><br><span class="line">git cherry-pick 56aec3410629347fefb5cfd918be32be6fb52e78</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch     查看所有分支</span><br><span class="line">git merge xxx   让新分支与xxx分支合并</span><br></pre></td></tr></table></figure></li></ol><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image086.gif" alt="clipboard.png"></p><h3 id="7-8-Vue项目首页-使用axios发送ajax请求"><a href="#7-8-Vue项目首页-使用axios发送ajax请求" class="headerlink" title="7-8  Vue项目首页-使用axios发送ajax请求"></a>7-8  Vue项目首页-使用axios发送ajax请求</h3><ol start="45"><li><h5 id="创建【index-ajax分支】"><a href="#创建【index-ajax分支】" class="headerlink" title="创建【index-ajax分支】"></a>创建【index-ajax分支】</h5></li><li><p>在Vue中发送ajax有很多工具可以供我们使用，浏览器自带的fetch函数、vue以前推荐的vue-resource，Vue官方推荐我们使用axios第三方模块，axios非常强大，可以实现跨平台的数据请求，比如你在浏览器端axios可以帮助你发送SHR的请求，在node服务器上可以帮助你发送http请求。</p></li><li><h5 id="安装axios-：npm-install-axios-–save-（0-17-1）"><a href="#安装axios-：npm-install-axios-–save-（0-17-1）" class="headerlink" title="安装axios  ：npm install axios –save  （0.17.1）"></a>安装axios  ：npm install axios –save  （0.17.1）</h5></li><li><p>整个首页发一个ajax请求，把ajax的代码写在Home.vue，可以把数据传给子组件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div&gt;   </span><br><span class="line">&lt;home-header&gt;&lt;/home-header&gt;   </span><br><span class="line">&lt;home-swiper&gt;&lt;/home-swiper&gt;   </span><br><span class="line">&lt;home-icons&gt;&lt;/home-icons&gt;   </span><br><span class="line">&lt;home-recommend&gt;&lt;/home-recommend&gt;   </span><br><span class="line">&lt;home-weekend&gt;&lt;/home-weekend&gt; </span><br><span class="line">  &lt;/div&gt; </span><br><span class="line">&lt;/template&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">import HomeHeader from &#x27;./components/Header&#x27; </span><br><span class="line">import HomeSwiper from &#x27;./components/Swiper&#x27; </span><br><span class="line">import HomeIcons from &#x27;./components/Icons&#x27; </span><br><span class="line">import HomeRecommend from &#x27;./components/Recommend&#x27; </span><br><span class="line">import HomeWeekend from &#x27;./components/Weekend&#x27; </span><br><span class="line">import axios from &#x27;axios&#x27; </span><br><span class="line">export default &#123;  </span><br><span class="line">name: &#x27;Home&#x27;,  </span><br><span class="line">components: &#123;   </span><br><span class="line">HomeHeader,   HomeSwiper,   HomeIcons,   HomeRecommend,   HomeWeekend  &#125;,  </span><br><span class="line">methods: &#123;   </span><br><span class="line">getHomeInfo()&#123;axios.get(&#x27;/static/mock/index.json&#x27;).then(this.getHomeInfoSucc)&#125;,   </span><br><span class="line">getHomeInfoSucc (res) &#123;console.log(res)&#125;&#125;,  </span><br><span class="line">mounted () &#123;this.getHomeInfo()&#125;&#125; </span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure><ul><li>axios返回的结果是一个promise对象，this.getHomeInfoSucc</li><li>mounted () { this.getHomeInfo() }：页面一挂载完成就请求ajax的数据，数据获取成功把数据打印出来</li></ul></li></ol><ul><li>static存放的是静态文件，创建一个mock文件夹，放index.json，把数据放到static是因为整个工程里面只有static目录下的内容可以被外部访问到</li></ul><table><thead><tr><th>↓↓可以访问↓↓</th><th>↓↓main.js不可以访问，会自动重新定位回到首↓↓</th></tr></thead><tbody><tr><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image090.gif" alt="clipboard.png"></td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image092.gif" alt="clipboard.png"></td></tr></tbody></table><p>【本地开发的模拟数据】不提交到线上：</p><ul><li>.gitignore文件中添加：static/mock     static/mock这样这个文件夹就不会被提交的线上的git仓库，也不会提交到本地的git仓库<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image094.gif" alt="clipboard.png"></li></ul><p>【本地开发的模拟数据】</p><ul><li><p>问题：  /static/mock/index.json现在用的都是本地模拟接口地址，假如代码要上线，不能填成这样的地址，需要在上线之前把地址改成 ‘/api/index.json’ 这种格式，上线之前改动代码有风险，不建议这样操作。<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image096.gif" alt="clipboard.png"></p></li><li><p>解决：  如果有一个转发机制，它可以帮助我们把对api下所有json文件的请求转发到本地的static/mock文件夹下，这样就可以了。Vue有提供Proxy代理的功能，通过这个功能可以实现这个构想。<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image098.gif" alt="clipboard.png"></p></li><li><p>如图配置：  当我们请求api这个目录的时候，我们希望它去把请求转发到服务器8080端口，路径作一个替换：一旦请求的地址是以api开头的，那么就替换请求到本地/static/mock(在开发环境里，Vue的脚手架工具会自动帮助你把api进行替换，即作一个开发环境的转发)    </p><ul><li>实际上这个功能不是Vue提供的，是webpack-dev-server这个工具提供的(了解即可) </li><li>改变了配置项文件需要重启服务器</li></ul></li></ul><p>【模拟数据的具体数据】： index.json<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image100.gif" alt="clipboard.png"></p><ul><li>“ret”: true  –服务器正确响应了你的请求</li><li>控制台有ajax返回值，ajax数据获取成功<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image102.gif" alt="clipboard.png"></li><li><strong>细节点：</strong>写json文件的时候如果最后数据末尾多加逗号【,】，这有可能导致json格式解析失败<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image104.gif" alt="clipboard.png"></li></ul><h3 id="7-9-Vue项目首页-首页父子组组件间传值"><a href="#7-9-Vue项目首页-首页父子组组件间传值" class="headerlink" title="7-9  Vue项目首页-首页父子组组件间传值"></a>7-9  Vue项目首页-首页父子组组件间传值</h3><p>上一节从ajax的接口获取到了首页的数据，要把这些数据分别传给首页的各个组件：<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image108.gif" alt="clipboard.png"></p><p>删除原来直接写上去的数据，父组件将数据传过去</p><ol start="53"><li><h5 id="问题解决：Header轮播图默认显示的图片是最后一张"><a href="#问题解决：Header轮播图默认显示的图片是最后一张" class="headerlink" title="问题解决：Header轮播图默认显示的图片是最后一张"></a>问题解决：Header轮播图默认显示的图片是最后一张</h5><ul><li><p>[原因]：使用swiper页面还没获取ajax的时候，这时props接收的数据是外部的空数组，swiperList最初创建的时候是通过空数组创建的，然后当ajax数据获取完成之后，swiperList变成真正的数据项，再传给home-swiper这个组件的时候它才获取到新的数据，然后重新渲染新数据对应的很多轮播的图片。</p></li><li><p>[解决]：swiper初次创建由完整的来创建而不是空数组来创建。(当传递过来的list是空数组，v-if的值是false，swiper不会被创建；真正数据过来了swiper才会被创建)<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image120.gif" alt="clipboard.png"></p></li><li><p>在模板里面尽量避免出现逻辑型的代码→computed属性：</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image124.gif" alt="clipboard.png"><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image122.gif" alt="clipboard.png"></p></li></ul></li></ol><ul><li><h5 id="需求改进：-Icons轮播图在页面自动左右滚动，使轮播图不自动滚动的实现如下："><a href="#需求改进：-Icons轮播图在页面自动左右滚动，使轮播图不自动滚动的实现如下：" class="headerlink" title="需求改进： Icons轮播图在页面自动左右滚动，使轮播图不自动滚动的实现如下："></a>需求改进： Icons轮播图在页面自动左右滚动，使轮播图不自动滚动的实现如下：</h5><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image126.gif" alt="clipboard.png"><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image128.gif" alt="clipboard.png"></p></li></ul><h3 id="8-1-Vue项目城市选择页-路由配置"><a href="#8-1-Vue项目城市选择页-路由配置" class="headerlink" title="8-1  Vue项目城市选择页-路由配置"></a>8-1  Vue项目城市选择页-路由配置</h3><ol start="54"><li><p>新建新分支：【city-router】，配置路由index.js</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image130.gif" alt="clipboard.png"></p></li></ol><ul><li><p>创建city组件</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image132.gif" alt="clipboard.png"></p></li></ul><ol start="55"><li><p>路由跳转</p><ul><li>点击首页的[北京]可以跳转City.vue  (做页面跳转的内置组件router-link)</li></ul><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image134.gif" alt="clipboard.png"></p><ul><li>点击首页的[北京]跳转页面，北京变成了灰色，是因为默认点击后加a标签。  处理成字体的颜色是白色<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image136.gif" alt="clipboard.png">  </li></ul></li><li><h5 id="做城市选择的Header-vue"><a href="#做城市选择的Header-vue" class="headerlink" title="做城市选择的Header.vue"></a>做城市选择的Header.vue</h5><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image142.gif" alt="clipboard.png"></p><ul><li>创建 、City.vue中import→export default注册，使用</li><li>返回图标的制作：做一个[绝对定位]显示出来</li><li>点击实现回到首页(<router-link to="/"></router-link>)(回到根路径也就是首页)</li></ul></li></ol><ul><li>代码的优化</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &#x27;~styles/varibles.styl&#x27;  </span><br><span class="line">height:$headerHeight；</span><br><span class="line">line-height:$headerHeight  </span><br><span class="line">/home/components/Header里面的 height 和 line-height 也替换掉  </span><br><span class="line">好处：改动所有页面的页头跟着变</span><br></pre></td></tr></table></figure><ul><li>提交到git仓库</li></ul><h3 id="8-2-Vue项目城市选择页-搜索框布局"><a href="#8-2-Vue项目城市选择页-搜索框布局" class="headerlink" title="8-2  Vue项目城市选择页-搜索框布局"></a>8-2  Vue项目城市选择页-搜索框布局</h3><p>新建git分支：【city-search】</p><p>做Search.vue，新建导入注册使用</p><ul><li><p>细节：让搜索框里面文字很长的时候文字不要紧贴搜索框两侧：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写padding要加box-sizing:border-box</span><br></pre></td></tr></table></figure><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image144.gif" alt="clipboard.png"></p></li><li><p>代码提交到git仓库</p></li></ul><h3 id="8-3-Vue项目城市选择页-列表布局"><a href="#8-3-Vue项目城市选择页-列表布局" class="headerlink" title="8-3  Vue项目城市选择页-列表布局"></a>8-3  Vue项目城市选择页-列表布局</h3><ul><li><p>准备：</p><ul><li><p>新建git分支：【city-list】</p></li><li><p>/city创建组件List.vue(→组件起名name:CityList)</p></li><li><p>官网的列表是借助浏览器的自带的滚轮实现的列表，我们希望引入更高级的关于区块滚动的内容Better-scroll</p></li><li><p>div加上上下边框的class：border-topbottom，(border-topbottom是border.css里面的)</p></li><li><p>原来的上下边框颜色比较浅，修改样式【控制页面上显示的1像素边框的颜色】：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.border-topbottom   </span><br><span class="line">  &amp;:before    </span><br><span class="line"> border-color:#ccc   </span><br><span class="line">  &amp;:after    </span><br><span class="line"> border-color:#ccc</span><br><span class="line"> 意思是：border-topbottom这个类:before和:after伪元素的border-color都设成#ccc</span><br></pre></td></tr></table></figure></li><li><p>.button-list→.button-wrapper→.button（城市button外面还要有div,进行包裹）</p></li><li><p>这样城市button没有显示出来，因为  .button-wrapper设置了float，要给.button-list加上overflow:hidden触发它的BFC     <a href="https://blog.csdn.net/ty987654/article/details/77863473">https://blog.csdn.net/ty987654/article/details/77863473</a><br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image146.gif" alt="clipboard.png"></p></li></ul></li><li><p>注意button-list右边留出padding给ABCDEFG…<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image148.gif" alt="clipboard.png"></p></li><li><p>Header和Search框不见了，因为没有设置overflow:hidden，多出去的高度会撑出去</p></li></ul><table><thead><tr><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image150.gif" alt="clipboard.png" style="zoom:150%;" /></th><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image152.gif" alt="clipboard.png" style="zoom:80%;" /></th></tr></thead><tbody><tr><td>●Header和Search出来了↓</td><td></td></tr><tr><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image154.gif" alt="clipboard.png"></td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image156.gif" alt="clipboard.png" style="zoom:80%;" /></td></tr><tr><td>●撑出来的部分是超过list区域的内容</td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image158.gif" alt="clipboard.png"></td></tr><tr><td>●加上overflow:hidden，看起来没有问题了，但是不能往下拖，只能显示这样一部城市列表↓</td><td>下节课会对这个区域使用Better-scroll的插件，可以让这个区域的滚动很类似于原生APP的拖拽效果，会非常酷炫</td></tr><tr><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image160.gif" alt="clipboard.png" style="zoom:200%;" /></td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image162.gif" alt="clipboard.png" style="zoom:67%;" /></td></tr></tbody></table><h3 id="8-4-Vue项目城市选择页-BetterScroll的使用和字母表布局"><a href="#8-4-Vue项目城市选择页-BetterScroll的使用和字母表布局" class="headerlink" title="8-4  Vue项目城市选择页-BetterScroll的使用和字母表布局"></a>8-4  Vue项目城市选择页-BetterScroll的使用和字母表布局</h3><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image174.gif" alt="clipboard.png" style="zoom:50%;" /><ul><li><p>准备：</p><ul><li><p>github搜索第三方的包–BetterScroll(iscroll的一个封装，BetterScroll使用起来更加友好)</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image164.gif" alt="clipboard.png"></p></li><li><p>安装 npm install better-scroll –save  （1.8.1）</p></li></ul></li><li><p>使用BetterScroll–制作完成可以往下拉列表，而且拉到尽头会有回弹的效果。官方文档使用说明：<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image166.gif" alt="clipboard.png"></p><ul><li>使用条件：需要符合上面这样的DOM结构：加多一个div把多个area内容包裹起来——list的div里面一个大的div</li></ul><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image168.gif" alt="clipboard.png"></p></li><li><p>使用方法：</p><ul><li><p>首先要引入Better Scroll，  然后创建一个BetterScroll的实例，  BetterScroll实例创建的时候要接收一个DOM元素或者一个DOM的选择器，ref可以帮助我们获取DOM<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image170.gif" alt="clipboard.png"></p></li><li><p>具体操作：导入，写一个生命周期函数：mounted会在页面挂载完毕执行， 创建一个scroll的实例属性=new  Bscroll(),同时把this.$refs.wrapper传入进去<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image172.gif" alt="clipboard.png"></p></li></ul></li><li><p>制作右侧字母表：</p><ul><li><p>在src/pages/city/components单独创建一个组件Alphabet.vue，导入注册使用</p></li><li><p>布局：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;ul class=&quot;list&quot;&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;   </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;   </span><br><span class="line">  &lt;/ul&gt;  </span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;   </span><br><span class="line">@import &#x27;~styles/varibles.styl&#x27;   </span><br><span class="line">.list    </span><br><span class="line">    display:flex    </span><br><span class="line">    flex-direction:column    </span><br><span class="line">    justify-content:center    </span><br><span class="line">    position:absolute    </span><br><span class="line">    top:1.58rem    </span><br><span class="line">    right:0    </span><br><span class="line">    bottom:0    </span><br><span class="line">    width:.4rem    </span><br><span class="line">.item    </span><br><span class="line">    line-height:.4rem     </span><br><span class="line">    text-align:center     </span><br><span class="line">    color:$bgColor  </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>‘finish city css’，提交代码到git</p></li></ul></li></ul><h3 id="8-5-Vue项目城市选择页-页面的动态数据渲染"><a href="#8-5-Vue项目城市选择页-页面的动态数据渲染" class="headerlink" title="8-5  Vue项目城市选择页-页面的动态数据渲染"></a>8-5  Vue项目城市选择页-页面的动态数据渲染</h3><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image192.gif" alt="clipboard.png" style="zoom:50%;" /><ul><li><p>准备工作：</p><ul><li><p>新建git分支：【city-ajax】</p></li><li><p>准备好city.json文件放到static/mock目录</p></li><li><p>放在最外层组件—City.vue来做，一次ajax就可以获得这个页面所有组件的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">import axios from &#x27;axios&#x27; import CityHeader from &#x27;./components/Header&#x27; import CitySearch from &#x27;./components/Search&#x27; import CityList from &#x27;./components/List&#x27; import CityAlphabet from &#x27;./components/Alphabet&#x27; </span><br><span class="line">export default &#123;   </span><br><span class="line">    name: &#x27;City&#x27;,   </span><br><span class="line">    components: &#123;CityHeader,CitySearch,CityList,CityAlphabet&#125;,   </span><br><span class="line">    data () &#123;return &#123;cities: &#123;&#125;,hotCities: []&#125;&#125;,   </span><br><span class="line">    methods: &#123;     </span><br><span class="line">    getCityInfo () &#123; axios.get(&#x27;/api/city.json&#x27;)         .then(this.handleGetCityInfoSucc)&#125;,     </span><br><span class="line">            handleGetCityInfoSucc (res) &#123; </span><br><span class="line">            res = res.data </span><br><span class="line">            if (res.ret &amp;&amp; res.data) &#123;</span><br><span class="line">            const data = res.data </span><br><span class="line">            this.cities = data.cities</span><br><span class="line">            this.hotCities = data.hotCities&#125;&#125;&#125;,   </span><br><span class="line">    mounted () &#123;this.getCityInfo()&#125;&#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>可以先console.log(res)看页面控制台接收到的模拟数据的内容</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image178.gif" alt="clipboard.png"></p></li><li><p>接收到数据就可以来做动态数据的渲染了：写完之后就需要把根组件的数据传给子组件</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image180.gif" alt="clipboard.png"></p></li></ul><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image182.gif" alt="clipboard.png"></p></li></ul><ul><li><p>注意细节: ，ABCDE…Z</p><ul><li><p>cities不是一个数组，是一个对象 。这个对象比如键A，它的属性值是所有开头的城市的名字的集合。所以我们还要对他进行二次遍历。才能依次取出对应的城市</p></li><li><p>对象的v-for循环是：v-for=”(item,key) of cities ，不是v-for=”(item,index) of cities。代表ABCDE…Z  ，指的是键值对中的键</p></li><li><p>二次循环：v-for=”innerItem of item”。</p></li><li><p>双重循环的key值  父级的key值等于key就可以，因为key是ABCDE…Z，不会重名，用key比较安全；如果父级的key值和子级的key值重名了也没有关系，只要这一层级的key值不重复就可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;area&quot; v-for=&quot;(item,key) of cities&quot; :key=&quot;key&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;area&quot; v-for=&quot;(item,key) of cities&quot; :key=&quot;key&quot;&gt;      </span><br><span class="line">  &lt;div class=&quot;title border-topbottom&quot;&gt;&#123;&#123;key&#125;&#125;&lt;/div&gt;      </span><br><span class="line">  &lt;div class=&quot;item-list&quot;&gt;       </span><br><span class="line">     &lt;div class=&quot;item border-bottom&quot;v-for=&quot;innerItem of item&quot; :key=&quot;innerItem.id&quot; &gt;          &#123;&#123;innerItem.name&#125;&#125;       </span><br><span class="line">     &lt;/div&gt;      </span><br><span class="line">  &lt;/div&gt;     </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>右侧ABCDE…Z字母表：在Alphabet组件中，循环出来的是key，因为只要字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;   </span><br><span class="line">  &lt;ul class=&quot;list&quot;&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot; v-for=&quot;(item,key) of cities&quot; :key=&quot;key&quot;&gt;     </span><br><span class="line">       &#123;&#123;key&#125;&#125;    </span><br><span class="line">    &lt;/li&gt;   </span><br><span class="line">  &lt;/ul&gt;  </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>代码提交到git</p></li></ul><h3 id="8-6-Vue项目城市选择页-兄弟组件数据传递"><a href="#8-6-Vue项目城市选择页-兄弟组件数据传递" class="headerlink" title="8-6  Vue项目城市选择页-兄弟组件数据传递"></a>8-6  Vue项目城市选择页-兄弟组件数据传递</h3><p>新建git分支：【city-components】</p><ul><li><h4 id="需求：希望点击右边的字母表，左侧的页面城市列表可以自动滚动到显示区域"><a href="#需求：希望点击右边的字母表，左侧的页面城市列表可以自动滚动到显示区域" class="headerlink" title="需求：希望点击右边的字母表，左侧的页面城市列表可以自动滚动到显示区域"></a>需求：希望点击右边的字母表，左侧的页面城市列表可以自动滚动到显示区域</h4></li><li><p>Alphabet.vue：绑定一个click事件，对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;    </span><br><span class="line">  handleLetterClick (e) &#123;     </span><br><span class="line">  this.$emit(&#x27;change&#x27;, e.target.innerText)    //e是事件对象</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>希望把这个字母传递给List.vue组件，然后List对应的区块显示出来：  需要做一个兄弟组件的传值（非父子组件，以前讲过bus总线的形式），因为非父子组件非常简单，它们就是兄弟组件，处理兄弟组件之间的传值也可以通过这种方式：  Alphabet.vue传递数据给City.vue组件→City.vue转发数据给List.vue</p></li><li><p>在父组件City.vue中监听：拿到这个字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@change=&quot;handleLetterChange&quot;       </span><br><span class="line">handleLetterChange (letter) </span><br><span class="line">  &#123; </span><br><span class="line">this.letter = letter    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>City.vue把letter转发给List.vue：  父传子通过属性的方式传递   。List组件拿到这个值，并且List.vue监听到letter有变化进行对应区块的展示：  借助【侦听器watch】！！！！（重要）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch: &#123;    </span><br><span class="line">  letter () &#123;     </span><br><span class="line">    if (this.letter) &#123;      </span><br><span class="line">      const element = this.$refs.[this.letter][0]  </span><br><span class="line">      this.scroll.scrollToElement(element)     </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//BetterScroll组件里面用到的参数必须是DOM元素或者DOM选择器</span><br><span class="line">(×)const element = this.$refs[this.letter]     </span><br><span class="line">(√)const element = this.$refs[this.letter][0]</span><br></pre></td></tr></table></figure><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image202.gif" alt="clipboard.png"></p></li></ul><h5 id="这个地方动态绑定ref非常关键：这是子组件能跳转到传过来字母所对应区域的关键一步，第二个关键点：才是跳转scrollToElement"><a href="#这个地方动态绑定ref非常关键：这是子组件能跳转到传过来字母所对应区域的关键一步，第二个关键点：才是跳转scrollToElement" class="headerlink" title="这个地方动态绑定ref非常关键：这是子组件能跳转到传过来字母所对应区域的关键一步，第二个关键点：才是跳转scrollToElement"></a>这个地方动态绑定ref非常关键：这是子组件能跳转到传过来字母所对应区域的关键一步，第二个关键点：才是跳转scrollToElement</h5><ul><li><h4 id="需求：实现在字母表作上下拖拽时对应城市列表自动上下滚动"><a href="#需求：实现在字母表作上下拖拽时对应城市列表自动上下滚动" class="headerlink" title="需求：实现在字母表作上下拖拽时对应城市列表自动上下滚动"></a>需求：实现在字母表作上下拖拽时对应城市列表自动上下滚动</h4><p>思路：  获得字母A距离顶部的高度ya，手指滑动的位置距离顶部的高度yb，作差即获得手指位置距离A的距离，再除以每个字母的高度就可以知道当前是第几个字母，然后取对应的字母触发事件给外部  </p><ul><li><p>首先绑定touch相关事件3个，开始，移动，结束<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image206.gif" alt="clipboard.png"></p></li><li><p>希望handleTouchStart后再去做其他事情，在data定义一个标识类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data () &#123;    </span><br><span class="line">  return &#123;     </span><br><span class="line">touchStatus: false    </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要一个数组来存储第几个字母，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;    </span><br><span class="line">  letters () &#123;     </span><br><span class="line">    const letters = []  </span><br><span class="line">//cities是一个对象不是一个数组，将他的每一项存储为一个数组</span><br><span class="line">      for (let i in this.cities) &#123;      </span><br><span class="line">        letters.push(i)     </span><br><span class="line">      &#125;     </span><br><span class="line">    return letters    </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line">原来的v-for=&quot;(item,  key) of cities&quot;  </span><br><span class="line">改成：v-for=&quot;item of letters&quot;  ,我们不是循环cities的键了，而是letters了，</span><br><span class="line">因为letters里面刚好存的就是就是字母</span><br></pre></td></tr></table></figure></li><li><p>手指移动事件具体做的事：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleTouchStart () &#123;     </span><br><span class="line">  this.touchStatus = true    </span><br><span class="line">&#125;,    </span><br><span class="line">handleTouchMove (e) &#123;   </span><br><span class="line">// 在handleTouchMove里面做的事情：判断手指滑动的是哪个字母，然后跟点击字母事件一样，都向外触发change事件，由父组件监听这个事件。所以点击和滑动的区别在于，获取字母的方式不一样，但是目的都是一样的，就是向外触发同一事件，并携带字母出去。</span><br><span class="line">  if (this.touchStatus) &#123;      </span><br><span class="line">const startY = this.$refs[&#x27;A&#x27;][0].offsetTop  </span><br><span class="line">    // 事件对象里会有一个touches数组   -79是减掉header和搜索框的高度 </span><br><span class="line">const touchY = e.touches[0].clientY - 79      </span><br><span class="line">const index = Math.floor((touchY - startY) / 20)      </span><br><span class="line">if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123;       </span><br><span class="line">   this.$emit(&#x27;change&#x27;, this.letters[index])      </span><br><span class="line">&#125;     </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;,    </span><br><span class="line">handleTouchEnd () &#123;     </span><br><span class="line">this.touchStatus = false    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>为Alphabet.vue绑定ref，</strong>作用：是为了计算字母A距离顶部的高度，拿到offsetTop值<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image208.gif" alt="clipboard.png"></p></li></ul></li></ul><h3 id="8-7-Vue项目城市选择页-列表性能优化"><a href="#8-7-Vue项目城市选择页-列表性能优化" class="headerlink" title="8-7  Vue项目城市选择页-列表性能优化"></a>8-7  Vue项目城市选择页-列表性能优化</h3><ul><li><h4 id="优化startY"><a href="#优化startY" class="headerlink" title="优化startY"></a>优化startY</h4><ul><li>this.startY的值其实是固定的，但每次执行函数都要算一遍，耗费性能</li><li>在初次渲染Alaphabet组件的时候，cities的值还是空对象。当ajax数据获取后，往Alphabet传的数据发生变化，Alphabet这个组件就会重新渲染，</li><li>当Alphabet重新渲染之后，updated这个生命周期钩子就会被执行，这个时候页面中已经展示出了城市列表的所有内容，这个时候就去获取A这个字母所在的DOM对应的offsetTop的值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updated () &#123;</span><br><span class="line">  /* 当页面的数据完成了更新，并完成页面渲染后，执行这个钩子 */</span><br><span class="line">  this.startY = this.$refs[&#x27;A&#x27;][0].offsetTop</span><br><span class="line">  //this.startY </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><h4 id="函数节流优化："><a href="#函数节流优化：" class="headerlink" title="函数节流优化："></a>函数节流优化：</h4><p>手指在字母表上移动，函数执行的频率是非常高的。限制函数执行的频率</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释节流函数：</span><br><span class="line">data里面定义一个timer，</span><br><span class="line"> 如果已经存在了就把this.timer去除掉：</span><br><span class="line">    if (this.timer) &#123;</span><br><span class="line">     clearTimeout(this.timer)</span><br><span class="line">   &#125;</span><br><span class="line"> 否则创建一个timer：this.timer = setTimeout()</span><br><span class="line">如果你正在做这样一件事情的时候，让它延迟16ms再去执行，如果在这16ms之间你又做了手指的滚动那么会把上一次你要做的操作清除掉、重新执行你这次要做的事情。</span><br><span class="line">通过函数节流的方式，可以大大节约handleTouchMove执行的频率，从而提高网页的性能</span><br><span class="line">肉眼察觉不到，实际上性能大大提高</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleTouchMove (e) &#123;</span><br><span class="line">      /* 当手指触摸的时候才去做的事 */</span><br><span class="line">      if (this.touchStatus) &#123;</span><br><span class="line">        if (this.timer) &#123;</span><br><span class="line">          clearTimeout(this.timer)</span><br><span class="line">        &#125;</span><br><span class="line">        this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">          const touchY = e.touches[0].clientY - 79</span><br><span class="line">          const index = Math.floor((touchY - this.startY) / 20)</span><br><span class="line">          if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123;</span><br><span class="line">            this.$emit(&#x27;change&#x27;, this.letters[index])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 16)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>代码提交到git，’performance’</p></li></ul><h3 id="8-8-Vue项目城市选择页-搜索逻辑实现"><a href="#8-8-Vue项目城市选择页-搜索逻辑实现" class="headerlink" title="8-8  Vue项目城市选择页-搜索逻辑实现"></a>8-8  Vue项目城市选择页-搜索逻辑实现</h3><ul><li><h5 id="需求：实现搜索城市名字或拼音把对应的城市名字显示出来"><a href="#需求：实现搜索城市名字或拼音把对应的城市名字显示出来" class="headerlink" title="需求：实现搜索城市名字或拼音把对应的城市名字显示出来"></a>需求：实现搜索城市名字或拼音把对应的城市名字显示出来</h5></li><li><p>新建git分支：【city-search】</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class=&quot;search&quot;&gt;</span><br><span class="line">    &lt;input  class=&quot;search-input&quot; type=&quot;text&quot;</span><br><span class="line">            placeholder=&quot;输入城市名或拼音&quot;</span><br><span class="line">            v-model=&quot;keyword&quot;&gt;</span><br><span class="line">            //这个地方的双向绑定，实现了有输入值的时候，List组件隐藏</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;search-conent&quot;</span><br><span class="line">        ref=&quot;search&quot; //这个ref用于设置滚动效果</span><br><span class="line">        v-show=&quot;  keyword&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li class=&quot;search-item border-bottom&quot;</span><br><span class="line">          v-for=&quot;item of list&quot;</span><br><span class="line">          :key=&quot;item.id&quot;</span><br><span class="line">          @click=&quot;handleCityClick(item.name)&quot;</span><br><span class="line">      &gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;</span><br><span class="line">      &lt;li class=&quot;search-item border-bottom&quot;</span><br><span class="line">            v-show=&quot;hasNoData&quot;&gt;</span><br><span class="line">        没有找到匹配数据</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import Bscroll from &#x27;better-scroll&#x27;</span><br><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;CitySearch&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    cities: Object</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      keyword: &#x27;&#x27;,  //与搜素词做双向绑定</span><br><span class="line">      list: [],</span><br><span class="line">      timer: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    hasNoData () &#123;</span><br><span class="line">      return !this.list.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">  //侦听器侦听keyword的改变：</span><br><span class="line">    keyword () &#123;</span><br><span class="line">      if (this.timer) &#123;</span><br><span class="line">        clearTimeout(this.timer)</span><br><span class="line">      &#125;</span><br><span class="line">      if (!this.keyword) &#123;</span><br><span class="line">        this.list = []</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">    //当keyword发生改变的时候，隔100ms箭头函数会被执行，</span><br><span class="line">      this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        const result = []</span><br><span class="line">        for (let i in this.cities) &#123;</span><br><span class="line">   //json里面每一项都有spell(拼音)和name(中文)，有搜索到关键字对应城市名就添加到result之中</span><br><span class="line">          this.cities[i].forEach((value) =&gt; &#123;</span><br><span class="line">            if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123;</span><br><span class="line">              result.push(value)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        //所有匹配结果集合在result中，赋值给list，让他去显示</span><br><span class="line">        this.list = result</span><br><span class="line">      &#125;, 100)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  updated () &#123;</span><br><span class="line">  //需要你传入一个DOM元素或者选择器→传search-content这个元素对应的ref：search</span><br><span class="line">  //注意不需要整个全部滚动，只需要搜索结果滚动</span><br><span class="line">    this.scroll = new Bscroll(this.$refs.search)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleCityClick(city) &#123;</span><br><span class="line">      /* 此处组件可以直接调用commit方法 */</span><br><span class="line">      /* this.$store.commit(&#x27;changeCity&#x27;, city) */</span><br><span class="line">      this.changeCity(city)</span><br><span class="line">      this.$router.push(&#x27;/&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">    ...mapMutations([&#x27;changeCity&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>进一步修改样式：此时搜索框输入a，对应的内容很多，不能向下滚动看到所有匹配项，借助BetterScroll解决：</p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image216.gif" alt="clipboard.png" style="zoom:50%;" /><ul><li><p>问题：把a取消掉城市列表还在，解决：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!this.keyword) &#123; </span><br><span class="line">this.list = []  return //没有输入关键字，就让显示为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当搜索框输入非匹配项，下面什么内容都没有，实现显示“没有找到匹配项”的文字：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个li标签：</span><br><span class="line">&lt;li class=&quot;search-item border-bottom&quot;&gt;没有找到匹配数据&lt;/li&gt;</span><br><span class="line">／／现在是无论找不找得到都显示”没有找到匹配数据“</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加上v-show来控制：</span><br><span class="line">&lt;li class=&quot;search-item border-bottom&quot; v-show=&quot;!length&quot;&gt;没有找到匹配数据&lt;/li&gt;</span><br><span class="line">length取反意思是如果list长度为0的时候才显示，</span><br><span class="line">现在是实现了找到的时候不显示+没找到显示+不搜索也显示,覆盖掉原来的所有城市列表</span><br><span class="line">search-content里面加上：v-show=&quot;keyword&quot;，意思是keyword有值的时候才会显示li标签</span><br><span class="line">二者是不同时存在的</span><br></pre></td></tr></table></figure><ul><li><p>模板里面尽量不要写逻辑运算，使用计算属性来优化(逻辑放到下面的js来完成)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li class=&quot;search-item border-bottom&quot; v-show=&quot;hasNoData&quot;&gt;没有找到匹配数据&lt;/li&gt;， </span><br><span class="line">computed: &#123;</span><br><span class="line">  hasNoData () &#123;return !this.list.length&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>‘search finish’代码提交到git</p></li></ul><h3 id="8-9-Vue项目城市选择页-Vuex实现数据共享"><a href="#8-9-Vue项目城市选择页-Vuex实现数据共享" class="headerlink" title="8-9  Vue项目城市选择页-Vuex实现数据共享"></a>8-9  Vue项目城市选择页-Vuex实现数据共享</h3><h4 id="需求1：实现在城市选择页点击城市，首页变为对应的城市"><a href="#需求1：实现在城市选择页点击城市，首页变为对应的城市" class="headerlink" title="需求1：实现在城市选择页点击城市，首页变为对应的城市"></a>需求1：实现在城市选择页点击城市，首页变为对应的城市</h4><ul><li><p>创建新的git分支：【city-vuex】</p></li><li><p>实现思路：City.vue和Home.vue没有公用的父级组件，这样就没有办法通过父级组件进行数据的中转，之前讲过bus总线的概念，在这里可以使用bus，但是使用bus依然比较麻烦，Vue的官方有提供一个工具——Vuex（Vue官方推荐的数据框架）。在Vue大型项目中，Vue只能承担视图层的主要内容，而当我们涉及大量数据之前传递时往往需要一个数据框架辅助，在Vue之中这个数据框架就是Vuex。</p><ul><li>当我们的一个项目之中各个页面或者多个组件之间进行复杂的数据传值很困难的时候，我们可以这样想，如果我们可以把这些数据放到公共的存储空间去存储，然后一个组件改变了这个公共的数据，其他的组件也能感知到，Vuex的设计理念是这样的</li></ul><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image218.gif" alt="clipboard.png"></p></li></ul><ul><li><p>解读：虚线部分的内容就是公共数据存储的区域，把这个区域理解成store仓库，这个仓库由几部分组成：</p><ul><li>【State】：所有的公用数据都存储在State之中，那如果组件想用一个公用的数据，直接去调用State就可以了。有的时候我们希望改变State里的数据，不能让组件直接改变而必须走一个流程</li><li>当有异步操作 或者一些比较多的逻辑操作，批量的同步操作时，放到Actions。组件先去调用Actions，Actions紧接着去调用Mutations，Mutations放的是一步一步对State的修改，当State存储的数据发生变化组件上显示的内容就会跟着变化了。</li><li>有的时候我们也可以略过Actions(这一步不是绝对的)，让组件直接去调用Mutations修改State里面的数据，这块需要额外注意的是：<ul><li>当组件调用Actions时，调用的是Dispatch方法来操作Actions</li><li>然后组件去调用Mutations或者Actions调用Mutations的时候，用commit方法来操作Mutations。</li></ul></li></ul></li><li><p>使用Vuex ：</p><ul><li><p>安装: npm install vuex –save</p></li><li><p>src目录新建store/index.js， 引入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;  </span><br><span class="line">import Vuex from &#x27;vuex&#x27;     </span><br><span class="line">Vue.use(Vuex)     </span><br><span class="line">export default new Vuex.Store(&#123;   </span><br><span class="line">state: &#123;city: &#x27;上海&#x27;&#125;,   //默认是上海</span><br><span class="line">mutations: &#123;</span><br><span class="line">  changeCity (state, city) &#123;     </span><br><span class="line">    state.city = city  &#125;   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>在main.js里面：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import store from &#x27;./store/index&#x27;</span><br><span class="line">引入了store，</span><br><span class="line">创建根Vue实例的时候把store:store传进去(键和值一样写一个东西就行)</span><br></pre></td></tr></table></figure><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image220.gif" alt="clipboard.png"></p></li></ul></li><li><p>组件(home的Header.vue)的城市使用这个公用的数据：<br>以前Home.vue的Header的城市数据是通过ajax后端返回给我们的，现在希望city是前端存储的不需要后端告诉，所以把原来的city代码删除。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">home的Header.vue的&#123;&#123;city&#125;&#125;改成</span><br><span class="line">&#123;&#123;this.$store.state.city&#125;&#125;   //此时Header的城市显示默认的上海</span><br><span class="line">//因为在main.js根实例把store传递进去了，紧接着Vuex创建的store会派发到每个子组件里面，所以每个子组件都可以用this.$store获取store</span><br></pre></td></tr></table></figure></li><li><h4 id="需求2：城市选择页面中，点击热门城市的时候公用数据发生变化"><a href="#需求2：城市选择页面中，点击热门城市的时候公用数据发生变化" class="headerlink" title="需求2：城市选择页面中，点击热门城市的时候公用数据发生变化"></a>需求2：城市选择页面中，点击热门城市的时候公用数据发生变化</h4></li><li><p>实现思路：</p></li><li><p>做法：</p><ul><li><p>为城市选择Citylist添加点击事件，当改变city的时候，派发changeCity这样一个Actions，把city作为第二个参数传过来。</p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image222.gif" alt="clipboard.png"></p><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image224.gif" alt="clipboard.png"></p></li><li><p>创建store的时候只有一个state，并没有actions，所以要在写一个actions对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions: &#123; </span><br><span class="line">//这里对应的是那边dispatch的事件和参数</span><br><span class="line">  changeCity (ctx, city) &#123;     </span><br><span class="line"> ctx.commit(&#x27;changeCity&#x27;, city)  </span><br><span class="line">     //注意这里是context</span><br><span class="line">     //之所以actions里面第一个参数是ctx，作用是可以借助ctx帮我们拿到commit方法</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>actions里面已经接收到了传递过来的city，它需要调用Mutations去改变公用的数据，所以↓创建Mutations</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;    </span><br><span class="line">  changeCity (state, city) &#123;     </span><br><span class="line">  state.city = city    </span><br><span class="line">  &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>此时，通过Vuex实现首页和列表页的数据共享，点击热门城市，城市选择页的当前城市和首页的城市会显示对应的城市（但是要自行返回首页）</p></li><li><p>其实这个过程并没有异步操作，没必要调用Actions去做一个转发，直接调用commit也是可以的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组件里：</span><br><span class="line">methods: &#123;  </span><br><span class="line">  handleCityClick (city) &#123;     </span><br><span class="line">    this.$store.commit(&#x27;changeCity&#x27;, city)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store里：</span><br><span class="line">mutations: &#123;    </span><br><span class="line">  changeCity (state, city) &#123;     </span><br><span class="line">  state.city = city    </span><br><span class="line">  &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="需求3：实现点击列表的时候也实现城市的切换"><a href="#需求3：实现点击列表的时候也实现城市的切换" class="headerlink" title="需求3：实现点击列表的时候也实现城市的切换"></a>需求3：实现点击列表的时候也实现城市的切换</h4><p>这跟需求1其实是类似的，监听、注意修改为innerItem.name，点击执行的都是一个方法<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image228.gif" alt="clipboard.png"></p></li><li><h4 id="需求4：实现搜索结果中点击城市也可以实现城市的切换："><a href="#需求4：实现搜索结果中点击城市也可以实现城市的切换：" class="headerlink" title="需求4：实现搜索结果中点击城市也可以实现城市的切换："></a>需求4：实现搜索结果中点击城市也可以实现城市的切换：</h4><p>同样监听点击，然后执行的是同一个方法，只是不同的组件，传参名字不一样而已。这个地方需求1与需求3都是在list组件里，所以执行方法写一个就可以。Search组件没有，所以要赋值一下这个方法<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image230.gif" alt="clipboard.png"></p></li><li><h5 id="需求1、需求2、需求4-：都需要自行返回页面才能看见对应城市的显示，但是不会自行跳转页面"><a href="#需求1、需求2、需求4-：都需要自行返回页面才能看见对应城市的显示，但是不会自行跳转页面" class="headerlink" title="需求1、需求2、需求4 ：都需要自行返回页面才能看见对应城市的显示，但是不会自行跳转页面"></a>需求1、需求2、需求4 ：都需要自行返回页面才能看见对应城市的显示，但是不会自行跳转页面</h5><p>解决：【路由—编程式导航】在网页上做页面跳转，有2种方式：</p><ul><li><p>一种是通过a标签的形式实现跳转</p></li><li><p>另一种是通过js中， window location.href这种形式。</p></li><li><p>在Vue之中也一样，可以通过router-link这种标签的形式做页面的跳转，还可以通过js作js形式的跳转，js跳转不像window location.href这么简单，在vue-router里面用的是编程式的导航，编程式的导航提供给我们一个方法：$router.push(location, onComplete?, onAbort?)：</p></li><li><p><a href="https://router.vuejs.org/zh/guide/essentials/navigation.html">https://router.vuejs.org/zh/guide/essentials/navigation.html</a></p></li><li><p>每个组件里都有实例属性router(在main.js里面根实例传了router)：</p></li></ul></li><li><p>点击城市的时候首先改变城市的内容，然后实现页面的跳转    this.$router.push(‘/‘)  ‘/‘是首页地址<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image232.gif" alt="clipboard.png"></p></li></ul><h3 id="8-10-Vue项目城市选择页-Vuex的高级使用及localStorage"><a href="#8-10-Vue项目城市选择页-Vuex的高级使用及localStorage" class="headerlink" title="8-10  Vue项目城市选择页-Vuex的高级使用及localStorage"></a>8-10  Vue项目城市选择页-Vuex的高级使用及localStorage</h3><h5 id="问题：点击三亚城市变为三亚，刷新一次页面城市又回到了默认的上海。"><a href="#问题：点击三亚城市变为三亚，刷新一次页面城市又回到了默认的上海。" class="headerlink" title="问题：点击三亚城市变为三亚，刷新一次页面城市又回到了默认的上海。"></a>问题：点击三亚城市变为三亚，刷新一次页面城市又回到了默认的上海。</h5><h5 id="需求1：希望实现选中过一次城市，下一次再访问网站的时候显示的是上次选择的城市"><a href="#需求1：希望实现选中过一次城市，下一次再访问网站的时候显示的是上次选择的城市" class="headerlink" title="需求1：希望实现选中过一次城市，下一次再访问网站的时候显示的是上次选择的城市"></a>需求1：希望实现选中过一次城市，下一次再访问网站的时候显示的是上次选择的城市</h5><ul><li><p>【引入localStorageAPI】：localStorage，HTML5提供的一个新的API，可以帮助我们实现类似cookie的功能，做到本地存储，这个API比cookie简单。</p></li><li><p>更改：</p><ul><li><p>点击城市的时候不但把state.city改了，同时存一个 localStorage.city ，city的默认值是localStorage.city 或者 ‘上海’ (优先从localStorage.city取，取不到才用上海)    </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;   </span><br><span class="line">state: &#123;    city: localStorage.city || &#x27;上海&#x27;   &#125;,   </span><br><span class="line">mutations: &#123;    </span><br><span class="line">changeCity (state, city) &#123; </span><br><span class="line">state.city = city     </span><br><span class="line">localStorage.city = city    </span><br><span class="line">&#125;   </span><br><span class="line">&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>建议只要用localStorage，就在外层包裹一层try catch，因为在某些浏览器，如果用户关闭了本地存储这样的功能或者使用隐身模式，使用localStorage可能会使浏览器直接抛出异常，整个代码就运行不了了<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image234.gif" alt="clipboard.png"></p></li><li><p>对index.js进行抽离：<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image236.gif" alt="clipboard.png"><br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image238.gif" alt="clipboard.png"><br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image240.gif" alt="clipboard.png"></p></li><li><h5 id="小问题：点击阿拉善盟，向下的箭头icon移位了"><a href="#小问题：点击阿拉善盟，向下的箭头icon移位了" class="headerlink" title="小问题：点击阿拉善盟，向下的箭头icon移位了"></a>小问题：点击阿拉善盟，向下的箭头icon移位了</h5><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image242.gif" alt="clipboard.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">home/Header.vue中：  (原来的width定死了)  原来：    </span><br><span class="line">.header-right     width:1.24rem     </span><br><span class="line">修改为：    </span><br><span class="line">.header-right     min-width:1.04rem     padding:0 .1rem    </span><br></pre></td></tr></table></figure><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image244.gif" alt="clipboard.png"></p></li></ul></li><li><h4 id="对Vuex的进一步优化：映射"><a href="#对Vuex的进一步优化：映射" class="headerlink" title="对Vuex的进一步优化：映射"></a>对Vuex的进一步优化：映射</h4><p>Vuex给了我们一个比较高级的API使得我们可以这样去写代码：    </p><ul><li>…mapState里可以传递一个数组，也可以是一个对象，  意思是想把Vuex里的city公用数据映射到这个组件的计算属性里，映射过来的名字叫currentCity</li><li>…mapMutations     有一个Mutations叫changeCity，然后把这个mutation映射到组件里changeCity的方法里，     然后可以写成:this.changeCity(city)</li><li>…mapGetters   getter的作用类似于组件中的computed计算属性的作用，当需要根据state里面的数据算出新的数据的时候就可以借助getter来提供新的数据，这样可以避免数据的冗余.组件使用之前要在computed里面做映射<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image250.gif" alt="clipboard.png"><br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image254.gif" alt="clipboard.png"></li></ul><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image252.gif" alt="clipboard.png"></p></li><li><p>【Module】<br>当遇到非常复杂的业务场景，如管理后台系统的时候，经常有很多功能的数据在Vuex里进行存储，如果把mutations都放在mutations.js文件里，这个文件会慢慢变得非常庞大，难以维护，这个时候可以借助module对一个复杂的mutation state包括actions进行一个拆分。创建store的时候可以通过模块来创建，对各个模块的数据进行整合，通过module来写代码可以有更好的维护性。</p></li></ul><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image256.gif" alt="clipboard.png"></p><p>当然我们的项目中只有city一个公用数据，没必要使用module进行拆分。</p><ul><li>‘use vuex’代码提交带git</li></ul><h3 id="8-11-Vue项目城市选择页-使用keep-alive优化网页性能"><a href="#8-11-Vue项目城市选择页-使用keep-alive优化网页性能" class="headerlink" title="8-11  Vue项目城市选择页-使用keep-alive优化网页性能"></a>8-11  Vue项目城市选择页-使用keep-alive优化网页性能</h3><ul><li><p>新建git分支：【city-keepalive】</p></li><li><p>问题分析：</p></li></ul><table><thead><tr><th>1.换到城市选择页city.json请求了一次</th><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image258.gif" alt="clipboard.png"></th></tr></thead><tbody><tr><td>2.返回到首页index.json也请求了一次</td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image260.gif" alt="clipboard.png"></td></tr><tr><td>再进入城市选择页city.json又被请求一次，每一次路由发生变化时ajax都会被重新发送</td><td>原因：  每一次切换，组件都会被重新渲染，如home/Home.vue中 mounted () {    this.getHomeInfo()   },  mounted钩子会被重新执行，ajax数据就会被重新获取    <br /> 问题：每一次都获取数据性能很低，希望实现获取一次就可以了：</td></tr></tbody></table><ul><li><p>问题解决：</p><ol><li><p>APP.vue中：  <router-view/>显示的是路由所对应的内容，外层包裹keep-alive标签(是Vue自带的一个标签)。  意思是：路由的内容被加载过一次后把内容放到内存之中，下一次再进这个路由的时候不用重新渲染这个组件去执行钩子函数，只需要你进入内存里把以前的内容拿出来显示在页面上。<br>此时，再进入城市列表页不会重复city.json，回到首页也是不会在index.json<br>此时，实际上逻辑上存在问题：当在桂林的时候首页显示的是桂林的内容，切换到北京的时候首页应该显示北京的内容，所以城市改变的时候，首页还是需要重新加载ajax请求</p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image262.gif" alt="clipboard.png" style="zoom: 67%;" /></li><li><p>Home.vue中：请求接口时应带一个参数，等于Vuex里面存的当前的城市。所以，引入Vuex；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27;</span><br><span class="line">data () &#123;    </span><br><span class="line">    return &#123; </span><br><span class="line"></span><br><span class="line">    //data里面设置一个数据lastCity，一开始值为空</span><br><span class="line">    lastCity: &#x27;&#x27;,     </span><br><span class="line">    swiperList: [],     </span><br><span class="line">    iconList: [],     </span><br><span class="line">    recommendList: [],     </span><br><span class="line">    weekendList: []    </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;    ...mapState([&#x27;city&#x27;])   &#125;, //获取到对应城市的内容</span><br><span class="line">请求接口时应带一个参数：**（重要）**</span><br><span class="line">axios.get(&#x27;api/index.json?city=&#x27; + this.city) //发ajax时把city放在请求里面</span><br><span class="line">//此时，首次进入页面mounted和activated都执行，当切换城市后只有activated执行，</span><br><span class="line">//所以借助这个生命周期函数实现：切换城市首页内容换成切换的城市的内容</span><br><span class="line">mounted () &#123;  </span><br><span class="line">//当页面被挂载时，对第一次的城市做一个保存</span><br><span class="line">this.getHomeInfo()   </span><br><span class="line">this.lastCity = this.city</span><br><span class="line">&#125;, </span><br><span class="line">activated () &#123; </span><br><span class="line">//mounted被挂载的时候，页面初次加载时，会发ajax请求，页面重新显示时activated被重新执行，所以每次页面重新显示时判断页面和上次页面是否相同城市，如果城市不相等重新发一次ajax请求：</span><br><span class="line">  if (this.lastCity !== this.city) &#123; </span><br><span class="line">    this.lastCity = this.city   </span><br><span class="line">    //重新发一次ajax请求</span><br><span class="line">    this.getHomeInfo() </span><br><span class="line">  &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol></li><li><p>总结：</p><ul><li>通过keep-alive新增的一个生命周期函数activated，结合lastCity这个临时缓冲变量，实现网页性能优化的调整</li><li>首页再次→城市选择页不会二次请求city.json</li><li>城市没有发生变换返回首页不会二次index.json，城市变化返回首页才会二次index.json，同时数据参数是变化后的城市。</li></ul></li><li><p>‘finish page’代码提交到git分支。</p></li></ul><h3 id="9-1-Vue项目详情页-详情动态路由和banner布局"><a href="#9-1-Vue项目详情页-详情动态路由和banner布局" class="headerlink" title="9-1  Vue项目详情页-详情动态路由和banner布局"></a>9-1  Vue项目详情页-详情动态路由和banner布局</h3><ul><li><p>新建git分支：【detail-banner】</p></li><li><h4 id="需求1：点击跳转对应景点的详情页"><a href="#需求1：点击跳转对应景点的详情页" class="headerlink" title="需求1：点击跳转对应景点的详情页"></a>需求1：点击跳转对应景点的详情页</h4><ul><li>代码： 注意将li标签改成router-link  添加to属性 为保持一致，修改tag属性为li</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#x27;/detail/&#x27; + item.id&quot;   tag=&quot;li&quot;&gt;  //配置路由信息   </span><br><span class="line">  &lt;li class=&quot;item border-bottom&quot; v-for=&quot;item of list&quot; :key=&quot;item.id&quot;&gt;       </span><br><span class="line">    &lt;img class=&quot;item-img&quot; :src=&quot;item.imgUrl&quot; /&gt;      </span><br><span class="line">    &lt;div class=&quot;item-info&quot;&gt;       </span><br><span class="line">        &lt;p class=&quot;item-title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt;       </span><br><span class="line">        &lt;p class=&quot;item-desc&quot;&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt;       </span><br><span class="line">        &lt;button class=&quot;item-button&quot;&gt;查看详情&lt;/button&gt;      </span><br><span class="line">    &lt;/div&gt;     </span><br><span class="line">  &lt;/li&gt;     </span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image276.gif" alt="clipboard.png"><br>景点文字会变颜色(router-link默认是a标签的颜色)，需要重新改样式</p><ul><li><p>修改路由配置<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image282.gif" alt="clipboard.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:to=&quot;&#x27;/detail/&#x27; + item.id&quot;</span><br><span class="line"></span><br><span class="line">//路径后面还会跟id这样的内容</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建pages/detail/Detail.vue:  </p><ul><li>使用iconfont下载的zip(包含之前的图标和现在的图标)替换掉(iconfont.eot，iconfont.svg，iconfont.ttf，iconfont.woff四个文件)  </li><li>注意iconfont.css的的data修改成新的<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image284.gif" alt="clipboard.png"></li></ul></li><li><p>修改Detail组件样式：<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image292.gif" alt="clipboard.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.banner-img     width:100%  //使图片展示完全</span><br><span class="line">.banner-info     //实现渐变效果</span><br><span class="line">display:flex     </span><br><span class="line">position:absolute     </span><br><span class="line">left:0     </span><br><span class="line">right:0     </span><br><span class="line">bottom:0     </span><br><span class="line">line-height:.6rem     </span><br><span class="line">color:#fff     </span><br><span class="line">background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8))</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-Vue项目详情页-公用图片画廊组件拆分"><a href="#9-2-Vue项目详情页-公用图片画廊组件拆分" class="headerlink" title="9-2  Vue项目详情页-公用图片画廊组件拆分"></a>9-2  Vue项目详情页-公用图片画廊组件拆分</h3><h4 id="需求：点击图片时展示图片轮播，下面显示图片轮播的页码"><a href="#需求：点击图片时展示图片轮播，下面显示图片轮播的页码" class="headerlink" title="需求：点击图片时展示图片轮播，下面显示图片轮播的页码"></a>需求：点击图片时展示图片轮播，下面显示图片轮播的页码</h4><ul><li><p>这种画廊组件在项目中可能不仅一个页面用到→变成一个公用的组件：创建common/gallary/Gallary.vue</p></li><li><h5 id="公用组件Gallary："><a href="#公用组件Gallary：" class="headerlink" title="公用组件Gallary："></a>公用组件Gallary：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot; @click = &quot;handleGallaryClick&quot;&gt;</span><br><span class="line">    &lt;!-- 对container绑定事件：希望点击轮播图，就会推出 --&gt;</span><br><span class="line">    &lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">      &lt;swiper :options = &quot;swiperOptions&quot;&gt;</span><br><span class="line">   &lt;!-- swiper里面的每一页应该循环一些图片。去电swiper-slide，src写死，不要循环，找一张图片 --&gt;</span><br><span class="line">        &lt;swiper-slide  v-for = &quot;(item, index) in imgs&quot; :key = index&gt;</span><br><span class="line">          &lt;img class=&quot;gallary-img&quot;   :src = &#x27;item&#x27;/&gt;</span><br><span class="line">        &lt;/swiper-slide&gt;</span><br><span class="line">        &lt;!-- 这样就有两张轮播图，是可以拖动的。但是下面还应该有反斜杠显示拖动的第第几张图片。</span><br><span class="line">        所以还要加pagination.怎么配置pagination呢? swiper里面的pagination,注意要在data里面定义swiperOptions--&gt;</span><br><span class="line">        &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/swiper&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;CommonGallary&#x27;,</span><br><span class="line">  // 图片是外面的数据传过来的</span><br><span class="line">  props: &#123;</span><br><span class="line">    imgs:&#123;</span><br><span class="line">      type: Array,</span><br><span class="line">      default() &#123;</span><br><span class="line">        return []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      swiperOptions:&#123;</span><br><span class="line">        // 在这里定义swiper里面的swiperOptions，没定义过是不能使用的</span><br><span class="line">        pagination: &#x27;.swiper-pagination&#x27;,</span><br><span class="line">        // 底层是借助Swiper实现的，想知道怎么实现，去baidu搜索Swiper3的pagination官网。</span><br><span class="line">        // 也可以查看Api官网,看左侧的pagination分页器。有一个paginationType.用第2种效果的fraction</span><br><span class="line">        paginationType: &quot;fraction&quot;,</span><br><span class="line">        // 解决点击后轮播图问题：加两个参数observeParents</span><br><span class="line">        // 意思是：Swiper插件只要监听到自己的元素或父级元素dom节点发生改变，就会自我刷新，就解决了宽度计算的问题</span><br><span class="line">        observeParents: true,</span><br><span class="line">        observer: true,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleGallaryClick() &#123;</span><br><span class="line">      // 点击后出发事件</span><br><span class="line">      this.$emit(&#x27;close&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style lang = stylus scoped&gt;</span><br><span class="line">/* 解决swiper的container里有overflow：hidden问题 */</span><br><span class="line">  .container &gt;&gt;&gt; .swiper-container</span><br><span class="line">    overflow: inherit</span><br><span class="line">  .container</span><br><span class="line">    display: flex</span><br><span class="line">    position: fixed</span><br><span class="line">    left: 0</span><br><span class="line">    right: 0</span><br><span class="line">    top: 0</span><br><span class="line">    bottom: 0</span><br><span class="line">    background: #000;</span><br><span class="line">    z-index: 99</span><br><span class="line">    flex-direction: column</span><br><span class="line">    justify-content: center</span><br><span class="line">    .wrapper</span><br><span class="line">      background: #fff</span><br><span class="line">      width: 100%   </span><br><span class="line">      /*不给高度，而是撑开一个 正方形的位置*/</span><br><span class="line">      height: 0</span><br><span class="line">      /* overflow: hidden */</span><br><span class="line">      padding-bottom: 100%</span><br><span class="line">      .gallary-img</span><br><span class="line">        width: 100%   解决图片太大的问题</span><br><span class="line">      .swiper-pagination</span><br><span class="line">      /* 让颜色是白色 */</span><br><span class="line">        color: red  </span><br><span class="line">        bottom: -1rem   </span><br><span class="line">        /* 这样会页面没有页码了。此时去掉wrapper的overflow 依然不行，*/</span><br><span class="line">        /* swiper-container上面默认是有overflow：hidden的内容，所以将高度限制死了 */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="Banner-vue使用Gallary-vue公用组件"><a href="#Banner-vue使用Gallary-vue公用组件" class="headerlink" title="Banner.vue使用Gallary.vue公用组件"></a>Banner.vue使用Gallary.vue公用组件</h5><ul><li><p>common-gallary默认情况是隐藏的，点击画廊才显示出来。点击轮播，显示画廊</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;banner&quot; @click = &quot;handleBannerClick&quot; &gt;</span><br><span class="line">      &lt;img :src=&quot;bannerImg&quot;  alt=&quot;&quot; class=&quot;banner-img&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;banner-info&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;banner-title&quot;&gt;</span><br><span class="line">          &#123;&#123;this.sightName&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;banner-number&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;iconfont banner-icon&quot;&gt;&amp;#xe632;&lt;/span&gt;</span><br><span class="line">         &#123;&#123;this.gallaryImgs.length&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 我希望他的默认状态是隐藏的 --&gt;</span><br><span class="line">    &lt;common-gallary :imgs = &quot;gallaryImgs&quot; </span><br><span class="line">                  v-show = &quot;showGallary&quot;</span><br><span class="line">                  @close = &quot;handleGallaryClose&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/common-gallary&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import CommonGallary from &#x27;common/gallary/Gallary&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;DetailBanner&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    CommonGallary,</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    sightName: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">    &#125;,</span><br><span class="line">    bannerImg: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">    &#125;,</span><br><span class="line">    gallaryImgs: &#123;</span><br><span class="line">      type: Array,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      showGallary: false,</span><br><span class="line">    // 默认是false不显示，当你点击的时候，显示</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleBannerClick()&#123;</span><br><span class="line">      this.showGallary = true</span><br><span class="line">      // 此时点击显示轮播图。但是此时轮播图页码又出现问题了。</span><br><span class="line">      //原因：一开始让commonGallary隐藏，</span><br><span class="line">      // 当再次显示的时候Swiper计算宽度会有问题，导致轮播图无法正常滚动，</span><br><span class="line">      //解决：Gallary.vue的SwiperOptions参数设置。</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    handleGallaryClose() &#123;</span><br><span class="line">      this.showGallary = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang = &quot;stylus&quot; scoped&gt;</span><br><span class="line">  .banner</span><br><span class="line">    overflow: hidden</span><br><span class="line">    position: relative</span><br><span class="line">    height: 0</span><br><span class="line">    padding-bottom: 55%</span><br><span class="line">  .banner-img</span><br><span class="line">    width: 100%</span><br><span class="line">  .banner-info</span><br><span class="line">    display: flex</span><br><span class="line">    position: absolute</span><br><span class="line">    left:0</span><br><span class="line">    right: 0</span><br><span class="line">    bottom 0</span><br><span class="line">    line-height: .6rem</span><br><span class="line">    color: #fff</span><br><span class="line">    background-image: linear-gradient(top, rgba(0, 0, 0, .8))</span><br><span class="line">    .banner-title</span><br><span class="line">      flex:1</span><br><span class="line">      font-size: .32rem</span><br><span class="line">      padding: 0 .2rem</span><br><span class="line">    .banner-number</span><br><span class="line">      margin-top: .2rem</span><br><span class="line">      padding: 0 .4rem</span><br><span class="line">      height: .32rem</span><br><span class="line">      line-height: .32rem</span><br><span class="line">      border-radius: .2rem</span><br><span class="line">      background: rgba(0, 0, 0, .8)</span><br><span class="line">      font-size: .24rem</span><br><span class="line">      .banner-icon</span><br><span class="line">        font-size: .24rem</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>115.</p><p>l 传imgs：</p><table><thead><tr><th>Banner.vue中：</th><th><common-gallary    :imgs="imgs"    >    </common-gallary></th></tr></thead><tbody><tr><td>data里面定义imgs</td><td>data () {    return {     imgs: [‘<a href="http://img1.qunarzz.com/sight/p0/1907/39/394802bd7fce909fa3.img.jpg_r_800x800_250e62f4.jpg&#39;">http://img1.qunarzz.com/sight/p0/1907/39/394802bd7fce909fa3.img.jpg_r_800x800_250e62f4.jpg&#39;</a>, ‘<a href="http://img1.qunarzz.com/sight/p0/1907/3d/3deee24945b577b3a3.img.jpg_r_800x800_46dee719.jpg&#39;]">http://img1.qunarzz.com/sight/p0/1907/3d/3deee24945b577b3a3.img.jpg_r_800x800_46dee719.jpg&#39;]</a>    }   },</td></tr></tbody></table><ul><li>‘banner finish’代码提交到git分支</li></ul><h3 id="9-3-Vue项目详情页-实现Header渐隐渐显效果"><a href="#9-3-Vue项目详情页-实现Header渐隐渐显效果" class="headerlink" title="9-3  Vue项目详情页-实现Header渐隐渐显效果"></a>9-3  Vue项目详情页-实现Header渐隐渐显效果</h3><ul><li><h4 id="需求：详情页左上方有返回按钮，往下滑返回回按钮消失、渐隐渐显Header区域"><a href="#需求：详情页左上方有返回按钮，往下滑返回回按钮消失、渐隐渐显Header区域" class="headerlink" title="需求：详情页左上方有返回按钮，往下滑返回回按钮消失、渐隐渐显Header区域"></a>需求：详情页左上方有返回按钮，往下滑返回回按钮消失、渐隐渐显Header区域</h4><ul><li>创建git分支：【detail-header】</li><li>pages/city/detail/components创建Header.vue</li><li>Detail.vue中：引入、注册、<detail-header></detail-header></li><li>页面需要足够长这样才可以滚动，∴Detail.vue中：写一个div帮助我们撑开页面的高度<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image316.gif" alt="clipboard.png"></li></ul></li><li><p>Header.vue中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-link class=&quot;header-abs&quot; </span><br><span class="line">                  to = &quot;/&quot; </span><br><span class="line">                  tag = div</span><br><span class="line">                  v-show = &quot;showAbs&quot;</span><br><span class="line">    &gt;</span><br><span class="line">       &lt;span class=&quot;iconfont header-abs-back&quot;&gt;&amp;#xe624;&lt;/span&gt;</span><br><span class="line">       &lt;!-- 点击区块，回到首页，router-link来实现。将div改成router-link --&gt;</span><br><span class="line">       &lt;!-- to回到根路径&quot;/&quot;，希望他会自动回到首页。如果写“.&quot;,他却后退到了detail页面，空白 --&gt;</span><br><span class="line">    &lt;/router-link&gt;</span><br><span class="line">    &lt;!-- 绑定style, 实现渐隐渐现的效果 --&gt;</span><br><span class="line">    &lt;div class=&quot;header-fixed&quot; v-show = &quot;!showAbs&quot; :style = &quot;opacityStyle&quot;&gt;</span><br><span class="line">      &lt;!-- 复制city页面的header进行修改 --&gt;</span><br><span class="line">      &lt;!-- 这时候页面详情会一直显示在顶部，这个箭头会覆盖上面的箭头 --&gt;</span><br><span class="line">      &lt;router-link to = &quot;/&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;iconfont header-fixed-back&quot;&gt;&amp;#xe624;&lt;/div&gt;</span><br><span class="line">      &lt;/router-link&gt;</span><br><span class="line">      景点详情</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;  </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;DetailHeader&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        showAbs: true,</span><br><span class="line">        // 这个变量定义了是否显示header-abs。而header-fixed取反，刚进页面他是不显示的，</span><br><span class="line">        // 只有当我滚动页面的时候，header-ads消失，他header-fixed才显示。所以监听scroll事件</span><br><span class="line">        opacityStyle: &#123;</span><br><span class="line">        opacity: 0</span><br><span class="line">        &#125;</span><br><span class="line">        // 默认等于0，当用户在60--140之间滚动的时候，有一个渐隐渐现的效果.给判断条件添加140</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      handleScroll()&#123;</span><br><span class="line">        const top = document.documentElement.scrollTop;</span><br><span class="line">//v-show实现刚进页面的时候显示返回按钮，Header区域景点详情不显示。什么时候显示Header区域景点详情呢？  往下滑到一定距离返回按钮隐藏、显示Header区域景点详情：通过对window的scroll事件进行监听</span><br><span class="line">        if (top &gt; 60) &#123;</span><br><span class="line">          this.showAbs =  false</span><br><span class="line">          // 此时不仅显示顶部，还要加动画</span><br><span class="line">          let opacity = top / 140  //这里要改用let来定义</span><br><span class="line">          opacity = opacity&gt;1 ? 1: opacity</span><br><span class="line">          this.opacityStyle = &#123;</span><br><span class="line">            // 对opacityStyle对象添加属性，键和值都相等</span><br><span class="line">            opacity: opacity</span><br><span class="line">          &#125;</span><br><span class="line">          // 此时渐隐渐现的下过已经有了，但一旦超过140，就会顶部不显示了,去掉&amp;&amp; top &lt; 140</span><br><span class="line">          // 对opacity进行判断:opacity?1: opacity,,这样就没有问题了</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.showAbs =  true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    activated()&#123;</span><br><span class="line">      // 在这个钩子里，用了keep-alive，所以当页面展示的时候他就会执行handleScroll方法</span><br><span class="line">      window.addEventListener(&#x27;scroll&#x27;, this.handleScroll)</span><br><span class="line">      // 这里addEventListener会带来问题：这是对window全局事件的监听，</span><br><span class="line">      // 这个事件不是对组件的绑定，而是绑定到了window的全局对象上面了</span><br><span class="line">      // Home组件也会收到影响，解决：deactived</span><br><span class="line">    &#125;,</span><br><span class="line">    deactivated() &#123;</span><br><span class="line">      // 所以我们要在离开组件的时候，移除对这一事件的监听</span><br><span class="line">      window.removeEventListener(&#x27;scroll&#x27;, this.handleScroll)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang = stylus scoped&gt;</span><br><span class="line">  @import &quot;~styles/varibles.styl&quot;</span><br><span class="line">  .header-abs</span><br><span class="line">    position: absolute</span><br><span class="line">    left: .2rem</span><br><span class="line">    top: .2rem</span><br><span class="line">    width: .8rem</span><br><span class="line">    height: .8rem</span><br><span class="line">    line-height: .8rem</span><br><span class="line">    border-radius: .4rem</span><br><span class="line">    background rgba(0, 0, 0, .8)</span><br><span class="line">    text-align: center</span><br><span class="line">    .header-abs-back</span><br><span class="line">      color: #fff</span><br><span class="line">      font-size: .4rem</span><br><span class="line">  .header-fixed</span><br><span class="line">    position fixed</span><br><span class="line">    top 0</span><br><span class="line">    left 0</span><br><span class="line">    right 0</span><br><span class="line">    height $headerHeight</span><br><span class="line">    line-height $headerHeight</span><br><span class="line">    text-align center</span><br><span class="line">    color #fff</span><br><span class="line">    background $bgColor</span><br><span class="line">    font-size .32rem</span><br><span class="line">    z-index 2 </span><br><span class="line">    /* 在详情页往下滑的时候，list前面的图标会浮出来，显示与顶部一起显示，z-index提高权重 */</span><br><span class="line">    .header-fixed-back</span><br><span class="line">      position absolute</span><br><span class="line">      top 0</span><br><span class="line">      left 0</span><br><span class="line">      width .64rem</span><br><span class="line">      text-align center</span><br><span class="line">      font-size .4rem</span><br><span class="line">      color #fff</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>‘header animation’代码提交到git</p></li></ul><h3 id="9-4-Vue项目详情页-对全局事件的解绑"><a href="#9-4-Vue项目详情页-对全局事件的解绑" class="headerlink" title="9-4  Vue项目详情页-对全局事件的解绑"></a>9-4  Vue项目详情页-对全局事件的解绑</h3><p>很多初学者因为没有对全局事件进行解绑，造成代码出现大量的bug。</p><ul><li>如果在某个组件的标签上绑定这个事件(@click…)不会带来任何问题，因为这个事件绑定在组件的某个元素上所以只作用于这个组件的内部，不会影响外部的组件。</li><li>可是如果在这个组件上写的是window全局事件的绑定，那就有问题了。 因为事件并不是绑定在组件中，而是绑定在了全局的window对象上了，所以不仅对这个组件有效果，而且对其他的组件也产生了影响。</li></ul><p>解决：</p><ul><li><p>当对组件用了keep-alive，组件会多出activated生命周期函数，在每次页面展示时会执行。其实还提供一个生命周期函数deactivated，在页面即将被隐藏或者页面将被替换成新的页面时会被执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">页面展示的时候绑定scroll事件，而页面被隐藏时对scroll全局事件进行解绑</span><br><span class="line">activated () &#123;    </span><br><span class="line">window.addEventListener(&#x27;scroll&#x27;, this.handleScroll)   </span><br><span class="line">&#125;</span><br><span class="line">deactivated () &#123;    </span><br><span class="line">window.removeEventListener(&#x27;scroll&#x27;, this.handleScroll)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码提交到git之前的分支【detail-header】<br>查看分支：git branch<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image336.gif" alt="clipboard.png"></p><ul><li><p>当前处于master主分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .，git commit -m &#x27;fix problem&#x27;，git push，</span><br><span class="line">（让之前的detai-header分支和master分支作合并：）</span><br><span class="line">git checkout detail-header，git merge master，git push</span><br></pre></td></tr></table></figure></li><li><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout detail-header，git add .，git commit -m &#x27;fix problem&#x27;，git push，</span><br><span class="line">git checkout master，git merge detail-header，git push</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="9-5-Vue项目详情页-使用递归组件实现详情页列表"><a href="#9-5-Vue项目详情页-使用递归组件实现详情页列表" class="headerlink" title="9-5  Vue项目详情页-使用递归组件实现详情页列表"></a>9-5  Vue项目详情页-使用递归组件实现详情页列表</h3><ul><li><p>新建git分支：【detail-list】<br>pages/detail/components/创建List.vue<br>Detail.vue引入这个组件DetailList、注册、使用</p></li><li><p>在List.vue做递归组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for = &quot;(item , index) in list&quot; :key = index</span><br><span class="line">        class=&quot;item&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;item-title&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;item-title-icon&quot;&gt;&lt;/span&gt;</span><br><span class="line">          &#123;&#123;item.title&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!-- 在组件的上一部分，循环了list数据的以及内容，递归组件怎么使用呢 --&gt;</span><br><span class="line">        &lt;!-- 他做了一个判断，如果item有children这个数据，说明他是一个多级菜单 --&gt;</span><br><span class="line">        &lt;div v-if = &quot;item.children&quot; class=&quot;item-children&quot;&gt;</span><br><span class="line">          &lt;!-- 在这里 :我们为一个组件起名字，他最大的用处就是在这里做递归组件的时候使用--&gt;</span><br><span class="line">          &lt;!-- 此时把children当做list，再传给自己 --&gt;</span><br><span class="line">          &lt;detail-list :list = &quot;item.children&quot;&gt;</span><br><span class="line">          &lt;/detail-list&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// class=&quot;item-children&quot;把样式调整至分级的形式显示在页面--给个padding左右（而不是让二级列表和一级标题一样对齐显示）</span><br></pre></td></tr></table></figure></li><li><p>作业：剩下部分的布局和逻辑实现（用户评论+列表样式+评论的页面）</p></li><li><p>‘use recursive component’代码提交到git</p></li></ul><h3 id="9-6-Vue项目详情页-动态获取详情页面数据（使用Ajax获取动态数据）"><a href="#9-6-Vue项目详情页-动态获取详情页面数据（使用Ajax获取动态数据）" class="headerlink" title="9-6  Vue项目详情页-动态获取详情页面数据（使用Ajax获取动态数据）"></a>9-6  Vue项目详情页-动态获取详情页面数据（使用Ajax获取动态数据）</h3><ul><li><p>新建git分支：【detail-ajax】</p></li><li><p>获取Ajax数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Detail.vue中：     </span><br><span class="line">//借助生命周期钩子mounted 发ajax请求，  </span><br><span class="line">methods:里定义getDetailInfo方法，  引入axios，      Ajax数据获取完毕就可以输出结果了then(this.handleGetDataSucc)        </span><br><span class="line">if (res.ret &amp;&amp; res.data) &#123;     </span><br><span class="line">const data = res.data        console.log(data)      &#125;可以输出数据        </span><br><span class="line">接下来把写死的数据换掉：  定义     sightName: &#x27;&#x27;,     bannerImg: &#x27;&#x27;,     gallaryImgs: [],     list: []  等于获取到的数据      this.sightName = data.sightName      this.bannerImg = data.bannerImg      this.gallaryImgs = data.gallaryImgs      this.list = data.categoryList                                                          |</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Detail.vue中： </span><br><span class="line">data () &#123;    </span><br><span class="line">return &#123; </span><br><span class="line">sightName: &#x27;&#x27;,     </span><br><span class="line">bannerImg: &#x27;&#x27;,    </span><br><span class="line">        gallaryImgs: [],     </span><br><span class="line">        list: []    &#125;   </span><br><span class="line">       &#125;,   </span><br><span class="line">methods: &#123;    </span><br><span class="line">  getDetailInfo () &#123;</span><br><span class="line">  // 每一次请求希望把id带给后端，这个id是动态路由的参数，获得动态路由的参数：router/index里有path: &#x27;/detail/:id&#x27;，router定义了动态路由会把对应的id存在id这个变量里，∴可以这样写：axios.get(&#x27;/api/detail.json&#x27; + this.$route.params.id)，但是这样拼接参数麻烦，可以写一个对象。</span><br><span class="line">    axios.get(&#x27;/api/detail.json&#x27;, &#123;</span><br><span class="line">        params: &#123;</span><br><span class="line">        id: this.$route.params.id</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;).then(this.handleGetDataSucc) &#125;,    </span><br><span class="line">  handleGetDataSucc (res) &#123;     </span><br><span class="line">  res = res.data     </span><br><span class="line">  if (res.ret &amp;&amp; res.data) &#123;      </span><br><span class="line">     const data = res.data      </span><br><span class="line">     this.sightName = data.sightName      </span><br><span class="line">     this.bannerImg = data.bannerImg      </span><br><span class="line">     this.gallaryImgs = data.gallaryImgs      </span><br><span class="line">     this.list = data.categoryList     </span><br><span class="line">  &#125;    </span><br><span class="line"> &#125; </span><br><span class="line">&#125;,   </span><br><span class="line">mounted () &#123;    this.getDetailInfo()   &#125;  &#125; </span><br></pre></td></tr></table></figure><ul><li>数据传子组件，替换</li></ul></li><li><h4 id="问题：第一次进详情页会拿到0001的数据，第二次进入0002详情页并没有重新获取0002的数据，还是0001的数据"><a href="#问题：第一次进详情页会拿到0001的数据，第二次进入0002详情页并没有重新获取0002的数据，还是0001的数据" class="headerlink" title="问题：第一次进详情页会拿到0001的数据，第二次进入0002详情页并没有重新获取0002的数据，还是0001的数据"></a>问题：第一次进详情页会拿到0001的数据，第二次进入0002详情页并没有重新获取0002的数据，还是0001的数据</h4><ul><li><p>原因：和之前首页原理一样）因为detail页面通过keep-alive作了缓存，mounted只会执行一次</p></li><li><p>解决：①如果想每次重新进页面都发一个ajax请求就需要使用activated生命周期钩子。</p><p>②exclude：Detail不被缓存，每一次进入详情页mounted钩子都会被重新执行，也就是重新获取数据<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image350.gif" alt="clipboard.png"></p></li></ul></li><li><h4 id="问题：首页被拖到下面，再进入详情页，详情页也是被拖到下面而不是从顶部开始"><a href="#问题：首页被拖到下面，再进入详情页，详情页也是被拖到下面而不是从顶部开始" class="headerlink" title="问题：首页被拖到下面，再进入详情页，详情页也是被拖到下面而不是从顶部开始"></a>问题：首页被拖到下面，再进入详情页，详情页也是被拖到下面而不是从顶部开始</h4><ul><li>解决：Vue Router官网&gt;-进阶&gt;-滚动行为<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image356.gif" alt="clipboard.png"></li><li>复制到路由部分<br><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image358.gif" alt="clipboard.png"></li></ul></li><li><p>思考：每个组件里面的name的用途：</p><ol><li>递归组件</li><li>想对某个页面取消缓存时</li><li>Vue开发调试工具Devtools，组件叫什么名字取决于name给的是什么名字</li></ol></li><li><p>‘ajax’代码提交到git</p></li></ul><h3 id="10-1-接口联调"><a href="#10-1-接口联调" class="headerlink" title="10.1 接口联调"></a>10.1 接口联调</h3><ul><li><p>在之前的static文文件夹下有一个mock文件夹，里面有json文件。当代码联调的时候，他们就没用了。而是切换为后端真实提供给我们的数据。<a href="http://localhost/api/index.json%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8D%E5%86%8D%E8%AF%B7%E6%B1%82%E6%9C%AC%E5%9C%B0mock%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%A0%E9%99%A4%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98404%E3%80%82%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F">http://localhost:80/api/index.json可以查看数据，不再请求本地mock文件夹的数据，删除之后，代码会有问题404。怎么做？</a><br>config找到index.js。proxytable的代码意思开发环境下，如果你访问的是api路径，会将你对这个路径的请求转发到localhost8080端口上面。这个端口是前端服务器的端口，现在要更换后台服务器端口。这个端口还在本地，只是更改了地址。</p></li><li><p>实际中后端服务器并不在本地，这时候代理就不能写在localhost地址了，而是内网的ip地址。或者外网的一个域名。这样前端的api请求转发后后端服务器。如果项目使用的是vue这种，你就不需要再使用fiddler和charles这种抓包工具了。只需要使用proxytable这个配置项，就服务器的请求地址写在这里。</p></li></ul><h3 id="10-2-真机测试"><a href="#10-2-真机测试" class="headerlink" title="10.2 真机测试"></a>10.2 真机测试</h3><p>在windows系统中重新打开一个终端输入： ipconfig</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210102171115248.png" alt="image-20210102171115248"></p><p> iPv4就是内网ip地址，复制地址，在浏览器输入这个地址。这个地址的8080端口就是localhost80端口。但是他拒绝了我们的连接请求，为了确认，将8080换成80。前端项目是通过webpack-dev-server启动的，他默认不支持通过ip的方式进行页面的访问，需要将默认配置package.json向进行修改：<br>我们每次运行npm run dev 本质运行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config             build/webpack.dev.conf.js&quot;,</span><br></pre></td></tr></table></figure><p>重启服务器</p><p>再通过ip地址进行访问就可以了</p><ul><li>让手机直接通过内网ip地址尽心访问：</li></ul><h3 id="10-课程总结与后续学习"><a href="#10-课程总结与后续学习" class="headerlink" title="10  课程总结与后续学习"></a>10  课程总结与后续学习</h3><h5 id="学习方向："><a href="#学习方向：" class="headerlink" title="学习方向："></a>学习方向：</h5><ul><li>Vue官方文档：<br>大部分内容都涉及到了，还有比如插件、自定义指令等多多查阅、提升边缘知识点能力。</li><li>打开生态系统的vue-router插件，还有其他内容：命名路由、重定向、别名、守卫</li><li>Vuex：熟悉运用核心概念(State,Getter,Mutation,Action,Module)后，可以看一下在大型项目中创建比较复杂的Vuex数据架构时，项目结构怎么设计，或者如何使用Vuex相关的插件。</li><li>Vuex觉得没有太大的问题后：Vue服务器端渲染。搞明白意味着基本上对Node.js、Vue、前后端路由、前后端渲染有了极深的理解，前端的基础会得到很大的提升。如果时工作不满一年对前后端分得不是很清楚，这一部分内容可以延迟学习。</li></ul><h5 id="插件研究："><a href="#插件研究：" class="headerlink" title="插件研究："></a>插件研究：</h5><ul><li>生态系统Vue资源：研究好用的插件的源码以及使用</li></ul><h5 id="全面了解Vue后：研究Vue的源码"><a href="#全面了解Vue后：研究Vue的源码" class="headerlink" title="全面了解Vue后：研究Vue的源码"></a>全面了解Vue后：研究Vue的源码</h5>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目2：去哪儿网：问题总结篇</title>
      <link href="/2021/12/13/%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%EF%BC%9A%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/13/%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%EF%BC%9A%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li><p>项目时间： 2020年10月大概</p></li><li><p>项目背景： 慕课网的项目学习时做的笔记</p></li><li><p>问题总结篇： 总结一些之前的问题（简洁版）</p></li><li><p>概述：去哪儿网的移动端页面的实现，其中有3大模块:<br>遇到的问题和优化点比较集中在搜索城市页面。主要包括：搜索城市的逻辑实现、手指滑动过程中的高度计算 和 更换城市过程中出现的一些问题。<br>在解决这些问题的过程中，又产生了新的问题并进行了优化。</p></li></ul><h3 id="1-localStorage解决变更城市名后，首页无法更新的问题"><a href="#1-localStorage解决变更城市名后，首页无法更新的问题" class="headerlink" title="1. localStorage解决变更城市名后，首页无法更新的问题"></a>1. localStorage解决变更城市名后，首页无法更新的问题</h3><ul><li><p><strong>原本需求：</strong>不选的时候有一个默认城市，展示该城市数据，实现选中一次，展示新的城市数据</p></li><li><p><strong>原本实现逻辑：</strong>当用户每次进入页面，都在mounted钩子里会发ajax请求，并将Vuex中城市名的数据带过去</p></li><li><h4 id="出现的问题：刷新了页面，城市又回到了默认城市上海"><a href="#出现的问题：刷新了页面，城市又回到了默认城市上海" class="headerlink" title="出现的问题：刷新了页面，城市又回到了默认城市上海"></a><strong>出现的问题：刷新了页面，城市又回到了默认城市上海</strong></h4><ul><li><p><strong>原因：</strong>由于store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值，就会使用state中默认保存的数据</p></li><li><p><strong>解决：</strong>localStorage可以实现当有缓存值的时候用缓存值，没有才用默认值的功能，为什么选它？</p><ul><li>localStorage是永久存储在本地，除非你主动去删除;</li><li>sessionStorage是存储到当前页面关闭为止;</li><li>cookie则根据你设置的有效时间来存储，但缺点是不能储存大数据且不易读取。</li></ul></li><li><p><strong>新的问题：</strong></p><p>引入localStorage，当用户重新选择了城市时，Vuex会更新state里面的city变量，此时城市名已经变动，此时应该进行ajax请求的。</p><p>但同时由于对首页用了keep_alive，所以再次回到首页不会再执行mounted这个钩子了，进而无法在该钩子里做数据获取得操作，我们可以用activated</p></li><li><p><strong>网络请求优化：</strong></p><p><strong>原因：</strong>每点一个城市都会数据请求，假如点击前后城市并没更新，其实没有必要重新请求：</p><p><strong>解决：</strong>在首页activated新定义一个变量保存每次请求前的城市名，来对state里面的城市做if判断，只有二者不一致时才会去重新请求</p><p><strong>实现：</strong>首次请求后不会再次请求的问题；城市名实际未变化，也不会再次请求的问题</p></li></ul></li></ul><h3 id="2-实现手指滑动时的更准确的高度计算并优化计算性能；"><a href="#2-实现手指滑动时的更准确的高度计算并优化计算性能；" class="headerlink" title="2. 实现手指滑动时的更准确的高度计算并优化计算性能；"></a>2. 实现手指滑动时的更准确的高度计算并优化计算性能；</h3><ul><li><p>需求：在右侧字母表上下拖拽时，左边对应的城市列表自动上下滚动</p></li><li><p>绑定touch相关的3个事件：touchstart、touchmove、touchend。设置标识位，在start里面将标识位更新为true，在move里判断标识位为true时才进行高度的计算。在touchend中将标识位false。</p></li><li><p>高度计算：</p><ul><li>获得字母A距离顶部的高度A ：·<code>this.$refs[&#39;A&#39;][0].offsetTop</code>DOM元素距离顶部的距离 ，再拿到当前手指滑动个位置距离顶部的高度B ：通过事件对象里面的touche数组，e.touches[0].clientY，相减的高度差除以一个字母的高度20，就拿到了当前字母对应的索引，然后从存储字母的数组中取出来。</li></ul></li><li><p>优化：每次执行一次move，都要获取dom结构的offsetTOP属性进行一次计算。这是没有必要的且耗费性能的                                                  <strong>JS方面的优化</strong></p><ul><li>字母A距离顶部的高度A，在初次渲染这个组件的时候数据还是空的，而当ajax数据获取后，往这个组件传的数据改变，updated生命周期钩子就会执行，页面中显示出了列表的内容。这个时候去获取就能得到字母A所在的DOM对应的offsetTop的值不仅是准确的，还能解决耗费性能的问题</li><li>引入防抖操作，在touchmove中，如果标志位为true，就清空定时器，并且设置新的定时器，将高度计算的操作放在定时器里</li></ul></li></ul><h3 id="3-城市名搜索的逻辑实现"><a href="#3-城市名搜索的逻辑实现" class="headerlink" title="3. 城市名搜索的逻辑实现"></a>3. 城市名搜索的逻辑实现</h3><ul><li><p>需求：</p><ul><li>搜索框搜索城市名或拼音，显示对应的搜索结果，并引入防抖降低搜索过程中查找匹配函数的频率</li><li>当匹配不到城市时，显示无法匹配</li><li>匹配的城市可以滚动显示</li></ul></li><li><p>实现：</p></li><li><p>搜索框通过<strong>v-model双向绑定</strong>数据keyword，在<strong>侦听器watch</strong>中监听keyword的改变，当它发生改变时，代表用户正在输入。</p><ul><li>此时对cities对象进行遍历，cities里每一项都包含了indexof一个城市的名字name和拼音。只要输入的内容能匹配其中之一，就将匹配到的城市数据加入到list列表中。然后对list列表中的数据在li组件中循环显示出来。</li></ul></li><li><p>在循环列表末尾添加一项li，用于展示是否无法匹配，当匹配不到城市时，通过<strong>v-show</strong>控制，显示匹配不到该城市</p><ul><li>滚动：将这个组件绑定ref，在mounted阶段，通过<strong>refs拿到DOM元素</strong>，传入<strong>new BetterScroll</strong>中，然后实现局部滚动</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器运行机制</title>
      <link href="/2021/12/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/12/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>待续</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程线程 </tag>
            
            <tag> 渲染解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典国内外计算机基础课程</title>
      <link href="/2021/12/12/%E7%BB%8F%E5%85%B8%E5%9B%BD%E5%86%85%E5%A4%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
      <url>/2021/12/12/%E7%BB%8F%E5%85%B8%E5%9B%BD%E5%86%85%E5%A4%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>斯坦福144：<a href="https://www.bilibili.com/video/BV137411Z7LR?from=search&amp;seid=5779448666653480680">https://www.bilibili.com/video/BV137411Z7LR?from=search&amp;seid=5779448666653480680</a><br>哈工大：<a href="https://www.bilibili.com/video/BV1Up411Z7hC">https://www.bilibili.com/video/BV1Up411Z7hC</a></p><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p>数据结构：<a href="https://www.bilibili.com/video/BV1Kb41127fT">https://www.bilibili.com/video/BV1Kb41127fT</a><br>leetcode刷题笔记：<a href="https://mp.weixin.qq.com/s?__biz=MzI0NjAxMDU5NA==&amp;mid=328435125&amp;idx=1&amp;sn=3de887a586e8a6a08784036de466623e&amp;chksm=7f22e23848556b2e67fedbd30b1ca0fcdb46ed336279aa4cb0899a0f2ff44210e829d125ade6#rd">https://mp.weixin.qq.com/s?__biz=MzI0NjAxMDU5NA==&amp;mid=328435125&amp;idx=1&amp;sn=3de887a586e8a6a08784036de466623e&amp;chksm=7f22e23848556b2e67fedbd30b1ca0fcdb46ed336279aa4cb0899a0f2ff44210e829d125ade6#rd</a></p><h2 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h2><p>南大蒋岩岩：<a href="https://www.bilibili.com/video/BV1N741177F5?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1606808223&amp;unique_k=ns64dc">https://www.bilibili.com/video/BV1N741177F5?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1606808223&amp;unique_k=ns64dc</a></p><p>国外213： <a href="https://www.bilibili.com/video/BV1iW411d7hd?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1606782897&amp;unique_k=JeN7fa">https://www.bilibili.com/video/BV1iW411d7hd?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1606782897&amp;unique_k=JeN7fa</a></p><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><p>哈工大：<a href="https://www.bilibili.com/video/BV1t4411e7LH/?spm_id_from=333.788.recommend_more_video.0">https://www.bilibili.com/video/BV1t4411e7LH/?spm_id_from=333.788.recommend_more_video.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目5：Node用户管理接口：学习记录篇</title>
      <link href="/2021/12/12/%E9%A1%B9%E7%9B%AE5%EF%BC%9ANode%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E7%AF%87/"/>
      <url>/2021/12/12/%E9%A1%B9%E7%9B%AE5%EF%BC%9ANode%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2021年2月</li><li>项目背景： 春节在家，只是想简单了解下接口、数据库的概念</li><li>学习记录篇：记录过程的，记忆丢失，嘤嘤嘤</li></ul><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><h3 id="1-划分目录结构"><a href="#1-划分目录结构" class="headerlink" title="1. 划分目录结构"></a>1. 划分目录结构</h3><ul><li><p>划分方式：</p><ul><li><p>按照功能模块划分；</p></li><li><p>按照业务模块划分；</p></li></ul></li><li><h4 id="项目配置文件信息："><a href="#项目配置文件信息：" class="headerlink" title="项目配置文件信息："></a>项目配置文件信息：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;start&quot;</span>: <span class="string">&quot;nodemon ./src/main.js&quot;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="项目的入口文件：main-js"><a href="#项目的入口文件：main-js" class="headerlink" title="项目的入口文件：main.js"></a>项目的入口文件：main.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app/index&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./app/config&#x27;</span>)</span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.listen(config.APP_PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动成功&#x27;</span>,config.APP_PORT);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><h4 id="创建服务器：index-js"><a href="#创建服务器：index-js" class="headerlink" title="创建服务器：index.js"></a>创建服务器：index.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyParser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(bodyParser())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将app传入到userRouter函数里面是为什么？？？</span></span><br><span class="line"><span class="comment">// router文件夹下的index.js的作用：对router文件夹下的每个router.js文件遍历，</span></span><br><span class="line"><span class="comment">//免去每注册一个路由都要写一次app.use(router1.allowed())和app.use(router1.routes())</span></span><br><span class="line"><span class="comment">//传入app，是因为使用app.use()</span></span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="built_in">require</span>(<span class="string">&#x27;../router/index&#x27;</span>)</span><br><span class="line">useRoutes(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errorHandle = <span class="built_in">require</span>(<span class="string">&#x27;./error-handle&#x27;</span>)</span><br><span class="line"><span class="comment">//监听错误事件</span></span><br><span class="line">app.on(<span class="string">&#x27;error&#x27;</span>, errorHandle)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br></pre></td></tr></table></figure></li><li><h4 id="加载配置的变量：config-js"><a href="#加载配置的变量：config-js" class="headerlink" title="加载配置的变量：config.js"></a>加载配置的变量：config.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过dotenv内置模块</span></span><br><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">dotenv.config();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取公钥+私钥 </span></span><br><span class="line"><span class="keyword">const</span> PRIVATE_KEY = fs.readFileSync(path.resolve(__dirname,<span class="string">&#x27;./keys/private.key&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> PUBLIC_KEY = fs.readFileSync(path.resolve(__dirname,<span class="string">&#x27;./keys/public.key&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  APP_PORT,</span><br><span class="line">  MYSQL_HOST,</span><br><span class="line">  MYSQL_PORT,</span><br><span class="line">  MYSQL_USER,</span><br><span class="line">  MYSQL_DATABASE,</span><br><span class="line">  MYSQL_PASSWORD,</span><br><span class="line">  LOCAL_HOST</span><br><span class="line">&#125; = process.env;</span><br><span class="line"><span class="comment">//两种exports顺序不能换</span></span><br><span class="line"><span class="built_in">module</span>.exports.PUBLIC_KEY = PUBLIC_KEY;</span><br><span class="line"><span class="built_in">module</span>.exports.PRIVATE_KEY = PRIVATE_KEY;</span><br></pre></td></tr></table></figure></li><li><h4 id="编写-env文件"><a href="#编写-env文件" class="headerlink" title="编写.env文件"></a>编写.env文件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">APP_PORT = <span class="number">8000</span></span><br><span class="line">LOCAL_HOST = <span class="string">&quot;http://localhost</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MYSQL_HOST = &quot;</span>localhost<span class="string">&quot;</span></span><br><span class="line"><span class="string">MYSQL_PORT = 3306</span></span><br><span class="line"><span class="string">MYSQL_USER = &quot;</span>root<span class="string">&quot;</span></span><br><span class="line"><span class="string">MYSQL_DATABASE = &quot;</span>coderhub<span class="string">&quot;</span></span><br><span class="line"><span class="string">MYSQL_PASSWORD = &quot;</span>56830908zml<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="错误类型模块：error-type-js"><a href="#错误类型模块：error-type-js" class="headerlink" title="错误类型模块：error-type.js"></a>错误类型模块：error-type.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NAME_OR_PASSWORD_IS_REQUIRED = <span class="string">&#x27;name_or_password_is_required&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> USER_ALREADY_EXISITS =  <span class="string">&#x27;user_alreay_exisits&#x27;</span></span><br><span class="line"><span class="keyword">const</span> USER_DOES_NOT_EXISITS = <span class="string">&#x27;user_does_not_exisits&#x27;</span></span><br><span class="line"><span class="keyword">const</span> PASSWORD_IS_NOT_CORRECT = <span class="string">&#x27;password_is_not_correct&#x27;</span></span><br><span class="line"><span class="keyword">const</span> NOT_AUTHORIZATION = <span class="string">&#x27;not_authorization&#x27;</span></span><br><span class="line"><span class="keyword">const</span> NOT_PERMISSION = <span class="string">&#x27;not_permission&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  NAME_OR_PASSWORD_IS_REQUIRED,</span><br><span class="line">  USER_ALREADY_EXISITS,</span><br><span class="line">  USER_DOES_NOT_EXISITS,</span><br><span class="line">  PASSWORD_IS_NOT_CORRECT,</span><br><span class="line">  NOT_AUTHORIZATION,</span><br><span class="line">  NOT_PERMISSION</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="错误处理模块-：error-handle-js"><a href="#错误处理模块-：error-handle-js" class="headerlink" title="错误处理模块 ：error-handle.js"></a>错误处理模块 ：error-handle.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="function">(<span class="params">error, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(error.message)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;name_or_password_is_required&#x27;</span>: </span><br><span class="line">      status = <span class="number">400</span>;</span><br><span class="line">      message = <span class="string">&#x27;用户名/密码不能为空&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;user_alreay_exisits&#x27;</span>:</span><br><span class="line">      status = <span class="number">409</span>,<span class="comment">// 发生冲突conflict</span></span><br><span class="line">      message = <span class="string">&#x27;用户名已经使用&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;user_does_not_exisits&#x27;</span>:</span><br><span class="line">      status = <span class="number">400</span>,</span><br><span class="line">      message = <span class="string">&#x27;用户名不存在&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;password_is_not_correct&#x27;</span>:</span><br><span class="line">      status = <span class="number">400</span>, </span><br><span class="line">      message = <span class="string">&#x27;密码不正确&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;not_authorization&#x27;</span>: </span><br><span class="line">      status = <span class="number">401</span>  </span><br><span class="line">      message = <span class="string">&#x27;没有授权，token无效&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;not_permission&#x27;</span>: </span><br><span class="line">      status = <span class="number">401</span>  </span><br><span class="line">      message = <span class="string">&#x27;你没有操作权限&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">      status = <span class="number">404</span></span><br><span class="line">      message = <span class="string">&#x27;Not Found1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  ctx.status = status</span><br><span class="line">  ctx.body = message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = errorHandler</span><br></pre></td></tr></table></figure></li><li><h4 id="数据库连接：database-js"><a href="#数据库连接：database-js" class="headerlink" title="数据库连接：database.js"></a>数据库连接：database.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connections = mysql.createPool(&#123;</span><br><span class="line">  <span class="attr">host</span>: config.MYSQL_HOST,</span><br><span class="line">  <span class="attr">port</span>: config.MYSQL_PORT,</span><br><span class="line">  <span class="attr">user</span>: config.MYSQL_USER,</span><br><span class="line">  <span class="attr">database</span>:config.MYSQL_DATABASE,</span><br><span class="line">  <span class="attr">password</span>: config.MYSQL_PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">connections.getConnection(<span class="function">(<span class="params">err, conn</span>) =&gt;</span> &#123;</span><br><span class="line">  conn.connect( <span class="function"><span class="params">errr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;连接失败&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = connections.promise()</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-用户注册接口"><a href="#2-用户注册接口" class="headerlink" title="2. 用户注册接口"></a>2. 用户注册接口</h3><ul><li><p>用户注册接口编写流程：</p><ul><li><p>注册用户路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;verifyUser&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/user.middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;create&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/user.controller&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">new</span> router(&#123;<span class="attr">prefix</span>: <span class="string">&#x27;/users&#x27;</span>&#125;)</span><br><span class="line">userRouter.post(<span class="string">&#x27;/&#x27;</span>, verifyUser,create)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = userRouter;</span><br></pre></td></tr></table></figure></li></ul><h4 id="注册用户校验：verifyUser"><a href="#注册用户校验：verifyUser" class="headerlink" title="注册用户校验：verifyUser"></a>注册用户校验：verifyUser</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> verifyUser = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">//1. 获取用户名和密码</span></span><br><span class="line">  <span class="keyword">const</span> &#123;name, password&#125; = ctx.request.body;</span><br><span class="line">  <span class="comment">// 如果没有传，name应该是undefined</span></span><br><span class="line">  <span class="comment">//2. 判断用户名/密码是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (!name || !password || name ===<span class="string">&#x27;&#x27;</span>|| password == <span class="string">&#x27;&#x27;</span> )&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.NAME_OR_PASSWORD_IS_REQUIRED)</span><br><span class="line">    <span class="comment">//此时发送一个错误信息，另一个地方去获取这个错误信息</span></span><br><span class="line">    <span class="comment">//emit传事件类型，事件，参数</span></span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>,error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3. 判断用户名是否已经存在</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> service.getUserByName(name)</span><br><span class="line">  <span class="keyword">if</span>(result.length)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.USER_ALREADY_EXISITS)</span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//必须调用next，等后面的中间件执行才返回结果</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  verifyUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询用户名是否被注册过：user.service.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&#x27;../app/database&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userService</span></span>&#123;</span><br><span class="line">  <span class="comment">// 查询是否存在该用户</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getUserByName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM users WHERE name = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [name])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//解构user</span></span><br><span class="line">    <span class="keyword">const</span> &#123;name, password&#125; = user;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO users (name, password) VALUES (?, ?)`</span>;</span><br><span class="line">    <span class="comment">//执行sql语句</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [name, password]);</span><br><span class="line">    <span class="comment">//将user存储到数据库中</span></span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> userService();</span><br></pre></td></tr></table></figure><h4 id="注册用户操作：create-js"><a href="#注册用户操作：create-js" class="headerlink" title="注册用户操作：create.js"></a>注册用户操作：create.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 验证注册用户后的处理逻辑抽到user.controller.js里面</span><br><span class="line"><span class="keyword">const</span> service= <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx, next</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//这部分要做的事很多，所以对每一部分再抽取：</span></span><br><span class="line">    <span class="comment">//获取用户用于传递的参数</span></span><br><span class="line">    <span class="keyword">const</span> user = ctx.request.body   </span><br><span class="line">    <span class="comment">//查询数据 ----抽取到user.service.js</span></span><br><span class="line">    <span class="comment">//user是传入的参数</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.create(user)  <span class="comment">// 见上面的user.service.js</span></span><br><span class="line">    <span class="comment">//返回数据</span></span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> userController();</span><br></pre></td></tr></table></figure><h4 id="密码加密存储"><a href="#密码加密存储" class="headerlink" title="密码加密存储"></a>密码加密存储</h4><p>此时已经手动注册两个用户，可在数据库查看：<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210206144301822.png" alt="image-20210206144301822"></p></li></ul><p>但是账户密码是明文的形式保存的，如果数据库泄露了，那么密码会被别人拿到登录。更危险的是，很多人的其他账户密码全是一样的，所以我们拿到ctx.request.body里面的用户名+密码。然后加密。但是开发中并不是这样做。而是在verify之后做密码加密</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userRouter.post(&#x27;/&#x27;, verifyUser,**增加拦截中间件handlePassword***，create)</span><br></pre></td></tr></table></figure><p>  加密中间件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> md5password = <span class="built_in">require</span>(<span class="string">&#x27;../utils/password-handle&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> verifyUser = <span class="keyword">async</span> (ctx, next) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handlePassword = <span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; password &#125; = ctx.request.body</span><br><span class="line">  <span class="comment">//通过加密函数，对password</span></span><br><span class="line">  ctx.request.body.password = md5password(password) </span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  verifyUser,</span><br><span class="line">  handlePassword</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  加密的方式MD5，借助<strong>框架crypto</strong>，node自带的，有一个函数调用createHash()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> md5password = <span class="function">(<span class="params">password</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到的是一个对象</span></span><br><span class="line">  <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>)</span><br><span class="line">  <span class="comment">// 返回还是一个对象,并转成16进制的结果,最终拿到字符串形式</span></span><br><span class="line">  <span class="keyword">const</span> result = md5.update(password).digest(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = md5password</span><br></pre></td></tr></table></figure><p>  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210206151111074.png" alt="image-20210206151111074"></p><p>  数据库那边也已经显示的是加密后的密码</p><h3 id="3-登录接口"><a href="#3-登录接口" class="headerlink" title="3. 登录接口"></a>3. 登录接口</h3><ul><li><p>登录路径是/login</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 新建路由配置auth.router.js</span><br><span class="line"><span class="keyword">const</span> authRouter = <span class="keyword">new</span> Router()</span><br><span class="line"><span class="keyword">const</span> &#123;login&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/auth.controller&#x27;</span>)</span><br><span class="line"></span><br><span class="line">authRouter.post(<span class="string">&#x27;/login&#x27;</span>, login)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 配置路由</span><br><span class="line">app.use(authRouter.routes())</span><br><span class="line">app.use(authRouter.allowedMethods())</span><br></pre></td></tr></table></figure><ul><li><h4 id="登录处理：login"><a href="#登录处理：login" class="headerlink" title="登录处理：login"></a>登录处理：login</h4></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthController</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">login</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//拿到用户名</span></span><br><span class="line">    <span class="keyword">const</span> &#123;name&#125; = ctx.request.body</span><br><span class="line">    ctx.body = <span class="string">`欢迎<span class="subst">$&#123;name&#125;</span>回来`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> AuthController();</span><br></pre></td></tr></table></figure></li><li><p>此时，用户随便输入密码账户都可以登录，并没有验证，在/login的post请求中插入中间件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">authRouter.post(<span class="string">&#x27;/login&#x27;</span>,***中间件verifyLogin***, login)</span><br></pre></td></tr></table></figure><h4 id="密码验证："><a href="#密码验证：" class="headerlink" title="密码验证："></a>密码验证：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> md5password = <span class="built_in">require</span>(<span class="string">&#x27;../utils/password-handle&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> verifyLogin = <span class="keyword">async</span>(ctx, next) =&gt;&#123;</span><br><span class="line"><span class="comment">//1.获取用户名+密码</span></span><br><span class="line">  <span class="keyword">const</span> &#123;name, password&#125; = ctx.request.body</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用户名/密码是否为空</span></span><br><span class="line"><span class="comment">//2. 判断用户名/密码是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (!name || !password)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.NAME_OR_PASSWORD_IS_REQUIRED)</span><br><span class="line">    <span class="comment">//此时发送一个错误信息，另一个地方去获取这个错误信息</span></span><br><span class="line">    <span class="comment">//emit传事件类型，事件，参数</span></span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>,error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//3.用户名/密码是否存在</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> service.getUserByName(name)</span><br><span class="line">  <span class="keyword">const</span> user = result[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">if</span>(!user)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.USER_DOES_NOT_EXISITS)</span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//4.用户名/密码是否一致(加密)</span></span><br><span class="line">  <span class="comment">//user.password是之前数据库中存储的密码，而且是已经加密了的</span></span><br><span class="line">  <span class="keyword">if</span>(md5password(password) !== user.password)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.PASSWORD_IS_NOT_CORRECT)</span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//5.完成所有验证步骤后，再执行router后面的中间件</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = verifyLogin</span><br></pre></td></tr></table></figure></li><li><h4 id="优化路由注册，动态加载路由："><a href="#优化路由注册，动态加载路由：" class="headerlink" title="优化路由注册，动态加载路由："></a>优化路由注册，动态加载路由：</h4></li></ul><p>之前每监理一个路由都要进行一次注册，当路由越来越多，index.js里面的内容越来越多。对这部分代码简化</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># index.js删除</span><br><span class="line">app.use(userRouter.routes())</span><br><span class="line">app.use(userRouter.allowedMethods())</span><br><span class="line">app.use(authRouter.routes())</span><br><span class="line">app.use(authRouter.allowedMethods())</span><br><span class="line"># 改为</span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="built_in">require</span>(<span class="string">&#x27;../router/index&#x27;</span>)</span><br><span class="line">useRoutes(app)</span><br></pre></td></tr></table></figure><p>在router文件夹下，新增index.js</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//读取当前文件所在的目录，返回的结果是数组</span></span><br><span class="line">  fs.readdirSync(__dirname).forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//对当前目录下的所有文件遍历，除了index.js</span></span><br><span class="line">    <span class="keyword">if</span>(file === <span class="string">&#x27;index.js&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则对每个router.js文件进行导入</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;$&#123;file&#125;&#x27;</span>)</span><br><span class="line">    app.use(router.routes())</span><br><span class="line">    app.use(router.allowedMethods())</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = useRoutes</span><br></pre></td></tr></table></figure><h3 id="4-登录凭证："><a href="#4-登录凭证：" class="headerlink" title="4. 登录凭证："></a>4. 登录凭证：</h3><ul><li><p>验证方式1：cookie+session；（正在被淘汰）</p><p>验证方式2：Token令牌；登录成功返回凭证：（未来更流行）</p></li><li><p>有关cookie、session、token的知识在14章节笔记：token采用了生成token时和验证token时使用同一密钥的方式</p></li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li><p>如果secretKey暴露是一件非常危险的事情，因为之后就可以模拟颁发token， 也可以解密token；所以HS256加密算法一单密钥暴露就是非常危险的事情。</p><ul><li><p>比如在分布式系统中，每一个子系统都需要获取到密钥；那么拿到这个密钥后这个子系统既可以发布另外，也可以验证令牌；</p></li><li><p>但是对于一些资源服务器来说，它们只需要有验证令牌的能力就可以了；这个时候我们可以使用非对称加密，RS256：</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210206220511367.png" alt="image-20210206220511367" style="zoom:67%;" />* 私钥（private key）：用于发布令牌* 公钥（public key）：用于验证令牌，是通过私钥得到的</li><li><p>可以使用openssl来生成一对私钥和公钥：Mac直接使用terminal终端即可；Windows默认的cmd终端是不能直接使用的，建议直接使用git bash终端；</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到公钥+私钥,拿到的是buffer，但是后面是可以传入buffer的</span></span><br><span class="line"><span class="keyword">const</span> PRIVATE_KEY = fs.readFileSync(<span class="string">&#x27;./keys/private.key&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> PUBLIC_KEY = fs.readFileSync(<span class="string">&#x27;./keys/public.key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/test&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//基于token实现：jwt，手里用私钥加密</span></span><br><span class="line">  <span class="keyword">const</span> user = &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>:<span class="string">&#x27;lily&#x27;</span>&#125;</span><br><span class="line">  <span class="keyword">const</span> token = jwt.sign(user, PRIVATE_KEY, &#123;</span><br><span class="line">    <span class="attr">expiresIn</span>: <span class="number">10</span>*<span class="number">100</span>,</span><br><span class="line">    <span class="comment">//加密算法</span></span><br><span class="line">    <span class="attr">algorithm</span>: <span class="string">&quot;RS256&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.body = token</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">&#x27;/demo&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//取出token</span></span><br><span class="line">  <span class="keyword">const</span> authorization = ctx.headers.authorization</span><br><span class="line">  <span class="keyword">const</span> token = authorization.replace(<span class="string">&quot;Bearer &quot;</span>,<span class="string">&quot;&quot;</span> )</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//验证token，手里有公钥解密</span></span><br><span class="line">  <span class="keyword">const</span> result = jwt.verify(token, PUBLIC_KEY, &#123;</span><br><span class="line">    <span class="comment">//这里传入的是数组，而且复数，说明可以传很多</span></span><br><span class="line">    <span class="attr">algorithms</span>: [<span class="string">&quot;RS256&quot;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;token是无效的&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(router.routes())</span><br><span class="line">app.use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;koa启动成功了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>补充：fs.readFileSync有时候可以传相对路径，绝对路径。但是有时又不可以。在项目中的任何地方，相对路径是相对于process的cwd，在哪个文件夹启动的项目就是process.cwd</li></ul></li><li><h4 id="颁发令牌-验证令牌（回到项目）"><a href="#颁发令牌-验证令牌（回到项目）" class="headerlink" title="颁发令牌+验证令牌（回到项目）"></a>颁发令牌+验证令牌（回到项目）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取公钥+私钥 </span></span><br><span class="line"><span class="keyword">const</span> PRIVATE_KEY = fs.readFileSync(path.resolve(__dirname,<span class="string">&#x27;./keys/private.key&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> PUBLIC_KEY = fs.readFileSync(path.resolve(__dirname,<span class="string">&#x27;./keys/public.key&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种exports顺序不能换</span></span><br><span class="line"><span class="built_in">module</span>.exports.PUBLIC_KEY = PUBLIC_KEY;</span><br><span class="line"><span class="built_in">module</span>.exports.PRIVATE_KEY = PRIVATE_KEY;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># auth.controller.js </span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;PUBLIC_KEY&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../app/config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;PRIVATE_KEY&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../app/config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthController</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">login</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//拿到用户名</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id, name&#125; = ctx.user </span><br><span class="line">    <span class="comment">//颁发令牌</span></span><br><span class="line">    <span class="keyword">const</span> token = jwt.sign(&#123;id, name&#125;, PRIVATE_KEY, &#123;</span><br><span class="line">      <span class="attr">expiresIn</span>: <span class="number">10</span>*<span class="number">100</span>*<span class="number">60</span>,</span><br><span class="line">      <span class="attr">algorithm</span>: <span class="string">&#x27;RS256&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      id, token, name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> AuthController();</span><br></pre></td></tr></table></figure></li><li><h4 id="验证用户是否授权，颁发的签名是否有效"><a href="#验证用户是否授权，颁发的签名是否有效" class="headerlink" title="验证用户是否授权，颁发的签名是否有效"></a>验证用户是否授权，颁发的签名是否有效</h4><p>比如当一个用户登录之后，发表动态，发表文章之前我们要验证该用户是否授权</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 验证的路径是/test,get请求</span><br><span class="line">authRouter.get(<span class="string">&#x27;/test&#x27;</span>, verifyAuth, success)<span class="comment">//success只是显示验证成功的功能</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># auth.middleware.js  验证函数</span><br><span class="line"><span class="keyword">const</span> verifyAuth = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;验证授权的middleware&#x27;</span>)</span><br><span class="line">  <span class="comment">// 注意这里发送请求时在postmen里记得把token复制，携带过去</span></span><br><span class="line">  <span class="keyword">const</span> authorization = ctx.headers.authorization</span><br><span class="line">  <span class="comment">//如果我们在postman中携带错误的token传过来，</span></span><br><span class="line">  <span class="comment">//此时ctx.headers里面压根就没有authorization</span></span><br><span class="line">  <span class="comment">//所以要先验证一遍</span></span><br><span class="line">  <span class="keyword">if</span>(!authorization)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.NOT_AUTHORIZATION)</span><br><span class="line">    <span class="comment">//这里必须是return,否则会卡在这里</span></span><br><span class="line">     <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> token = authorization.replace(<span class="string">&#x27;Bearer &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 验证token</span></span><br><span class="line">    <span class="keyword">const</span> result = jwt.verify(token, PUBLIC_KEY, &#123;</span><br><span class="line">    <span class="attr">algorithms</span>: [<span class="string">&#x27;RS256&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    ctx.body = result</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.NOT_AUTHORIZATION)</span><br><span class="line">    ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-1-发布-查询动态内容"><a href="#5-1-发布-查询动态内容" class="headerlink" title="5.1 发布/查询动态内容"></a>5.1 发布/查询动态内容</h3><h4 id="1-发布动态内容"><a href="#1-发布动态内容" class="headerlink" title="1. 发布动态内容"></a>1. 发布动态内容</h4><ul><li><p>新建moment.router.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;verifyAuth&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/auth.middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;create&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/moment.controller.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> momentRouter = <span class="keyword">new</span> Router(&#123;<span class="attr">prefix</span>: <span class="string">&#x27;/moment&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">//发表评论之前要先验证登录，然后才是create创建评论</span></span><br><span class="line">momentRouter.post(<span class="string">&#x27;/&#x27;</span>, verifyAuth, create)</span><br><span class="line"><span class="built_in">module</span>.exports = momentRouter </span><br></pre></td></tr></table></figure></li><li><p>创建新的表 moment</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS <span class="string">`moment`</span> (</span><br><span class="line">  <span class="comment">// 评论的id，表示哪条评论</span></span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  content VARCHAR(<span class="number">1000</span>) NOT NULL,</span><br><span class="line">  <span class="comment">// 该评论对应的用户id</span></span><br><span class="line">  user_id INT NOT NULL,</span><br><span class="line">  createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  <span class="comment">// 引用外键约束，user_id是发表评论对应的用户的id，</span></span><br><span class="line">  <span class="comment">// users(id)是用户表中的用户的id，表示哪个用户，二者应该是联动的</span></span><br><span class="line">  <span class="comment">// 代表了哪条评论对应了哪个用户</span></span><br><span class="line">  FOREIGN KEY(user_id) REFERENCES users(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>定义发布动态内容的接口</p><ul><li><p>验证用户登录:  verifyAuth直接导入使用</p></li><li><p>Controller和Service中处理内容</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.controller.js</span><br><span class="line"><span class="keyword">const</span> momentService = <span class="built_in">require</span>(<span class="string">&#x27;../service/moment.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">momentController</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 发表动态的逻辑:</span></span><br><span class="line">    <span class="comment">//1.拿到user_id, 动态内容，上一个中间件的ctx.user里面存着</span></span><br><span class="line">    <span class="keyword">const</span> user_id = ctx.user.id   <span class="comment">// 拿到用户id，是哪个用户</span></span><br><span class="line">    <span class="keyword">const</span> content = ctx.request.body.content  <span class="comment">// 是什么动态内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 将数据插入到数据库中</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.create(user_id, content)</span><br><span class="line">    ctx.body =  result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> momentController();</span><br></pre></td></tr></table></figure></li><li><p>moment.service.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const connection = require(&#x27;../app/database&#x27;)</span><br><span class="line">class momentService&#123;</span><br><span class="line">  async create(user_id, content)&#123;</span><br><span class="line">    const statement = `INSERT INTO moment (content, user_id) VALUES (?, ?)`</span><br><span class="line">    const result = connection.execute(statement, [content, user_id])</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = new momentService();</span><br></pre></td></tr></table></figure><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210207173925587.png" alt="image-20210207173925587"></p></li></ul></li></ul><h4 id="2-查询动态内容"><a href="#2-查询动态内容" class="headerlink" title="2.查询动态内容"></a>2.查询动态内容</h4><ul><li><p>定义查询单个内容的接口</p><ul><li><p>根据momentId查询接口内容；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 路由</span><br><span class="line"><span class="comment">// 查看评论,不需要登录,需要知道评论对应的id</span></span><br><span class="line">momentRouter.get(<span class="string">&#x27;/:momentId&#x27;</span>, momentDetail)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.controller.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">momentDetail</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 从数据库中获取评论信息，需要id,</span></span><br><span class="line">    <span class="comment">//1. id是请求接口params里面携带的momentId</span></span><br><span class="line">    <span class="keyword">const</span> momentId = ctx.params.momentId</span><br><span class="line">    <span class="comment">//2.拿到id去数据库查询评论信息,让service做</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.getMomentById(momentId)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 去数据库查询内容</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">getMomentById</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT </span></span><br><span class="line"><span class="string">      m.id id, m.content content, </span></span><br><span class="line"><span class="string">      m.createAt createTime, m.updateAt updateTime, </span></span><br><span class="line"><span class="string">      JSON_OBJECT(&#x27;id&#x27;, u.id, &#x27;name&#x27;, u.name) author</span></span><br><span class="line"><span class="string">      FROM moment m</span></span><br><span class="line"><span class="string">      LEFT JOIN users u ON m.user_id = u.id </span></span><br><span class="line"><span class="string">      WHERE m.id =?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [id])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义查询多条内容的接口</p><ul><li><p>查询所有moment接口内容（根据offset和size决定查询数量）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 路由</span><br><span class="line"><span class="comment">// 查看多条动态</span></span><br><span class="line">momentRouter.get(<span class="string">&#x27;/&#x27;</span>, list)</span><br></pre></td></tr></table></figure><p>在实际中，数据很多的，不能一次性把所有数据查完而是分页查询，所以你请求路径后面还要跟上偏移offset+size，从哪儿查，一次查多少</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.controller.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">list</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询参数</span></span><br><span class="line">    <span class="keyword">const</span> &#123;offset, size&#125; = ctx.request.query</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.getMomentList(offset, size)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 查询多条内容</span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="title">getMomentList</span>(<span class="params">offset, size</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT </span></span><br><span class="line"><span class="string">      m.id id, m.content content, </span></span><br><span class="line"><span class="string">      m.createAt createTime, m.updateAt updateTime, </span></span><br><span class="line"><span class="string">      JSON_OBJECT(&#x27;id&#x27;, u.id, &#x27;name&#x27;, u.name) author</span></span><br><span class="line"><span class="string">      FROM moment m</span></span><br><span class="line"><span class="string">      LEFT JOIN users u ON m.user_id = u.id </span></span><br><span class="line"><span class="string">      LIMIT ?, ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [offset, size])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>代码优化：sql语句有很多相似的地方，可以抽出来 ，简化代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sqlFragment = <span class="string">`SELECT </span></span><br><span class="line"><span class="string">  m.id id, m.content content, </span></span><br><span class="line"><span class="string">  m.createAt createTime, m.updateAt updateTime, </span></span><br><span class="line"><span class="string">  JSON_OBJECT(&#x27;id&#x27;, u.id, &#x27;name&#x27;, u.name) author</span></span><br><span class="line"><span class="string">  FROM moment m</span></span><br><span class="line"><span class="string">  LEFT JOIN users u ON m.user_id = u.id `</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> statement = <span class="string">`</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;sqlFragment&#125;</span></span></span><br><span class="line"><span class="string">WHERE m.id =?`</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-2-修改-删除动态内容"><a href="#5-2-修改-删除动态内容" class="headerlink" title="5.2 修改/删除动态内容"></a>5.2 修改/删除动态内容</h3><h4 id="1-定义修改动态内容的接口"><a href="#1-定义修改动态内容的接口" class="headerlink" title="1.  定义修改动态内容的接口"></a>1.  定义修改动态内容的接口</h4><p>​    用户必须已经登录验证; 只能修改自己发表的内容，而不能修改别人的内容，是否有权限</p><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改动态 </span></span><br><span class="line">momentRouter.patch(<span class="string">&#x27;/:momentId&#x27;</span>,verifyAuth, verifyPermission, update)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：省略</p></li><li><p>验证用户的权限</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.middleware.js的中间件</span><br><span class="line"><span class="keyword">const</span> verifyPermission = <span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 验证已经登陆的用户与要修改的评论是否有权限</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;验证是否有修改权限&#x27;</span>)</span><br><span class="line"><span class="comment">// 1.获取参数</span></span><br><span class="line">  <span class="comment">// momentId 是要修改的动态id</span></span><br><span class="line">  <span class="keyword">const</span> &#123;momentId&#125; = ctx.request.params</span><br><span class="line">  <span class="comment">// 拿到当前登录用户的id，也就是谁登陆的</span></span><br><span class="line">  <span class="comment">//在update前面的中间件auth.verify中将ctx.user = result</span></span><br><span class="line">  <span class="comment">//当前登录信息结果保存在user里面</span></span><br><span class="line">  <span class="keyword">const</span> &#123;id&#125; = ctx.user</span><br><span class="line"><span class="comment">// 2. 查询是否具备权限并处理</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isPermission = <span class="keyword">await</span> authService.checkMoment(momentId, id)</span><br><span class="line">    <span class="keyword">if</span>(!isPermission)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()<span class="comment">//这个错误会在catch捕获</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.NOT_PERMISSION)</span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="单独封装权限查询的函数，这是为了后续各种需要权限的操作时，不用再重复写"><a href="#单独封装权限查询的函数，这是为了后续各种需要权限的操作时，不用再重复写" class="headerlink" title="单独封装权限查询的函数，这是为了后续各种需要权限的操作时，不用再重复写"></a>单独封装权限查询的函数，这是为了后续各种需要权限的操作时，不用再重复写</h4><p>验证权限的中间件很重要：</p><ol><li>很多功能都需要权限验证</li><li>业务接口，一般只需要验证当前登录的这个人与修改评论即可。但在后台管理系统中，权限验证是非常重要的，它是有一对一的关系：后台管理系统中用户有角色，还有权限表，是多对多的关系。角色是否具备某个权限，到时候可以去查询就可以了。</li><li>开发业务接口和后台管理系统一般是两个系统，而且可能部署到不同的服务器，一般不会放在一起开发。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># auth.service.js</span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&#x27;../app/database&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">authService</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">checkMoment</span>(<span class="params">momentId, userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM moment WHERE id =? AND user_id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [momentId, userId])</span><br><span class="line">    <span class="keyword">return</span> result.length === <span class="number">0</span>? <span class="literal">false</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> authService()</span><br></pre></td></tr></table></figure></li><li><p>Controller和Service中的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.controller.js</span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="title">update</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// momentId 是要修改的动态id</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId&#125; = ctx.request.params</span><br><span class="line">    <span class="keyword">const</span> &#123;content&#125; = ctx.request.body</span><br><span class="line">    <span class="comment">// 修改动态</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.update(content, momentId)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">update</span>(<span class="params">content, id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`UPDATE moment SET content =? WHERE id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [content, id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-定义删除内容的接口"><a href="#2-定义删除内容的接口" class="headerlink" title="2. 定义删除内容的接口"></a>2. 定义删除内容的接口</h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除动态</span></span><br><span class="line">momentRouter.delete(<span class="string">&#x27;/:momentId&#x27;</span>,verifyAuth, verifyPermission, remove)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：省略</p></li><li><p>验证用户权限： 省略</p></li><li><p>Controller和Service的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.controller.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">remove</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 拿到要输出动态的id</span></span><br><span class="line">  <span class="keyword">const</span> id = ctx.params.momentId</span><br><span class="line">  <span class="comment">// 删除内容</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.remove(id)</span><br><span class="line">  ctx.body = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">remove</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`DELETE FROM moment WHERE id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-发表-修改评论内容"><a href="#6-1-发表-修改评论内容" class="headerlink" title="6.1 发表/修改评论内容"></a>6.1 发表/修改评论内容</h3><ul><li><p>创建新的表 comment</p><p>需要记录是对当前动态做的评论，还是对评论做了评论，但他们都属于当前这条动态下的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS <span class="string">`comment`</span>(</span><br><span class="line">  # 评论唯一的主键</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  # 评论的内容</span><br><span class="line">  content VARCHAR(<span class="number">1000</span>) NOT NULL,</span><br><span class="line">  # 对哪个动态做的评论</span><br><span class="line">  moment_id INT NOT NULL,</span><br><span class="line">  # 哪个用户做的评论</span><br><span class="line">  user_id INT NOT NULL,</span><br><span class="line">  # 这个评论是对哪个评论做的评论</span><br><span class="line">  comment_id INT DEFAULT NULL,</span><br><span class="line">  createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line"></span><br><span class="line">  FOREIGN KEY (moment_id) REFERENCES moment(id) ON DELETE CASCADE ON UPDATE CASCADE,</span><br><span class="line">  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,</span><br><span class="line">  FOREIGN KEY (comment_id) REFERENCES comment(id) ON DELETE CASCADE ON UPDATE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-定义发布评论内容的接口"><a href="#1-定义发布评论内容的接口" class="headerlink" title="1. 定义发布评论内容的接口"></a>1. 定义发布评论内容的接口</h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;create&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/comment.controller&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;verifyAuth&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/auth.middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commentRouter = <span class="keyword">new</span> Router(&#123;<span class="attr">prefix</span>: <span class="string">&quot;/comment&quot;</span>&#125;)</span><br><span class="line">commentRouter.post(<span class="string">&#x27;/&#x27;</span>, verifyAuth, create)</span><br><span class="line"><span class="built_in">module</span>.exports = commentRouter</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录： verifyAuth省略</p></li><li><p>Controller和Service中处理内容</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.service.js</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/comment.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">momentController</span></span>&#123;</span><br><span class="line">  <span class="comment">// 创建评论</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在请求体里对哪个动态(动态id)拿到评论的内容(content)</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId, content&#125; = ctx.request.body</span><br><span class="line">    <span class="comment">// 谁发布的评论，在上一个中间件认证中已经知道</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.user</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.create(momentId, content, id)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> momentController()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.controller.js</span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&#x27;../app/database&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">momentService</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">momentId, content, user_id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO comment (content, moment_id, user_id) </span></span><br><span class="line"><span class="string">    VALUES (?, ?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, </span><br><span class="line">    [content, momentId, user_id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> momentService()</span><br></pre></td></tr></table></figure><ul><li>在这里犯了错：写sql语句的时候一定要记得对照数据库里面的称呼名字，传参时对应就可以，但写语句时必须严格一样</li></ul></li></ul><h4 id="2-定义回复评论内容的接口"><a href="#2-定义回复评论内容的接口" class="headerlink" title="2. 定义回复评论内容的接口"></a>2. 定义回复评论内容的接口</h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">commentRouter.post(<span class="string">&#x27;/:commentId/reply&#x27;</span>, verifyAuth, reply)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录： verifyAuth</p></li><li><p>Controller和Service中的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.controller.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">reply</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 拿到传的参数commentId</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId, content&#125; = ctx.request.body</span><br><span class="line">    <span class="keyword">const</span> &#123;commentId&#125; = ctx.params</span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.user</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.reply(commentId, momentId, content, id)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">reply</span>(<span class="params">commentId, momentId, content, id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO comment (content, moment_id, user_id, comment_id) VALUES (?, ?, ?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, </span><br><span class="line">    [content, momentId, id, commentId])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-定义修改评论内容的接口"><a href="#3-定义修改评论内容的接口" class="headerlink" title="3. 定义修改评论内容的接口"></a>3. 定义修改评论内容的接口</h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改评论,你只能修改自己发表的评论，而不能修改别人发表的评论</span></span><br><span class="line">commentRouter.patch(<span class="string">&#x27;/:commentId&#x27;</span>, verifyAuth, verifyPermission, update)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录: verifyAuth</p></li><li><p>验证用户的权限</p><ul><li>之前的权限是验证是否具备发表动态的权限，而这里是验证是否有修改评论的权限，是不可以继续用以前的那个权限的</li><li>一种思路是按之前验证动态权限一样，再去写一个函数verifyPermission来验证，但是随着越来越多的业务都需要验证时，此时代码量会越来越多。</li><li>另一种解决办法是：写一个函数既具备验证动态，也具备验证评论。但是如果你只是调用checkmoment，里面的const statement = <code>SELECT * FROM moment WHERE id =? AND user_id = ?</code>是写死的，你只能验证动态。所以让这个验证权限的函数具备多种验证功能的方法是：动态的改变statement，让他查询的东西随权限的不同而变化。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 对auth.middleware.js重新修改  verifyPermission函数</span><br><span class="line"># 更改了checkmoment为checkResource，并对参数做了改变</span><br><span class="line"><span class="keyword">const</span> verifyPermission = <span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 验证已经登陆的用户与要修改的动态是否有权限</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;验证是否有修改权限&#x27;</span>)</span><br><span class="line"><span class="comment">// 1.获取参数</span></span><br><span class="line">  <span class="comment">// momentId 是要修改的动态id</span></span><br><span class="line">  <span class="comment">// const &#123;momentId&#125; = ctx.request.params</span></span><br><span class="line">  <span class="comment">// 拿到当前登录用户的id，也就是谁登陆的</span></span><br><span class="line">  <span class="comment">//在update前面的中间件auth.verify中将ctx.user = result</span></span><br><span class="line">  <span class="comment">//当前登录信息结果保存在user里面</span></span><br><span class="line">    <span class="comment">// 获取tablename:</span></span><br><span class="line">    <span class="comment">//思路1：</span></span><br><span class="line">    <span class="comment">//思路2：如果路径是restful风格，可以从里面取出tableNmae</span></span><br><span class="line">    <span class="keyword">const</span> [resourceKey] = <span class="built_in">Object</span>.keys(ctx.params)</span><br><span class="line">    <span class="keyword">const</span> tableName = resourceKey.replace(<span class="string">&#x27;Id&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">//resourceId是想修改的那个评论在table中所处的id号</span></span><br><span class="line">    <span class="keyword">const</span> resourceId = ctx.params[resourceKey]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.user</span><br><span class="line"><span class="comment">// 2. 查询是否具备权限并处理</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isPermission = <span class="keyword">await</span> authService.checkResource(tableName,resourceId, id)</span><br><span class="line">    <span class="keyword">if</span>(!isPermission)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()<span class="comment">//这个错误会在catch捕获</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须加await，否则会出问题，为什么</span></span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.NOT_PERMISSION)</span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># auth.service.js修改后</span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&#x27;../app/database&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">authService</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">checkResource</span>(<span class="params">tableNmae, id, userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM <span class="subst">$&#123;tableNmae&#125;</span> WHERE id =? AND user_id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [id, userId])</span><br><span class="line">    <span class="keyword">return</span> result.length === <span class="number">0</span>? <span class="literal">false</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> authService()</span><br></pre></td></tr></table></figure><ul><li><p>Controller和Service中的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.controller.js</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">update</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;content&#125; = ctx.request.body</span><br><span class="line">    <span class="keyword">const</span> &#123;commentId&#125; = ctx.params</span><br><span class="line">    <span class="comment">// 修改评论</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.update(content, commentId)</span><br><span class="line">    ctx.body = content+commentId+result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">update</span>(<span class="params">content, commentId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`UPDATE comment SET content=? WHERE comment_id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [content, commentId])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-删除-查询评论内容"><a href="#6-2-删除-查询评论内容" class="headerlink" title="6.2  删除/查询评论内容"></a>6.2  删除/查询评论内容</h3><h4 id="1-定义删除评论内容的接口"><a href="#1-定义删除评论内容的接口" class="headerlink" title="1. 定义删除评论内容的接口"></a>1. 定义删除评论内容的接口</h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除评论</span></span><br><span class="line">commentRouter.delete(<span class="string">&#x27;/:commentId&#x27;</span>, verifyAuth, verifyPermission, remove)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：verifyAuth</p></li><li><p>验证用户权限：verifyPermission</p></li><li><p>Controller和Service的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.controller.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">remove</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 删除评论需要这个评论的id即可</span></span><br><span class="line">    <span class="keyword">const</span> &#123;commentId&#125; = ctx.params</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.delete(commentId)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">delete</span>(<span class="params">commentId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`DELETE FROM comment WHERE id=? `</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [commentId])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-查询动态"><a href="#2-查询动态" class="headerlink" title="2. 查询动态"></a>2. 查询动态</h4><ul><li><p>需求：</p><ul><li><p>查询一个动态详情时，既要看动态信息，还要看用户信息，评论的列表。需要回头修改moment.user.需要修改sql语句</p></li><li><p>查询动态列表时，有一个commentCount，也就是对应着你这条动态下有多少条评论计数。</p></li></ul></li><li><p>查询多个动态时，<strong>显示评论的个数</strong></p><p>在原有的查看动态getMomentList下的基础上，对sql语句进行了修改，添加查询字段，并增添了评论数量</p><p>在此基础上添加查询字段，子查询字段。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  m.id id, m.content content, </span><br><span class="line">  m.createAt createTime, m.updateAt updateTime, </span><br><span class="line">  JSON_OBJECT(<span class="string">&#x27;id&#x27;</span>, u.id, <span class="string">&#x27;name&#x27;</span>, u.name) author,</span><br><span class="line">(SELECT COUNT(*) FROM comment c WHERE c.moment_id = m.id) commentCount</span><br><span class="line">  FROM moment m</span><br><span class="line">  LEFT JOIN users u ON m.user_id = u.id</span><br><span class="line">LIMIT ?, ?;</span><br></pre></td></tr></table></figure><ul><li><p>进行请求：<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210208223358740.png" alt="image-20210208223358740"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;评论动态的内容&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="string">&quot;2021-02-07T09:33:56.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updateTime&quot;</span>: <span class="string">&quot;2021-02-07T09:33:56.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lucy&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;commentCount&quot;</span>: <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;评论动态的内容&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="string">&quot;2021-02-07T09:34:48.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updateTime&quot;</span>: <span class="string">&quot;2021-02-07T09:34:48.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lucy&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;commentCount&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>数据库中显示查询结果：<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210208223616477.png" alt="image-20210208223616477"></p></li></ul></li><li><p>查询单个动态时，显示评论的列表</p><p>当用户点击动态后，会进入动态详情页。如何获取评论的列表，之前是评论数量</p><ul><li>思路1：动态的接口与评论接口分开，分别用不同的接口获得不同的需求</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.router.js</span><br><span class="line"><span class="comment">// 获取评论列表：不需要验证登录、权限</span></span><br><span class="line">commentRouter.get(<span class="string">&#x27;/&#x27;</span>, list)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.controller.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">list</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 拿到要获取comment的动态id：momentId</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId&#125; = ctx.query</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.getCommentsBymomentId(momentId)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">getCommentsBymomentId</span>(<span class="params">momentId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM comment  WHERE moment_id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.exexute(statement, [momentId])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210208231911140.png" alt="image-20210208231911140"></p><ul><li>思路2：直接在请求动态的接口时候，就会携带评论相关的信息，嵌入动态信息里面。缺点：sql语句复杂，容易写错；如果信息很多，一次性请求过多的信息，网速慢，用户体验不好，可以把用户的动态先请求过来。省略</li><li>点赞功能：用户之间的多对多的关系，一个动态可以被多个用户点赞，一个用户也可以点赞多个用户。动态表中有很多动态，用户表也有很多用户，在这两个之间建立关系表，把动态相关的id+user_id结合在一起网这个表插入进去。</li></ul></li></ul><h3 id="7-标签接口开发（多对多）"><a href="#7-标签接口开发（多对多）" class="headerlink" title="7. 标签接口开发（多对多）"></a>7. 标签接口开发（多对多）</h3><p>标签是给动态加标签，每个动态都有对应着。所以需要标签表记录标签id，标签名等。一个动态可以有多个标签，一个标签可以属于多个动态。多对多的关系，所以当给一条动态添加一个标签以后，先判断是否存在这个标签，没有要先创建，有了再添加。</p><ul><li><p>创建标签的表</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS <span class="string">`label`</span>(</span><br><span class="line"> # id是主键</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line"># 标签名 是不能重复的，没意义</span><br><span class="line">name VARCHAR(<span class="number">10</span>) NOT NULL UNIQUE,</span><br><span class="line">createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP </span><br><span class="line"> ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-创建标签接口"><a href="#1-创建标签接口" class="headerlink" title="1. 创建标签接口"></a>1. 创建标签接口</h4><ul><li><p>路由配置Router</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; verifyAuth &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/auth.middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;create&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/label.controller&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> labelRouter = <span class="keyword">new</span> Router(&#123;<span class="attr">prefix</span>: <span class="string">&#x27;/label&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建标签时会先验证登录，</span></span><br><span class="line">labelRouter.post(<span class="string">&#x27;/&#x27;</span>, verifyAuth,create)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = labelRouter</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：verifyAuth</p></li><li><p>Controller和Service的处理：创建标签</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.controller</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/label.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">laberController</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 拿到要添加的标签</span></span><br><span class="line">    <span class="keyword">const</span> &#123;name&#125; = ctx.request.body</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.create(name)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> laberController()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.service</span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&quot;../app/database&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">labelService</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO label (name) VALUES (?);`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [name])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> labelService()</span><br></pre></td></tr></table></figure></li><li><p>创建标签和动态关系表</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS <span class="string">`moment_label`</span>(</span><br><span class="line">moment_id INT NOT NULL,</span><br><span class="line">label_id INT NOT NULL,</span><br><span class="line">createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line"><span class="comment">// 让二者成为联合主键，与复合主键是一个概念</span></span><br><span class="line">PRIMARY KEY (moment_id, label_id),</span><br><span class="line"><span class="comment">// 这里的联动效果是：这条动态删掉了，关系表里的记录会删掉，但是标签name并不会被删掉,</span></span><br><span class="line">FOREIGN KEY (moment_id) REFERENCES moment(id) ON DELETE CASCADE ON UPDATE CASCADE,</span><br><span class="line">FOREIGN KEY (label_id) REFERENCES label(id) ON DELETE CASCADE ON UPDATE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-给动态添加标签"><a href="#2-给动态添加标签" class="headerlink" title="2. 给动态添加标签"></a>2. 给动态添加标签</h4><ul><li><p>给<strong>动态</strong>添加新的接口： /moment/1/labels</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.router.js</span><br><span class="line"><span class="keyword">const</span> &#123;verifyLabelExist&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/label.middleware&#x27;</span>)</span><br><span class="line"><span class="comment">// 给动态添加标签</span></span><br><span class="line">momentRouter.post(<span class="string">&#x27;/:momentId/labels&#x27;</span>, verifyAuth, verifyPermission,</span><br><span class="line">                    verifyLabelExist,addLabels)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：verifyAuth</p></li><li><p>验证用户权限：verifyPermission</p></li><li><p>验证标签是否存在：Controller和Service的处理</p><p>如果标签不存在，添加到label表中，也就是为label创建新标签。而下面的创建标签是在关系表中添加标签</p><ul><li>这里是不可以直接将标签与动态联系在一起的，标签的名字有可能在标签的表里是不存在的，此时是没有对应的id，此时联系表label_id就不存在</li><li>所以当用户调用接口时，判断是否存在这个标签，如果不存在先创建这个标签，再往关系表里面插入数据。</li><li>所以路由中间还应该有一个中间件labelmiddleware,里面有函数varifyLabelExists，验证标签是否存在</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.middleware.js</span><br><span class="line"><span class="comment">// 验证要添加的标签是否已经存在与标签表</span></span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/label.service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> verifyLabelExist = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">//取出要添加的所有标签</span></span><br><span class="line">  <span class="keyword">const</span> &#123;labels&#125; = ctx.request.body</span><br><span class="line">  <span class="keyword">const</span> newLabels = []</span><br><span class="line">  <span class="comment">// 判断每个标签是否存在于标签表，遍历</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> name <span class="keyword">of</span> labels)&#123;</span><br><span class="line">    <span class="comment">// 如果该标签不存在，返回结果是result[0]，为undefined</span></span><br><span class="line">    <span class="comment">// 如果存在：结果是:BinaryRow &#123;</span></span><br><span class="line">    <span class="comment">//   id: 2,</span></span><br><span class="line">    <span class="comment">//   name: &#x27;游戏&#x27;,</span></span><br><span class="line">    <span class="comment">//   createAt: 2021-02-09T10:00:56.000Z,</span></span><br><span class="line">    <span class="comment">//   updateAt: 2021-02-09T10:00:56.000Z</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">const</span> labelResult = <span class="keyword">await</span> service.getLabelByName(name) <span class="comment">//  label.service.js</span></span><br><span class="line">    <span class="keyword">const</span> label = &#123;name&#125;</span><br><span class="line">    <span class="comment">// 如果不存在,就添加标签</span></span><br><span class="line">    <span class="keyword">if</span>(!labelResult)&#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> service.create(name)   <span class="comment">//  label.service.js</span></span><br><span class="line">      label.id = result.insertId</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      label.id = labelResult.id</span><br><span class="line">    &#125;</span><br><span class="line">    newLabels.push(label)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环结束，完成所有不存在标签的添加到label表</span></span><br><span class="line">  ctx.body = newLabels</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  verifyLabelExist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.service.js</span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&quot;../app/database&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">labelService</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO label (name) VALUES (?);`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [name])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断标签是否存在的情况</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">getLabelByName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM label WHERE name = ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [name])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> labelService()</span><br></pre></td></tr></table></figure></li><li><p>在关系表中添加标签：Controller和Service的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.controller.js </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">addLabels</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1. 给哪条动态上加什么标签</span></span><br><span class="line">    <span class="keyword">const</span> &#123;labels&#125; = ctx</span><br><span class="line">    <span class="keyword">const</span> &#123;momentId&#125; = ctx.params</span><br><span class="line">    <span class="comment">//2. 判断：如果添加标签是否已存在关系表</span></span><br><span class="line">      <span class="comment">// 2.1 在关系表中是否关于这个moment的标签已经有了</span></span><br><span class="line">      <span class="comment">// 标签表、关系表中标签都应该是唯一的</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> label <span class="keyword">of</span> labels)&#123;</span><br><span class="line">        <span class="keyword">const</span> isExist = <span class="keyword">await</span> momentService.hasLabel(momentId, label.id)</span><br><span class="line">        <span class="keyword">if</span>(!isExist)&#123;</span><br><span class="line">         <span class="keyword">await</span> momentService.addLabels(label.id, momentId)</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">    ctx.body = <span class="string">&#x27;在关系表中添加标签&#x27;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.service.js </span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">hasLabel</span>(<span class="params">momentId, labelId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM moment_label WHERE moment_id=? AND label_id=?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [momentId, labelId])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]? <span class="literal">true</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">addLabels</span>(<span class="params">label_id, momentId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO moment_label (moment_id, label_id) VALUES (?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.execute(statement, [momentId, label_id])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-展示标签"><a href="#3-展示标签" class="headerlink" title="3. 展示标签"></a>3. 展示标签</h4><ul><li><p>展示标签的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询标签列表</span></span><br><span class="line">labelRouter.get(<span class="string">&#x27;/&#x27;</span>, list)</span><br></pre></td></tr></table></figure></li><li><p><strong>查询动态列表</strong>，展示<strong>标签数量</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.controller.js</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">list</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;offset, limit&#125; = ctx.query</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">await</span> service.getLabels(offset, limit)</span><br><span class="line">   ctx.body = result</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.service.js</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getLabels</span>(<span class="params">offset, limit</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM label LIMIT ?, ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [offset, limit])</span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改标签接口：一般标签创建后一般不会做修改和删除操作</p></li><li><p>查询<strong>动态详情</strong>，展示<strong>标签列表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql语句太复杂了，暂时先不写这块</span><br></pre></td></tr></table></figure><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210209225206649.png" alt="image-20210209225206649"></p></li></ul><h3 id="8-上传图片"><a href="#8-上传图片" class="headerlink" title="8. 上传图片"></a>8. 上传图片</h3><h4 id="分析实现思路："><a href="#分析实现思路：" class="headerlink" title="分析实现思路："></a>分析实现思路：</h4><ul><li><p>图片（文件）上传 /upload/avatar</p><ul><li>图片上传就是文件上传的一种，服务器端可以保存一张图片</li></ul></li><li><p>提供一个接口，可以让用户获取图片</p><ul><li><p>如果有一天浏览器请求这个图片时，要在img标签里展示出来图片。必须提供一个接口提供给用户获取这个接口，而不是让用户下载这个图片文件。</p></li><li><p>找到图片，读取图片，设置content-type，告诉浏览器类型，而不是将二进制流直接给他。这样浏览器才知道是一图片的形式展示出去</p></li><li><p>avatar -&gt; 找到图片\读取图片\content-type: image/jpeg\返回图像的信息</p></li></ul></li><li><p>将URL存储到用户信息中</p><ul><li><p>将url存储到用户信息中，用户信息中有一个字段： avatar字段，直接给用户头像的地址</p></li><li><p>avatarURL: 头像的地址</p></li></ul></li><li><p>获取信息时，获取用户的头像</p></li></ul><h4 id="1-上传头像"><a href="#1-上传头像" class="headerlink" title="1. 上传头像"></a>1. 上传头像</h4><ul><li>定义所有关于上传头像的接口</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.router.js   希望在这个路由里定义所有关于图片上传的路由</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;verifyAuth&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/auth.middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;uploadHandle&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/file.middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileRouter = <span class="keyword">new</span> Router(&#123;<span class="attr">prefix</span>: <span class="string">&quot;/upload&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 上传图片：中间件定义图片保存在哪里，保存在服务器里；</span></span><br><span class="line"><span class="comment">// 关于图片的信息：类型，大小，controller.js里</span></span><br><span class="line"><span class="comment">// 上传头像必须要登录的，verifyAuth, 验证登录</span></span><br><span class="line">fileRouter.post(<span class="string">&#x27;/avatar&#x27;</span>, verifyAuth, uploadHandle,saveAvatarInfo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fileRouter</span><br></pre></td></tr></table></figure>  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210153519583.png" alt="image-20210210153519583" style="zoom:50%;" />  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.middleware.js   借助插件koa-multer来实现文件上传</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Multer = <span class="built_in">require</span>(<span class="string">&#x27;koa-multer&#x27;</span>)</span><br><span class="line"><span class="comment">// 在本地的process.cwd路径下创建路径./uploads/avatar下的文件夹</span></span><br><span class="line"><span class="keyword">const</span> uploadAvatar = Multer(&#123;</span><br><span class="line">  <span class="attr">dest</span>: <span class="string">&#x27;./uploads/avatar&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 找到在postman那边上传的avatar字段,single只找一个文件</span></span><br><span class="line"><span class="comment">// 然后放入后面的路由后面，登陆之后会对上传文件进行处理</span></span><br><span class="line"><span class="keyword">const</span> uploadHandle = uploadAvatar.single(<span class="string">&#x27;avatar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  uploadHandle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此时文件夹已经有上传过来的图片了</p>  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210153559449.png" alt="image-20210210153559449" style="zoom:50%;" /><ul><li><p>对上传图片信息保存</p><ul><li><p>新建表avatar</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS <span class="string">`avatar`</span>(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">filename VARCHAR(<span class="number">255</span>) NOT NULL UNIQUE,</span><br><span class="line">mimetype VARCHAR(<span class="number">30</span>),</span><br><span class="line">size INT,</span><br><span class="line">user_id INT,</span><br><span class="line">createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>图像信息保存：saveAvatarInfo中间件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/file.service&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fileController</span></span>&#123;</span><br><span class="line">  <span class="comment">// 上传图片时不仅要传图片，还要对图片信息相关进行保存</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">saveAvatarInfo</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 拿到图片信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123;filename, mimetype, size&#125; = ctx.req.file</span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.user</span><br><span class="line">    <span class="comment">// 将图片保存到数据库中，所以需要单独创建表</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.createAvatar(filename, mimetype, size, id)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> fileController()</span><br></pre></td></tr></table></figure><p>ctx.req.file里面保存的信息：</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210154139788.png" alt="image-20210210154139788" style="zoom:50%;" /></li><li><p>service的操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&quot;../app/database&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fileService</span></span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">createAvatar</span>(<span class="params">filename, mimetype, size, user_id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO avatar (filename, mimetype, size, user_id) VALUES (?, ?, ?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [filename, mimetype, size, user_id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> fileService()</span><br></pre></td></tr></table></figure><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210162609117.png" alt="image-20210210162609117"></p></li></ul></li></ul><h4 id="2-获取头像"><a href="#2-获取头像" class="headerlink" title="2. 获取头像"></a>2. 获取头像</h4><ul><li>定义获取图像的接口</li></ul><p>输入浏览器的头像，希望直接展示出来。此时必须单独写个接口，给用户返回头像</p><p>  获取用户信息的时候，可以直接看到用户的头像。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># user.router.js</span><br><span class="line">userRouter.get(&#x27;/:userId/avatar&#x27;, avatarInfo)</span><br></pre></td></tr></table></figure><ul><li>请求用户信息时，获取头像</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># user.controller.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">avatarInfo</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 用户获取的文件id</span></span><br><span class="line">    <span class="keyword">const</span> &#123;userId&#125; = ctx.params</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> fileService.getAvatarByUserId(userId) # file.service.js</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">getAvatarByUserId</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM avatar WHERE id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [userId])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  此时返回的数据：<br>  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210171048347.png" alt="image-20210210171048347" style="zoom:50%;" /></p><p>  要想将图片信息展示出来：ctx.body = result需要修改。</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">avatarInfo</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 用户获取的文件id</span></span><br><span class="line">  <span class="keyword">const</span> &#123;userId&#125; = ctx.params</span><br><span class="line">  <span class="keyword">const</span> avatarInfo = <span class="keyword">await</span> fileService.getAvatarByUserId(userId)</span><br><span class="line">  ctx.body = fs.createReadStream(<span class="string">`<span class="subst">$&#123;AVATAR_PATH&#125;</span>/<span class="subst">$&#123;avatarInfo.filename&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"># AVATAR_PATH是导入的路径常量：./upload/avatar  <span class="comment">// 在constants/file-path.js里</span></span><br></pre></td></tr></table></figure><p>  此时图片再进行请求，浏览器自动下载文件，并不会展示图片，因为他不知道是图片还是文件。这种做法是只适合普通的图片。现在我们要设置reponse， 拿到响应对象</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.response.set(<span class="string">&#x27;content-type&#x27;</span>, avatarInfo.mimetype)</span><br><span class="line">ctx.body = fs.createReadStream(<span class="string">`<span class="subst">$&#123;AVATAR_PATH&#125;</span>/<span class="subst">$&#123;avatarInfo.filename&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><ul><li><p>对user表添加一段avatar，用来保存用户头像的url</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ALTER TABLE <span class="string">`users`</span> ADD <span class="string">`avatar_url`</span> VARCHAR(<span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>希望用户在上传图像成功后，就保存这个url。在fileController中，上传后将用户数据保存到users表中。修改之前上传头像的接口：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.controller.js</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">saveAvatarInfo</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 拿到图片信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123;filename, mimetype, size&#125; = ctx.req.file</span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.user</span><br><span class="line">    <span class="comment">// 将图片保存到数据库中，所以需要单独创建表</span></span><br><span class="line">   <span class="keyword">const</span> res =  <span class="keyword">await</span> service.createAvatar(filename, mimetype, size, id)</span><br><span class="line">  <span class="comment">// 保存图片地址在users表里</span></span><br><span class="line">    <span class="comment">// 拿到图片路径</span></span><br><span class="line">    <span class="keyword">const</span> avatarUrl = <span class="string">`<span class="subst">$&#123;AVATAR_PATH&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span></span><br><span class="line">    <span class="comment">//更改users表</span></span><br><span class="line">    <span class="keyword">await</span> userService.updateAvatarUrlById(avatarUrl, id)</span><br><span class="line">    ctx.body = <span class="string">&#x27;用户头像上传头像&#x27;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">createAvatar</span>(<span class="params">filename, mimetype, size, user_id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO avatar </span></span><br><span class="line"><span class="string">    (filename, mimetype, size, user_id) VALUES (?, ?, ?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, </span><br><span class="line">    [filename, mimetype, size, user_id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># user.service.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">updateAvatarUrlById</span>(<span class="params">avatarUrl, id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`UPDATE users SET avatar_url = ? WHERE id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [avatarUrl, id])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时上传头像，users里就有url字段存储着地址<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210195615751.png" alt="image-20210210195615751"></p><p>但这个地址是相对路径，更改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 更改env</span><br><span class="line">APP_PORT = <span class="number">8000</span></span><br><span class="line">LOCAL_HOST = <span class="string">&quot;localhost</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># config.js</span><br><span class="line">导出增加这一项</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> avatarUrl = <span class="string">`<span class="subst">$&#123;AVATAR_PATH&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span></span><br><span class="line">更改为：</span><br><span class="line"><span class="keyword">const</span> avatarUrl = <span class="string">`<span class="subst">$&#123;LOCAL_HOST&#125;</span>:<span class="subst">$&#123;APP_PORT&#125;</span>/<span class="subst">$&#123;id&#125;</span>/avatar`</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210201631018.png" alt="image-20210210201631018"></p></li></ul><h4 id="3-上传动态的配图"><a href="#3-上传动态的配图" class="headerlink" title="3. 上传动态的配图"></a>3. 上传动态的配图</h4><ul><li><p>定义上传动态配图的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.router.js</span><br><span class="line">fileRouter.post(<span class="string">&#x27;/picture&#x27;</span>, verifyAuth, pictureHandle)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># fie.middleware.js</span><br><span class="line"><span class="comment">// 上传动态图</span></span><br><span class="line"><span class="keyword">const</span> uploadPicture = Multer(&#123;</span><br><span class="line">  <span class="attr">dest</span>: PICTURE_PATH</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> pictureHandle = uploadPicture.array(<span class="string">&#x27;picture&#x27;</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure></li><li><p>创建表file存储上传的动态配图</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS <span class="string">`file`</span>(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">filename VARCHAR(<span class="number">100</span>) NOT NULL UNIQUE,</span><br><span class="line">mimetype VARCHAR(<span class="number">30</span>),</span><br><span class="line">size INT,</span><br><span class="line">moment_id INT,</span><br><span class="line">user_id INT,</span><br><span class="line">createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,</span><br><span class="line">FOREIGN KEY (moment_id) REFERENCES moment(id) ON DELETE CASCADE ON UPDATE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>我希望上传时，把query参数一起传过来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># # file.router.js</span><br><span class="line">fileRouter.post(<span class="string">&#x27;/picture&#x27;</span>, verifyAuth, pictureHandle, savePictureInfo)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.controller.js</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">savePictureInfo</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取头像信息</span></span><br><span class="line">    <span class="keyword">const</span> files = ctx.req.files</span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.user</span><br><span class="line">    <span class="keyword">const</span> &#123;momentId&#125; = ctx.query</span><br><span class="line">    <span class="comment">// 将所有的文件信息保存到数据库中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> file <span class="keyword">of</span> files)&#123;</span><br><span class="line">      <span class="comment">// 拿到图片信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123;originalname, mimetype, size&#125; = file</span><br><span class="line">    <span class="comment">// 拿user_id</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.createPicture(</span><br><span class="line">       originalname, mimetype, size, momentId, id)</span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.service.js</span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="title">createPicture</span>(<span class="params">originalname, mimetype, size, momentId, userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO file (filename, mimetype, size, moment_id, user_id) </span></span><br><span class="line"><span class="string">                       VALUES (?, ?, ?, ?, ?);`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.execute(statement, [originalname, mimetype, size, momentId, userId,])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210213006041.png" alt="image-20210210213006041">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p><p>从服务器拿到的图片是原图，服务器会对上传的图片进行一些处理，举例一张图像变成3张（1280、640、320）。当我们在列表中展示图片的时候，可以提供不同类型的图片，这是就需要对用户上传过来的图片进行专门的处理。</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node、MySQL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目5：Node用户管理接口：项目梳理篇</title>
      <link href="/2021/12/12/%E9%A1%B9%E7%9B%AE5%EF%BC%9ANode%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86%E7%AF%87/"/>
      <url>/2021/12/12/%E9%A1%B9%E7%9B%AE5%EF%BC%9ANode%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2021年2月</li><li>项目背景： 春节在家，只是想简单了解下接口、数据库的概念</li><li>梳理篇：大概梳理了哪些功能，实现思路。。吧，记忆丢失，嘤嘤嘤</li></ul><h2 id="用户管理系统逻辑"><a href="#用户管理系统逻辑" class="headerlink" title="用户管理系统逻辑"></a>用户管理系统逻辑</h2><h4 id="1-用户注册"><a href="#1-用户注册" class="headerlink" title="1. 用户注册"></a>1. 用户注册</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用户注册</span><br><span class="line">userRouter.post(&#x27;/&#x27;, verifyUser, handlePassword, create)</span><br></pre></td></tr></table></figure><ol><li><p>验证是否已有该账户： verifyUser<br>查询数据库，结果是否为空</p></li><li><p>对用户信息加密：handlePassWord，目的：避免存在数据库中的用户信息是明文的</p><p>借助框架crypto的createHash（），MD5的加密方式</p></li><li><p>创建新用户：create</p><p>对users表插入数据</p></li></ol><h4 id="2-用户登录"><a href="#2-用户登录" class="headerlink" title="2. 用户登录"></a>2. 用户登录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用户登录</span><br><span class="line">authRouter.post(&#x27;/login&#x27;, verifyLogin, login)</span><br><span class="line">// 验证是否授权的一个接口</span><br><span class="line">authRouter.get(&#x27;/test&#x27;, verifyAuth, success)</span><br></pre></td></tr></table></figure><ol><li>验证账户密码正确：verifyLogin<ul><li>拿到请求中的账户密码，是否为空、是否存在该用户</li><li>对登录的密码进行MD5的加密，去数据库查询是否匹配</li></ul></li><li>登录：login<ul><li>从ctx.user中拿到id和name，通过jwt.sign({})，设置过期时间+私钥的加密算法，生成token。</li></ul></li></ol><h4 id="3-用户动态"><a href="#3-用户动态" class="headerlink" title="3. 用户动态"></a>3. 用户动态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//发表动态之前要先验证登录，然后才是create创建动态</span><br><span class="line">momentRouter.post(&#x27;/&#x27;, verifyAuth, create)</span><br><span class="line">// 查看动态,不需要登录,需要知道动态对应的id</span><br><span class="line">momentRouter.get(&#x27;/:momentId&#x27;, momentDetail)</span><br><span class="line"></span><br><span class="line">// 修改动态 </span><br><span class="line">momentRouter.patch(&#x27;/:momentId&#x27;,verifyAuth, verifyPermission, update)</span><br><span class="line">// 删除动态</span><br><span class="line">momentRouter.delete(&#x27;/:momentId&#x27;,verifyAuth, verifyPermission, remove)</span><br><span class="line">// 给动态添加标签</span><br><span class="line">momentRouter.post(&#x27;/:momentId/labels&#x27;, verifyAuth, verifyPermission,</span><br><span class="line">                    verifyLabelExist,addLabels)</span><br></pre></td></tr></table></figure><ol><li><p>验证登录：verifyAuth，作用：验证用户授权与否、颁发签名是否有效</p><p>在验证时：</p><ul><li>通过ctx.headers.authorization拿到authorization，处理（去掉Bearer ），得到token</li><li>通过jwt.verify(token, 公钥，{解密算法})拿到解密后的信息。</li><li>通过try.catch块包裹，如果有错误会抛出。否则进入下一个中间件</li></ul></li><li><p>创建动态：create</p><ul><li>在上一中间件中ctx.user，进行解构拿到id（哪个用户），拿到content内容（请求体），插入数据库moment表中</li></ul></li><li><p>查询动态:</p><ul><li>单条：由params拿到要查询的动态id，再去数据库moment表中查询（左连接）</li><li>多条：offset和size在query中拿到，在评论的功能汇总添加的动态的评论数量。这是通过修改sql语句，增加字段</li></ul></li><li><p>修改动态</p><ul><li><p>验证登录verifyAuth</p></li><li><p>验证是否具备修改权限verifyPermission<br>拿到要删除的动态id（params中得到），登录用户的id，查询结果是否为空，判断是否具有权限</p></li><li><p>更改</p><p>对moment表中id为xxx的content设置新的值</p></li></ul></li><li><p>删除动态</p><ul><li>验证登录</li><li>验证权限</li><li>删除remove：从params中拿到要删除的动态id，Delete删除</li></ul></li></ol><h4 id="4-用户评论：comment"><a href="#4-用户评论：comment" class="headerlink" title="4. 用户评论：comment"></a>4. 用户评论：comment</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commentRouter.post(&#x27;/&#x27;, verifyAuth, create)</span><br><span class="line">commentRouter.post(&#x27;/:commentId/reply&#x27;, verifyAuth, reply)</span><br><span class="line">// 修改评论,你只能修改自己发表的评论，而不能修改别人发表的评论</span><br><span class="line">commentRouter.patch(&#x27;/:commentId&#x27;, verifyAuth,verifyPermission, update)</span><br><span class="line">// 删除评论</span><br><span class="line">commentRouter.delete(&#x27;/:commentId&#x27;, verifyAuth, verifyPermission, remove)</span><br><span class="line">// 获取评论列表：不需要验证登录、权限</span><br><span class="line">commentRouter.get(&#x27;/&#x27;, list)</span><br></pre></td></tr></table></figure><ol><li><p>发布评论</p><ul><li>验证登录</li><li>创建评论<br>从请求体里拿到动态id，内容content、用户id。也就是哪个用户对哪条动态做了怎样的评论</li></ul></li><li><p>回复评论</p><ul><li>验证登录</li><li>回复：从请求体里拿到动态id，内容content、用户id，再拿到要评论的id（params），去操作moment表</li></ul></li><li><p>修改评论</p><ul><li><p>验证登录</p></li><li><p>验证权限：varifyPermission，只能修改自己的评论</p><p>对varifyPermission做了修改，通过遍历ctx.params属性拿到表名，从而动态的修改statement中的表名，使其作为一个参数传入进去，这样每次查询的是否，根据传入参数tablename的不同，查询的不同权限，使其既具备验证动态权限处理又可验证评论权限</p></li><li><p>update</p></li></ul></li><li><p>删除评论</p><ul><li>验证登录</li><li>验证权限</li><li>remove</li></ul></li><li><p>查询动态，显示评论</p><ul><li>单条：显示评论列表</li><li>多条：修改sql语句，增加commentCount字段</li></ul></li></ol><h4 id="5-标签功能"><a href="#5-标签功能" class="headerlink" title="5. 标签功能"></a>5. 标签功能</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建标签时会先验证登录，</span><br><span class="line">labelRouter.post(&#x27;/&#x27;, verifyAuth,create)</span><br><span class="line"></span><br><span class="line">// 查询标签列表</span><br><span class="line">labelRouter.get(&#x27;/&#x27;, list)</span><br></pre></td></tr></table></figure><h5 id="添加标签的过程"><a href="#添加标签的过程" class="headerlink" title="添加标签的过程"></a>添加标签的过程</h5><ol><li><p>验证登录  √</p></li><li><p>验证用户权限  √</p></li><li><p>验证要添加的标签是否存在 （verifyLabelsExists）</p><ul><li><p>从params中拿到动态id，再拿到所有的标签，进行遍历，getLabelByName判断label表中，是否有标签id</p><p>如果没有标签id，通过create在label表中添加，此时数据库的操作返回结果result.insertId就有了该id</p><p>如果已有标签id，通过getLabelByName查询的结果 labelResult.id中，可以拿到id</p></li><li><p>补充如何添加标签：创建标签表、验证登录、从请求体拿到标签名，通过create插入label中</p></li></ul></li><li><p>再给某条动态添加标签（在关系表中）</p><p>此时已有commentId、标签id，以及标签。在添加标签之前，hasLabel判断该动态是否已存在该标签，对没有某些标签的那个动态，再通过addLabels去添加标签。在关系表中添加</p></li></ol><h5 id="展示标签"><a href="#展示标签" class="headerlink" title="展示标签"></a>展示标签</h5><ul><li>从query中取出offset和size，去label表中查询结果</li></ul><h4 id="6-图片上传"><a href="#6-图片上传" class="headerlink" title="6. 图片上传"></a>6. 图片上传</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用户上传头像</span><br><span class="line">userRouter.get(&#x27;/:userId/avatar&#x27;, avatarInfo)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fileRouter.post(&#x27;/avatar&#x27;, verifyAuth, uploadHandle,saveAvatarInfo)</span><br><span class="line">fileRouter.post(&#x27;/picture&#x27;, verifyAuth, pictureHandle,pictureResize, savePictureInfo)</span><br></pre></td></tr></table></figure><ol><li>头像上传<ul><li>验证登录：VerifyAuth</li><li>uploadHandle：借助koa-multer，实现上传功能，单张图片用single的方法</li><li>图像信息保存：saveAvatarInfo，从ctx.req.file中拿到filename,mimetype,size，再去数据库中插入数据</li></ul></li><li>头像获取<ul><li>拿到用户id（从params中），再去数据库中查询，拿到查询结果</li></ul></li><li>展示头像<ul><li>ctx.body = result，不能直接去那个接口请求，会下载下来。而是先设置ctx.response.set()设置content-type为头像的mimetype。</li><li>再修改ctx.body =为fs读取文件流的结果，读取的地址是http：//localhost:8000/…..等接口下的某路径。但是这个地方不能写死了，所以可以将端口主机等修改为导入的量。</li><li>为表users添加字段avatar_url，保存请求地址，此时修改获取头像时，只需要传入avatar_url和用户的id，就可以在users中查找到对应的头像</li></ul></li><li>上传动态的配图（多张）<ul><li>登录验证</li><li>savePictureInfo<ul><li>上传文件，使用multer，并用array的方法</li><li>拿到文件信息，用户id，momentId（query中），遍历每个文件，都进行插入数据库的表file中，</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node、MySQL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本使用</title>
      <link href="/2021/12/11/%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/12/11/%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="一、本地仓库"><a href="#一、本地仓库" class="headerlink" title="一、本地仓库"></a>一、本地仓库</h2><h3 id="1、初始化、操作命令"><a href="#1、初始化、操作命令" class="headerlink" title="1、初始化、操作命令"></a>1、初始化、操作命令</h3><h4 id="1、Linux命令"><a href="#1、Linux命令" class="headerlink" title="1、Linux命令"></a>1、Linux命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ll：显示目录中全部文件信息</span><br><span class="line">ls -la:带隐藏资源</span><br><span class="line">pwd：用于显示工作目录</span><br><span class="line">cd ~：进入家目录</span><br><span class="line">如果显示: 说明内容一页放不完，按空格进入下一页</span><br><span class="line">vim编辑器</span><br><span class="line"></span><br><span class="line">:wq 保存退出</span><br><span class="line">esc 退出编辑模式</span><br><span class="line">显示行号:set nu</span><br></pre></td></tr></table></figure><p>多屏显示控制方式：</p><ul><li>空格向下翻页</li><li>b 向上翻页</li><li>q 退出</li></ul><h4 id="2、创建版本库："><a href="#2、创建版本库：" class="headerlink" title="2、创建版本库："></a>2、创建版本库：</h4><ul><li><code>git init</code>把这个目录变成Git管理的仓库：<ul><li>当前目录下多了一个<code>.git</code>的目录，是Git来跟踪管理版本库的，不要随意修改这个文件夹</li><li>如果没有<code>.git</code>目录，用<code>ls -ah</code>命令（list file）可看见，因为默认隐藏了</li></ul></li><li>版本控制系统只能跟踪<strong>文本文件</strong>的改动，而不能追踪Microsoft的Word、图片、视频这些<strong>二进制文件</strong>，无法知道这些文件具体改了啥</li></ul><h4 id="3、签名"><a href="#3、签名" class="headerlink" title="3、签名"></a>3、签名</h4><ul><li><h4 id="项目级别-仓库级别：仅在当前本地库（如MyBooBPMS）范围内有效"><a href="#项目级别-仓库级别：仅在当前本地库（如MyBooBPMS）范围内有效" class="headerlink" title="项目级别/仓库级别：仅在当前本地库（如MyBooBPMS）范围内有效"></a>项目级别/仓库级别：仅在当前本地库（如MyBooBPMS）范围内有效</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name wuyunzhi_pro</span><br><span class="line">git config user.email hangOn_pro@zz</span><br><span class="line">信息保存位置：./.git/config文件</span><br><span class="line">查看签名命令 cat .git/config</span><br></pre></td></tr></table></figure></li><li><h4 id="系统用户级别：登录当前操作系统的用户范围"><a href="#系统用户级别：登录当前操作系统的用户范围" class="headerlink" title="系统用户级别：登录当前操作系统的用户范围"></a>系统用户级别：登录当前操作系统的用户范围</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name tom_glb</span><br><span class="line">git config --global goodMorning@atguigu.com</span><br><span class="line">信息保存位置：~/.gitconfig 文件</span><br><span class="line">查看签名命令 cat ~/.gitconfig</span><br></pre></td></tr></table></figure></li><li><h4 id="级别优先级"><a href="#级别优先级" class="headerlink" title="级别优先级"></a>级别优先级</h4><p>就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别的签名<br>如果只有系统用户级别的签名，就以系统用户级别的签名为准<br>二者都没有不允许</p></li></ul><h3 id="2、基本操作"><a href="#2、基本操作" class="headerlink" title="2、基本操作"></a>2、基本操作</h3><h4 id="0、工作区、暂存区概念"><a href="#0、工作区、暂存区概念" class="headerlink" title="0、工作区、暂存区概念"></a>0、工作区、暂存区概念</h4><ul><li><strong>工作区：</strong>在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区</li><li><strong>版本库：</strong>工作区有一个隐藏目录<code>.git</code>，它里面存了很多东西，其中：<ul><li><strong>暂存区：</strong>最重要的，也叫stage（或者叫index）</li><li><strong><code>master</code>分支</strong>：Git自动创建的</li><li><strong>HEAD指针：</strong>指向<code>master</code>的一个指针</li></ul></li></ul><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo"></p><h4 id="1、命令理解："><a href="#1、命令理解：" class="headerlink" title="1、命令理解："></a>1、命令理解：</h4><ul><li><p><code>git add</code>：把文件修改添加到暂存区；</p><p>没有git add的文件时，<code>git status</code>查看文件的状态是<code>Untracked</code>；</p><p>add 之后的状态是：changes to be commited，并且实际状态变成如下：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020074026336/0" alt="git-stage"></p></li><li><p><code>git commit</code>：一次性把暂存区的所有修改提交到当前分支</p></li><li><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><img src="https://www.liaoxuefeng.com/files/attachments/919020100829536/0" alt="git-stage-after-commit" style="zoom:80%;" /></li></ul><h4 id="2、查看、改变状态"><a href="#2、查看、改变状态" class="headerlink" title="2、查看、改变状态"></a>2、查看、改变状态</h4><ul><li><code>git status</code>：可以时刻掌握仓库当前的状态，可以知道哪些文件被修改了</li><li><code>git diff</code>：可以知道相比于上次的修改内容</li><li><code>git add readme.txt</code>：把文件添加到仓库</li><li><code>commit</code>：把文件提交到仓库：git commit –m “文件说明”<ul><li>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，再一次性提交</li></ul></li></ul><h4 id="3、日志"><a href="#3、日志" class="headerlink" title="3、日志"></a>3、日志</h4><ul><li><p><code>git log</code>：显示从最近到最远的提交日志 </p><ul><li>一大串数字是版本号commit id</li><li>每提交一个新版本Git就会把它们自动串成一条时间线，如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线</li></ul></li><li><p><code>git log--pretty=oneline</code>：每个记录一行显示</p></li><li><p><code>git reflog</code>：有距离本次的HEAD回退次数：</p><ul><li>在Git中，用<code>HEAD</code>表示当前版本，是最新提交</li><li>上一个版本是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本<code>HEAD~100</code></li></ul><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210101204117305.png" alt="image-20210101204117305"></p><p>回退到上一个版本：可以使用<code>git reset</code>命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>此时，如果想回未来的某个版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 1094a       //版本号没必要写全，前几位就可以了，Git会自动去找</span><br></pre></td></tr></table></figure><p>【注意】：这里的id是提交时候的那个id</p></li></ul><h3 id="3、-文件删除、找回"><a href="#3、-文件删除、找回" class="headerlink" title="3、 文件删除、找回"></a>3、 文件删除、找回</h3><h5 id="1、文件删除"><a href="#1、文件删除" class="headerlink" title="1、文件删除"></a>1、文件删除</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm test.txt     // 或者文件管理器删除</span><br><span class="line">// 删除工作区文件后，工作区和版本库就不一致了，`git status`命令会告诉你哪些文件被删除了</span><br><span class="line"></span><br><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$git reset --hard commitId</span><br></pre></td></tr></table></figure><h5 id="2、删除文件找回"><a href="#2、删除文件找回" class="headerlink" title="2、删除文件找回"></a>2、删除文件找回</h5><p>【前提】：删除前，文件存在的状态被提交到了版本库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- test.txt   // 丢弃掉本次修改，无论工作区是修改还是删除，都可以“一键还原”</span><br></pre></td></tr></table></figure><h3 id="4、版本回退reset"><a href="#4、版本回退reset" class="headerlink" title="4、版本回退reset"></a>4、版本回退reset</h3><h4 id="1、版本回退原理："><a href="#1、版本回退原理：" class="headerlink" title="1、版本回退原理："></a>1、版本回退原理：</h4><ul><li>Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本<code>append GPL</code>的时候，Git仅仅是把HEAD从指向你回退的那个地方，并把工作区的文件更新：</li></ul><h4 id="2、直接操作HEAD指针"><a href="#2、直接操作HEAD指针" class="headerlink" title="2、直接操作HEAD指针"></a>2、直接操作HEAD指针</h4><ul><li><p>基于commitID操作：推荐</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 1094a </span><br></pre></td></tr></table></figure></li><li><p>基于符号^操作：只能后退</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li><li><p>基于符号~来操作：只能后退</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~N</span><br></pre></td></tr></table></figure></li></ul><img src="https:////upload-images.jianshu.io/upload_images/4428238-fcad08ebe26933a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp" alt="img" style="zoom:67%;" /><h4 id="3、git-checkout"><a href="#3、git-checkout" class="headerlink" title="3、git checkout"></a>3、git checkout</h4><p>撤销工作区的修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- readme.txt //把`readme.txt`文件在工作区的修改全部撤销</span><br></pre></td></tr></table></figure><h4 id="4、reset的参数-–hard"><a href="#4、reset的参数-–hard" class="headerlink" title="4、reset的参数 –hard"></a>4、reset的参数 –hard</h4><h5 id="1、作用："><a href="#1、作用：" class="headerlink" title="1、作用："></a>1、作用：</h5><ol><li>在本地库移动HEAD指针、<strong>branch</strong></li><li>重置暂存区</li><li>重置工作区</li></ol><h5 id="2、效果："><a href="#2、效果：" class="headerlink" title="2、效果："></a>2、效果：</h5><ol><li> <strong>HEAD 和当前 branch</strong> 切到了上一条<strong>commit</strong>的位置</li><li> 暂存区、工作区的内容变成了和<strong>HEAD</strong>的新位置相同的内容，之前你没有commit的内容会全部丢失</li></ol><h5 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h5><p>撤销 <strong>commit</strong> 的效果在于：</p><ul><li>它把 <strong>HEAD</strong> 和它所指向的 branch 一起移动到了当前 <strong>commit</strong> 的父 <strong>commit</strong> 上，从而起到了「撤销」的效果：</li></ul><img src="https:////upload-images.jianshu.io/upload_images/4428238-6dbab74ae9ad2e1f?imageMogr2/auto-orient/strip|imageView2/2/w/466/format/webp" alt="img" style="zoom:50%;" /><h5 id="4、使用场景"><a href="#4、使用场景" class="headerlink" title="4、使用场景"></a>4、使用场景</h5><ol><li><p><strong>要放弃目前本地的所有改变</strong>：强制恢复git管理的文件夹的內容及状态</p></li><li><p><strong>想抛弃某节点后的所有commit，：</strong>可能觉得目标节点到原节点之间的commit提交都是错了，之前所有的commit有问题</p></li><li><p>移动到任何你想去的分支：</p><img src="https:////upload-images.jianshu.io/upload_images/4428238-71f7141a3878da7e?imageMogr2/auto-orient/strip|imageView2/2/w/434/format/webp" alt="img" style="zoom: 33%;" /></li></ol><h4 id="5、reset的3个参数–mixed"><a href="#5、reset的3个参数–mixed" class="headerlink" title="5、reset的3个参数–mixed"></a>5、reset的3个参数–mixed</h4><p>git reset 不加参数</p><h5 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h5><ol><li>在本地库移动HEAD指针、<strong>branch</strong></li><li>保留工作目录，并重置暂存区</li></ol><h5 id="2、效果"><a href="#2、效果" class="headerlink" title="2、效果"></a>2、效果</h5><ol><li>工作区的修改、暂存区的内容以及由 <strong>reset</strong> 所导致的新的文件差异，都会被放进工作区</li><li>一样可以达到合并<strong>commit</strong>节点的效果</li></ol><h5 id="3、使用场景"><a href="#3、使用场景" class="headerlink" title="3、使用场景"></a>3、使用场景</h5><ol><li><p>发现add错文件到暂存区</p></li><li><p>合并提交节点：</p><ul><li><p><strong>commit</strong>提交某些错误代码，不想再修改错误再<strong>commit</strong>，因为会留下一个错误<strong>commit</strong>点</p></li><li><p>可以回退到正确的<strong>commit</strong>点上，然后所有原节点和<strong>reset</strong>节点之间差异会在工作区，错误的文件修改后，再<strong>commit</strong>上去就OK了</p></li></ul></li></ol><h4 id="6、reset的3个参数-–soft"><a href="#6、reset的3个参数-–soft" class="headerlink" title="6、reset的3个参数 –soft"></a>6、reset的3个参数 –soft</h4><h5 id="1、作用-1"><a href="#1、作用-1" class="headerlink" title="1、作用"></a>1、作用</h5><ul><li>仅在本地库移动HEAD指针、<strong>branch</strong></li></ul><h5 id="2、效果-1"><a href="#2、效果-1" class="headerlink" title="2、效果"></a>2、效果</h5><ul><li>重置 <strong>HEAD</strong> 和 <strong>branch</strong></li><li><strong>保留工作区和暂存区</strong>中的内容，此时暂存区里是最新的变动内容</li></ul><h5 id="3、使用场景-1"><a href="#3、使用场景-1" class="headerlink" title="3、使用场景"></a>3、使用场景</h5><p>想合并「当前节点」与「reset目标节点」之间不具太大意义的 <strong>commit</strong> 记录时</p><ul><li>比如：开发一个功能，改或增一个文件就<strong>commit</strong>，<strong>这样导致一个完整的功能会多个commit点</strong></li><li>而你又想把这些<strong>commit</strong>整合成一个<strong>commit</strong>时，可以使用<strong>reset  –soft</strong>，再 <strong>git commit</strong> 將 index暂存区中的內容提交至 <strong>repository</strong> 中</li></ul><h2 id="二、远程仓库"><a href="#二、远程仓库" class="headerlink" title="二、远程仓库"></a>二、远程仓库</h2><h3 id="1、仓库配置"><a href="#1、仓库配置" class="headerlink" title="1、仓库配置"></a>1、仓库配置</h3><h4 id="1、创建SSH-Key"><a href="#1、创建SSH-Key" class="headerlink" title="1、创建SSH Key"></a>1、创建SSH Key</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line">// 一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码</span><br></pre></td></tr></table></figure><ul><li>在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥</li><li>登录远程仓库，比如github，找到添加“SSH Keys”页面，粘贴<code>id_rsa.pub</code>文件的内容</li></ul><h4 id="2、为什么远程需要SSH-Key？"><a href="#2、为什么远程需要SSH-Key？" class="headerlink" title="2、为什么远程需要SSH Key？"></a>2、为什么远程需要SSH Key？</h4><ol><li>GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的</li><li>Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送</li><li>GitHub允许添加多个Key，多设备提交</li></ol><h4 id="3、建立关联"><a href="#3、建立关联" class="headerlink" title="3、建立关联"></a>3、建立关联</h4><ul><li><p>把一个已有的本地仓库与之<strong>关联</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git；</span><br><span class="line"></span><br><span class="line">$ git remote add origin git@github.com:claire-woodsen/cangku1.git</span><br></pre></td></tr></table></figure><p>origin：远程库的名字，是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>claire-woodsen：邮箱名</p><p>cangku1.git：<strong>远程版本库</strong>的名字</p></li></ul><h3 id="2、删除远程库"><a href="#2、删除远程库" class="headerlink" title="2、删除远程库"></a>2、删除远程库</h3><ol><li><p>先用<code>git remote -v</code>查看远程库信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure></li><li><p>然后根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure></li></ol><p>【注意】：</p><ol><li>删除，指的是解除了本地和远程的绑定关系，远程库本身并没有删除</li><li>真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮</li></ol><h3 id="3、克隆远程库"><a href="#3、克隆远程库" class="headerlink" title="3、克隆远程库"></a>3、克隆远程库</h3><ul><li><p>找到合适路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:claire-woodsen/cangku2.git</span><br></pre></td></tr></table></figure></li></ul><ul><li>Git支持多种协议，默认的<code>git://</code>使用ssh，<code>ssh</code>协议速度最快</li><li>也可以用<code>https</code>等其他协议，<code>https</code>除了速度慢以外，每次推送都必须输入口令</li></ul><h3 id="4、推送远程仓库"><a href="#4、推送远程仓库" class="headerlink" title="4、推送远程仓库"></a>4、推送远程仓库</h3><ul><li><p>把本地仓库的内容<strong>推送</strong>到GitHub仓库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master   //实际是将当前分支推送到远程</span><br></pre></td></tr></table></figure><ul><li><code>-u</code>参数：<ol><li>不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支</li><li>把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来</li></ol></li></ul></li></ul><h4 id="安装警告"><a href="#安装警告" class="headerlink" title="安装警告"></a>安装警告</h4><ul><li><p>【注意】：第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><ol><li>输入<code>yes</code>回车即可，后面的操作就不会有任何警告了</li><li>Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器</li></ol></li></ul><h2 id="三、分支管理"><a href="#三、分支管理" class="headerlink" title="三、分支管理"></a>三、分支管理</h2><h3 id="1、分支关系、命令"><a href="#1、分支关系、命令" class="headerlink" title="1、分支关系、命令"></a>1、分支关系、命令</h3><h4 id="1、分支命令"><a href="#1、分支命令" class="headerlink" title="1、分支命令"></a>1、分支命令</h4><ul><li><p><code>git switch </code>：切换分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master   // 切换到已有的master分支</span><br><span class="line">$ git switch -c dev  //创建并切换到新的`dev`分支</span><br></pre></td></tr></table></figure></li><li><p><code>git checkout</code>：切换分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- file.txt    撤销工作区的修改</span><br><span class="line">git checkout master   // 切换到已有的master分支</span><br><span class="line">git checkout -b dev  //创建并切换到新的`dev`分支</span><br></pre></td></tr></table></figure></li><li><p><code>git merge </code>：合并某分支到当前分支</p></li><li><p><code>git branch -d </code>：删除分支</p></li><li><p><code>git branch</code>：查看分支</p></li></ul><h4 id="2、分支关系"><a href="#2、分支关系" class="headerlink" title="2、分支关系"></a>2、分支关系</h4><ol><li><p><strong>主分支：</strong></p><p>在Git里，每次提交它们会串成一条时间线主分支，即<code>master</code>分支，<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，**<code>master</code>才是指向提交的**</p><img src="https://www.liaoxuefeng.com/files/attachments/919022325462368/0" alt="git-br-initial" style="zoom:67%;" /></li><li><p><strong>新建分支：</strong></p><p>当前分支在<code>dev</code>上：指的是，新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code></p><img src="https://www.liaoxuefeng.com/files/attachments/919022363210080/l" alt="git-br-create" style="zoom: 67%;" /></li><li><p><strong>提交分支</strong>：</p><p>新分支提交后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><img src="https://www.liaoxuefeng.com/files/attachments/919022387118368/l" alt="git-br-dev-fd" style="zoom:50%;" /></li><li><p><strong>合并分支：</strong></p><p>把<code>dev</code>合并到<code>master</code>上。最简单的方法，直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge" style="zoom:50%;" /></li><li><p><strong>删除分支：</strong></p><p>合并完分支后，删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，就剩下了一条<code>master</code>分支：</p><img src="https://www.liaoxuefeng.com/files/attachments/919022479428512/0" alt="git-br-rm" style="zoom:50%;" /></li></ol><h3 id="2、分支合并模式"><a href="#2、分支合并模式" class="headerlink" title="2、分支合并模式"></a>2、分支合并模式</h3><p>分支合并有两种方式，“快速合并”模式、no-diff模式</p><h4 id="1、Fast-forward模式"><a href="#1、Fast-forward模式" class="headerlink" title="1、Fast forward模式"></a>1、<code>Fast forward</code>模式</h4><ul><li><p>新建了dev 的分支，并在其上进行一系列提交，完成时，回到 master 分支，此时，master 分支在创建 dev 分支之后并未产生任何新的 commit。此时的合并就会直接移动文件指针，就叫 <code>fast forward</code></p></li><li><p>这种模式下，删除分支后，会丢掉分支信息，看不出来曾经做过合并</p></li></ul><h4 id="2、-no-ff-方式"><a href="#2、-no-ff-方式" class="headerlink" title="2、--no-ff 方式"></a>2、<code>--no-ff</code> 方式</h4><ul><li><p>指的是：强制禁用 <code>Fast forward</code> 模式（<code>--no-ff</code> 方式）的 <code>git merge</code></p></li><li><p>Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息</p></li><li><p>操作流程：</p><ol><li>修改 <code>readme.md</code> 文件，并提交一个新的 commit：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -am &quot;update readme&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>切换回 master，合并 dev 分支，请注意 <code>--no-ff</code> 参数，表示禁用 <code>Fast forward</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README.md                                          |   4 +-</span><br><span class="line"> ...5\217\344\275\234\346\226\207\346\241\243.docx&quot; | Bin 278553 -&gt; 279350 bytes</span><br><span class="line"> ...234\200\345\212\240\345\210\206\357\274\237.md&quot; |  62 +++++++++++++++++++++</span><br><span class="line"> 3 files changed, 65 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 &quot;\346\225\260\346\215\256\345\210\206\346\236\220\351\235\242\350\257\225-\344\270\273\350\247\202\351\242\230/\345\275\223\351\235\242\350\257\225\345\256\230\350\257\264\357\274\214\342\200\234\344\275\240\346\234\211\344\273\200\344\271\210\350\246\201\351\227\256\346\210\221\357\274\237\342\200\235\346\200\216\346\240\267\345\233\236\347\255\224\346\234\200\345\212\240\345\210\206\357\274\237.md&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>合并后，用 <code>git log</code> 看分支历史：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   1d78e1a merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 237907d update readme</span><br><span class="line">| * 75a4fbc update 主观题</span><br><span class="line">| * 9669636 update 协作文档</span><br><span class="line">|/</span><br><span class="line">* b1aa3ed update 协作文档</span><br><span class="line">* 5c7018e update readme</span><br><span class="line">* 85c15e2 update readme</span><br><span class="line">* a803ecf update readme</span><br><span class="line">* bb3adfb update 协作文档</span><br><span class="line">*   acf2104 Merge pull request #1 from dta0502/add-license-1</span><br><span class="line">|\</span><br><span class="line">| * 4330188 Create LICENSE</span><br><span class="line">|/</span><br><span class="line">* f05e852 Initial commit</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="3、两种合并模式对比"><a href="#3、两种合并模式对比" class="headerlink" title="3、两种合并模式对比"></a>3、两种合并模式对比</h4><ul><li><p>合并模式对比图</p><img src="https://tding.top/archives/37b26b3a/1.png" alt="图1" style="zoom:50%;" /></li><li><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode" style="zoom:50%;" /></li></ul><h3 id="3、bug分支"><a href="#3、bug分支" class="headerlink" title="3、bug分支"></a>3、bug分支</h3><h4 id="1、git-stash"><a href="#1、git-stash" class="headerlink" title="1、git stash"></a>1、git stash</h4><h5 id="1、使用场景："><a href="#1、使用场景：" class="headerlink" title="1、使用场景："></a>1、使用场景：</h5><p>正在开发<strong>dev分支</strong>，需要紧急修复bug，需要新建分支，但dev分支上的开发内容仍在工作区，还未完成开发，且未提交</p><ul><li><strong>做法1：</strong>将dev提交到版本库，再新建分支修复bug。但是手头提交的东西别人拉下了可能会造成项目无法启动，因为我当前还没开发完，可能项目都跑不起来</li><li><strong>做法2：</strong>git stash</li></ul><h5 id="2、-git-stash操作流程："><a href="#2、-git-stash操作流程：" class="headerlink" title="2、 git stash操作流程："></a>2、<code> git stash</code>操作流程：</h5><ol><li><p><code>git stash</code> ：把当前工作现场“储藏”起来，等以后恢复现场后继续工作；此时，git status查看工作区，就是干净的（除非有没有被Git管理的文件），放心创建分支来修复bug</p><ul><li>首先用<code>git status</code>看看，有没有add的，也就是新文件</li><li>有执行：<code>git stash -a</code> ,其中-a代表所有（追踪的&amp;未追踪的），没有执行：<code> git stash</code></li><li>总之:都可以执行<code>git stash -a </code></li></ul></li><li><p>新建修复bug分支，然后提交</p></li><li><p>回dev分支继续干活，工作区是干净的，刚才的工作现场怎么找回呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">$ git status</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></li><li><p><code>git stash list</code>查看之前保存的工作现场</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list  </span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure></li></ol><h5 id="3、恢复方式："><a href="#3、恢复方式：" class="headerlink" title="3、恢复方式："></a>3、恢复方式：</h5><ul><li><p>方式1：<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure><ul><li>可以多次stash，恢复时，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式2：<code>git stash pop</code>，恢复的同时把stash内容也删了，用<code>git stash list</code>就看不到任何stash内容了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、bug修复同步"><a href="#2、bug修复同步" class="headerlink" title="2、bug修复同步"></a>2、bug修复同步</h4><h5 id="1、bug修复的问题"><a href="#1、bug修复的问题" class="headerlink" title="1、bug修复的问题"></a>1、bug修复的问题</h5><p>【问题】：dev分支是早期从master分支分出来的，在master分支上修复了bug后，这个bug其实<strong>在当前dev分支上也存在</strong>，怎么办？</p><ol><li><p>做法1：在dev分支上手动再把修bug的过程重复一遍   不现实</p></li><li><p>做法2：</p><ul><li>将bug的修复提交<code>4c805e2 fix bug 101</code>复制在dev分支上，但我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2   //能复制一个特定的提交到当前分支</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><ul><li>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但是两个不同的commit</li><li>同样，可以在dev分支上修复bug，然后在master分支上“重放”，不过记得<code>git stash</code>命令保存现场，才能从dev分支切换到master分支</li></ul></li></ol><h5 id="2、feature分支"><a href="#2、feature分支" class="headerlink" title="2、feature分支"></a>2、feature分支</h5><ol><li>开发一个新feature，新建一个分支；</li><li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D </code>强行删除</li><li>如果删除，将丢失掉修改</li></ol><h3 id="4、-协作开发"><a href="#4、-协作开发" class="headerlink" title="4、 协作开发"></a>4、 协作开发</h3><h4 id="1、远程、本地仓库："><a href="#1、远程、本地仓库：" class="headerlink" title="1、远程、本地仓库："></a>1、远程、本地仓库：</h4><ol><li>远程仓库克隆时，Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了</li><li>程仓库的默认名称是<code>origin</code>。用<code>git remote</code>查看远程库的信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote origin</span><br></pre></td></tr></table></figure><ol start="3"><li>用<code>git remote -v</code>显示更详细的信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br><span class="line">// 显示了可以抓取和推送的`origin`的地址。如果没有推送权限，就看不到push的地址</span><br></pre></td></tr></table></figure><h4 id="2、推送分支"><a href="#2、推送分支" class="headerlink" title="2、推送分支"></a>2、推送分支</h4><ol><li>把该分支上的所有本地提交推送到远程库，推送时，要指定本地分支</li><li>这样，Git就会把该分支推送到远程库对应的远程分支上</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li><p><strong>不是所有分支必须提交到远程：</strong></p><ul><li><p>bug分支只用于在本地修复bug，就没必要推到远程了</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发</p></li></ul></li></ul><h4 id="3、拉取分支"><a href="#3、拉取分支" class="headerlink" title="3、拉取分支"></a>3、拉取分支</h4><ol><li><p>假如要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></li><li><p>小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而你也对同样的文件作了修改，并推送：就会有分支冲突产生：</p><ol><li><p>先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来</p><p>假如：<code>git pull</code>提示<code>no tracking information</code>，则说明本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接关系没有创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line"></span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure></li><li><p>重新<strong>再pull：</strong>然后，在本地合并，解决冲突</p></li><li><p>再推送</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="5、git-rebase"><a href="#5、git-rebase" class="headerlink" title="5、git rebase"></a>5、git rebase</h3><h4 id="1、分支合并merge问题"><a href="#1、分支合并merge问题" class="headerlink" title="1、分支合并merge问题"></a>1、分支合并merge问题</h4><ul><li><p>假如你有6个程序员一起工作，你就会有6个程序员的分支，使用merge, 你的代码历史树就会有六个branch跟这个主的branch交织在一起</p><ol><li><p>多人在同一个分支上协作时，很容易出现冲突</p></li><li><p>即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功</p></li><li><p>每次合并再push后，分支变成了这样：Git的提交历史不能是一条干净的直线</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure></li></ol></li><li><p>rebase可以给你提供一套清晰的代码历史</p></li></ul><h4 id="2、git-rebase做法"><a href="#2、git-rebase做法" class="headerlink" title="2、git rebase做法"></a>2、<code>git rebase</code>做法</h4><ul><li>如果你不希望看到这么乱的提交线，<code>git rebase</code>，它把分叉的提交历史“整理”成一条直线，看上去更直观</li><li><strong>缺点：</strong>本地的分叉提交已经被修改过了</li></ul><ol><li><p>新建分支B1、B2、B3，并基于此开发。开发途中，master更新了，B1需要基于新Master开发功能，此时拉取远程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin B1 --rebase</span><br><span class="line">From gitlab.xpaas.lenovo.com:baiyl3/project1</span><br><span class="line"> * branch            B1         -&gt; FETCH_HEAD</span><br><span class="line">Already up-to-date.</span><br><span class="line">Current branch B1 is up to date.</span><br></pre></td></tr></table></figure></li><li><p>将master上面的代码合并到B1分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: FILE1 第一次修改</span><br></pre></td></tr></table></figure></li><li><p>开发完毕之后，推送到远程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin B1 --force</span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-2aaa4467856de84f746592f43e17944f_1440w.jpg" alt="img" style="zoom:50%;" /></li></ol><h4 id="3、解释过程"><a href="#3、解释过程" class="headerlink" title="3、解释过程"></a>3、解释过程</h4><ol><li>更新代码使用的是 <code>git pull origin B1 --rebase</code> 而不是 <code>git pull origin B1</code><ul><li><code>git pull</code>默认使用了 <code>--merge</code> 的方式更新代码</li><li>如果不指定用 <code>--rebase</code>，就会发现日志里有这样的一次提交 <code>Merge branch &#39;dev&#39; of gitlab.xpaas.lenovo.com:liuyy23/lenovo-mbg into dev</code> ，自己分支合并到了自己分支，没有必要，时间轴上也不好看</li></ul></li><li>使用 rebase 之后，直接使用 <code>git push origin B1</code> 发现是不好使的<ul><li> rebase 之后，master分支上比B1分支上多的修改，直接“插入”到了B1分支修改的内容之后，也就是， master 分支的修改在 B1 分支上重演了一遍</li><li> 相对远程 B1 分支而言，本地仓库的B1分支的“基底”已经变化了，直接 <code>push</code> 是不行的，确保没有问题的情况下必须使用 <code>--force</code> 参数才能提交，也是变基的解释</li></ul></li></ol><h4 id="4、git-merge过程"><a href="#4、git-merge过程" class="headerlink" title="4、git merge过程"></a>4、git merge过程</h4><ol><li><p>新建分支B1、B2、B3，并基于此开发。开发途中，master更新了，B1需要基于新Master开发功能，此时拉取远程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin B1</span><br><span class="line">From gitlab.xpaas.lenovo.com:baiyl3/project2</span><br><span class="line"> * branch            B1         -&gt; FETCH_HEAD</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure></li><li><p>将master上面的代码合并到B1分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge master</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README.md | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure></li><li><p>开发完毕之后，推送到远程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin B1</span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-9f5e6526d5621ee39a45b93554bc6fe3_1440w.jpg" alt="img" style="zoom: 33%;" /></li></ol><h4 id="5、对比提交线"><a href="#5、对比提交线" class="headerlink" title="5、对比提交线"></a>5、对比提交线</h4><h5 id="1、图形"><a href="#1、图形" class="headerlink" title="1、图形"></a>1、图形</h5><p>假如现在B1开发完成，合入到了master，整个提交线</p><ul><li><p>只提交B1，左边是git rebase，右边是git merge</p><p><img src="https://pic2.zhimg.com/80/v2-715f4b3b38f8d10c8b30403db5ae8211_1440w.jpg" alt="img" style="zoom:33%;" /><img src="https://pic1.zhimg.com/80/v2-11ccc0b77b3b6e2e93664e562ab27e84_1440w.jpg" alt="img" style="zoom:33%;" /></p></li><li><p>提交了B1、B2、B3，左边是git rebase，右边是git merge<br><img src="https://pic2.zhimg.com/80/v2-bc38eefe1fc068ddc4119ebc7d16eded_1440w.jpg" alt="img" style="zoom:33%;" /><img src="https://pic3.zhimg.com/80/v2-6df13493237417eda788e4031e894186_1440w.jpg" alt="img" style="zoom:33%;" /></p></li></ul><h5 id="2、git-log"><a href="#2、git-log" class="headerlink" title="2、git log"></a>2、git log</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git logs --graph</span><br><span class="line">* 5826260&lt;baiyl3&gt; - (HEAD -&gt; master, origin/master, origin/B3, B3) FILE3 第一次修改 (6 minutes ago)| </span><br><span class="line">| file3</span><br><span class="line"></span><br><span class="line">* cffcc9a&lt;baiyl3&gt; - (origin/B2, B2) FILE2 第一次修改 (8 minutes ago)| </span><br><span class="line">| file2</span><br><span class="line"></span><br><span class="line">* 00032a7&lt;baiyl3&gt; - (origin/B1, B1) FILE1 第一次修改 (87 minutes ago)| </span><br><span class="line">| file1</span><br><span class="line"></span><br><span class="line">* c782e83&lt;baiyl3&gt; - 添加README.md文件 (2 hours ago)| </span><br><span class="line">| README.md</span><br><span class="line"></span><br><span class="line">* b783e0a&lt;baiyl3&gt; - 在项目一中初始化三个代码文件 (3 hours ago)  </span><br><span class="line">  file1</span><br><span class="line">  file2</span><br><span class="line">  file3</span><br><span class="line">git logs --graph</span><br><span class="line">*   bc3f385&lt;baiyl3&gt; - (HEAD -&gt; master, origin/master, origin/B3, B3) Merge branch &#x27;master&#x27; into B3 (4 minutes ago)</span><br><span class="line">|\  </span><br><span class="line">| *   64b4f3d&lt;baiyl3&gt; - (origin/B2, B2) Merge branch &#x27;master&#x27; into B2 (5 minutes ago)</span><br><span class="line">| |\  </span><br><span class="line">| | *   e040c7b&lt;baiyl3&gt; - (origin/B1, B1) Merge branch &#x27;master&#x27; into B1 (35 minutes ago)</span><br><span class="line">| | |\  </span><br><span class="line">| | | * 2cedfcb&lt;baiyl3&gt; - 添加README.md文件 (2 hours ago)| | | | </span><br><span class="line">| | | | README.md</span><br><span class="line"></span><br><span class="line">| | * | d3ea69c&lt;baiyl3&gt; - FILE1 第一次修改 (2 hours ago)</span><br><span class="line">| | |/  | | |   </span><br><span class="line">| | |   file1</span><br><span class="line"></span><br><span class="line">| * | 5975eae&lt;baiyl3&gt; - FILE2 第一次修改 (2 hours ago)</span><br><span class="line">| |/  | |   </span><br><span class="line">| |   file2</span><br><span class="line"></span><br><span class="line">* | 37ec6de&lt;baiyl3&gt; - FILE3 第一次修改 (2 hours ago)</span><br><span class="line">|/  |   </span><br><span class="line">|   file3</span><br><span class="line"></span><br><span class="line">* 891d1ed&lt;baiyl3&gt; - 在项目二中初始化三个代码文件 (3 hours ago)  </span><br><span class="line">  file1</span><br><span class="line">  file2</span><br><span class="line">  file3</span><br></pre></td></tr></table></figure><h2 id="四、命令补充"><a href="#四、命令补充" class="headerlink" title="四、命令补充"></a>四、命令补充</h2><h3 id="1、git-commit-–amend"><a href="#1、git-commit-–amend" class="headerlink" title="1、git commit –amend"></a>1、git commit –amend</h3><h4 id="1、两个作用："><a href="#1、两个作用：" class="headerlink" title="1、两个作用："></a>1、两个作用：</h4><ol><li><p>追加提交</p><p>它可以在不增加一个新的commit记录的情况下将新修改的代码追加到前一次的commit中，但commit-id会改变</p></li><li><p>覆盖上次提交的信息</p><p>也会生成一个新的commit-id</p></li></ol><h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><ol><li><p>代码提交至远程，突然发现还有几个文件没有提交，但又不想产生多余的commit</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>这时会弹出一个上一次提交的时候你写的提交信息，保存这个信息，：wq</p></li><li><p>把远端代码拉下来，git pull， 如果有冲突</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> git reset --merge</span><br><span class="line"> git add .</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure></li><li><p>推送到远程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin 你的feature名</span><br></pre></td></tr></table></figure></li></ol><h4 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h4><ul><li>GitHub目前不支持git commit –amend去追加修改而保持不增加提交记录</li><li>GitHub目前你的每次提交都会生成一个新的提交记录，即使你使用的是git commit –amend，不过gitlab都支持的</li></ul><h3 id="2、git-pull-git-fetch"><a href="#2、git-pull-git-fetch" class="headerlink" title="2、git pull / git fetch"></a>2、git pull / git fetch</h3><ul><li>待补充</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基本-0</title>
      <link href="/2021/12/11/webpack%E5%9F%BA%E6%9C%AC-0/"/>
      <url>/2021/12/11/webpack%E5%9F%BA%E6%9C%AC-0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP &amp;&amp; UDP传输</title>
      <link href="/2021/12/11/TCP-UDP/"/>
      <url>/2021/12/11/TCP-UDP/</url>
      
        <content type="html"><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="1、传输层概述"><a href="#1、传输层概述" class="headerlink" title="1、传输层概述"></a>1、传输层概述</h3><ul><li><p>物理层、数据链路层以及网络层之间他们共同解决了将主机通过异构网络互连起来所面临的问题，<strong>实现了主机到主机之间的通信</strong></p></li><li><p>实际上在计算机网络中进行通信的真正实体是位于通信两端的主机中的进程</p></li><li><p><strong>传输层：</strong>为运行在不同主机上的应用进程提供直接的通信服务，又被称为端到端协议</p><img src="https://img-blog.csdnimg.cn/20210204214054815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="运输层简单传输过程" style="zoom: 25%;" /></li><li><p><strong>逻辑通信的概念：</strong></p><p>指运输层之间的通信使人感觉是沿水平方向传送数据；</p><p>但事实上，这数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送</p><ul><li><p>举例：假设进程Ap1与Ap4之间进行基于网络的通信，通信的简单过程如下：</p><ol><li>根据不同的进程，在运输层选择使用不同的端口</li><li>通过网络层及其下层来传输应用层报文</li><li>将收到的应用层报文到达接收方的运输层后，通过不同的端口，交付给应用层中相应的应用进程</li></ol><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来<strong>区分不同应用进程的标识符</strong></p><img src="https://img-blog.csdnimg.cn/20210204214642914.png" alt="运输层屏蔽下面核心细节" style="zoom:50%;" /></li></ul></li></ul><h3 id="2、端口号、复用和分用"><a href="#2、端口号、复用和分用" class="headerlink" title="2、端口号、复用和分用"></a>2、端口号、复用和分用</h3><h4 id="1、端口号"><a href="#1、端口号" class="headerlink" title="1、端口号"></a>1、端口号</h4><ul><li>为什么要用到端口号：<ol><li>在操作系统中 ，运行在计算机上的进程使用进程标识符PID来标志，但是因特网上的计算机并不是使用统一的操作系统，不同的操作系统使用不同格式的进程标识符。</li><li><strong>为了使运行不同系统的计算机的应用进程之间能够进行网络通信</strong>，就必须使用统一的方法来对TCP/IP体系的应用进程进行标识。也就是使用端口号</li><li>TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程：<img src="https://img-blog.csdnimg.cn/20210204215346994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="端口号的知识" style="zoom: 33%;" /></li></ol></li></ul><h4 id="2、发送方的复用和接收方的分用"><a href="#2、发送方的复用和接收方的分用" class="headerlink" title="2、发送方的复用和接收方的分用"></a>2、发送方的复用和接收方的分用</h4><ul><li><p>复用可以理解为<strong>多个进程重复使用一个协议进行应用报文的封装</strong></p></li><li><p>分用可以理解为<strong>一个封装好的应用报文根据某协议进行解析成不同的进程应用报文</strong></p><img src="https://img-blog.csdnimg.cn/20210204221120338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="发送方复用和接收方分用" style="zoom: 33%;" /></li><li><p><strong>发送方复用：</strong></p><p>在发送方中，多个进程通过端口利用一个运输层协议将数据封装成报文后发送，这就称为发送方复用</p><ul><li>不同协议就叫不同协议复用，如图中的UDP复用</li><li>在IP复用中也会<strong>根据协议字段的不同将其使用不同协议再次进行封装</strong></li></ul></li><li><p><strong>接收方复用：</strong></p><ul><li>在接收方中，利用一个协议，将用报文解析成不同数据，将数据根据端口发送不同进程，这就称为接收方分用</li><li>在IP分用中也会根据协议字段的不同将其使用不同协议进行解析</li></ul></li><li><p>TCP/IP体系的应用层常用协议的运输层熟知端口号：</p><img src="https://img-blog.csdnimg.cn/20210204221501845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="运用层熟知端口号" style="zoom:33%;" /></li></ul><h4 id="对一个域名访问中的运输层传输流程进行解读："><a href="#对一个域名访问中的运输层传输流程进行解读：" class="headerlink" title="对一个域名访问中的运输层传输流程进行解读："></a>对<strong>一个域名访问中的运输层传输流程进行解读：</strong></h4><img src="https://img-blog.csdnimg.cn/20210204221831138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="运输层传输中的主要路由器" style="zoom:50%;" /><ul><li><p>首先先认识在一次运输层传输中的主要路由器：</p><ol><li>DNS服务器：记录有某域名所对应的IP地址，在输入网页域名后，在hosts中找不到网页对应的IP地址时，就要通过DNS服务器获取域名对应的IP地址</li><li>Web服务器:某域名的服务器，也就是前面几章所说的目的主机，在访问域名时IP数据报最终即使到达Web服务器，服务器进行响应</li></ol></li><li><p>在浏览器中输入某域名，点击回车键开始访问：</p><ol><li><p>若此时在本地hosts缓存中有该域名的IP地址，直接发送带有目的地址的IP数据报</p></li><li><p>若计算机中没有该域名对应的IP地址，进行以下操作：</p><ol><li><p>构建DNS请求报文：</p><img src="https://img-blog.csdnimg.cn/2021020422245862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="构建DNS请求报文" style="zoom:33%;" /></li><li><p>然后在空闲的短暂端口中随机选择一个端口来表表示本进程：</p><p>DNS协议请求是熟悉端口之一，根据常见端口熟悉协议可查到，DNS协议的端口为53</p></li><li><p>将该UDP请求数据报通过以太网发送给DNS服务器</p></li><li><p>DNS服务器接收到请求数据报文后，从中解封出UDP用户数据报：</p><p>从数据报的目的端口知道,其目的端口为53后，服务器会将数据载荷部分（DNS请求报文）交给53端口对应的进程进行处理，此例中也就是DNS服务器端进程</p></li><li><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按照其要求查找对应的IP地址。查找到后会发送DNS响应报文：</p></li><li><p>该响应报文使用运输层的UDP协议封装成UDP报文。然后将其源端口设置成发送来的端口，目的端口设置为发送来的源端口</p><img src="https://img-blog.csdnimg.cn/20210204223342657.png" alt="DNS响应报文" style="zoom:50%;" /></li><li><p>接收方将UDP用户响应数据报封装在IP数据报中发送给发送方</p></li><li><p>用户在获得响应报文后，从中解封出用户数据报。根据用户数据报的目的端口，可以知道其传输给DNS进程</p></li><li><p>此时会将数据载荷，也就是DNS响应报文交给DNS进程进行处理，DNS进程将其响应报文进行解析，就可知道自己之前所请求的Web服务器的域名，此时就可以开始进行<strong>访问域名</strong></p></li></ol></li><li><p>知道域名对应的IP地址后，可以开始构建HTTP请求，并发送该请求</p><img src="https://img-blog.csdnimg.cn/20210204224440923.png" alt="构建TCP请求报文" style="zoom: 50%;" /><ul><li>HTTP请求报文的构建需要TCP协议构建TCP首部，在首部中选择一个空闲的短暂端口作为源端口，此时该端口代表TCP应用进程。目的端口选择80，这是HTTP协议所占的常用端口。</li><li>将TCP报文段封装在IP数据报中，并进行发送</li><li>HTTP请求报文通过以太网传输到对应Web服务器中，在接收到报文后会对其进行解析，在知道其端口为80后，会将数据载荷部分传输给本服务器中的<strong>HTTP服务器端进程进</strong>行解析。</li></ul></li><li><p>解析到内容后按照其要求查找首页内容。查找到后会给给用户PC发送HTTP响应报文。此时构建的源端口和目的端口刚好和发送的端口含义相反，原因与上面查询DNS服务过程相同</p><img src="https://img-blog.csdnimg.cn/20210204225235116.png" alt="构建HTTP响应报文" style="zoom:50%;" /><ul><li><p>Web服务器发送响应报文回用户PC</p><p>用户PC接收到报文后进行解封，解封后发现目的端口是49152，也就是用户PC内的HTTP进程。因此将数据载荷（HTTP报文）传输给HTTP进程进行处理</p></li><li><p>HTTP进程解析到其内同后，在网页浏览器中进行展示</p></li></ul></li><li><p>至此，一次网页请求结束</p></li></ol></li></ul><h3 id="3、TCP、UDP协议"><a href="#3、TCP、UDP协议" class="headerlink" title="3、TCP、UDP协议"></a>3、TCP、UDP协议</h3><h4 id="1、概念上"><a href="#1、概念上" class="headerlink" title="1、概念上"></a>1、概念上</h4><ul><li>UDP（User Datagram Protocol）：用户数据报协议，向上层提供<strong>无连接、不可靠</strong>服务</li><li>TCP（Transmission Control Protocol）：传输控制协议，向上层提供<strong>面向连接、基于字节流</strong>的可靠服务<ul><li>流就是指不间断的数据结构，可以把它想象成排水管中的水流</li></ul></li></ul><h4 id="2、在连接方式上"><a href="#2、在连接方式上" class="headerlink" title="2、在连接方式上"></a>2、在连接方式上</h4><ul><li><p>UDP是无连接的通信方式；</p><ul><li>UDP 想发数据就可以开始发送了，不需要连接，它只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</li><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识为UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul></li><li><p>TCP是通过著名的<strong>“三次握手”建立连接，“四次挥手”释放连接</strong></p><img src="https://img-blog.csdnimg.cn/20210205101524393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="连接方式" style="zoom: 33%;" /></li></ul><h4 id="3、在传播方式上："><a href="#3、在传播方式上：" class="headerlink" title="3、在传播方式上："></a>3、在传播方式上：</h4><ul><li><p>UDP由于不建立连接，支持单播、多播和广播；</p></li><li><p>TCP由于每次通信需要建立基于TCP连接的可靠信道，且每次只能建立一条连接，因此只支持单播</p><img src="https://img-blog.csdnimg.cn/20210205101823359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="传播方式上的区别" style="zoom: 50%;" /></li></ul><h4 id="4、在报文传输处理上："><a href="#4、在报文传输处理上：" class="headerlink" title="4、在报文传输处理上："></a>4、在报文传输处理上：</h4><img src="https://img-blog.csdnimg.cn/20210205102109359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="报文传输处理上" style="zoom: 33%;" /><ul><li><strong>UDP协议，面向报文。</strong><ol><li>UDP发送方：对应用层传下来的<strong>报文不进行处理，保留报文的边界</strong>。在给报文<strong>加上UDP首部就发送</strong>。</li><li>UDP接收方：首部接收到UDP数据后，去除其首部，交付给应用层</li><li>因此，应用程序必须选择合适大小的报文</li><li>可以看出，<strong>UDP是针对报文为单位进行处理的，也就是UDP是面向应用报文的</strong></li></ol></li></ul><ol start="5"><li>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</li></ol><ul><li><p><strong>TCP协议，面向字节流的。</strong></p><p>发送方：</p><ol><li>TCP协议会把应用进程交付下来的数据块（报文）看作是<strong>一连串无结构的字节流</strong>（TCP并不知道这些子节含义），将他们<strong>编号</strong>，并存储在自己的<strong>发送缓存</strong>中</li><li>TCP再根据发送策略，<strong>提取一定量的字节</strong>，加上TCP首部，构建成TCP报文进行发送</li></ol><p>接收方：</p><ol><li>从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中</li><li>同时将接收缓存中的一些字节交付给应用进程。</li></ol><p>【注意】：</p><ol><li><p>TCP协议保证接收方收到的字节流和发送方应用进程发出的字节流完全一样；</p></li><li><p>TCP<strong>不保证</strong>接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系：</p><p>例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但不会全部将数据交付给上层。</p><p>因此<strong>接收方的TCP应用进程必须有能力识别收到的字节流</strong>，把它还原成有意义的应用层数据</p></li></ol><p>可以看出，TCP对报文的处理是以子节为单位的，也就是TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p></li></ul><h4 id="5、在给上层提供的服务上："><a href="#5、在给上层提供的服务上：" class="headerlink" title="5、在给上层提供的服务上："></a>5、在给上层提供的服务上：</h4><img src="https://img-blog.csdnimg.cn/20210205103545602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" /><ul><li><p>UDP提供的是不可靠服务：</p><ol><li><p>不可靠性首先体现在无连接上，通信不需要建立连接，想发就发，这样的情况肯定不可靠</p></li><li><p>对于发送的UDP数据报，接收方在检测到其误码后直接丢弃，不做其他操作</p><p>对于发送方发送过程中出现分组丢失，也不做处理。因此其传输数据是不一定能使接收方全部收到数据，因此是不可靠服务。</p></li><li><p>网络环境时好时坏，但 UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整</p></li><li><p>这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景 ( 比如电话会议 ) 就需要使用 UDP 而不是 TCP</p></li></ol></li><li><p>TCP提供的是可靠服务：</p><ol><li><p>TCP传输过程中需要建立连接，通过建立的可靠信道进行传输</p></li><li><p>TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收</p><p>判断误码、丢失、乱序、重复靠的是TCP的段编号以及确认号;</p><p>然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)，如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传</p></li><li><p>因此可以保证发送端发送什么，接收端接收到什么，是可靠传输</p></li></ol></li></ul><h4 id="6、协议首部对比"><a href="#6、协议首部对比" class="headerlink" title="6、协议首部对比"></a>6、协议首部对比</h4><img src="https://img-blog.csdnimg.cn/20210205104221506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="协议首部对比" style="zoom: 50%;" /><ul><li><p>由于UDP不提供可靠传输的服务，因此其首部只需要在<strong>网际层的基础上添加区分端口的子节</strong>，其头部包含了以下几个数据</p><ul><li>两个十六位的端口号，分别为发出端口和接收端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><p>所以UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时高效的</p></li><li><p>在TCP中，需要提供可靠传输、流量控制、拥塞控制等服务，首部比较复杂，字段比较多</p></li></ul><h3 id="4、TCP的流量控制"><a href="#4、TCP的流量控制" class="headerlink" title="4、TCP的流量控制"></a>4、TCP的流量控制</h3><h4 id="1、流量控制过程"><a href="#1、流量控制过程" class="headerlink" title="1、流量控制过程"></a>1、流量控制过程</h4><ul><li><p>流量控制：</p><p>数据传输中，希望传输的越快越好，但若传输过快会导致接收方不够时间接收数据，造成数据丢失。</p><p>流量控制就是为了让发送方速率不要太快，要让接收方来的及接收</p><p><strong>TCP 利用滑动窗口实现流量控制</strong></p><p><img src="https://img-blog.csdnimg.cn/20210205110201196.png" alt="A与B建立连接"></p></li><li><p>举例说明：</p><p><img src="https://img-blog.csdnimg.cn/20210205110243488.png" alt="400的数据窗口"></p><p>A与B建立连接,建立完后约定好一个数据传输窗口，例如400：此后，双方传输数据就会以此约束的窗口大小进行。</p><img src="https://img-blog.csdnimg.cn/20210205111208400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="流量控制发送第一步" style="zoom:50%;" /><ol><li><p>A主机根据窗口长度，向B主机分三次发送了300子节的数据，但是201-300子节数据报丢失，此时发送方还不知道丢失，只知道传输了300子节，还能传输100子节</p></li><li><p>此时接收方根据收到的数据进行累计确认，发送确认信号，第一次流量控制，此信号参数含义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACK = 1:这是一个TCP确认字段</span><br><span class="line">ack = 201 :201编号以前的数据全部确认收到</span><br><span class="line">rwnd = 300 : 将接收窗口大小调整为300</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210205111708336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="流量控制示例2" style="zoom:33%;" /></li><li><p>在A收到确认ACK报文后，根据报文内容，将窗口进行滑动，此时由于前200子节已确认，因此将其<strong>从缓存中删除</strong>。同时根据报文内容的窗口调整调整为300大小。继续发送数据，直到无法发送窗口已满</p><p>此时由于201-300分组丢失超过重传计数器设置时间，对开始重传201-300分组；</p><p>接收方在收到501号所有分组后，发送新的ACK确认报文，报文中将窗口设置为100大小（第二次流量控制）</p><img src="https://img-blog.csdnimg.cn/20210205112138766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="流量控制示例3" style="zoom:50%;" /></li><li><p>在接收方接收到ACK报文后，对前500字节数据在缓存中删除，并将窗口调整为100，然后调整滑动窗口位置，开始新的传输。</p></li></ol></li></ul><pre><code> 传输窗口数据后不再传输数据。等待ACK确认信号。 此时接收方接收到数据后再次发送ACK报文，将窗口大小设置为0。(第三次流量控制)5. 此时由于窗口为零，不再发送数据</code></pre><h4 id="2、死锁情况考虑"><a href="#2、死锁情况考虑" class="headerlink" title="2、死锁情况考虑"></a>2、死锁情况考虑</h4><ul><li><p>出现的场景：</p><p>在缓存不足，接收方窗口调整为0后，过了一段时间便有了新的空间，此时发送一个新的调整窗口报文，但是此时报文传输丢失！无法到达发送方；</p><p>此时就会出现发送方等待接收方有缓存空间，接收方等待发送方发送数据的死锁情况</p></li><li><p>为了解决这个问题，TCP为每一个连接设有一个<strong>持续计时器：</strong></p><img src="https://img-blog.csdnimg.cn/20210205112832621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="持续计时器" style="zoom:50%;" /><ol><li><p>在连接的一方接收到对方的零窗口通知后一段时间后，超时计时器到时，就会发送一个1子节的<strong>零窗口发送报文</strong>，在接收方接收到该信号后，就会通告自己的窗口大小</p></li><li><p>当知道窗口可以传输数据后，就会开始通信</p></li><li><p>如果<strong>零窗口探测报文</strong>在发送过程中如果丢失，还是能打破死锁局面：</p><p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p></li></ol></li></ul><p>【注意】：TCP中规定不论接收方有没有空间，都必须接收发送方的3种报文：<br><strong>零窗口检测报文段</strong>、确认报文段、携带有紧急数据的报文段</p><h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><ul><li>利用滑动窗口机制，可以很方便地在TCP连接上实现对发送方的流量控制：<ol><li>TCP接收方利用自己的<strong>接收窗口</strong>的大小来限制发送方<strong>发送窗口</strong>的大小；</li><li>TCP发送官方收到接收方的<strong>零窗口通知</strong>后，应启动<strong>持续计时器</strong>，持续计时器超时后，向接收方发送<strong>零窗口探测报文</strong>。</li></ol></li></ul><h3 id="5、TCP拥塞控制"><a href="#5、TCP拥塞控制" class="headerlink" title="5、TCP拥塞控制"></a>5、TCP拥塞控制</h3><ul><li><p>拥塞：</p><p>某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏；</p><p>而拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载；</p><p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降</p></li></ul><img src="https://img-blog.csdnimg.cn/20210205170452296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="拥塞情况" style="zoom:50%;" /><h4 id="0、拥塞算法的基本思路"><a href="#0、拥塞算法的基本思路" class="headerlink" title="0、拥塞算法的基本思路"></a>0、拥塞算法的基本思路</h4><p>以下算法的前提条件：</p><img src="https://img-blog.csdnimg.cn/20210205171237333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="拥塞算法假定条件" style="zoom: 33%;" /><ul><li><p>发送方维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值取决于网络的拥塞程度，并且动态变化</p></li><li><p><strong>拥塞窗口的维护原则：</strong>只要没有网络出现拥塞，拥塞窗口就再增大一些，只要网络出现拥塞，拥塞窗口就减少一些。</p></li><li><p><strong>判断网络拥塞的依据：</strong>没有按时收到应到达的确认报文（发生超时重传）</p></li><li><p>发送方将拥塞窗口作为<strong>发送窗口swnd</strong>，即：swnd = cwnd</p></li><li><p>维护一个<strong>慢开始门限ssthresh</strong>状态便变量，其维护原则为:</p><img src="https://img-blog.csdnimg.cn/20210205172001338.png" alt="在这里插入图片描述" style="zoom:50%;" /></li></ul><h4 id="1、拥塞控制算法1：慢开始"><a href="#1、拥塞控制算法1：慢开始" class="headerlink" title="1、拥塞控制算法1：慢开始"></a>1、拥塞控制算法1：慢开始</h4><ul><li><p>慢开始算法：用来确定网络的负载能力或拥塞程度，</p><ul><li>实现是由小到大逐渐增大（以倍数增长）拥塞窗口数值；慢开始指的是一开始网络注入的报文段少，并不是指拥塞窗口cwnd的增长速度慢</li></ul></li><li><p>过程举例：</p><ul><li>横坐标为传输轮次，即完整发送一个拥塞窗口数据并收到确认报文的时间（可理解为往返时间）</li><li>纵坐标为拥塞窗口，并且根据不同情况会设置一个慢开始门限</li></ul><p><img src="https://img-blog.csdnimg.cn/20210205172339397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="坐标系"></p><p>初始化：发送方将初始拥塞窗口设为1，并设置一个ssthresh（慢开始传送位），然后开始传送数据</p><p>进行第一轮数据通信：</p><ol><li><p>在收到确认报文后：不断地将拥塞窗口设置为原来的两倍</p><img src="https://img-blog.csdnimg.cn/20210205172719478.png" alt="将拥塞窗口设置新值" style="zoom: 50%;" /></li><li><p>第四次发送顺利进行，成功接收到确认报文后，将<strong>拥塞窗口增大到16.</strong><br><img src="https://img-blog.csdnimg.cn/20210205173731557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="坐标轴情况3"></p></li><li><p>此时，**拥塞窗口已达到慢开始门限SSTHRESH,**此时，慢开始算法阶段结束，开始拥塞避免算法</p></li></ol></li></ul><h4 id="2、拥塞控制算法2：拥塞避免"><a href="#2、拥塞控制算法2：拥塞避免" class="headerlink" title="2、拥塞控制算法2：拥塞避免"></a>2、拥塞控制算法2：拥塞避免</h4><ul><li><p>拥塞避免算法：</p><p>让拥塞窗口 cwnd 缓慢地增大（每伦窗口大小+1），避免出现拥塞；</p><p>在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点</p><p>拥塞避免算法并不能完全避免拥塞，只是在拥塞避免阶段将容易拥塞的窗口控制为按线性规律增长，使网络比较不易出现拥塞</p></li><li><p>接着上面的例子：</p><ol><li><p>进行第六轮传输：此时不再使用慢开始算法，采用拥塞避免算法，每个轮次只给拥塞窗口+1。</p><img src="https://img-blog.csdnimg.cn/20210205173921444.png" alt="第六轮传输" style="zoom: 50%;" /><p><img src="https://img-blog.csdnimg.cn/20210205174101695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="坐标轴情况5"></p></li><li><p>第七轮传输：传输成功后，给拥塞窗口+1.</p></li></ol></li></ul><h5 id="假如报文段丢失："><a href="#假如报文段丢失：" class="headerlink" title="假如报文段丢失："></a>假如报文段丢失：</h5><ul><li>循环重复此传输过程，若出现以下情况：</li></ul><img src="https://img-blog.csdnimg.cn/2021020517424021.png" alt="出现报文段丢失情况" style="zoom:50%;" /><ul><li><p>重传计时器超时后，判断网络很可能出现了拥塞，进行以下工作：</p><p>将ssthresh值更新为拥塞时cwnd值的一半<br>将cwnd值减少为1，重新开始执行慢开始算法</p></li></ul><h5 id="以上两个算法的完整示意图："><a href="#以上两个算法的完整示意图：" class="headerlink" title="以上两个算法的完整示意图："></a>以上两个算法的完整示意图：</h5><img src="https://img-blog.csdnimg.cn/20210205174838531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="两个算法的完整示意图" style="zoom:50%;" /><h5 id="新问题："><a href="#新问题：" class="headerlink" title="新问题："></a>新问题：</h5><p>因此提出了<strong>快重传算法和快恢复算法</strong></p><img src="https://img-blog.csdnimg.cn/20210205174947201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="错误设置窗口情况" style="zoom:50%;" /><h4 id="3、拥塞控制算法3：快重传"><a href="#3、拥塞控制算法3：快重传" class="headerlink" title="3、拥塞控制算法3：快重传"></a>3、拥塞控制算法3：快重传</h4><ul><li><p>快重传算法：</p><p>在出现分组错误后，发送方尽快重传数据，而不是等待超时计时器超时再重传。</p><p>三个原则：</p><ol><li>要求接收方不要等等自己发送数据时才进行捎带确认，而是要立即发送确认</li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</li><li>发送方一旦收到了3个连续的重复确认，就立即将相应的报文段立即重传，不用等到超时计时器超时后再重传</li></ol></li><li><p>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（这会使拥塞窗口设置为1），该算法可以使整个网络吞吐量提高约20％</p><img src="https://img-blog.csdnimg.cn/20210205175746820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="快重传算法" style="zoom:50%;" /></li><li><p>举例说明：</p><ol><li>在快重传算法中，发送方会在接收到确认分组前就发送下一个分组（前提是在拥塞窗口大小内）</li><li>对于丢失的分组，会在收到3个分组后发送3个重复确认丢失分组序号</li><li>接收方收到3个重复分组序号后便开始重传，而不是等待超时计时器到时，这样子也不会误以为出现了拥塞</li></ol></li></ul><h4 id="4、拥塞控制算法4：快恢复"><a href="#4、拥塞控制算法4：快恢复" class="headerlink" title="4、拥塞控制算法4：快恢复"></a>4、拥塞控制算法4：快恢复</h4><ul><li><p>快恢复算法：</p><ul><li>是发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，并开始执行拥塞避免算法</li><li>发送方在收到3个重复确认后，就知道现在只是丢失了个别的报文段。于是不开始启动慢开始算法，转而执行快恢复算法</li></ul></li><li><p>四个算法再传输过程中的使用顺序图：</p></li></ul><img src="https://img-blog.csdnimg.cn/2021020518062065.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="算法使用顺序图" style="zoom:50%;" /><pre><code>1. 一开始使用慢开始算法，拥塞窗口开始指数规律增大到设定的ssthres值后执行拥塞避免算法   2. 拥塞避免算法将拥塞窗口以1为单位线性增大，直到出现分组丢失   3. 重传计时器时间到后，cwnd设置为1，ssthresh值设置为发生拥塞的窗口值大小一半，并重新开始执行慢开始算法   4. 在发送方收到3个重复确认时及执行快重传和快恢复算法，将ssthresh的值更新为当前拥塞窗口值得一半，更新cwnd值为ssthresh值</code></pre><h3 id="6、TCP超时重传时间的选择"><a href="#6、TCP超时重传时间的选择" class="headerlink" title="6、TCP超时重传时间的选择"></a>6、TCP超时重传时间的选择</h3><p>TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p><ul><li><p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p></li><li><p>TCP超时重传时间的选择是TCP最复杂的问题之一：</p><ul><li>若RTTO超时重传时间过短会导致不必要的重传，使网络负荷增大。</li><li>RTO过长会导致网络的空闲时间增大，降低了传输效率</li><li>因此，<strong>RTTO的设置应该略大于RTT</strong></li></ul></li><li><p>新问题：RTTO的判定问题：</p><p>由于网络传输环境的不同，导致接下来的RTT是不确定的，不能直接用某次测量得到的RTT样本值来计算超时重传时间RTO。如此应该如何去认定RTO？</p><img src="https://img-blog.csdnimg.cn/20210205220126650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="RTT测量复杂" style="zoom:50%;" /></li><li><p>关于RTTs的计算：</p><img src="https://img-blog.csdnimg.cn/20210205215919856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="RTTs的计算" style="zoom: 67%;" /></li><li><p>计算超时重传时间RTO:</p><img src="https://img-blog.csdnimg.cn/20210205220003983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="RFC6298建议下的RTO计算" style="zoom:50%;" /></li></ul><p>针对以上问题，有以下解决方式：</p><img src="https://img-blog.csdnimg.cn/20210205220207182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="Karn解决算法" style="zoom:50%;" /><ul><li><p>一个计算RTO的例子：</p><img src="https://img-blog.csdnimg.cn/20210205220305521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="计算RTO例子" style="zoom:67%;" /></li></ul><h3 id="7、TCP可靠传输的实现"><a href="#7、TCP可靠传输的实现" class="headerlink" title="7、TCP可靠传输的实现"></a>7、TCP可靠传输的实现</h3><p>TCP基于以子节为单位的滑动窗口来实现可靠传输：</p><img src="https://img-blog.csdnimg.cn/20210205222040265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="TCP可靠传输的实现" style="zoom: 33%;" /><h4 id="1、发送方"><a href="#1、发送方" class="headerlink" title="1、发送方"></a>1、发送方</h4><ul><li><p>在要传递的字节流中，可以大致分为几个区域：</p><ol><li><strong>发送窗口后数据</strong>（图中的左边）：这些数据已经成功发送出去并且已经收到确认信号，因此这部分数据可以从缓存中删除</li><li><strong>发送窗口中数据</strong>（图中的蓝色部分）：这部分数据正处于发送窗口中，此时数据有两种情况，已发送正在等待确认或者未发送出去，对于已发送的数据要存在发送缓存中。</li><li><strong>发送窗口前数据</strong>（图中的右半部分）：这部分数据不允许发送</li></ol></li><li><p>根据发送的具体情况，<strong>发送窗口的后延移动</strong>情况有两种:</p><p>不动：没有收到新的确认信息。</p><p>前移：收到了新的确认信息。</p></li><li><p>根据发送的具体情况,前，<strong>发送窗口的前延移动</strong>情况有三种：</p><p><strong>不间断向前移动：</strong>收到了新的确认分组</p><p><strong>不动：</strong>没有收到新的确认分组并且对方的通知窗口信号大小不变；收到新的确认但对方通知的端口缩小个数等于后延移动的位数，使得发送窗口前沿正好不动。</p><p><strong>向后收缩：</strong>对方通知的窗口缩小了，但是这种情况容易造成错误，是TCP协议不愿看到的情况</p></li></ul><h4 id="2、如何描述发送窗口中数据的状态"><a href="#2、如何描述发送窗口中数据的状态" class="headerlink" title="2、如何描述发送窗口中数据的状态"></a>2、如何描述发送窗口中数据的状态</h4><p>由于发送窗口中的字节可能是已经发送的或者未发送的，就出现了一个问题，我们应该如何描述发送窗口中数据的状态？</p><ul><li><p>可以采用三个指针来定位不同状态区域</p><img src="https://img-blog.csdnimg.cn/20210205223228998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="描述发送窗口状态的方法" style="zoom: 33%;" /></li></ul><h4 id="3、接收方"><a href="#3、接收方" class="headerlink" title="3、接收方"></a>3、接收方</h4><img src="https://img-blog.csdnimg.cn/20210205223433830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="接收方字节状态" style="zoom:50%;" /><p>在接收方中也有跟发送方相同的字节序列情况：</p><p>​    其字节序列也可以分为三个部分，跟发送方一致，不过多赘述。</p><ol><li><p>若接收方收到未按序到达的数据，如本例收到32-33编号字节数据，<strong>由于TCP的确认方式是只能发送按序收到的最高序号确认</strong>，因此发送一个ack = 31的确认信号，也就是表示现在需要发送31号数据</p><img src="https://img-blog.csdnimg.cn/2021020522354113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="接受方收到未按序到达的数据" style="zoom: 33%;" /></li><li><p>发送方收到ack = 31报文后，知道31号数据未按序到达，但是根据上面所学的知识，只有<strong>第3次接收到同一个ack信号才会进行重传</strong>，此时<strong>不做处理，继续发送往下的数据</strong>。</p><img src="https://img-blog.csdnimg.cn/20210205224016267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="成功接收到31序号" style="zoom:50%;" /></li><li><p>此时若成功接收到31号数据，此时31-33号数据按序到达，此时接收方会<strong>择机将数据交给应用层，并且将窗口向后滑动3字节，同时发送确认报文</strong>。</p><img src="https://img-blog.csdnimg.cn/20210205224238102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="发送确认报文以及同时有数据来到" style="zoom: 33%;" /></li><li><p>在接收方发送的确认报文被发送方收到后，<strong>会将发送窗口向后滑动若干字节（此处为3字节）</strong>。<strong>发送方此时会将31.32.33字节数据从缓存中删除</strong>。</p><img src="https://img-blog.csdnimg.cn/20210205224631661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="发送方继续发送剩余的数据" style="zoom: 50%;" />此时若发送方**又发送了3个未按序到达的数据**。此时接收方接受数据后不做处理。<p>此时若迟迟等不到接收方确认信号，重传计时器超时，此时会重新发送发送窗口内已发送的数据，并重启重传计时器。</p></li></ol><ul><li>关于可靠传输实现的注意事项：</li></ul><img src="https://img-blog.csdnimg.cn/2021020522514810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="可靠传输实现的注意事项" style="zoom: 33%;" /><h3 id="8、TCP的3次握手、4次挥手"><a href="#8、TCP的3次握手、4次挥手" class="headerlink" title="8、TCP的3次握手、4次挥手"></a>8、TCP的3次握手、4次挥手</h3><ul><li><p>TCP是面向连接的协议，它基于运输连接来传送TCP报文段；运输连接管理就是使用运输连接的建立和释放都能正常的进行。<strong>连接建立</strong>有以下三个阶段：</p><ol><li>三次挥手建立连接</li><li>建立连接后进行数据传输</li><li>四次挥手释放TCP连接</li></ol></li><li><p>TCP的连接建立要解决以下3个问题：</p><p>1、使TCP双方都能确知对方的存在<br>2、使TCP双方能够协商一些参数（如窗口最大值、是否使用窗口扩大选项和时间戳选项和服务质量等等）<br>3、使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</p></li></ul><h4 id="1、3次握手"><a href="#1、3次握手" class="headerlink" title="1、3次握手"></a>1、3次握手</h4><blockquote><p>在三报文握手过程中，有<strong>两个角色</strong>，<strong>客户端</strong>发送握手连接请求，<strong>服务器</strong>等待接收请求。</p><p>在最开始：<strong>双方都是处于关闭状态，此时双方的TCP进程都是关闭的。</strong></p><p>此时，<strong>服务器在连接之前要进行准备</strong>：</p><p>1、服务器创建传输控制块，在块中有TCP连接表等一些TCP连接的重要信息。</p><p>2、<strong>创建后便开始监听</strong>，准备接收来自客户端的连接请求</p><p>【注意】：TCP服务器进程是被动等待来自TCP客户进程的连接请求。而不是主动发起，因此称为被动打开连接</p><p>与服务器类似，客户端进程也需要进行准备：其准备过程只有建立传输数据块。</p></blockquote><img src="https://img-blog.csdnimg.cn/20210205231822366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="客户端进程进行准备" style="zoom:33%;" /><h5 id="1、-第1次握手"><a href="#1、-第1次握手" class="headerlink" title="1、 第1次握手"></a>1、 第1次握手</h5><img src="https://img-blog.csdnimg.cn/202102052321410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第一次发送握手报文" style="zoom: 33%;" /><ul><li><p><strong>客户端</strong>向服务端发送连接请求报文段，并进入同步已发送( <code>SYN-SENT</code> 状态)</p></li><li><p>TCP连接请求报文段首部中，有两个关键数据：</p><ol><li>同步位SYN：被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq：被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ol><p>【注意】：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></li></ul><h5 id="2、-第2次握手"><a href="#2、-第2次握手" class="headerlink" title="2、 第2次握手"></a>2、 第2次握手</h5><img src="https://img-blog.csdnimg.cn/20210205232429727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="服务器收到信号后" style="zoom:33%;" /><ul><li><p><strong>TCP服务器进程</strong>收到客户端发送的TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP<strong>连接请求确认报文段</strong>，并进入<strong>同步已接受</strong>(  <code>SYN-RECEIVED</code> 状态)</p></li><li><p>连接请求确认报文段首部中有几个关键数据位：</p><ol><li>同步位SYN和确认为ACK：都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq：设置了一个初始值y，作为TCP服务器进程所选择的初始序号</li><li>确认号字段ack:值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ol></li></ul><p>  【注意】：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样消耗一个序号</p><h5 id="3、-第3次握手"><a href="#3、-第3次握手" class="headerlink" title="3、 第3次握手"></a>3、 第3次握手</h5><ul><li><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接（ <code>ESTABLISHED</code> 状态）</p></li><li><p>普通的TCP确认报文段首部中有以下重点数据位：</p><ol><li>确认位ACK:设置为1，由于没有SYN同步字段，表明这是一个普通的TCP确认报文段，表示已确认收到建立连接报文。</li><li>序号字段seq:设置为x+1，因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1（SYN字段报文需要消耗一个序号）</li><li>确认号字段ack：设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ol><p>值得注意的是：TCP规定普通的<strong>TCP确认报文段(只有ACK没有SYN)可以携带数据</strong>，但<strong>如果不携带数据，则不消耗序号</strong></p></li><li><p>三次握手完毕后，服务器也进入连接已建立状态，此时双方连接已建立，可以开始进行数据传输</p></li></ul><h4 id="2、3次握手的问题"><a href="#2、3次握手的问题" class="headerlink" title="2、3次握手的问题"></a>2、3次握手的问题</h4><h5 id="1、为什么是3次？"><a href="#1、为什么是3次？" class="headerlink" title="1、为什么是3次？"></a>1、为什么是3次？</h5><ul><li><h5 id="三次握手的目的：三次握手才能确认双方的接收与发送能力都正常"><a href="#三次握手的目的：三次握手才能确认双方的接收与发送能力都正常" class="headerlink" title="三次握手的目的：三次握手才能确认双方的接收与发送能力都正常"></a>三次握手的目的：三次握手才能确认双方的接收与发送能力都正常</h5></li><li><p>第一次：服务端确认自己的接收能力、客户端的发送能力</p><p>第2次：客户端确认自己的接收+发送能力、服务端的发送能力</p><p><strong>但此时服务器并不能确认客户端的接收能力是否正常</strong></p><p>第3次：客户端发包，服务端收到了，服务器就能确定</p></li></ul><h5 id="2、2次有什么问题？"><a href="#2、2次有什么问题？" class="headerlink" title="2、2次有什么问题？"></a>2、2次有什么问题？</h5><ul><li><h5 id="2次握手：不采用三次握手，只要服务端发出确认，就建立新的连接了"><a href="#2次握手：不采用三次握手，只要服务端发出确认，就建立新的连接了" class="headerlink" title="2次握手：不采用三次握手，只要服务端发出确认，就建立新的连接了"></a>2次握手：不采用三次握手，只要服务端发出确认，就建立新的连接了</h5></li><li><p><strong>防止出现失效的连接请求报文段被服务端接收的情况</strong>，从而产生错误</p><ul><li>假如客户端共发出了两个连接请求报文段，其中第一个在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，第二个到达了服务端；</li><li>此时服务端<strong>误认为客户端又发出一次新的连接请求</strong>，于是就向客户端发出确认报文段，同意建立连接</li><li>此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，<strong>浪费资源</strong></li></ul></li></ul><h5 id="3、什么是半连接队列？"><a href="#3、什么是半连接队列？" class="headerlink" title="3、什么是半连接队列？"></a>3、什么是半连接队列？</h5><ul><li><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，这种队列称为<strong>半连接队列</strong>。</p></li><li><p><strong>全连接队列</strong>：已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象</p></li><li><p><strong>SYN-ACK 重传次数</strong>：</p><p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，</p><p>等待一段时间仍未收到客户确认包，进行第二次重传。</p><p>如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s……</p></li></ul><h5 id="4、ISN是固定的吗？"><a href="#4、ISN是固定的吗？" class="headerlink" title="4、ISN是固定的吗？"></a>4、ISN是固定的吗？</h5><ul><li>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。</li><li>ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</li><li><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></li></ul><h4 id="3、4次挥手"><a href="#3、4次挥手" class="headerlink" title="3、4次挥手"></a>3、4次挥手</h4><img src="https://img-blog.csdnimg.cn/20210206101844970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="数据建立主动释放" style="zoom:33%;" /><p>在双方连接已建立后，此时需要客户端<strong>主动发出关闭</strong>信号</p><h5 id="1、第1次挥手"><a href="#1、第1次挥手" class="headerlink" title="1、第1次挥手"></a>1、第1次挥手</h5><img src="https://img-blog.csdnimg.cn/2021020610204186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第一次挥手" style="zoom: 33%;" /><ul><li><p>TCP客户进程会<strong>发送TCP连接释放报文段</strong>，并进入<strong>终止等待1</strong>状态</p></li><li><p>TCP连接释放报文段首部中有以下关键数据位：</p><ol><li>终止位FIN和确认位ACK：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段：值设置为u，u等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1，用来表示发送过程中的最后一个字节序号为u</li><li>确认号ack字段：值设置为v，v等于服务器进程之前发送的数据中最后一个字节的序号加1，也就是确认收到已经收到的服务器发送的数据</li></ol></li><li><p><strong>【注意】：</strong>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></li></ul><h5 id="2、第2次挥手"><a href="#2、第2次挥手" class="headerlink" title="2、第2次挥手"></a>2、第2次挥手</h5><img src="https://img-blog.csdnimg.cn/20210206103509759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第二次挥手" style="zoom: 33%;" /><ul><li><p>接收方再接收到连接释放报文后，会发送一个<strong>普通的TCP确认报文段</strong>并进入关闭等待（<code>CLOSE_WAIT</code> 状态）</p></li><li><p>普通的TCP确认报文段首部中有以下关键数据位：</p><ol><li><p>确认位ACK：值被设置为1，表明这是一个普通的TCP确认报文段。</p></li><li><p>序号seq：值设置为v，v等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，与之前收到的TCP连接释放报文段中的确认号ack值匹配</p></li><li><p>确认号ack字段：值为u+1，这是对TCP连接释放报文段的确认，也就是为发送方连接释放报文中的seq的值+1.</p></li></ol></li><li><p>在第2次挥手后，会产生以下过程：</p><ul><li>TCP服务器进程通知高层应用进程，TCP客户进程要断开与自己的TCP连接，此时的TCP连接进入半关闭状态。</li><li>半关闭状态可以认为，此时<strong>客户端与服务器的连接不再传输数据</strong>，也就是客户端没有数据在发生。而此时<strong>服务器若有剩余数据要发送会继续发送</strong>。</li><li>半关闭状态可能会持续一段时间，直到发送方没有数据进行发送</li></ul></li><li><p>在以上等待过程中，客户端会进入<strong>终止等待2状态：</strong></p><img src="https://img-blog.csdnimg.cn/20210206104044261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第二次挥手后服务器状态" style="zoom:33%;" /></li></ul><h5 id="3、第3次挥手"><a href="#3、第3次挥手" class="headerlink" title="3、第3次挥手"></a>3、第3次挥手</h5><p>此时当服务器没有数据要传输后。进行第三次挥手：</p><img src="https://img-blog.csdnimg.cn/2021020610480896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第三次挥手" style="zoom: 33%;" /><ul><li><p>此时TCP服务器进程会发送TCP连接释放报文段并进入最后确认状态：</p></li><li><p>在该报文段中有以下关键数据段：</p><p>1、终止位FIN和确认位ACK：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</p><p>2、序号seq：值为w，因为在半关闭状态下，TCP服务器进程可能又发送一段数据，因此w就是该段数据最后的序号。</p><p>3、确认号ack：值为u+1，这是对之前收到的TCP连接释放报文段的重复确认，因此值与发送方第一次挥手发送的seq值+1。</p></li></ul><h5 id="4、第4次挥手"><a href="#4、第4次挥手" class="headerlink" title="4、第4次挥手"></a>4、第4次挥手</h5><p>TCP客户进程<strong>收到TCP连接释放报文段</strong>后开始第四次挥手：</p><img src="https://img-blog.csdnimg.cn/20210206105234687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第四次挥手" style="zoom:33%;" /><ul><li><p>针对第三次挥手的报文段发送<strong>普通的TCP确认报文段</strong>，之后进入<strong>时间等待状态。</strong></p></li><li><p>该报文段首部中有以下关键数据位：</p><p>1、确认位ACK：值被设置为1，表明这是一个普通的TCP确认报文段。</p><p>2、序号seq字段：值设置为u+1，用来表示最后一个发送的字节序号，</p><p>​    但是为何没有发送数据，而此时值要设置为u+1（对比第一次挥手数据）？</p><p>​    因为TCP客户进程之前发送的TCP连接释放报文段(带有FIN)虽不携带数据，但要消耗一个序号</p><p>3、确认号ack：值设置为w+1，这是对所收到的TCP连接释放报文段的确认</p></li><li><p>此时<strong>TCP服务器进程收到该报文段后就进入关闭状态</strong></p></li><li><p>而TCP客户进程还要<strong>经过2MSL</strong>后才能进入关闭状态，MSL具体的值（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）可以根据TCP协议的不同实现进行设置。</p></li></ul><h4 id="4、4次挥手的问题"><a href="#4、4次挥手的问题" class="headerlink" title="4、4次挥手的问题"></a>4、4次挥手的问题</h4><h5 id="1、为什么4次？"><a href="#1、为什么4次？" class="headerlink" title="1、为什么4次？"></a>1、为什么4次？</h5><ul><li>服务端收到客户端的FIN报文后，不能立刻回应FIN断开服务端-客户端的连接</li><li>因为自己可能还有数据发给客户端。所以先发ACK应答给客户端，告诉他已经知道要释放链接了，把自己的数据发送完，再开始发FIN来断开服务端-客户端的连接</li></ul><h5 id="2、为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？，是否有必要？"><a href="#2、为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？，是否有必要？" class="headerlink" title="2、为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？，是否有必要？"></a>2、为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？，是否有必要？</h5><ul><li><p>目的1：为了保证客户端发送的最后一个ACK报文段能够到达服务器，保证服务器关闭</p></li><li><p>目的2：防止“已失效的连接请求报文段”出现在本连接中</p></li><li><p>举例说明：</p><img src="https://img-blog.csdnimg.cn/20210206110230216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="不等待2MSL的情况" style="zoom: 33%;" /><ol><li><p>若客户端发送完最后一次报文后，也就是第四次挥手后就直接进入关闭状态，此时若第四次挥手报文丢失，会导致服务器的超时重传</p></li><li><p>此时客户端又已经关闭，导致不接受该报文，因此服务器会一直不断重传，并一直处于最后确认状态无法进入关闭状态。</p></li><li><p>因此，有以下结论：</p><ul><li><p>客户端进入时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p></li><li><p>TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p></li></ul></li></ol></li><li><p>假如另一种情况：</p><ol><li><p>TCP双方已经建立了连接，但是传输过程中<strong>TCP客户进程所在的主机</strong>出现了故障，此时TCP服务器进程以后就不能再收到TCP客户进程发来的数据，这时服务器进程会一直处于等待状态。</p></li><li><p>为了使TCP服务器进程不要再白白等待下去出现了<strong>TCP保活计时器：</strong></p><img src="https://img-blog.csdnimg.cn/20210206110921258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="保活计时器" style="zoom: 50%;" /></li></ol></li></ul><h5 id="3、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#3、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="3、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a>3、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h5><ul><li>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但有可能最后一个ACK丢失。所以<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong></li></ul><h3 id="9、TCP报文的首部格式："><a href="#9、TCP报文的首部格式：" class="headerlink" title="9、TCP报文的首部格式："></a>9、TCP报文的首部格式：</h3><p>为了实现可靠传输，TCP采用了面向字节流的方式。在发送数据时，<strong>从发送缓存中取出一部分或者全部字节，并给其添加一个首部</strong>使之称为<strong>TCP报文段</strong>。</p><ol><li>一个TCP报文段由首部、数据载荷两部分构成</li><li>TCP的<strong>全部功能都能体现在它首部中各字段</strong>的作用</li></ol><p>TCP首部和IP地址的首部类似，都由固定部分和扩展部分构成</p><img src="https://img-blog.csdnimg.cn/20210206111411616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="TCP首部" style="zoom:50%;" /><h4 id="1、固定部分"><a href="#1、固定部分" class="headerlink" title="1、固定部分"></a>1、固定部分</h4><ul><li>源端口和目的端口字段：</li></ul><img src="https://img-blog.csdnimg.cn/20210206111530978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="源端口和目的端口字段" style="zoom: 33%;" /><ul><li>序号、确认号、ACK字段：</li></ul><img src="https://img-blog.csdnimg.cn/20210206112000569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="序号" style="zoom: 33%;" /><img src="https://img-blog.csdnimg.cn/20210206112111207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="确认号" style="zoom:33%;" /><p>也就是四次挥手中的SEQ.</p><img src="https://img-blog.csdnimg.cn/20210206112144726.png" alt="ACK" style="zoom: 33%;" /><p>以上三个字段的使用例子：</p><img src="https://img-blog.csdnimg.cn/20210206112234844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="三个字段例子" style="zoom:50%;" /><ul><li>数据偏移字段：</li></ul><img src="https://img-blog.csdnimg.cn/2021020611235494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="数据偏移字段" style="zoom:33%;" /><p>例如：其数据偏移二进制数的十进制表示 * 4 = 首部长度</p><img src="https://img-blog.csdnimg.cn/20210206112504633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="数据偏移例子" style="zoom:33%;" /><ul><li><p>保留、窗口、校验和字段：</p><img src="https://img-blog.csdnimg.cn/20210206112718623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="保留、窗口" style="zoom: 50%;" /></li><li><p>与连接管理相关的字段：</p><img src="https://img-blog.csdnimg.cn/20210206112822979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="同步标志位" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/20210206112841284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="终止标志位" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210206112906122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="复位标志位字段" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210206112926575.png" alt="推送标志位字段" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210206113010144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="紧急标志位URG紧急指针" style="zoom: 50%;" /></li></ul><h4 id="2、拓展部分"><a href="#2、拓展部分" class="headerlink" title="2、拓展部分"></a>2、拓展部分</h4><ul><li><p>选项和填充字段：</p><img src="https://img-blog.csdnimg.cn/20210206113129998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="选项字段" style="zoom:33%;" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS</title>
      <link href="/2021/12/11/HTTPS/"/>
      <url>/2021/12/11/HTTPS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTPS-概述"><a href="#1-HTTPS-概述" class="headerlink" title="1. HTTPS 概述"></a>1. HTTPS 概述</h2><h3 id="1、什么是HTTPS"><a href="#1、什么是HTTPS" class="headerlink" title="1、什么是HTTPS"></a>1、什么是HTTPS</h3><ul><li><p>HTTPS：HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><ul><li>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，</li><li>而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生</li><li>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10885a9d4d574d7caf3fee1416f623ca~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:25%;" /></li><li><p><strong>SSL：</strong>是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输</p></li><li><p>http默认采用<strong>80</strong>作为通讯端口，传输不加密</p></li><li><p>https默认采用<strong>443</strong>，对于传输的数据进行加密传输。 主流</p></li></ul><h3 id="2、TSL工作原理"><a href="#2、TSL工作原理" class="headerlink" title="2、TSL工作原理"></a>2、TSL工作原理</h3><p><strong>TLS/SSL</strong>全称<strong>安全传输层协议</strong>， 是介于TCP和HTTP之间的一层安全协议</p><h2 id="2-对称加密"><a href="#2-对称加密" class="headerlink" title="2. 对称加密"></a>2. 对称加密</h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704172932212-1865243822.png" alt="img" style="zoom: 67%;" /><ul><li><strong>特点：</strong>客户端、服务端的对称加密算法的加密和解密都是用<strong>同一个密钥</strong></li><li><strong>安全性问题：</strong><ol><li>密钥需要通过网络传输，怎么让传输的双方知晓，同时不被别人知道？</li><li>传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容</li></ol></li></ul><h2 id="3-非对称加密-单向安全"><a href="#3-非对称加密-单向安全" class="headerlink" title="3. 非对称加密             单向安全"></a>3. 非对称加密             单向安全</h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704172950412-1093634792.png" alt="img" style="zoom:67%;" /><ul><li><h4 id="特点：不需担心公钥泄露，确保了客户端发送到服务端数据的安全"><a href="#特点：不需担心公钥泄露，确保了客户端发送到服务端数据的安全" class="headerlink" title="特点：不需担心公钥泄露，确保了客户端发送到服务端数据的安全"></a>特点：不需担心公钥泄露，确保了客户端发送到服务端数据的安全</h4><ol><li>非对称加密需要<strong>一组密钥对</strong>，分别是<strong>公钥</strong>和<strong>私钥</strong>，这两个密钥是成对出现的。</li><li><strong>公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密</strong></li><li>私钥由服务器自己保存，<strong>公钥发送给客户端</strong></li><li>客户端拿到公钥后对请求加密后发送给服务端，服务器收到后用私钥解开</li></ol></li></ul><h2 id="4-非对称加密改良-双向安全但解密慢"><a href="#4-非对称加密改良-双向安全但解密慢" class="headerlink" title="4. 非对称加密改良           双向安全但解密慢"></a>4. 非对称加密改良           双向安全但解密慢</h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173037022-575825113.png" alt="img" style="zoom:67%;" /><ul><li><h4 id="传输过程："><a href="#传输过程：" class="headerlink" title="传输过程："></a>传输过程：</h4><p>服务器拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2</p><ol><li><p>浏览器向服务器请求，服务器把公钥A1明文传输给浏览器</p></li><li><p>浏览器把公钥B1明文传输给服务器</p></li><li><p>之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密</p><p>由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全</p></li><li><p>服务器向浏览器传输的东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。</p></li></ol></li><li><h4 id="但HTTPS并没有用这种方案"><a href="#但HTTPS并没有用这种方案" class="headerlink" title="但HTTPS并没有用这种方案"></a>但HTTPS并没有用这种方案</h4><p>最主要的原因是非对称加密算法非常耗时，而对称加密快很多。能不能运用<strong>非对称加密的特性</strong>解决对称加密中<strong>公钥传输的安全传输</strong>问题？？</p></li><li><h4 id="仍存在的漏洞：中间人攻击"><a href="#仍存在的漏洞：中间人攻击" class="headerlink" title="仍存在的漏洞：中间人攻击"></a>仍存在的漏洞：中间人攻击</h4></li></ul><h2 id="5-非对称加密-对称加密-HTTPS采用的加密方案"><a href="#5-非对称加密-对称加密-HTTPS采用的加密方案" class="headerlink" title="5. 非对称加密 + 对称加密          HTTPS采用的加密方案"></a>5. 非对称加密 + 对称加密          HTTPS采用的加密方案</h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173049712-841772692.png" alt="img" style="zoom:67%;" /><ul><li><h4 id="过程：-只需要服务端有一对公、私钥对"><a href="#过程：-只需要服务端有一对公、私钥对" class="headerlink" title="过程： 只需要服务端有一对公、私钥对"></a>过程： 只需要服务端有一对公、私钥对</h4><p>服务器拥有用于非对称加密的公钥A1、私钥A2</p><ol><li>浏览器向服务器请求，服务器把公钥A1明文给传输浏览器</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器</li><li>服务器拿到后用私钥A2解密得到密钥X</li><li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可</li></ol></li><li><h4 id="漏洞：中间人攻击-中间人完全不需要拿到私钥A2就能劫持信息"><a href="#漏洞：中间人攻击-中间人完全不需要拿到私钥A2就能劫持信息" class="headerlink" title="漏洞：中间人攻击   中间人完全不需要拿到私钥A2就能劫持信息"></a>漏洞：中间人攻击   中间人完全不需要拿到私钥A2就能劫持信息</h4></li></ul><h2 id="6-中间人攻击"><a href="#6-中间人攻击" class="headerlink" title="6. 中间人攻击"></a>6. 中间人攻击</h2><p><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173100652-22100951.png" alt="img"></p><ul><li><h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4><p>服务器用于非对称加密的公钥A1、私钥A2</p><ol><li>浏览器向服务器请求，服务器把公钥A1明文传输给浏览器</li><li>中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器</li><li>中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器</li><li>在双方都不会发现异常的情况下，中间人得到了对称密钥X</li></ol></li><li><h4 id="根本原因：浏览器无法确认自己收到的公钥是不是服务端自己的，下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？"><a href="#根本原因：浏览器无法确认自己收到的公钥是不是服务端自己的，下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？" class="headerlink" title="根本原因：浏览器无法确认自己收到的公钥是不是服务端自己的，下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？"></a>根本原因：浏览器无法确认自己收到的公钥是不是服务端自己的，下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？</h4></li></ul><h2 id="7-数字证书"><a href="#7-数字证书" class="headerlink" title="7. 数字证书"></a>7. 数字证书</h2><ul><li><p>网站在使用HTTPS前，需要向“<strong>CA机构</strong>”申请颁发一<strong>数字证书</strong>，数字证书里有<strong>证书持有者、证书持有者的公钥等信息</strong></p></li><li><p>服务器把证书传输给浏览器，浏览器<strong>从证书里取公钥</strong>就可以了</p></li><li><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？</p></li></ul><h2 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8. 数字签名"></a>8. 数字签名</h2><h3 id="1-数字签名的制作过程："><a href="#1-数字签名的制作过程：" class="headerlink" title="1. 数字签名的制作过程："></a>1. 数字签名的制作过程：</h3><ol><li>CA拥有非对称加密的私钥和公钥。</li><li>CA对证书明文信息进行hash。</li><li>对hash后的值用私钥加密，得到数字签名</li><li><strong>明文和数字签名共同组成了数字证书</strong>，这样一份数字证书就可以颁发给网站了</li></ol><h3 id="2-浏览器验证过程："><a href="#2-浏览器验证过程：" class="headerlink" title="2. 浏览器验证过程："></a>2. 浏览器验证过程：</h3><ol><li>拿到证书，得到明文T1，数字签名S1。</li><li>用CA机构的公钥对S1解密（由于是浏览器信任的机构，所以<strong>浏览器保有它的公钥</strong>），得到S2。</li><li>用证书里说明的hash算法对明文T1进行hash得到T2。</li><li>比较S2是否等于T2，等于则表明证书可信。</li></ol><ul><li>下图中左侧是数字签名的制作过程，右侧是验证过程</li></ul><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173241563-445049817.png" alt="img" style="zoom:67%;" /><h3 id="3-为什么这样可以证明证书可信？"><a href="#3-为什么这样可以证明证书可信？" class="headerlink" title="3. 为什么这样可以证明证书可信？"></a>3. 为什么这样可以证明证书可信？</h3><ul><li>假设中间人篡改了证书的原文，<strong>由于他没有CA机构的私钥</strong>，所以无法得到此时加密后签名，无法相应地篡改签名。</li><li>浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人</li></ul><h3 id="4-既然不可能篡改，那如果整个证书被掉包呢？"><a href="#4-既然不可能篡改，那如果整个证书被掉包呢？" class="headerlink" title="4. 既然不可能篡改，那如果整个证书被掉包呢？"></a>4. 既然不可能篡改，那如果整个证书被掉包呢？</h3><ul><li>假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。</li><li>于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞</li><li><strong>其实这并不会发生</strong>，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</li></ul><h3 id="5-制作数字签名时为什么需要hash一次？"><a href="#5-制作数字签名时为什么需要hash一次？" class="headerlink" title="5. 制作数字签名时为什么需要hash一次？"></a>5. 制作数字签名时为什么需要hash一次？</h3><h4 id="性能问题："><a href="#性能问题：" class="headerlink" title="性能问题："></a>性能问题：</h4><ul><li>非对称加密是非常耗时和耗性能的；</li><li>对一个字符加密和对100个字符加密哪个更快一些？越短加密越快</li><li>证书的明文基本都很长，但是经过hash之后都很短，而且基本都是固定的长度了</li></ul><h3 id="6-HTTPS必须在每次请求中都要先在SSL-TLS层进行握手传输密钥吗？"><a href="#6-HTTPS必须在每次请求中都要先在SSL-TLS层进行握手传输密钥吗？" class="headerlink" title="6. HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？"></a>6. HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？</h3><p>显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？</p><ul><li>用session就可以，相当于服务器那里有个小本本记录着</li><li>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下</li><li>之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了</li></ul><h2 id="9-HTTPS-工作原理"><a href="#9-HTTPS-工作原理" class="headerlink" title="9. HTTPS 工作原理"></a>9. HTTPS 工作原理</h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173337291-1775767129.png" alt="img" style="zoom:67%;" /><ol><li><p><strong>发请求</strong></p><p>client向server发送请求<a href="https://baidu.com,然后连接到server的443端口./">https://baidu.com，然后连接到server的443端口。</a></p></li><li><p>服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。</p></li><li><p><strong>传送证书</strong><br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。</p></li><li><p><strong>客户端解析证书</strong><br>这部分工作是由客户端的TLS来完成的，首先会<strong>验证公钥是否有效</strong>，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。</p></li><li><p><strong>传送加密信息</strong><br>这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p></li><li><p><strong>服务端加密信息</strong><br>服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。</p></li><li><p><strong>传输加密后的信息</strong><br>这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。</p></li><li><p><strong>客户端解密信息</strong><br>客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> 证书 </tag>
            
            <tag> 数字签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2021/12/11/HTTP/"/>
      <url>/2021/12/11/HTTP/</url>
      
        <content type="html"><![CDATA[<h3 id="1、HTTP概述"><a href="#1、HTTP概述" class="headerlink" title="1、HTTP概述"></a>1、HTTP概述</h3><h4 id="1、是什么："><a href="#1、是什么：" class="headerlink" title="1、是什么："></a>1、是什么：</h4><ol><li>超文本传输协议，基于TCP/IP协议，<strong>是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></li><li>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息</li></ol><h4 id="2、特点："><a href="#2、特点：" class="headerlink" title="2、特点："></a>2、特点：</h4><h5 id="1、灵活可扩展"><a href="#1、灵活可扩展" class="headerlink" title="1、灵活可扩展"></a>1、灵活可扩展</h5><ul><li>一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。</li><li>另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据</li></ul><h5 id="2、请求-应答模式"><a href="#2、请求-应答模式" class="headerlink" title="2、请求-应答模式"></a>2、请求-应答模式</h5><ul><li>通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等</li></ul><h5 id="3、可靠传输"><a href="#3、可靠传输" class="headerlink" title="3、可靠传输"></a>3、可靠传输</h5><ul><li>HTTP是基于TCP/IP，因此把这一特性继承了下来</li></ul><h5 id="4、无状态"><a href="#4、无状态" class="headerlink" title="4、无状态"></a>4、无状态</h5><ul><li><p>指协议对于事物处理没有记忆能力。不对请求和响应之间的通信状态进行保存</p></li><li><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传</p></li><li><p>无状态协议解决办法：</p><p>1、通过、Cookie  </p><p>2、通过Session会话保存</p></li></ul><h4 id="3、优、缺点"><a href="#3、优、缺点" class="headerlink" title="3、优、缺点"></a>3、优、缺点</h4><h5 id="1、无状态"><a href="#1、无状态" class="headerlink" title="1、无状态"></a>1、无状态</h5><ul><li>有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等</li><li>另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说</li></ul><h5 id="2、明文传输"><a href="#2、明文传输" class="headerlink" title="2、明文传输"></a>2、明文传输</h5><ul><li>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式</li><li>这让HTTP的报文信息暴露给了外界，给攻击者带来了便利</li><li>不验证对方信息，会遭遇伪装；</li></ul><h5 id="3、队头阻塞"><a href="#3、队头阻塞" class="headerlink" title="3、队头阻塞"></a>3、队头阻塞</h5><ul><li>当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题</li></ul><h3 id="2、HTTP-状态码"><a href="#2、HTTP-状态码" class="headerlink" title="2、HTTP 状态码"></a>2、HTTP 状态码</h3><p>RFC 规定 HTTP 的状态码为<strong>「三位数」</strong>，第一个数字定义了响应的类别，被分为五类:</p><ul><li><strong>「1xx」</strong>: 代表请求已被接受，需要继续处理。</li><li><strong>「2xx」</strong>: 表示成功状态。</li><li><strong>「3xx」</strong>: 重定向状态。</li><li><strong>「4xx」</strong>: 客户端错误。</li><li><strong>「5xx」</strong>: 服务器端错误。</li></ul><h4 id="1、1xx-信息类"><a href="#1、1xx-信息类" class="headerlink" title="1、1xx 信息类"></a>1、1xx 信息类</h4><ul><li>100继续 ：指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100允许客户端继续或用417告诉客户端不同意接受附件。     HTTP 1.1中新加入的</li><li>101转换协议：指服务器将按照其上的头信息变为一个不同的协议。 HTTP 1.1中新加入的</li></ul><h4 id="2、2xx-成功"><a href="#2、2xx-成功" class="headerlink" title="2、2xx 成功"></a>2、2xx 成功</h4><ul><li><p>200 （成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页</p></li><li><p>201 （已创建） 请求成功并且服务器创建了新的资源</p></li><li><p>204：请求得到了成功处理，但返回的响应报文中不含实体的主体部分（没有资源可以返回）</p></li><li><p>206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 <strong>「Content-Range」</strong> 指定范围的实体内容。</p></li></ul><h4 id="3、3xx-重定向"><a href="#3、3xx-重定向" class="headerlink" title="3、3xx 重定向"></a>3、3xx 重定向</h4><h5 id="同样是重定向，307，303，302的区别？"><a href="#同样是重定向，307，303，302的区别？" class="headerlink" title="同样是重定向，307，303，302的区别？"></a>同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h5><ul><li><p>302是http1.0的状态码，在http1.1版本的时候为了细化302状态码出来了两个303和307。</p><ul><li> 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。</li></ul></li><li><p>307会遵照浏览器标准，不会从post变为get。</p></li><li><p>301 （永久移动）表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI，新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。</p><ul><li>若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址</li><li>使用场景：<ul><li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul></li></ul></li><li><p>302 （临时移动） 表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。</p><ul><li> 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。</li><li> 若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</li><li> 同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li><li>使用场景：<ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。</li></ul></li></ul></li><li><p>303 （查看其他位置）表示由于请求对应的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源</p><ul><li>和 302 Found 相似功能，但 303 状态码明确表示客户端应当用 GET 方法获取资源</li><li>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</li><li>注意：<ul><li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li><li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做</li></ul></li></ul></li><li><p><strong>304 （未修改，协商缓存可用） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</strong> </p><p>304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系</p><ol><li><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul></li><li><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。</li></ul></li><li><p><strong>HTTP状态码304是多好还是少好</strong></p><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。</p><p>若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累的回访率也会高</p></li></ol></li><li><p>305 （使用<strong>代理</strong>） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</p></li><li><p>307 （临时重定向）会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容</p></li></ul><h4 id="4、4XX-客户端错误"><a href="#4、4XX-客户端错误" class="headerlink" title="4、4XX 客户端错误"></a>4、4XX 客户端错误</h4><ul><li><p>400  请求报文存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p></li><li><p>401 unauthorized，表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败。</p><ul><li><p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p></li><li><p>出现401场景：</p><ul><li>401.1 - 登录失败。</li><li>401.2 - 服务器配置导致登录失败。</li><li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li><li>401.4 - 筛选器授权失败。</li><li>401.5 - ISAPI/CGI 应用程序授权失败。</li><li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li></ul></li></ul></li><li><p>403 forbidden，表示对请求资源的访问被服务器拒绝。服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。<strong>进入该状态后，不能再继续进行验证。</strong>该访问是永久禁止的，并且与应用逻辑密切相关。</p></li><li><p>404 not found，表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：</p></li><li><p>405  表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。</p><p>GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、5XX-服务器错误"><a href="#5、5XX-服务器错误" class="headerlink" title="5、5XX 服务器错误"></a>5、5XX 服务器错误</h4><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误。</li><li>502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li></ul><h3 id="3、HTTP版本差异"><a href="#3、HTTP版本差异" class="headerlink" title="3、HTTP版本差异"></a>3、HTTP版本差异</h3><h4 id="1、HTTP-0-9"><a href="#1、HTTP-0-9" class="headerlink" title="1、HTTP 0.9"></a>1、HTTP 0.9</h4><ul><li>91年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，已过时。</li></ul><h4 id="2、HTTP-1-0"><a href="#2、HTTP-1-0" class="headerlink" title="2、HTTP 1.0"></a>2、HTTP 1.0</h4><ul><li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件</li><li>除了GET命令，还引入了POST命令和HEAD命令</li><li>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</li><li>只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li><li>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</li></ul><h4 id="3、HTTP-1-1"><a href="#3、HTTP-1-1" class="headerlink" title="3、HTTP 1.1"></a>3、HTTP 1.1</h4><p><strong>http1.1是目前最为主流的http协议版本</strong>，从1999年发布至今，仍是主流的http协议版本。</p><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li><li>引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率</li><li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效</li><li>支持断点续传，通过使用请求头中的 <code>Range</code> 来实现</li><li>使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE</li></ul><h4 id="3-2、总结1-0与1-1区别"><a href="#3-2、总结1-0与1-1区别" class="headerlink" title="3.2、总结1.0与1.1区别"></a>3.2、总结1.0与1.1区别</h4><ul><li><p><strong>连接方面</strong></p><p>http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延</p></li><li><p><strong>资源请求方面</strong></p><p>在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</p></li><li><p><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p></li><li><p>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</p></li><li><p>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</p></li></ul><h4 id="4、http1-x版本问题"><a href="#4、http1-x版本问题" class="headerlink" title="4、http1.x版本问题"></a>4、http1.x版本问题</h4><ul><li><h4 id="安全："><a href="#安全：" class="headerlink" title="安全："></a>安全：</h4><p>在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性</p></li><li><h4 id="队头阻塞："><a href="#队头阻塞：" class="headerlink" title="队头阻塞："></a>队头阻塞：</h4><p>HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞</p></li><li><h4 id="Keep-alive性能问题"><a href="#Keep-alive性能问题" class="headerlink" title="Keep-alive性能问题"></a>Keep-alive性能问题</h4><p>http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间 </p></li></ul><h4 id="5、HTTP-2-0"><a href="#5、HTTP-2-0" class="headerlink" title="5、HTTP 2.0"></a>5、HTTP 2.0</h4><h5 id="1、二进制分帧"><a href="#1、二进制分帧" class="headerlink" title="1、二进制分帧"></a>1、<code>二进制分帧</code></h5><ul><li>这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。</li><li>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li></ul><h5 id="2、头部压缩"><a href="#2、头部压缩" class="headerlink" title="2、头部压缩"></a>2、<code>头部压缩</code></h5><ul><li>HTTP 1.1版本会出现 <strong>「User-Agent、Cookie、Accept、Server、Range」</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。</li><li>HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li></ul><h5 id="3、多路复用"><a href="#3、多路复用" class="headerlink" title="3、多路复用"></a>3、<code>多路复用</code></h5><ul><li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</li></ul><h5 id="4、服务器推送"><a href="#4、服务器推送" class="headerlink" title="4、服务器推送"></a>4、<code>服务器推送</code></h5><ul><li>允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li></ul><h5 id="5、请求优先级"><a href="#5、请求优先级" class="headerlink" title="5、请求优先级"></a>5、<code>请求优先级</code></h5><ul><li>可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验</li></ul><h4 id="6、3-0-QUIC-协议"><a href="#6、3-0-QUIC-协议" class="headerlink" title="6、3.0  QUIC 协议"></a>6、3.0  QUIC 协议</h4><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a0a2ec0ef143b49d79256cea543418~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:25%;" /><h5 id="1-特点："><a href="#1-特点：" class="headerlink" title="1. 特点："></a>1. 特点：</h5><ul><li>HTTP/3 是基于 UDP 实现的，实现了类似于 TCP 的多路数据流、传输可靠性等功能，称为 QUIC 协议<ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li><li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li><li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li><li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li></ul></li></ul><h5 id="2-HTTP-3-的挑战"><a href="#2-HTTP-3-的挑战" class="headerlink" title="2. HTTP/3 的挑战"></a>2. HTTP/3 的挑战</h5><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ul><h3 id="4、对HTTP-2理解"><a href="#4、对HTTP-2理解" class="headerlink" title="4、对HTTP/2理解"></a>4、对HTTP/2理解</h3><h4 id="1、头部压缩"><a href="#1、头部压缩" class="headerlink" title="1、头部压缩"></a>1、头部压缩</h4><ul><li><p>由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。</p><ul><li><p>所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p></li><li><p><strong>「User-Agent、Cookie、Accept、Server、Range」</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重</p></li></ul></li><li><p>HTTP/2 实现了头信息压缩，引入了头信息压缩机制。</p><ul><li>一方面，头信息使用 gzip 或 compress 压缩后再发送；</li><li>另一方面，客户端和服务器同时维护一张头信息表<code>HPACK</code> 算法，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了</li></ul></li><li><h4 id="HPACK-算法：-传索引"><a href="#HPACK-算法：-传索引" class="headerlink" title="HPACK 算法：  传索引"></a><code>HPACK</code> 算法：  传索引</h4><ul><li>类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引</li><li>对于之前出现过的头部信息，只需要把<strong>「索引」</strong>(比如1，2，…)传给对方，对方拿到索引查表就行了</li></ul></li></ul><img src="https://user-images.githubusercontent.com/34484322/89356545-a3fd4100-d6f0-11ea-8e0a-8870d832e96e.png" alt="img" style="zoom: 33%;" /><ul><li><h4 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h4><ol><li><p>这种<strong>「传索引」</strong>的方式，可以说让请求头字段得到极大程度的精简和复用</p></li><li><p>其次是对于整数和字符串进行<strong>「哈夫曼编码」</strong></p><p>哈夫曼编码的原理就是先将所有出现的字符建立一张索引表</p><p>然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>「索引序列」</strong>，可以达到非常高的压缩率</p></li></ol></li></ul><h4 id="2、多路复用"><a href="#2、多路复用" class="headerlink" title="2、多路复用"></a>2、多路复用</h4><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p><h5 id="HTTP2中："><a href="#HTTP2中：" class="headerlink" title="HTTP2中："></a>HTTP2中：</h5><ul><li><p>同域名下所有通信都在单个连接上完成。</p></li><li><p>单个连接可以承载任意数量的双向数据流。</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是<code>Stream ID</code>，流标识符</p><p>有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。</p></li><li><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了**”队头堵塞”**的问题。</p></li></ul><h4 id="3、服务器推送"><a href="#3、服务器推送" class="headerlink" title="3、服务器推送"></a>3、服务器推送</h4><ul><li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送，这样就可以相对减少一些延迟时间</li><li>需要注意的是 http2 下服务器主动推送的是<strong>静态资源</strong>，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><h5 id="相比较http-1-1的优势👇"><a href="#相比较http-1-1的优势👇" class="headerlink" title="相比较http/1.1的优势👇"></a>相比较http/1.1的优势👇</h5><ul><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li></ul><h4 id="4、二进制分帧与数据流"><a href="#4、二进制分帧与数据流" class="headerlink" title="4、二进制分帧与数据流"></a>4、二进制分帧与数据流</h4><h5 id="二进制帧："><a href="#二进制帧：" class="headerlink" title="二进制帧："></a>二进制帧：</h5><ul><li><p>在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。</p></li><li><p>HTTP/2 则是一个彻底的二进制协议，一个报文格式就被拆分为一个个二进制帧，帧的概念是它实现多路复用的基础。</p><ul><li><p>用<strong>「Headers帧」</strong>存放头部字段，<strong>「Data帧」</strong>存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了HTTP队头阻塞问题</p></li><li><p>HTTP/2采用二进制格式，全部传输01串，便于机器解码</p><p>明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低</p></li></ul></li></ul><h5 id="数据流："><a href="#数据流：" class="headerlink" title="数据流："></a>数据流：</h5><ul><li>在客户端与服务器之间，双方都可以互相发送二进制帧，这样子<strong>「双向传输的序列」</strong>，称为<code>流</code>，所以HTTP/2中以<strong>流</strong>来<strong>表示一个TCP连接上进行多个数据帧的通信</strong>，这就是<strong>多路复用</strong>概念</li><li>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。<ul><li>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流；</li><li>每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li></ul></li></ul><h5 id="那乱序的二进制帧，是如何组装成对于的报文呢？"><a href="#那乱序的二进制帧，是如何组装成对于的报文呢？" class="headerlink" title="那乱序的二进制帧，是如何组装成对于的报文呢？"></a>那乱序的二进制帧，是如何组装成对于的报文呢？</h5><ul><li>乱序，指的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的</li><li>接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文</li><li>二进制帧中有一些字段，控制着<code>优先级</code>和<code>流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验</li></ul><h5 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h5><ul><li>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的；</li><li>HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。</li><li>队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理；</li><li>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</li></ul><h3 id="5、keep-alive"><a href="#5、keep-alive" class="headerlink" title="5、keep-alive"></a>5、keep-alive</h3><h4 id="1、什么是keep-alive"><a href="#1、什么是keep-alive" class="headerlink" title="1、什么是keep-alive"></a>1、什么是keep-alive</h4><ul><li><h4 id="普通模式："><a href="#普通模式：" class="headerlink" title="普通模式："></a>普通模式：</h4><p>HTTP协议采用“请求-应答”模式，当使用普通模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接，这就是<strong>短连接</strong>。（HTTP协议为无连接的协议）</p></li><li><h4 id="Keep-Alive模式："><a href="#Keep-Alive模式：" class="headerlink" title="Keep-Alive模式："></a>Keep-Alive模式：</h4><p>当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 ，这就是<strong>长连接</strong>。</p></li></ul><h4 id="2、为什么要使用keep-alive"><a href="#2、为什么要使用keep-alive" class="headerlink" title="2、为什么要使用keep-alive"></a>2、为什么要使用keep-alive</h4><ul><li><strong>创建目的：</strong>能在多次HTTP之前重用同一个TCP连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）</li></ul><img src="https://user-images.githubusercontent.com/34484322/89356849-64832480-d6f1-11ea-8f53-5372f8c30f39.png" alt="img" style="zoom:50%;" /><ul><li>优点：<ul><li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li><li>允许请求和应答的HTTP管线化；</li><li>降低拥塞控制 （TCP连接减少了）；</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li><li>报告错误⽆需关闭TCP连；</li></ul></li><li>缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li></ul><h4 id="3、客户端如何开启"><a href="#3、客户端如何开启" class="headerlink" title="3、客户端如何开启"></a>3、客户端如何开启</h4><p>Keep-Alive的<strong>建立过程</strong>：</p><ul><li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li><li>服务器收到请求并处理 Connection字段</li><li>服务器回送Connection:Keep-Alive字段给客户端</li><li>客户端接收到Connection字段</li><li>Keep-Alive连接建立成功</li></ul><p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p><ul><li>客户端向服务器只是发送内容报文（不包含Connection字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有Connection字段，断开连接</li></ul><p><strong>客户端请求断开连接过程</strong>：</p><ul><li>客户端向服务器发送Connection:close字段</li><li>服务器收到请求并处理connection字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接</li></ul><h3 id="6、请求方法get-post"><a href="#6、请求方法get-post" class="headerlink" title="6、请求方法get/post"></a>6、请求方法get/post</h3><h4 id="1、HTTP请求方法"><a href="#1、HTTP请求方法" class="headerlink" title="1、HTTP请求方法"></a>1、HTTP请求方法</h4><ul><li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</li><li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li></ul><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li><p>GET：                请求获取Request-URI所标识的资源</p></li><li><p>POST：              在Request-URI所标识的资源后附加新的数据</p></li><li><p>HEAD：             请求获取由Request-URI所标识的资源的响应消息报头，没有响应体</p></li><li><p>PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）</p><ul><li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等</li><li>也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li></ul></li><li><p>OPTIONS：       用于请求获得由<code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项</p><ul><li>通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</li></ul><p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p><ul><li><p>获取服务器对该资源支持的所有HTTP请求方法；</p><p>该方法会用’*’来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。</p></li><li><p>用来检查访问权限。例如：JS 的 XMLHttpRequest对象在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</p></li></ul></li><li><p>DELETE：          请求服务器删除对应所标识的资源</p></li><li><p>TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断</p></li><li><p>CONNECT：      建立连接隧道，用于代理服务器</p></li></ul><h4 id="2、谈一谈GET-和-POST-的区别"><a href="#2、谈一谈GET-和-POST-的区别" class="headerlink" title="2、谈一谈GET 和 POST 的区别"></a>2、谈一谈GET 和 POST 的区别</h4><p>本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。</p><p>从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册</p><p>想装逼请参考 <a href="https://zhuanlan.zhihu.com/p/22536382">https://zhuanlan.zhihu.com/p/22536382</a></p><h5 id="1、缓存角度"><a href="#1、缓存角度" class="headerlink" title="1、缓存角度"></a>1、缓存角度</h5><ul><li>GET 请求后浏览器会主动缓存，POST 默认情况下不能</li></ul><h5 id="2、参数角度"><a href="#2、参数角度" class="headerlink" title="2、参数角度"></a>2、参数角度</h5><ul><li>GET请求一般放在URL中，因此不太安全，因为请求的 url 会被保留在历史记录中</li><li>POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的</li></ul><h5 id="3、编码角度"><a href="#3、编码角度" class="headerlink" title="3、编码角度"></a>3、编码角度</h5><ul><li>GET请求只能进行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。</li></ul><h5 id="3-2、请求长度："><a href="#3-2、请求长度：" class="headerlink" title="3.2、请求长度："></a>3.2、请求长度：</h5><ul><li><p>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</p><p><strong>为什么会限制长度？</strong></p><ul><li>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。</li><li>get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET的长度值 = URL（<span class="number">2083</span>）- （你的Domain+Path）-<span class="number">2</span>（<span class="number">2</span>是get请求中?=两个字符的长度）</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、请求幂等"><a href="#4、请求幂等" class="headerlink" title="4、请求幂等"></a>4、请求幂等</h5><ul><li>GET请求幂等</li><li>POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致</li></ul><h5 id="5、请求时"><a href="#5、请求时" class="headerlink" title="5、请求时"></a>5、请求时</h5><ul><li>GET请求会一次性发送请求报文</li><li>POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分</li></ul><h4 id="3、POST与PUT的区别"><a href="#3、POST与PUT的区别" class="headerlink" title="3、POST与PUT的区别"></a>3、POST与PUT的区别</h4><ul><li>PUT不会产生新数据，只是覆盖老数据，是幂等的</li><li>POST请求一次就产生一个新数据，是非幂等的</li></ul><h3 id="6-1、请求头、响应头"><a href="#6-1、请求头、响应头" class="headerlink" title="6.1、请求头、响应头"></a>6.1、请求头、响应头</h3><h4 id="HTTP-Request-Header-常见的请求头："><a href="#HTTP-Request-Header-常见的请求头：" class="headerlink" title="HTTP Request Header 常见的请求头："></a><strong>HTTP Request Header 常见的请求头：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Accept:浏览器能够处理的内容类型</span><br><span class="line">* Accept-Charset:浏览器能够显示的字符集</span><br><span class="line">* Accept-Encoding：浏览器能够处理的压缩编码</span><br><span class="line">* Accept-Ranges：可以请求网页实体的一个或者多个子范围字段</span><br><span class="line">* Connection：浏览器与服务器之间连接的类型</span><br><span class="line">* Cookie：当前页面设置的任何Cookie</span><br><span class="line">* Host：发出请求的页面所在的域</span><br><span class="line">* Referer：发出请求的页面的URL</span><br><span class="line">* User-Agent：浏览器的用户代理字符串</span><br></pre></td></tr></table></figure><h4 id="响应头："><a href="#响应头：" class="headerlink" title="响应头："></a>响应头：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP Responses Header 常见的响应头：</span><br><span class="line"></span><br><span class="line">Date：表示消息发送的时间，时间的描述格式由rfc822定义</span><br><span class="line">server:服务器名称</span><br><span class="line">Connection：浏览器与服务器之间连接的类型</span><br><span class="line">Cache-Control：控制HTTP缓存</span><br><span class="line">content-type:表示后面的文档属于什么MIME类型</span><br></pre></td></tr></table></figure><h4 id="常见的-Content-Type-属性值有四种："><a href="#常见的-Content-Type-属性值有四种：" class="headerlink" title="常见的 Content-Type 属性值有四种："></a>常见的 Content-Type 属性值有四种：</h4><p>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><p>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。</p><p>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p><h3 id="7、对URL组成"><a href="#7、对URL组成" class="headerlink" title="7、对URL组成"></a>7、对URL组成</h3><h4 id="1、URL与URI"><a href="#1、URL与URI" class="headerlink" title="1、URL与URI"></a>1、URL与URI</h4><ul><li><p>URI：统一资源标识符         </p><p>父类        表示请求服务器资源，定位这个资源</p></li><li><p>URL：统一资源定位符，常常被称为网址，是因特网上标准的资源地址</p><p>子类       而URL还要表示如何访问这个资源</p><p>通用的格式：scheme://host[:port]/path/…/?query#anchor</p></li></ul><h4 id="2、组成格式："><a href="#2、组成格式：" class="headerlink" title="2、组成格式："></a>2、组成格式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.aspxfans.com:8080/news/index.…</span><br></pre></td></tr></table></figure><ul><li><p><strong>协议：</strong>访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等后面一定接上://</p></li><li><p><strong>域名：</strong>该URL的域名部分为“<a href="http://www.aspxfans.com”/">www.aspxfans.com”</a></p></li><li><p><strong>port：</strong>跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。</p><ul><li>端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li></ul></li><li><p>（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</p></li><li><p><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</p></li><li><p><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分</p><ul><li>如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分</li><li>如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。</li><li>本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li></ul></li><li><p><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例的锚部分是“name”。锚部分也不是一个URL必须的部分；</p></li><li><p><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。</p><p>本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ul><h4 id="3、URL-编码"><a href="#3、URL-编码" class="headerlink" title="3、URL 编码"></a>3、URL 编码</h4><ul><li>URL 只能使用 <a href="https://link.juejin.cn/?target=https://www.w3school.com.cn/tags/html_ref_ascii.asp">ASCII 字符集</a>来通过因特网进行发送。</li><li>由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</li><li>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</li><li>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">天天`转换为有效的ASCII格式就是`%CC%EC%CC%EC</span><br></pre></td></tr></table></figure><h3 id="8、队头阻塞问题"><a href="#8、队头阻塞问题" class="headerlink" title="8、队头阻塞问题"></a>8、队头阻塞问题</h3><h4 id="1、什么是队头阻塞？"><a href="#1、什么是队头阻塞？" class="headerlink" title="1、什么是队头阻塞？"></a>1、什么是队头阻塞？</h4><ul><li>对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的</li><li>一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<code>HTTP队头阻塞</code>问题</li></ul><h4 id="2、解决1：并发连接"><a href="#2、解决1：并发连接" class="headerlink" title="2、解决1：并发连接"></a>2、解决1：并发连接</h4><ul><li>我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务</li><li>在<code>RFC规范</code>中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。</li></ul><h4 id="3、解决2：域名分片"><a href="#3、解决2：域名分片" class="headerlink" title="3、解决2：域名分片"></a>3、解决2：域名分片</h4><ul><li>可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器</li><li>就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题</li></ul><p>比如<code>TianTian.com</code>，可以分出很多二级域名，比如<code>Day1.TianTian.com</code>，<code>Day2.TianTian.com</code>,<code>Day3.TianTian.com</code>,这样子就可以有效解决队头阻塞问题</p><h3 id="9、谈一谈HTTP数据传输"><a href="#9、谈一谈HTTP数据传输" class="headerlink" title="9、谈一谈HTTP数据传输"></a>9、谈一谈HTTP数据传输</h3><p>大概遇到的情况就分为<strong>「定长数据」</strong> 与 <strong>「不定长数据」</strong>的处理吧。</p><h4 id="1、定长数据"><a href="#1、定长数据" class="headerlink" title="1、定长数据"></a>1、定长数据</h4><ul><li>发送端在发送数据的过程中，需要设置<code>Content-Length</code>,来指明发送数据的长度。如果采用了Gzip压缩的话，Content-Length设置的就是压缩后的传输长度</li></ul><p>【注意】：</p><ul><li>Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。</li><li>如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。</li><li>那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。</li><li>在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于<code>Content-Length</code>,若是非Keep-alive，跟前面情况一样，Content-Length可有可无</li></ul><h4 id="2、不定长数据"><a href="#2、不定长数据" class="headerlink" title="2、不定长数据"></a>2、不定长数据</h4><p>现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>通过chunked机制，可以完成对不定长数据的处理，当然了，你需要知道的是</p><ul><li>如果头部信息中有<code>Transfer-Encoding</code>,优先采用Transfer-Encoding里面的方法来找到对应的长度。</li><li>如果设置了Transfer-Encoding，那么Content-Length将被忽视。</li><li>使用长连接的话，会持续的推送动态内容。</li></ul><p>那我们来模拟一下吧👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const server = require(&#x27;http&#x27;).createServer();</span><br><span class="line">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  if(req.url === &#x27;/index&#x27;) &#123;</span><br><span class="line">   // 设置数据类型</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);</span><br><span class="line">    res.setHeader(&#x27;Content-Length&#x27;, 10);</span><br><span class="line">    res.setHeader(&#x27;Transfer-Encoding&#x27;, &#x27;chunked&#x27;);</span><br><span class="line">    </span><br><span class="line">    res.write(&quot;你好，使用的是Transfer-Encoding设置传输数据形式&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输数据给您&lt;br/&gt;&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    res.write(&quot;骚等一下&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输数据给您&quot;);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;成功启动--TinaTian&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的组件通信</title>
      <link href="/2021/12/11/React%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
      <url>/2021/12/11/React%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="数据是如何在react组件上流动"><a href="#数据是如何在react组件上流动" class="headerlink" title="数据是如何在react组件上流动"></a>数据是如何在react组件上流动</h2><p>React视图会随着数据的变化而变化：UI= render(data)；因此data在react中非常重要；</p><p>react中如果希望两个组件之间能够产生耦合，那么<strong>两个组件必须建立数据上的连接。也就是组件间通信，</strong>其背后是一套 <strong>环环相扣的react数据流解决方案</strong>。</p><p>时下react中的组件通信解决方案：</p><h4 id="1、基于props的数据流"><a href="#1、基于props的数据流" class="headerlink" title="1、基于props的数据流"></a>1、基于props的数据流</h4><ul><li><p>组件，从概念上类似于JS函数，它接收任意的入参（即props），并返回用于描述页面展示内容的React元素</p></li><li><p>既然props是入参，通过修改props来完成通信就是很自然的事。</p></li><li><p>遵循的原则：单向数据流。当前组件的state以props的形式流动时，只能流向组件树中比自己层级更低的树。比如父组件—&gt;子组件，而不能反过来。</p><p>基于这种原则，可以完成<strong>父子通信，子父通信、兄弟通信</strong></p><ul><li><h5 id="父子通信：父组件通过this-props传入子组件，实现父–子通信"><a href="#父子通信：父组件通过this-props传入子组件，实现父–子通信" class="headerlink" title="父子通信：父组件通过this.props传入子组件，实现父–子通信"></a>父子通信：父组件通过this.props传入子组件，实现父–子通信</h5></li><li><h5 id="子父通信：由于单向数据流的原则限制："><a href="#子父通信：由于单向数据流的原则限制：" class="headerlink" title="子父通信：由于单向数据流的原则限制："></a>子父通信：由于单向数据流的原则限制：</h5><p>父组件传递给子组件的是一个绑定在自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去</p></li><li><p>子传父，再由父传新子。</p></li></ul></li><li><p>优点：简单</p></li><li><p>缺点：层层嵌套的场景很繁琐</p></li></ul><h4 id="2、发布订阅模式"><a href="#2、发布订阅模式" class="headerlink" title="2、发布订阅模式"></a>2、发布订阅模式</h4><p>解决通信类问题的“万金油”</p><p>最初的案例是：addEventlistener，监听事件的位置、触发事件的位置是不受限的。</p><h5 id="事件的监听、触发"><a href="#事件的监听、触发" class="headerlink" title="事件的监听、触发"></a>事件的监听、触发</h5><ul><li>on()负责注册事件的监听器，指定事件触发时的回调函数</li><li>emit（）：负责触发事件，可以通过传参使其在触发的时候携带数据</li><li>off()：负责监听器的删除</li></ul><h5 id="写出一个同时拥有on、emit、off的EventEmitter"><a href="#写出一个同时拥有on、emit、off的EventEmitter" class="headerlink" title="写出一个同时拥有on、emit、off的EventEmitter"></a>写出一个同时拥有on、emit、off的EventEmitter</h5><ol><li>事件和监听函数的对应关系应该如何处理？映射，因此全局应该设计一个对象来存储二者的关系</li><li>如何实现订阅？写操作，将具体的事件和监听函数写入到队列里去</li><li>如何实现发布？ 读操作，触发安装在某个事件上对应的监听函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myEventEmitter</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.eventMap = &#123;&#125;; <span class="comment">//eventMap用来存储事件和监听函数的关系</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">on</span>(<span class="params">type, handler</span>)</span>&#123;  <span class="comment">//type事件名称</span></span><br><span class="line"><span class="keyword">if</span>(!handler <span class="keyword">instanceof</span> <span class="built_in">Function</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;你传错了&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 判断type事件对应的队列是否存在</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">this</span>.eventMap[type])&#123;</span><br><span class="line">      <span class="built_in">this</span>.eventMap[type] = []; <span class="comment">// 若不存在该类型，新建该队列</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 直接往队列里推入handler</span></span><br><span class="line"><span class="built_in">this</span>.eventMap[type].push(handler);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">emit</span>(<span class="params">type, params</span>)</span>&#123;  <span class="comment">// 触发时可以传参</span></span><br><span class="line">    <span class="comment">// 假设该事件是有订阅的（对应的事件队列存在）</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.eventMap[type])&#123;</span><br><span class="line">      <span class="comment">// 将事件队列里的handler依次执行出队</span></span><br><span class="line">      <span class="built_in">this</span>.eventMap[type].forEach(<span class="function">(<span class="params">handler, index</span>) =&gt;</span> &#123;</span><br><span class="line">        handler(params);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type, handler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.eventMap[type])&#123;</span><br><span class="line">      <span class="built_in">this</span>.eventMap[type].splice(<span class="built_in">this</span>.eventMap[type].indexOf(handler)&gt;&gt;&gt;<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myEvent = <span class="keyword">new</span> myEventEmitter();</span><br><span class="line"><span class="keyword">const</span> testHandler = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;test事件被处罚了,参数是:&#x27;</span>+<span class="string">`<span class="subst">$&#123;params&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">myEvent.on(<span class="string">&#x27;test&#x27;</span>, testHandler); <span class="comment">//监听</span></span><br><span class="line">myEvent.emit(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;newState&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="借助发布订阅实现AB通信"><a href="#借助发布订阅实现AB通信" class="headerlink" title="借助发布订阅实现AB通信"></a>借助发布订阅实现AB通信</h5><p>在B中编写一个handler，在handler中进行this.setState的操作，然后将handler作为监听器的回调，与某事件（自定义）关联起来，在A组件中触发对应的事件，并将希望携带的参数入参传入即可。</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121125421211.png" alt="image-20211121125421211" style="zoom: 33%;" /><h4 id="3、Context-API"><a href="#3、Context-API" class="headerlink" title="3、Context API"></a>3、Context API</h4><p>React天然提供的一种组件树的全局通信方式，16.3之后具备更强的可用性；</p><h5 id="1、Context-API工作流"><a href="#1、Context-API工作流" class="headerlink" title="1、Context API工作流"></a>1、Context API工作流</h5><p>Provider作为数据的提供方，可以将数据下发给自身组件树中任意层级的consumer；</p><p>consumer不仅能读取到provider下发的数据，还能读取到这些数据的更新；</p><p>因此，数据在生产者、消费者之间能够及时同步；</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121130228283.png" alt="image-20211121130228283" style="zoom:33%;" /><h5 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h5><ol><li><p>创建Context容器对象： </p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> XxxContext = React.createContext(defaultVlaue);</span><br></pre></td></tr></table></figure></li><li><p>从创建的context中，可以读取到Provider、Comsumer</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Provider, Consumer&#125; = XxxContext;</span><br></pre></td></tr></table></figure></li><li><p>使用Provider(数据的提供者)对组件树中的根组件进行包裹，然后传入<strong>value的属性</strong>，这个value就是后续在组件树中流动的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Provider value=&#123;数据&#125;&gt;</span><br><span class="line">子组件</span><br><span class="line">&lt;Title /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Contet</span> /&gt;</span></span></span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure><ul><li>数据其实是字符串，如果你想传对象，或多个值，可以再包一个{}</li></ul></li></ol>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Provider value=&#123;&#123;username, age, height&#125;&#125;&gt;</span><br><span class="line">子组件</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>这个Value可以被consumer消费，可以读取Provider下发的数据。前提是需要函数、类组件作为它的子组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="params">value</span> =&gt;</span> ( <span class="comment">// value就是context中的value数据</span></span><br><span class="line">        要显示的内容</span><br><span class="line">  &lt;div&gt; &#123;value.title&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure><ul><li>当consumer没有对应的Provider时，会直接去创建的地方defaultValue查找；</li></ul></li></ol><h5 id="3、-新的context-API解决了什么问题"><a href="#3、-新的context-API解决了什么问题" class="headerlink" title="3、 新的context API解决了什么问题"></a>3、 新的context API解决了什么问题</h5><ul><li><p>过时的context API存在的问题：</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121134007115.png" alt="image-20211121134007115" style="zoom:33%;" /><ul><li>前两者提供生产者的角色；</li><li>contextTypes的成为消费者；</li></ul></li><li><p>缺点： </p><ol><li><p>代码不够优雅，不能很好辨别provider、cosumer</p></li><li><p>无法保证数据在生产者和消费者之间的及时同步，官网描述：</p><p>如果组件提供的一个context发生了变化，而中间父组件的shouldComponentUpdate返回了false，那么使用该组件的后代组件不会尽心更新。</p><p>返回了context的组件则完全失控，所以基本上没有办法能够可靠的更新context</p></li></ol></li><li><p>新的context解决了什么问题：</p><p>即使组件的shouldComponentUpdate返回了false，它依然可以<strong>“穿透”</strong>组件继续向后代进行传播，进而确保了数据生产者、数据消费者之间数据的一致性。</p></li></ul><h4 id="4、Redux"><a href="#4、Redux" class="headerlink" title="4、Redux"></a>4、Redux</h4><p>官网描述：是JS的状态容器，它提供可预测的状态管理；Vue、React可以用</p><img src="https://tomoya92.github.io/assets/2021-04-29-09-56-16.png" alt="img" style="zoom:50%;" /><h5 id="1、角色："><a href="#1、角色：" class="headerlink" title="1、角色："></a>1、角色：</h5><ul><li>store：单一的数据源，而且是只读的；</li><li>action：对变化的描述</li><li>reducer：负责对变化进行分发、处理</li></ul><p>在Redux的整个工作过程中，数据流是严格单向的，很重要一定要说！！！</p><ul><li>如果想修改数据，只有一种方式：派发action，action会被reducer读取，进而根据action的不同对数据修改，返回新的state，新的state会更新到store里，进而驱动视图层做出对应的改变；</li><li>因此，任何组件都可以通过store读取到全局的状态；也可以通过合理地派发action，来修改全局的状态。redux提供了状态容器，使得状态能够自由地在组件之间传播；这就是redux实现的思路。</li></ul><h5 id="2、redux工作流"><a href="#2、redux工作流" class="headerlink" title="2、redux工作流"></a>2、redux工作流</h5><ol><li><p>createStore：使用createStore创建包含指定reducer的store对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)   <span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)   <span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)   <span class="keyword">const</span> store = createStore(reducer)</span><br></pre></td></tr></table></figure></li><li><p>reducer的作用：将新的state返回给store</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer=  <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> new_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>action:通知reducer，让改变发生</p><p>如何在众多的store状态库中，准确地希望他改变state呢？将action对比，因此必须要用正确的action</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;add_mm&#x27;</span>,</span><br><span class="line"><span class="attr">payload</span>: <span class="string">&quot;ss&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>action只是一个对象，要想让action真正产生动作，还要靠store的dispatch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(action);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue&amp;&amp;React的数据流管理</title>
      <link href="/2021/12/11/Vue-React%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86/"/>
      <url>/2021/12/11/Vue-React%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><h3 id="1、Flux"><a href="#1、Flux" class="headerlink" title="1、Flux"></a>1、Flux</h3><p>redux的问题背景和架构思想是什么？</p><p>虽然它并不严格遵循flux的设定，但Redux可被认定为Flux的一种实现方式</p><h4 id="1、Flux4部分"><a href="#1、Flux4部分" class="headerlink" title="1、Flux4部分"></a>1、Flux4部分</h4><p>有FB提出的一套应用架构，并不是一套具体的框架，这套架构约束的是“应用处理数据的模式”。</p><p><strong>把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测</strong>。</p><p>在Flux架构中，一个应用被拆解为4部分：</p><ul><li><h4 id="View：用户界面，可以以任何形式展示"><a href="#View：用户界面，可以以任何形式展示" class="headerlink" title="View：用户界面，可以以任何形式展示"></a>View：用户界面，可以以任何形式展示</h4><ol><li>特性：store改变了VIew也要跟着改变</li><li>如何改变view：一般 Store 一旦发生改变，都会往外面发送一个事件，比如 change，通知所有的订阅者。View 通过订阅也好，监听也好，不同的框架有不同的技术，反正 Store 变了，View 就会变。</li></ol></li><li><h4 id="Action：视图层发出的消息，会触发应用状态的改变"><a href="#Action：视图层发出的消息，会触发应用状态的改变" class="headerlink" title="Action：视图层发出的消息，会触发应用状态的改变"></a>Action：视图层发出的消息，会触发应用状态的改变</h4><ol><li>必须经过一套流程，视图先要通过action告诉 Dispatcher，让 Dispatcher dispatch 一个 action</li><li>Dispatcher 会把 addUser 这个 action 发给所有的 store，store 就会触发 addUser 这个 action，来更新数据</li><li>数据一更新，那么 View 也就跟着更新了</li></ol></li><li><h4 id="Dispatcher：派发器，负责action的派发"><a href="#Dispatcher：派发器，负责action的派发" class="headerlink" title="Dispatcher：派发器，负责action的派发"></a>Dispatcher：派发器，负责action的派发</h4></li><li><h4 id="store：数据层，应用状态的仓库，此外还定义修改状态的逻辑"><a href="#store：数据层，应用状态的仓库，此外还定义修改状态的逻辑" class="headerlink" title="store：数据层，应用状态的仓库，此外还定义修改状态的逻辑"></a>store：数据层，应用状态的仓库，此外还定义修改状态的逻辑</h4></li></ul><h4 id="2、Flux工作流"><a href="#2、Flux工作流" class="headerlink" title="2、Flux工作流"></a>2、Flux工作流</h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/18/167c11c13ef4e9a8~tplv-t2oaga2asx-watermark.awebp" alt="image.png | center | 827x250" style="zoom:50%;" /><ol><li>用户与 view之间产生交互，通过view发起一个action，通过dispatch会把该action派发给store，通过store相应的状态更新</li><li>store完成更新后，会进一步通知View更新界面；</li></ol><p>【注意】：图中的箭头都是单向的，这也是Flux架构一个特点，<strong>单向数据流</strong></p><h4 id="3、Flux解决了什么"><a href="#3、Flux解决了什么" class="headerlink" title="3、Flux解决了什么"></a>3、Flux解决了什么</h4><p>Flux的核心特征是：<strong>单向数据流</strong>，那么双向数据流会有什么问题呢？</p><ol><li><p>典型应用场景：MVC架构，</p><ul><li><p>除了通过用户通过view层来触发数据以外，还可以通过control来触发逻辑</p></li><li><p>model：程序需要操作的数据或信息；</p></li><li><p>view视图：视图</p></li><li><p>controller：控制器，用于连接view和model，管理model与view之间的逻辑</p></li><li><p>用户操作view后，control来处理逻辑，将改变应用到model上，再反馈到view中，这个过程中，是单向的。在服务端的应用中，数据流确实能够保持单向。但是在前端场景下，处于交互的需要往往允许view和model进行直接通信。这就允许了数据流的存在，当业务场景比较复杂时，数据流就会比较混乱，出现这样：</p><p>这样即使一个小小的修改，也可能造成蝴蝶效应问题。因为你很难区分数据是哪个control，哪个view引发的。</p></li></ul></li><li><p><strong>而Flux的架构模式，最核心的是严格的单向数据流，在单向数据流下，状态的变化是可预测的，避免了混乱的数据结构</strong></p></li><li><p>缺点：</p><ol><li><p>对数据流约束的背后是成本，因此也只在大型的项目中才会使用，这一点对redux也是一样的。</p><p>Store 封装了数据还有处理数据的逻辑等等</p></li><li><p>比如一个应用可以拥有多个 Store，多个Store之间可能有依赖关系；</p></li></ol></li></ol><h3 id="2、Redux"><a href="#2、Redux" class="headerlink" title="2、Redux"></a>2、Redux</h3><p>它与Flux设计思想上一脉相承</p><p>官网描述：是JS的状态容器，它提供可预测的状态管理；Vue、React可以用</p><img src="https://tomoya92.github.io/assets/2021-04-29-09-56-16.png" alt="img" style="zoom:50%;" /><h4 id="1、角色："><a href="#1、角色：" class="headerlink" title="1、角色："></a>1、角色：</h4><ul><li>store：单一的数据源，而且是只读的；</li><li>action：对变化的描述</li><li>reducer：负责对变化进行分发、处理</li></ul><p>在Redux的整个工作过程中，数据流是严格单向的，很重要一定要说！！！</p><ul><li>如果想修改数据，只有一种方式：派发action，action会被reducer读取，进而根据action的不同对数据修改，返回新的state，新的state会更新到store里，进而驱动视图层做出对应的改变；</li><li>因此，任何组件都可以通过store读取到全局的状态；也可以通过合理地派发action，来修改全局的状态。redux提供了状态容器，使得状态能够自由地在组件之间穿梭；这就是redux实现的思路。</li></ul><h4 id="2、redux工作流"><a href="#2、redux工作流" class="headerlink" title="2、redux工作流"></a>2、redux工作流</h4><ol><li><p>createStore：使用createStore创建包含指定reducer的store对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)   <span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="number">2</span>)   <span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="number">3</span>)   <span class="keyword">const</span> store = createStore(reducer)</span><br></pre></td></tr></table></figure></li><li><p>reducer的作用：将新的state返回给store</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer=  <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> new_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>action:通知reducer，让改变发生</p><p>如何在众多的store状态库中，准确地希望他改变state呢？将action对比，因此必须要用正确的action</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;add_mm&#x27;</span>,</span><br><span class="line"><span class="attr">payload</span>: <span class="string">&quot;ss&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>action只是一个对象，要想让action真正产生动作，还要靠store的dispatch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(action);</span><br></pre></td></tr></table></figure></li></ol><h3 id="3、redux源码分析"><a href="#3、redux源码分析" class="headerlink" title="3、redux源码分析"></a>3、redux源码分析</h3><ul><li>utils文件夹：工具方法库</li><li>index.js：入口文件，主要做模块导出</li><li>真正干活的文件：<ul><li>applyMiddleWare.js：中间件模块，将在后面单独讲解</li><li>bingActionCreator.js：用于将传入的actionCreator与dispatch方法相结合，揉成一个新的方法。工具性质的方法（即使不理解它也不影响了解redux）</li><li>combineReducer.js：用于将多个reducer合并起来。工具性质的方法</li><li>compose.js：用于把接收到的函数，从右向左进行结合。工具性质的方法</li><li><strong>createStore.js：了解redux的主要模块。使用redux最先调用的方法，是整个流程的入口，也是Redux中最核心的API</strong></li></ul></li></ul><h4 id="1、createStore-js分析"><a href="#1、createStore-js分析" class="headerlink" title="1、createStore.js分析"></a>1、createStore.js分析</h4><ul><li>使用</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,   </span><br><span class="line">  initial_state, <span class="comment">//初始状态内容</span></span><br><span class="line">  applyMiddleware(middleware1, middleware2,...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>源码截图<br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225633907.png" alt="image-20211127225633907" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225732058.png" alt="image-20211127225732058" style="zoom:15%;" /><br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225800737.png" alt="image-20211127225800737" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230121583.png" alt="image-20211127230121583" style="zoom:15%;" /><br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230134769.png" alt="image-20211127230134769" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230309854.png" alt="image-20211127230309854" style="zoom:15%;" /><br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230558433.png" alt="image-20211127230558433" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230626348.png" alt="image-20211127230626348" style="zoom:15%;" /><br><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230634791.png" alt="image-20211127230634791" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230646868.png" alt="image-20211127230646868" style="zoom:15%;" /></li></ul><h5 id="1、整体流程"><a href="#1、整体流程" class="headerlink" title="1、整体流程"></a>1、整体流程</h5><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230657392.png" alt="image-20211127230657392" style="zoom: 33%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230746655.png" alt="image-20211127230746655" style="zoom:33%;" /><ul><li><p>与redux主流程强相关的，也是使用较多的：getState、subscribe、dispatch</p><p>getState的源码：</p><p>subscribe、dispatch：关键的分发动作，最核心的</p></li></ul><h4 id="2、dispatch"><a href="#2、dispatch" class="headerlink" title="2、dispatch"></a>2、dispatch</h4><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><p> redux关键要素：action   reducer   store    而dispatch刚好能够将这三位主角串起来：</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230309854.png" alt="image-20211127230309854" style="zoom:20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230558433.png" alt="image-20211127230558433" style="zoom:20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230626348.png" alt="image-20211127230626348" style="zoom:20%;" /></p><h5 id="dispatch核心工作流"><a href="#dispatch核心工作流" class="headerlink" title="dispatch核心工作流"></a>dispatch核心工作流</h5><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127232248297.png" alt="image-20211127232248297" style="zoom:25%;" /><p><strong>通过上锁避免套娃式的dispatch</strong></p><p>最关键的是执行reducer，它通过reducer的更新规则，指定了应用状态的变化如何响应action，并发送到store。currentReducer包裹的try部分代码</p><ul><li><p>在调用dispatch之前会通过isDispatching变量设置为true，待reducer执行完毕后，再将isDispatching变量设置为false；这跟setState的批处理也很相似</p></li><li><p>这里这样做的目的是：<strong>避免套娃式的dispatch</strong>，也就是避免开发者在开发中手动调用dispatch</p></li><li><p><strong>为什么要这样设计呢？</strong></p><p>redux在设计reducer时就强调了它必须是纯净的，它不应该执行除了计算之外的任何脏操作。dispatch是一个脏操作；</p><p>其次从执行的角度看，若真的在reducer中调用dispatch，那么dispatch又会返过来调用reducer、reducer又会再次调用，陷入死循环。</p><p>因此，在dispatch中做了if判断，一旦识别isDispatching为true，直接抛错</p></li></ul><h4 id="3、subscribe触发订阅"><a href="#3、subscribe触发订阅" class="headerlink" title="3、subscribe触发订阅"></a>3、subscribe触发订阅</h4><p>在reducer执行完毕后，会触发订阅执行的过程。</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230626348.png" alt="image-20211127230626348" style="zoom:20%;" /><ul><li><p>subscribe这个API执行订阅。接收一个function类型的listener做入参，返回是对应listener的解绑函数</p><p>因为redux中已经默认了订阅的对象就是<strong>状态的变化</strong>，准确来说是dispatch函数的调用这个事件</p></li><li><p>subscribe的工作流程：</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127234248963.png" alt="image-20211127234248963" style="zoom:25%;" /></li></ul><p><strong>问题：</strong></p><ol><li><p><strong>subscribe是如何与redux主流程相结合的呢？</strong></p><p>在store对象创建成功后，通过调用store.subscribe来注册监听函数，也可以通过subscribe的返回函数来解绑监听函数。</p><p>listeners数组用来维护监听函数。</p><p>当diapatch action发生变化时，redux会在reducer执行完毕后，将listeners数组中的监听函数逐个执行。</p></li><li><p>为什么会有currentListeners、nextListeners这两个数组呢？</p><p>redux中的订阅过程和发布过程是如何处理数组的？</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nextListeners = currentListeners;<span class="comment">// 二者指向同一个引用</span></span><br></pre></td></tr></table></figure><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225732058.png" alt="image-20211127225732058" style="zoom: 25%;" /><ul><li><p>但ensureCanMutateNextListener每次都会在注册listener之前无条件调用：用来确保两个数组引用不同。</p></li><li><p>在这个函数执行的是listener的注册逻辑： nextListener.push(listener)，注册到这个数组中。</p></li><li><p>触发订阅的逻辑：</p><p>在触发订阅的过程中，currentListeners会被赋值为nextListener，而即将被执行的数组listeners又被赋值为currentListeners。因此最终被执行的数组指向nextListener的同一个引用。</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230626348.png" alt="image-20211127230626348" style="zoom:20%;" /><p>既然注册监听使用nextListener、触发订阅也是nextListener。<strong>为什么还需要currentListeners数组呢？</strong></p><p>currentListeners用于确保监听函数执行过程中的稳定性。因为任何变更都是在nextListener上发生的，因此需要一个不会被变更的稳定的listener保证不出乱子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenerA</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> unSubscribeA = store.subscribe(listenerA);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenerB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  unSubscribeA();<span class="comment">//在B中解绑A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenerC</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">store.subscribe(listenerB);<span class="comment">//订阅B</span></span><br><span class="line">store.subscribe(listenerC);<span class="comment">//订阅C</span></span><br></pre></td></tr></table></figure><ul><li><p>这种操作在redux是合法的。执行完毕后，listeners数组中[listenerA,  listenerB, listenerC]</p></li><li><p>触发订阅逻辑：遍历listener数组，分别执行自己的函数。而listenerB中执行了unSubscribeA这个动作，而监听、触发、解绑触发影响的都是nextListener数组</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230134769.png" alt="image-20211127230134769" style="zoom: 25%;" /></li><li><p>假如不要currentListeners这个数组，也就不需要执行解绑函数中的ensureCanMutateNextListener这个调用。而没有这个动作，unSubscribeA执行完之后，listenerA会同时从listeners数组和nextListener数组中移除，那么listeners数组就只剩下listenerB、listenerC。也就是listeners数组的长度发生了改变，但for循环并不会感知到，它将继续循环下去。下一步索引对应的会出现undefined，进而导致函数异常。</p></li></ul></li><li><p>那怎么办呢？</p><ul><li><p>因此需要将当前正在执行的listeners数组与nextListener数组隔离开，将两者指向不同的引用。这也是ensureCanMutateNextListener所执行的事情，这个函数执行前：三者关系：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">listeners === nextListener === currentListeners</span><br></pre></td></tr></table></figure><p>执行后：nextListener上的任何改变都无法再影响正在执行中的listeners。而currentListeners就是为了记录下当前正在工作中的listeners数组的引用，将它与可能发生改变的nextListener区分开来，以确保监听函数在执行过程中的稳定性</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">nextListener = currentListeners.slice()</span><br><span class="line">listeners === nextListener !== currentListeners</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="4、redux中间件"><a href="#4、redux中间件" class="headerlink" title="4、redux中间件"></a>4、redux中间件</h3><h4 id="1、用法"><a href="#1、用法" class="headerlink" title="1、用法"></a>1、用法</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,   </span><br><span class="line">  initial_state, <span class="comment">//初始状态内容</span></span><br><span class="line">  applyMiddleware(middleware1, middleware2,...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2、中间件的引入，为redux工作流带来什么改变？"><a href="#2、中间件的引入，为redux工作流带来什么改变？" class="headerlink" title="2、中间件的引入，为redux工作流带来什么改变？"></a>2、中间件的引入，为redux工作流带来什么改变？</h4><ul><li><p>redux-thunk  经典的<strong>异步action场景</strong></p><p>在redux源码中可以看出，只有同步操作，当我们dispatch一个action时，会立即更新，因此如果想在redux中引入异步数据流，该怎么办？</p><p>使用中间件来支持，其中最受欢迎的是redux-thunk </p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thunkMiddleWare <span class="keyword">for</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunkMiddleware));</span><br></pre></td></tr></table></figure></li><li><p>异步action的例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">for</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunk));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payMoney = <span class="function"><span class="params">payInfo</span> =&gt;</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;payStart&#x27;</span>&#125;);</span><br><span class="line">  fetch().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch();</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> axios.post(<span class="string">&#x27;./api/payMoney&#x27;</span>, &#123;</span><br><span class="line">    payInfo</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;paySuccess&#x27;</span>&#125;);<span class="comment">//付款成功</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;payError&#x27;</span>&#125;); <span class="comment">// 付款失败</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payInfo = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;ss&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">  <span class="attr">count</span>: <span class="number">5</span>,</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意action是函数这里</span></span><br><span class="line">store.dispatch(payMoney(payInfo));</span><br></pre></td></tr></table></figure><ul><li>createStore的源码中，初始化时会检查中间件，使得即使写在第2个参数也可以识别</li></ul></li></ul><p>dispatch的入参从action对象，变成了一个函数，源码中是有校验的action入参必须是一个对象，thunk似乎绕开了这层校验，为什么呢？</p><h4 id="3、redux中间件的工作流程"><a href="#3、redux中间件的工作流程" class="headerlink" title="3、redux中间件的工作流程"></a>3、redux中间件的工作流程</h4><ul><li><p>当只有一个中间件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action -- middleWare -- dispatch -- reducer -- nextState</span><br></pre></td></tr></table></figure><p>middleWare会在action分发之后，到达reducer之前执行；</p></li><li><p>当有多个中间件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action -- middleWare1 （安装的执行顺序）</span><br><span class="line"> -- middleWare2</span><br><span class="line"> -- middleWare3...</span><br><span class="line">-- dispatch -- reducer -- nextState</span><br></pre></td></tr></table></figure><p>中间件的执行时机使得它能在状态正在发生之前结合action信息，做一些自己的处理。</p></li><li><h5 id="中间件如何绕过主流程的校验逻辑呢？"><a href="#中间件如何绕过主流程的校验逻辑呢？" class="headerlink" title="中间件如何绕过主流程的校验逻辑呢？"></a>中间件如何绕过主流程的校验逻辑呢？</h5><p>其实并没有被绕过，而是被<strong>applyMiddleWare</strong>改写了，使得dispatch，在触发reducer之前首先执行对redux中间件的链式调用</p></li></ul><h3 id="5、redux-thunk源码"><a href="#5、redux-thunk源码" class="headerlink" title="5、redux-thunk源码"></a>5、redux-thunk源码</h3><p>主要做的事情：</p><ul><li><p>在拦截到action后，会检查它是否为一个函数：</p><p>若为函数，就会执行它；并且返回执行结果</p><p>若不是函数，就不处理它，直接调用next，工作流可以继续往下走</p></li></ul><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128140700555.png" alt="image-20211128140700555" style="zoom:25%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128141206440.png" alt="image-20211128141206440" style="zoom:25%;" /></p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225633907.png" alt="image-20211127225633907" style="zoom:15%;" /><ol><li><p><strong>applyMiddleWare</strong>是如何配合createStore工作的？</p><ul><li><p><strong>applyMiddleWare</strong>返回的是一个接收createStore作为入参的函数，这个函数将会作为入参传递给createStore</p></li><li><p>createStore中，会判断enhancer存在，就会返回一个针对enhancer的调用，调用中第一层入参是createStore，第二层入参是reducer、preloadedState</p></li><li><p>对应到applymiddelware中的逻辑：</p><p>这个函数中的return 的createStore对应createStore本身，args对应的就是reducer、preloadedState</p></li><li><p>applyMiddeware是enhancer的一种，而enhancer的意思是增强，增强的是createStore的能力。因此入参是传入这个函数是有必要的</p></li></ul><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128141742510.png" alt="image-20211128141742510" style="zoom:20%;" /><ol start="2"><li><p>dispatch函数是如何改写的？</p><p>做了两件事，以，，aPI作为入参逐个调用传入的middleWare函数，获取一个由内层函数组成的数组chain；</p><p>然后调用compose函数，将内层函数逐个组合起来。并调用最终组合出来的函数</p><p>内层函数：creatThunk函数的返回值 return next(action) 仍然是一个函数，高阶函数，要求redux中间节都是高阶函数，内层的就是内层函数。</p></li></ol><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128141804611.png" alt="image-20211128141804611" style="zoom:20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128141819905.png" alt="image-20211128141819905" style="zoom:20%;" /></li><li><p>compose函数是如何组合起来的？</p></li></ol><p><strong>redux中间件是如何实现的？</strong></p><p>​    <strong>函数合成（组合函数</strong>）并不是redux的专利，而是<strong>函数式编程</strong>中的一个通用概念，它其实作为一个工具类的文件存在。源码：</p><ul><li><p>函数组合是通过调用reduce来实现的；特点是对数组中每个元素执行指定的逻辑，并将结果汇总为单个返回值。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">(...args) =&gt; f1(f2(f3(f4(...args)))) <span class="comment">//最后一行等效为</span></span><br></pre></td></tr></table></figure></li></ul><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128020307931.png" alt="image-20211128020307931" style="zoom:25%;" /><h3 id="6、中间件背后的AOP"><a href="#6、中间件背后的AOP" class="headerlink" title="6、中间件背后的AOP"></a>6、中间件背后的AOP</h3><ol><li>为什么中间件可以流行？</li><li>为什么我们的应用需要中间件？</li></ol><p>AOP的存在恰恰是为了解决OOP的局限性。AOP可以被看成是OOP的补充，在OOP模式下，想要拓展一个类的逻辑时，最常见的思路是：</p><ul><li>Class A继承Class B  classB继承classC，这样一层层 将逻辑向下传递</li><li>当我们想要为某几个类追加一段共同的逻辑时，可以通过修改他们的父类来实现，这会导致公共类越来越臃肿。但也没有更好的办法</li></ul><p>面向切面就登场了。切面是一个相对于执行流程来说的概念，以redux为例，其自上而下的工作流：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action</span><br><span class="line"> reducer</span><br><span class="line"> store</span><br></pre></td></tr></table></figure><ul><li>假如在每个action被派发后，都打印一个action被派发的记录，这样的逻辑通用性很强，但业务属性很弱，因此不适合与任何的业务逻辑耦合在一起。因此就可以以切面的方式，将其与业务功能剥离开来。扩展功能在工作流中的执行节点可以看做一个单独切点，我们把扩展功能的逻辑放到这个切点上来，形成的就是一个可以拦截连续逻辑的切面，如下图：</li><li>切面与业务逻辑是分离的，因此AOP是一种典型的非侵入式的逻辑扩容思路。在日常开发中，日志追溯、性能打点、异步工作流处理这种和业务逻辑关系不大的功能，都可以抽取到切面中去做。</li></ul><p>切面编程的收益？</p><ol><li>可以很大程度上提升了组织逻辑的灵活度与干净度、帮助了我们规避掉了逻辑冗余、逻辑耦合问题</li><li>通过将业务逻辑与切面剥离，更高地专注与开发。而切面这种即插即用的方式，自由组织想要的扩展功能</li></ol><h3 id="7、Vuex"><a href="#7、Vuex" class="headerlink" title="7、Vuex"></a>7、Vuex</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/18/167c11c13fc70df1~tplv-t2oaga2asx-watermark.awebp" alt="image.png | center | 701x551" style="zoom: 50%;" /><h4 id="1、Vuex的设计"><a href="#1、Vuex的设计" class="headerlink" title="1、Vuex的设计"></a>1、Vuex的设计</h4><ul><li><h5 id="五个核心属性：state、mutations、actions、Getter、modules"><a href="#五个核心属性：state、mutations、actions、Getter、modules" class="headerlink" title="五个核心属性：state、mutations、actions、Getter、modules"></a>五个核心属性：state、mutations、actions、Getter、modules</h5></li><li><p>把同步和异步拆分开，不要互相干涉</p></li><li><p>store的改变流程：</p><p><strong>在 vuex 中只有 mutations 可以更新state</strong></p><ul><li>commit 一个 mutation，mutation 负责更改 state（store状态更新的唯一方式）</li><li>dispatch 一个 action，在 action 中 commit 一个 mutation</li></ul></li><li><p>引入 Getter，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性</p></li><li><p>引入 Module 的概念，把一个大 Store 拆开，每个 Module 有自己的 state、mutation、action、getter：</p></li></ul><h4 id="1、Store"><a href="#1、Store" class="headerlink" title="1、Store"></a>1、Store</h4><ul><li>每一个 Vuex 里面有一个全局的 Store，包含着应用中的状态 <strong>State</strong></li><li>Vuex通过 store 选项，把 state 注入到整个应用中，这样子组件能通过 this.$store 访问到 state 了</li><li><strong>State 改变，View 就会跟着改变，这个改变利用的是 Vue 的响应式机制</strong></li></ul><h4 id="2、Mutation-同步-store状态更新的唯一方式"><a href="#2、Mutation-同步-store状态更新的唯一方式" class="headerlink" title="2、Mutation           同步    store状态更新的唯一方式"></a>2、Mutation           同步    store状态更新的唯一方式</h4><ul><li><h5 id="改变state的唯一方法是提交commit来触发-mutations"><a href="#改变state的唯一方法是提交commit来触发-mutations" class="headerlink" title="改变state的唯一方法是提交commit来触发_mutations"></a>改变state的唯一方法是提交commit来触发_mutations</h5></li><li><p>每个 mutation 都有一个字符串的 事件类型和 一个 回调函数</p></li><li><p>mutation 有些类似 Redux 的 Reducer，<strong>但Vuex直接修改 State</strong></p><ol><li><strong>Redux 强调的 immutability</strong>，在保证了每一次状态变化都能追踪，收益很有限</li><li>为了同构而设计的 API 很繁琐，必须依赖第三方库才能相对高效率地获得状态树的局部状态，这些不足的地方，所以也被 Vuex 舍掉了</li></ol></li></ul><h4 id="3、假如在mutation里面提交异步"><a href="#3、假如在mutation里面提交异步" class="headerlink" title="3、假如在mutation里面提交异步"></a>3、假如在mutation里面提交异步</h4><h5 id="1、问题、坑"><a href="#1、问题、坑" class="headerlink" title="1、问题、坑"></a>1、问题、坑</h5><ul><li><p>提交的时候页面状态view发生变化，但是真正的状态是没有变化的，<strong>页面改变了</strong>，<strong>而devtool工具里面的state状态不一致</strong> 如下面图片</p></li><li><p>在/src/store/index.js 的mutations里面模拟异步发现状态是混乱的</p><img src="https://segmentfault.com/img/remote/1460000011528057?w=1406&amp;h=538" alt="image_1bs7rnpdd1slf119n1k6k1ltt1o8m9.png-73.7kB" style="zoom:50%;" /></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">num</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="comment">// 任何时候改变state的状态都通过提交 mutation 来改变</span></span><br><span class="line">        <span class="comment">// 里面可以定义多个函数，当触发这个函数就会改变state状态</span></span><br><span class="line">        <span class="function"><span class="title">addIncrement</span>(<span class="params">state, stark</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(stark);</span><br><span class="line">            <span class="comment">// 接收一个state作为参数， 相当于上面的state</span></span><br><span class="line">            <span class="comment">// 模拟异步，状态会发生混乱</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                state.num += stark.n;</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">minIncrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.num -= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h5 id="2、解决："><a href="#2、解决：" class="headerlink" title="2、解决："></a>2、解决：</h5><ol><li>在组件里面利用this.$store.dispatch(“addAction”); 提交actions</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;加减法计算器&lt;/h2&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;-&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;minHandle&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;+&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;addHandle&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">computed</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">num</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.num</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">addHandle</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// this.num += 5;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// 点击的时候需要改变状态，提交mutation addIncrement</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// 利用$store.commit 里面 写参数相当于 mutation的函数名字</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// this.$store.commit(&quot;addIncrement&quot;,&#123;name:&#x27;stark&#x27;,age:18,n:5&#125;)</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// this.$store.commit(&#123;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">//     type:&quot;addIncrement&quot;,</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">//     n:5,</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">//     age:18,</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">//     name:&#x27;stark.wang&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// &#125;)</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;addAction&quot;</span>); <span class="comment">// 在这提交 actions</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">minHandle</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// this.num -= 5;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.$store.commit(<span class="string">&quot;minIncrement&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// this.$store.         </span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="3、为什么呢？"><a href="#3、为什么呢？" class="headerlink" title="3、为什么呢？"></a>3、为什么呢？</h5><ul><li><p>在vuex里，改变state的唯一方法是提交commit来触发_mutations，而调用actions时会判断是不是Promise，调用异步处理，你在mutations里写情求他都不会跑then方法，你怎么改变</p></li><li><h5 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个就是 Store 类的 commit 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commit</span> (<span class="params">_type, _payload, _options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// check object-style commit</span></span><br><span class="line">    <span class="keyword">const</span> &#123;type, payload, options&#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">    <span class="comment">// 定义mutation对象，type 其实就是我们要操作的 mutation 的方法名， payload 是参数（载荷）</span></span><br><span class="line">    <span class="keyword">const</span> mutation = &#123; type, payload &#125;</span><br><span class="line">    <span class="comment">// entry 就是要被执行的 mutation 方法</span></span><br><span class="line">    <span class="keyword">const</span> entry = <span class="built_in">this</span>._mutations[type]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略了一些中间不影响逻辑的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册一些回调函数，可以看到 mutation 方法（entry）最终是在这个回调函数中执行，直接就执行结束，没有任何的 return 以及 异步处理，这样也就是说在 commit 中不可以写异步逻辑</span></span><br><span class="line">    <span class="built_in">this</span>._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">            handler(payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>._subscribers</span><br><span class="line">    .slice() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">    .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="built_in">this</span>.state))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、在组件中执行异步操作，在异步的回调中执行commit可以吗？"><a href="#4、在组件中执行异步操作，在异步的回调中执行commit可以吗？" class="headerlink" title="4、在组件中执行异步操作，在异步的回调中执行commit可以吗？"></a>4、在组件中执行异步操作，在异步的回调中执行commit可以吗？</h5><p>可以，但是一般不这么做</p><ul><li><p>state状态更新逻辑是可复用的，但是如果把这部分逻辑写在了组件内：</p><p>比如写在了组件A中，这时候另外一个组件B也需要更新这个状态，你就需要把组件A中的那段异步代码复制到组件B中</p><p>这个不是一个合理的方式（代码冗余，应该将公共逻辑抽离出来），虽然可以这么做，但是不推荐</p></li></ul><h4 id="4、vuex中为什么把异步操作封装在action，把同步操作放在mutations？"><a href="#4、vuex中为什么把异步操作封装在action，把同步操作放在mutations？" class="headerlink" title="4、vuex中为什么把异步操作封装在action，把同步操作放在mutations？"></a>4、vuex中为什么把异步操作封装在action，把同步操作放在mutations？</h4><ul><li><p>官方文档说明：“在 mutation 中混合异步调用会导致你的程序很难调试</p><p>例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念</p><p>在 Vuex 中，我们将全部的改变都用同步方式实现。我们将全部的异步操作都放在<a href="https://link.zhihu.com/?target=http://vuex.vuejs.org/zh-cn/actions.html">Actions</a>中。”</p></li><li><p>如果同时出发了两个异步的actions，那么这两个回调的时间不一样，那么对于state的更新还是存在竞态的。所以我觉得这样进行区分并不能解决“那么先回调，哪个后回调”来更新state的问题</p></li><li><p>尤大的回答：区分 actions 和 mutations 并不是为了解决竞态问题，而是为了能用 devtools 追踪状态变化</p><ol><li><p>vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行</p></li><li><p>异步竞态怎么处理那是用户自己的事情。vuex 真正限制你的只有 mutation 必须是同步的这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）</p></li><li><p>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了</p></li><li><p>如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态</p></li><li><p>尤大没有做的：</p><p>把记录下来的 mutations 做成类似 rx-marble 那样的时间线图，对于理解应用的异步状态变化很有帮助</p></li></ol></li></ul><h4 id="5、Action"><a href="#5、Action" class="headerlink" title="5、Action"></a>5、Action</h4><ul><li><h5 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">_type, _payload</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// check object-style dispatch</span></span><br><span class="line">    <span class="keyword">const</span> &#123;type,payload&#125; = unifyObjectStyle(\type, _payload)</span><br><span class="line">    <span class="comment">// 定义 action 对象，type 是 actions 对象中的一个属性，payload 是载荷</span></span><br><span class="line">    <span class="keyword">const</span> action = &#123; type, payload &#125;</span><br><span class="line">    <span class="comment">// 待执行的 action 方法</span></span><br><span class="line">    <span class="keyword">const</span> entry = <span class="built_in">this</span>._actions[type]</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._actionSubscribers</span><br><span class="line">        .slice() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">        .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.before)</span><br><span class="line">        .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.before(action, <span class="built_in">this</span>.state))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里执行了 action 方法，并将结果用 Promise.all 方法处理</span></span><br><span class="line">    <span class="keyword">const</span> result = entry.length &gt; <span class="number">1</span></span><br><span class="line">    ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</span><br><span class="line">    : entry[<span class="number">0</span>](payload)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 result.then 执行完以后会 return 一个结果出去（其实就是我们自己调用的异步逻辑的结果）</span></span><br><span class="line">    <span class="keyword">return</span> result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._actionSubscribers</span><br><span class="line">            .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after)</span><br><span class="line">            .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after(action, <span class="built_in">this</span>.state))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6、对比Redux"><a href="#6、对比Redux" class="headerlink" title="6、对比Redux"></a>6、对比Redux</h4><ul><li><p>Redux： view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样）</p></li><li><p>Vuex： view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）</p><p>​             view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作）</p></li></ul><h4 id="3者总的思想："><a href="#3者总的思想：" class="headerlink" title="3者总的思想："></a>3者总的思想：</h4><p><strong>总的来说都是让 View 通过某种方式触发 Store 的事件或方法，Store 的事件或方法对 State 进行修改或返回一个新的 State，State 改变之后，View 发生响应式改变</strong></p>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据流管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue&amp;&amp;React的路由管理</title>
      <link href="/2021/12/11/Vue-React%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/"/>
      <url>/2021/12/11/Vue-React%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h2><p>最基本、核心的能力：路由跳转；3个重要部分：</p><ul><li><strong>路由器</strong>：BrowserRouter、HashRouter。根据Route定义的映射关系，为新路径匹配它对应的逻辑</li><li>路由：Route、switch。负责定义路径与组件之间的映射关系</li><li>导航：Link、NavLink、Redirect。负责触发路径的改变</li></ul><h3 id="1、路由器简介"><a href="#1、路由器简介" class="headerlink" title="1、路由器简介"></a>1、路由器简介</h3><p>路由器是整个路由系统中最终重要功能。它负责感知路由的变化并作出反应。react-roter中支持两种路由器：BrowserRouter、HashRouter</p><p>两种路由器的不同仅在于调用的history不同。这两个API源码中</p><ul><li>BrowserRouter在浏览器中使用H5的history API来控制路由跳转：</li><li>HashRouter通过控制URL的hash属性来控制路由跳转的。</li></ul><h3 id="2、为什么需要路由？产生背景"><a href="#2、为什么需要路由？产生背景" class="headerlink" title="2、为什么需要路由？产生背景"></a>2、为什么需要路由？产生背景</h3><p>什么是路由、它能解决什么问题</p><h4 id="1-后端路由时代："><a href="#1-后端路由时代：" class="headerlink" title="1. 后端路由时代："></a>1. 后端路由时代：</h4><ul><li><p>在前后端不分离时代，一个url对应一个页面。</p></li><li><p>由<strong>后端来控制路由</strong>，当接收到客户端发来的   <code>HTTP</code> 请求，就会<strong>根据所请求的相应 <code>URL</code>，来找到相应的映射函数</strong>，然后执行该函数，并将函数的返回值发送给客户端</p></li><li><p>举例：请求页面：<code>http://www.xxx.com/login</code>，大致流程：</p><ol><li>浏览器发出请求</li><li>服务器监听到80端口（或443）有请求过来，并解析url路径</li><li>根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）</li><li>浏览器根据数据包的 Content-Type 来决定如何解析数据</li></ol><img src="http://www.conardli.top/img/wl/wlqq_1.png" alt="image" style="zoom: 67%;" /><ul><li><p><strong>好处：安全性好，<code>SEO</code> 好；</strong></p></li><li><p><strong>缺点：</strong></p><ol><li>加大服务器的压力</li><li>任何和服务器的交互都需要刷新页面，<strong>用户体验</strong>非常差     <strong>Ajax解决了它</strong></li><li>代码冗合不好维护；</li></ol></li></ul></li></ul><h4 id="2-前后端分离时代"><a href="#2-前后端分离时代" class="headerlink" title="2. 前后端分离时代"></a>2. 前后端分离时代</h4><ul><li><p><strong>Ajax：</strong></p><p>概念：<code>Async JavaScript And XML</code>，浏览器的<code>XMLHttpRequest</code>是实现<code>Ajax</code>最重要的对象，通过XHR对象获取数据后，可以使用DOM方法将数据插入到网页中</p></li><li><p><strong>最大优势特点</strong>：页面<strong>不刷新</strong>的情况下与服务器通信，异步交互体验好</p></li><li><p><strong>缺点：</strong></p><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源策略限制）</li><li>SEO不友好</li></ol></li></ul><h4 id="3-SPA"><a href="#3-SPA" class="headerlink" title="3. SPA"></a>3. SPA</h4><p>在ajax的背景下，出现了SPA</p><ul><li><p>SPA 允许页面在不刷新的情况下更新页面内容，内容的切换更流畅</p></li><li><p>但SPA的问题：定位的问题</p><p>页面切换前后，页面的url都是一样的，这就导致了两个问题</p><ol><li>SPA并不知道：当前页面当前页面“进展到哪一步”，刷新页面之后，你必须重复之前的操作，才可以重新对内容进行定位，SPA并不会记住你的操作。</li><li>SPA有且仅有一个URL给页面做映射，这对SEO并不友好</li></ol></li></ul><h4 id="4-前端路由"><a href="#4-前端路由" class="headerlink" title="4. 前端路由"></a>4. 前端路由</h4><p>它解决了SPA的什么问题呢？</p><ul><li><p>它可以帮助我们在仅有一个页面的情况下，<strong>记住用户走到了哪一步？</strong></p></li><li><p>它为各个SPA中的各个视图匹配唯一标识，这时候用户前进后退触发的新内容都映射到URL上去，此时即便刷新页面，当前的URL也可以标识出它所在的位置，因此内容也不会丢失</p></li></ul><p>是如何解决的呢？</p><ul><li><p><strong>解决问题1：</strong>在SPA中，当用户刷新页面时，浏览器会默认根据当前的URL对资源进行重新定位（发送请求）。这个动作对SPA是不必要的。</p><p>因为SPA作为单页面，无论如何也只有一个页面与之对应；此时若走正常的请求刷新流程，反而会使用户的前进、后退流程无法被记录</p></li><li><p><strong>解决问题2：</strong>单页面应用对服务器来说就是一个URL、一套资源，那么如何做到用不同的URL来映射不同的视图内容呢？</p></li></ul><p><strong>此时服务端已经无法解决SPA的场景了。前端自己解决：</strong></p><p><strong>提供解决思路：</strong>拦截用户的刷新操作，避免服务器盲目响应，返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉，感知URL的变化，这里并不是改造URL，给他做一些处理，这些处理并不会影响其本身的性质，也不会影响服务器对它的识别。</p><p>一旦感知到它的变化，根据JS生成不同的页面。</p><h3 id="3、前端路由实践思路"><a href="#3、前端路由实践思路" class="headerlink" title="3、前端路由实践思路"></a>3、前端路由实践思路</h3><h4 id="1、hash模式"><a href="#1、hash模式" class="headerlink" title="1、hash模式"></a>1、hash模式</h4><ul><li><strong>#后面 hash 值的变化，不会导致浏览器向服务器发请求，浏览器不发请求，就不会刷新页面</strong></li><li>每次 hash 值的变化，还会触发 <strong>hashchange 这个事件</strong>，通过这个事件可知道 hash 值发生了哪些变化。便可以监听 hashchange 来实现更新页面部分内容的操作：</li></ul><h5 id="hash值改变的方式："><a href="#hash值改变的方式：" class="headerlink" title="hash值改变的方式："></a>hash值改变的方式：</h5><ul><li><p><strong>方式1：</strong>通过 <code>a</code> 标签，并设置 <code>href</code> 属性，当用户点击这个标签后，<code>URL</code> 就会发生改变，也就会触发 <code>hashchange</code> 事件了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#search&quot;</span>&gt;search&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>方式2：</strong>直接使用 <code>Js</code>来对 <code>loaction.hash</code> 进行赋值，从而改变 <code>URL</code>，触发 <code>hashchange</code> 事件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.hash=<span class="string">&quot;#search&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="感知hash的方式：-hashChange事件"><a href="#感知hash的方式：-hashChange事件" class="headerlink" title="感知hash的方式： hashChange事件"></a>感知hash的方式： hashChange事件</h5><ul><li><p><code>hashchange</code> 事件来监听 <code>hash</code> 的变化：可以在回调中执行展示和隐藏不同UI显示的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#x27;hashChange&#x27;, () =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h5 id="Hash的特点："><a href="#Hash的特点：" class="headerlink" title="Hash的特点："></a>Hash的特点：</h5><ul><li><p><strong>HTTP请求中不包括#及其后面的部分</strong>，都不会被发送到服务器端</p><p>所以，hash 虽然出现在 URL 中，<strong>但不会被包括在 HTTP 请求中，对后端完全没有影响</strong>，因此改变 hash 不会重新加载页面</p><p>对于后端来说，即使没有做到对路由的全覆盖，也<strong>不会返回 404 错误</strong></p></li><li><p><strong>改变#后面的内容不触发网页重载</strong>，浏览器只会滚动到相应位置</p><p>#代表网页中的一个位置。其右面的字符，就是该位置的标识符：<a href="http://www.example.com/index.html#print%EF%BC%8C%E5%B0%B1%E4%BB%A3%E8%A1%A8%E7%BD%91%E9%A1%B5index.html%E7%9A%84print%E4%BD%8D%E7%BD%AE%E3%80%82%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E8%BF%99%E4%B8%AAURL%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86print%E4%BD%8D%E7%BD%AE%E6%BB%9A%E5%8A%A8%E8%87%B3%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F">http://www.example.com/index.html#print，就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域</a></p></li></ul><h4 id="2、history模式"><a href="#2、history模式" class="headerlink" title="2、history模式"></a>2、history模式</h4><p>通过浏览器的回退、前进按钮控制，就可以实现页面跳转，这是通过API来实现的。浏览器的History API所赋予的。但H4只能切换，而不能改变。H5后增加了pushState、replaceState。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增一个历史记录，所以会相应地启用“后退”按钮</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>,一个新状态的标题，path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接替换当前的历史记录</span></span><br><span class="line"><span class="comment">// 要确保每个“假”URL 背后都对应着服务器上一个真实的物理 URL。否则，单击“刷新”按钮会导致 404 错误</span></span><br><span class="line"><span class="built_in">window</span>.history.replaceState(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br></pre></td></tr></table></figure><p>在hsitory模式下，可以通过监听 <code>popstate</code> 事件，达到目的：</p><ul><li><p>每当浏览记录发生变化， <code>popstate</code> 事件就会触发，go、forward、back等调用确实会触发popState、但<code>pushState()</code> 或 <code>replaceState()</code> 不会触发 <code>popstate</code> 事件。</p></li><li><p>但我们可以通过手动触发来实现。</p></li></ul><h3 id="4、404-错误"><a href="#4、404-错误" class="headerlink" title="4、404 错误"></a>4、404 错误</h3><p>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.abc.com/book/id">http://www.abc.com/book/id</a> 如果后端缺少对 /book/id 的子路由处理，将返回 404 错误</p><h4 id="为什么histroy需要额外配置？"><a href="#为什么histroy需要额外配置？" class="headerlink" title="为什么histroy需要额外配置？"></a>为什么histroy需要额外配置？</h4><ul><li><p>假设应用地址为<code>abc.com</code>，服务端不加额外的配置。当通过<code>abc.com</code>来访问时，是没有问题的，可以正常加载到html文件</p></li><li><p>之后通过route-link或router.api来跳转也不会有问题，因为之后都不会刷新页面请求html，只是通过<code>history.pushState</code>或者<code>history.replaceState</code>改变history记录，修改地址栏地址而已；</p></li><li><p>但如果是<strong>直接访问子路由<code>abc.com/test</code>时就会有问题</strong>，<code>/test</code>是子路由名，但是服务器中并不存在该目录，就无法索引到html文件，此种情况下就会出现404，所以不管是访问什么路径，都应该加载根目录的html文件，因为<code>/xxx/yyy</code>对我们应用来讲是子路由路径而已</p></li><li><p><strong>处理：</strong></p><p>在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。一般需要后端将所有页面都配置重定向到首页路由</p></li></ul><h4 id="为什么hash不需要？"><a href="#为什么hash不需要？" class="headerlink" title="为什么hash不需要？"></a>为什么hash不需要？</h4><ul><li>hash 虽然出现在 URL 中，<strong>但不会被包括在 HTTP 请求中，对后端完全没有影响</strong>，因此改变 hash 不会重新加载页面</li><li>对于后端来说，即使没有做到对路由的全覆盖，也<strong>不会返回 404 错误</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Hook的出现</title>
      <link href="/2021/12/11/React-Hook%E7%9A%84%E5%87%BA%E7%8E%B0/"/>
      <url>/2021/12/11/React-Hook%E7%9A%84%E5%87%BA%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h3 id="一、-why"><a href="#一、-why" class="headerlink" title="一、 why"></a>一、 why</h3><ul><li>Hooks是React团队在实践中逐渐认知的一个改进点，背后设计到<strong>类组件、函数组件</strong>两种组件形式的思考和侧重</li></ul><h4 id="1、类组件"><a href="#1、类组件" class="headerlink" title="1、类组件"></a>1、类组件</h4><ul><li>基于ES6的写法，通过继承React.component的组件</li></ul><h4 id="2、函数组件"><a href="#2、函数组件" class="headerlink" title="2、函数组件"></a>2、函数组件</h4><ul><li>以函数组件的形态存在的组件，在早期没有Hooks加持时，函数组件内部无法定义、维护state，因此也叫“无状态组件”</li></ul><h4 id="3、对比两种组件："><a href="#3、对比两种组件：" class="headerlink" title="3、对比两种组件："></a>3、对比两种组件：</h4><ul><li>类组件继承自class，函数组件不需要；</li><li>类组件可以访问生命周期，函数组件不可；</li><li>类组件可以获取实例化后的this，并基于该this做事情，但函数组件不可；</li><li>类组件可以定义并维护state状态，但函数组件不可；</li></ul><h4 id="4、这是否意味着函数组件没有类组件好呢？"><a href="#4、这是否意味着函数组件没有类组件好呢？" class="headerlink" title="4、这是否意味着函数组件没有类组件好呢？"></a>4、这是否意味着函数组件没有类组件好呢？</h4><p>不是，在Hooks出现之前，类组件的<strong>能力边界</strong>明显强于函数组件。一味鼓吹轻量、易上手、取代类组件也不是应该讨论谁优谁劣的依据。更多的关注点，应该是二者的不同之处，把对应的场景与不同的特性结合起来。</p><ol><li><p>类组件</p><p>类组件是一个面向对象编程思想的一种表现。面向对象的特性之一：</p><ul><li>封装：将一类属性和方法聚合到一个class中</li><li>继承：新的class可以通过继承现有的class，实现对某一类属性和方法的复用；</li></ul><p>react类组件内部只需要继承React.component，就轻易获得了内部丰富的配备。</p><ul><li>React.component提供了很多东西，学习成本更高，比如生命周期，用的不好也会让代码一团糟。大而全的背后是不可忽略的学习成本。可以但没有必要。</li><li>开发者编写的逻辑在封装后，是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。这就需要学习更高的设计模式，用更高的学习成本来交换一点编码的灵活度</li></ul></li><li><p>函数组件</p><p>不仅能承担数据渲染（简单的任务），同样可以承担复杂的交互逻辑；</p><ul><li>粗浅的认知：轻量、灵活、较低的学习成本</li><li><strong>Dam（React开发者）：函数组件会捕获render内部的状态，这是两类组件最大的不同。</strong></li><li>类组件、函数组件之间的千差万别，但最不能被我们忽视的是，<strong>心智模式层面的差异。</strong>是面向对象和函数式编程这两种不同设计思想的差异</li></ul></li><li><p><strong>函数式组件更加契合React的理念：</strong></p><p>UI = f(data)，react组件本身的定位就是函数，吃进去数据，吐出来UI。作为开发者，我们编写的是声明式的代码，而React就是把声明式的代码转换为命令式的DOM操作，把数据层面的描述映射到用户可见的UI变化中去。</p><p>这就意味着react中数据和渲染是紧密绑在一起的，但类组件是做不到这一点。<strong>为什么呢？</strong></p><p>因为<strong>函数组件会捕获render内部的状态，这是两类组件最大的不同。</strong></p></li></ol><h4 id="5、函数组件会捕获render内部的状态，这是两类组件最大不同"><a href="#5、函数组件会捕获render内部的状态，这是两类组件最大不同" class="headerlink" title="5、函数组件会捕获render内部的状态，这是两类组件最大不同"></a>5、函数组件会捕获render内部的状态，这是两类组件最大不同</h4><ol><li><p>类组件：</p><ul><li>类组件中，虽然props是不可变的，但是this是可变的，this上的数据是可以修改的。this.props的调用每次都可以获取最新的props，而这正是react获取数据实时性的重要手段。多数情况下，this.props与预期的渲染动作的连贯。</li><li>假如通过setTimeout将预期的渲染推迟了3s，打破了this.props和渲染动作之间的这种时机上的联动。也就是渲染时捕获到的是一个错误的props，这就出现了问题</li></ul></li><li><p>函数组件：</p><p>在函数执行的一瞬间就被捕获，而props本身又是一个不可变值，因此在任何时机读取到的props都是最新的props。</p><p>当父组件传递新的props时，其实内部产生了一次新的函数调用，并不会影响上一个props。</p><p>函数组件是真正将数据与渲染绑定在了一起。</p></li></ol><p>【总结】：总的说，函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分和重用的组件表达形式。</p><h4 id="6、Hook"><a href="#6、Hook" class="headerlink" title="6、Hook"></a>6、Hook</h4><ul><li>是一套使函数组件更强大、更灵活的钩子。函数组件相比于类组件少了很多东西，而Hooks的出现就是帮助函数式组件补齐这种缺陷。函数式组件可以自由的使用Hooks提供的丰富工具</li></ul><h3 id="二、what"><a href="#二、what" class="headerlink" title="二、what"></a>二、what</h3><h4 id="1、useState：引入状态"><a href="#1、useState：引入状态" class="headerlink" title="1、useState：引入状态"></a>1、useState：引入状态</h4><p>早期函数组件相比于类组件，劣势之一：缺乏维护和定义state的能力，而这个API就是为函数组件引入状态</p><ul><li><p>同样逻辑的函数组件比类组件复杂度更低，代码量更少</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法: const [xxx, setXxx] = React.useState(initValue)</span><br><span class="line">* 参数: 初始值，允许任意类型的值</span><br><span class="line">* 返回值:  第1个为state变量, 第2个为能够修改这个变量的API</span><br><span class="line">* React.useState的调用实际上给这个组件关联上了一个状态</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>  <span class="title">Button</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="keyword">const</span>  [buttonText, setButtonText] =  useState(<span class="string">&quot;Click me,   please&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> setButtonText(<span class="string">&quot;Thanks, been clicked!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  <span class="xml"><span class="tag">&lt;<span class="name">button</span>  <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>&#123;buttonText&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：多个状态声明时，必须分开写，且不能出现在条件判断语句中，因为它必须有一样的渲染顺序                </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [ age , setAge ] = useState(<span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> [ sex , setSex ] = useState(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> [ work , setWork] = useState(<span class="string">&#x27;前端程序员&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [ age , setAge ] = useState(<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">if</span>(showSex)&#123;</span><br><span class="line">        <span class="keyword">const</span> [ sex , setSex ] = useState(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">        showSex=<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ work , setWork ] = useState(<span class="string">&#x27;前端程序员&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、useEffect：为组件引入副作用、生命周期"><a href="#2、useEffect：为组件引入副作用、生命周期" class="headerlink" title="2、useEffect：为组件引入副作用、生命周期"></a>2、useEffect：为组件引入副作用、生命周期</h4><p>过去在DidMount 、DidUpdate、willUnmount中做的事，可以放在该钩子做。比如：操作DOM、获取外部API</p><p>生命周期到useEffect的转换关系都不是最重要的，最重要的是构建组件有副作用，引入useEffect这样的条件反射。<strong>为函数组件引入副作用的钩子。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(callback, [](可选));</span><br><span class="line">--  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次渲染都执行</span></span><br><span class="line">    &#125;);</span><br><span class="line">--  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只在挂载阶段执行一次的副作用，且该函数的返回值不是一个函数</span></span><br><span class="line">    &#125;,[]);</span><br><span class="line">--  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只在挂载、卸载阶段执行的副作用，且该函数的返回值是一个函数</span></span><br><span class="line">  <span class="comment">// 业务逻辑A: 它会在挂载阶段执行</span></span><br><span class="line">  ....</span><br><span class="line">      <span class="comment">// 业务逻辑B:它会在卸载时执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    &#125;,[]);</span><br><span class="line">--  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 每一次渲染、且卸载阶段执行的副作用，且该函数的返回值是一个函数，不传第2个参数</span></span><br><span class="line">  <span class="comment">// 业务逻辑A: 它会在每次渲染时执行</span></span><br><span class="line">  ....</span><br><span class="line">      <span class="comment">// 业务逻辑B:它会在卸载时执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">--  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 根据一定的依赖条件出发的副作用</span></span><br><span class="line">      <span class="comment">// 业务逻辑：</span></span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">// 若xxx是一个函数，则xxx会在组件卸载时被触发</span></span><br><span class="line">  <span class="keyword">return</span> xxx;</span><br><span class="line">    &#125;,[count1, count2, count3]);</span><br></pre></td></tr></table></figure><p>【补充】：useEffect中返回的函数叫“清除函数”，当React识别到该函数，会在下卸载阶段执行其清除逻辑。这个规律不会收第2个参数、或其他参数因素的影响。只要你在useEffect回调中返回了一个函数，它就会被当做清除函数来处理。</p><h4 id="3、Hooks是如何升级工作模式的，为什么需要Hooks？重点"><a href="#3、Hooks是如何升级工作模式的，为什么需要Hooks？重点" class="headerlink" title="3、Hooks是如何升级工作模式的，为什么需要Hooks？重点"></a>3、Hooks是如何升级工作模式的，为什么需要Hooks？重点</h4><h5 id="1、告别难以理解的class"><a href="#1、告别难以理解的class" class="headerlink" title="1、告别难以理解的class"></a>1、告别难以理解的class</h5><p>class的两大痛点：</p><ol><li><p>this</p><p>比如推出了箭头函数、bind来解决this问题，但本质上是在用实践层面解决设计层面的问题。而函数组件就没有这个问题了。</p></li><li><p>生命周期</p><ol><li>学习成本</li><li>不合理的逻辑规划方式</li></ol></li></ol><h5 id="2、解决业务逻辑难以拆分的问题"><a href="#2、解决业务逻辑难以拆分的问题" class="headerlink" title="2、解决业务逻辑难以拆分的问题"></a>2、解决业务逻辑难以拆分的问题</h5><ol><li><p>类组件：</p><p>过去组织业务逻辑时，先想清楚业务需要，将对应的业务逻辑拆到对应的生命周期中，逻辑与生命周期强耦合。比如：DidMout去获取数据，在DidUpdate里获取数据的变化，但是大型项目中，一个生命周期做的事情很多。这些事情看起来毫无关联，而有关联的被分散在不同的生命周期里。</p></li><li><p>但是Hooks有专门管理状态的、有引入副作用的等等，<strong>它能帮我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。</strong></p></li></ol><h5 id="3、使状态逻辑复用变得更简单可行"><a href="#3、使状态逻辑复用变得更简单可行" class="headerlink" title="3、使状态逻辑复用变得更简单可行"></a>3、使状态逻辑复用变得更简单可行</h5><ol><li>过去复用状态逻辑，靠的是HOC、renderer Props这些组件设计模式，但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是<strong>“嵌套地狱”</strong>的现象。</li><li>而Hooks可以看做是React解决状态逻复用的原生途径，达到既不破坏组件结构，又能够实现逻辑复用的效果</li><li>这块在第3下一个专题上会展开</li></ol><h5 id="4、从设计思想上更加契合React的理念"><a href="#4、从设计思想上更加契合React的理念" class="headerlink" title="4、从设计思想上更加契合React的理念"></a>4、从设计思想上更加契合React的理念</h5><p>前面的函数组件、类组件已经做了对比分析。</p><h4 id="4、Hooks的局限性"><a href="#4、Hooks的局限性" class="headerlink" title="4、Hooks的局限性"></a>4、Hooks的局限性</h4><p>Hooks并非万能，在认识到Hooks利好的同时，也需要认识到他的局限性。</p><ol><li><p>Hooks暂时还不嫩而过完全第为函数组件补全类组件的能力：<br>比如，某些钩子还是没有；</p></li><li><p>函数组件仍然是“轻量”，这可能使得它并不能很好地消化“复杂”</p></li><li><p>在使用层面严格的约束</p><p>耦合和内聚的边界很难把握，函数式组件给了更多自由，却对开发者代码能力提了更高的要求。</p></li></ol><h3 id="三、how：深入React-Hooks工作机制"><a href="#三、how：深入React-Hooks工作机制" class="headerlink" title="三、how：深入React-Hooks工作机制"></a>三、how：深入React-Hooks工作机制</h3><h4 id="1、HOOKS的使用原则2个："><a href="#1、HOOKS的使用原则2个：" class="headerlink" title="1、HOOKS的使用原则2个："></a>1、HOOKS的使用原则2个：</h4><ol><li><p>只在函数组件中调用Hook</p></li><li><p>不要在循环、条件、嵌套函数中调用Hook</p><p>目的：确保Hooks在每次渲染时，都能保持同样的渲染执行顺序。</p></li></ol><h4 id="2、为什么渲染顺序如此重要呢？"><a href="#2、为什么渲染顺序如此重要呢？" class="headerlink" title="2、为什么渲染顺序如此重要呢？"></a>2、为什么渲染顺序如此重要呢？</h4><ul><li><p>如果不保证Hooks执行顺序会导致什么问题？</p><p>下面的代码按照意图，预期希望初次渲染时，展示出来，点击后，只获取carrer，并且名字修改更新（第二次渲染）</p><p>现象：组件没有发生变化，且报错渲染Hooks钩子减少。</p><p>初次渲染输出：isMounted是false， carrer：搬砖</p><p>单机修改按钮：isMounted为true，但carrer：小1，为什么发生的是carrer呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eslint-disable-next-line   禁止校验</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isMounted = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name, age, career, serName, setCareer;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;isMounted is:&#x27;</span>, isMounted);</span><br><span class="line">  <span class="keyword">if</span>(!isMounted)&#123;</span><br><span class="line">    [name, setName] = useState(<span class="string">&#x27;小1&#x27;</span>);</span><br><span class="line">    [age] = useState(<span class="string">&#x27;100&#x27;</span>);</span><br><span class="line">    isMounted = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [career, setCareer] = useState(<span class="string">&#x27;搬砖&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;career&#x27;</span>, career);</span><br><span class="line">  rerurn (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">&quot;personInfo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;&#123;name&#125; ? <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名： &#123;name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> : null&#125;</span></span><br><span class="line"><span class="xml">      &#123;&#123;age&#125; ? <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄： &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> : null&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>职业：&#123;career&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">        setName(&#x27;小2&#x27;);</span></span><br><span class="line"><span class="xml">      &#125;&#125;&gt;</span></span><br><span class="line"><span class="xml">        修改姓名</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、源码调用流程"><a href="#3、源码调用流程" class="headerlink" title="3、源码调用流程"></a>3、源码调用流程</h4><p>Hooks的正常运作，在底层依赖于顺序链表；</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121185614905.png" alt="image-20211121185614905" style="zoom: 33%;" /><h5 id="1、mounState"><a href="#1、mounState" class="headerlink" title="1、mounState"></a>1、mounState</h5><p>useState的调用会落脚到mounState中：</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121185632743.png" alt="image-20211121185632743" style="zoom: 20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121185651487.png" alt="image-20211121185651487" style="zoom: 20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121185932268.png" alt="image-20211121185932268" style="zoom: 20%;" /></p><ul><li><p>主要工作是：初始化Hooks，最需要关注的是mountWorkInProgressHook</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121190156553.png" alt="image-20211121190156553" style="zoom: 25%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121190221958.png" alt="image-20211121190221958" style="zoom:25%;" /></p></li></ul><p>Hooks所有的信息收在Hook对象里，而对象以单向链表的形式相互串联。</p><h5 id="2、mountState"><a href="#2、mountState" class="headerlink" title="2、mountState"></a>2、mountState</h5><p>首次渲染和更新的区别是，是调用的mounState还是updateState。</p><ul><li><p>mountState：首次渲染，构建链表并渲染</p></li><li><p>updateState做的事情：依次遍历链表并渲染。</p></li><li><p>因此Hooks的渲染是通过“一次遍历”来定位每个Hooks的内容的，如果前后两次读到的链表在顺序出现差异，那么渲染的结果自然是不可控的。</p></li><li><p>Hooks的本质是链表。</p></li></ul><h5 id="3、重现2中的执行过程"><a href="#3、重现2中的执行过程" class="headerlink" title="3、重现2中的执行过程"></a>3、重现2中的执行过程</h5><ol><li>首次渲染时的链表结构：</li></ol><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121191404195.png" alt="image-20211121191404195" style="zoom: 20%;" /><ol start="2"><li>第二次渲染时，只有一个钩子</li></ol><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121191424244.png" alt="image-20211121191424244" style="zoom:20%;" /><ol start="3"><li>在更新时，只会按照顺序取到链表头结点</li></ol><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121191456565.png" alt="image-20211121191456565" style="zoom:20%;" />]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的生命周期</title>
      <link href="/2021/12/11/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2021/12/11/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><ul><li><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程</p></li><li><img src="https://img-blog.csdnimg.cn/20200418101911580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX1RvZ2V0aGVy,size_16,color_FFFFFF,t_70" alt="图片转自coderwhy老师" style="zoom: 33%;" /></li></ul><h3 id="2-各个钩子的作用"><a href="#2-各个钩子的作用" class="headerlink" title="2. 各个钩子的作用"></a>2. 各个钩子的作用</h3><p><strong>过程：</strong>均不可用——初始数据获取，方法——虚拟Dom创建 ——el完成挂载，真实DOM创建——Diff算法，打补丁——更新数据</p><h5 id="1）beforeCreate："><a href="#1）beforeCreate：" class="headerlink" title="1）beforeCreate："></a>1）beforeCreate：</h5><ul><li>在<strong>实例初始化之后</strong>，数据观测(data observer) 和 event/watcher 事件配置之前被调用</li><li>特点： data、methods、computed 以及 watch 上的数据和方法都不能被访问</li></ul><h5 id="2）created："><a href="#2）created：" class="headerlink" title="2）created："></a>2）created：</h5><ul><li>实例已完成以下的配置：<ul><li><strong>数据劫持 (data observer)，属性和方法</strong>的运算。</li><li>数据已经和<strong>data属性绑定</strong>（放在data中的属性将来值发生改变的同时，视图也会改变）</li></ul></li><li>此时操作数据，不会触发update函数，一般在这里做初始数据的获取，且相比在 beforeMount 获取数据页面渲染速度较快</li><li>然而，**<code>$el</code> 属性**目前尚不可用。如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom</li></ul><h5 id="3）beforeMount"><a href="#3）beforeMount" class="headerlink" title="3）beforeMount"></a>3）beforeMount</h5><ul><li><p>在挂载开始之前被调用：</p><p>相关的 <code>render</code> 函数首次被调用。</p><p><strong>虚拟dom 创建完成，真实 dom未完成挂载</strong>，这里更改数据不会触发 update函数，这里是渲染前最后一次更改数据的机会，在这里也可以做初始数据的获取</p></li></ul><h5 id="4）mounted："><a href="#4）mounted：" class="headerlink" title="4）mounted："></a>4）mounted：</h5><ul><li>实例完成的配置：<ul><li><strong>完成了挂载，这时 <code>el</code></strong> 被新创建的 <code>vm.$el</code> 替换了。</li><li><strong>数据、真实dom</strong>都已经处理，一般在这里初始化一些操作真实 dom 的方法</li></ul></li><li>注意：此阶段不会保证所有的子组件也都一起被挂载，如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a></li></ul><h5 id="5）beforeUpdate："><a href="#5）beforeUpdate：" class="headerlink" title="5）beforeUpdate："></a>5）beforeUpdate：</h5><ul><li><p>时机：当组件或实例的数据更改，会立即执行beforeUpdate，发生在虚拟 DOM 打补丁之前</p></li><li><p>特点：可以监听到 <strong>data 变化，但view层的数据还没有变化</strong></p></li><li><p>适合：在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器</p></li></ul><h5 id="6）updated："><a href="#6）updated：" class="headerlink" title="6）updated："></a>6）updated：</h5><ul><li><p>时机：完成虚拟 DOM 重新渲染和打补丁后，来到这个钩子</p></li><li><p>特点：</p><ul><li><p>此时组件 DOM 已经更新，可以操作更新后的虚拟dom，view层的数据重新渲染完成；</p></li><li><p>应该避免在此期间更改状态，如果要相应状态改变，通常最好使用<a href="https://cn.vuejs.org/v2/api/#computed">计算属性</a>或 <a href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之；</p></li><li><p><strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p></li></ul></li></ul><h5 id="7）beforeDestroy："><a href="#7）beforeDestroy：" class="headerlink" title="7）beforeDestroy："></a>7）beforeDestroy：</h5><ul><li>时机：实例销毁之前调用，实例仍然完全可用</li><li>工作：做一些善后工作，例如**清除计时器、数据和事件的监听等 ** </li></ul><h5 id="8）destroyed："><a href="#8）destroyed：" class="headerlink" title="8）destroyed："></a>8）destroyed：</h5><ul><li>时机：实例销毁后调用，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</li></ul><h5 id="9）activated：被-keep-alive-缓存的组件激活时调用"><a href="#9）activated：被-keep-alive-缓存的组件激活时调用" class="headerlink" title="9）activated：被 keep-alive 缓存的组件激活时调用"></a>9）activated：被 keep-alive 缓存的组件激活时调用</h5><ul><li>keep-alive：当在组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题</li></ul><h5 id="10）deactivated：被-keep-alive-缓存的组件停用时调用"><a href="#10）deactivated：被-keep-alive-缓存的组件停用时调用" class="headerlink" title="10）deactivated：被 keep-alive 缓存的组件停用时调用"></a>10）deactivated：被 keep-alive 缓存的组件停用时调用</h5><h5 id="11）errorHandler：被-keep-alive-缓存的组件停用时调用"><a href="#11）errorHandler：被-keep-alive-缓存的组件停用时调用" class="headerlink" title="11）errorHandler：被 keep-alive 缓存的组件停用时调用"></a>11）errorHandler：被 keep-alive 缓存的组件停用时调用</h5><ul><li><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm, info</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="12）errorCaptured"><a href="#12）errorCaptured" class="headerlink" title="12）errorCaptured"></a>12）errorCaptured</h5><ul><li>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播</li><li>触发时机都是相同的，不同的是 errorCaptured 发生在前，且如果某个组件的 errorCaptured 方法返回了 false，那么这个异常信息不会再向上冒泡也不会再调用 errorHandler 方法</li></ul><h3 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h3><h4 id="1-调用异步请求"><a href="#1-调用异步请求" class="headerlink" title="1. 调用异步请求"></a>1. 调用异步请求</h4><ul><li>可以 created、beforeMount、mounted 中调用：在这三个钩子函数中，<strong>data 已经创建</strong>，可以将服务端端返回的<strong>数据进行赋值。</strong></li><li>如果异步请求不需要依赖 Dom 推荐在 <strong>created</strong> 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<ul><li>能更快获取到服务端数据，减少页面  loading 时间；</li><li>ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></li></ul><h4 id="2-el选项对生命周期影响："><a href="#2-el选项对生命周期影响：" class="headerlink" title="2. el选项对生命周期影响："></a>2. el选项对生命周期影响：</h4><ul><li><p><strong>没有el选项，则停止编译</strong>，也意味着暂时停止了生命周期。生命周期到created就结束了</p></li><li><p>而当我们不加el选项，但是手动执行<code>vm.$mount(el)</code>方法的话，也能够使暂停的生命周期进行下去</p></li><li><p><code>template</code>和<code>HTML</code>的优先级：</p><blockquote><p>结论</p></blockquote><ol><li>如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数</li><li>如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高</li><li>如果1,2条件都不具备，则报错</li></ol><blockquote><p>注意</p></blockquote><ol><li>Vue需要通过el去找对应的template，Vue实例通过el的参数，首先找自己有没有template，如果没有再去找外部的html，找到后将其编译成render函数。</li><li>runtime-only也可以直接调用<a href="https://cn.vuejs.org/v2/api/#render">render</a>选项，优先级：<code>render函数选项  &gt; template参数  &gt; 外部HTML</code></li></ol></li></ul><h3 id="4-父子组件"><a href="#4-父子组件" class="headerlink" title="4. 父子组件"></a>4. 父子组件</h3><ul><li><h4 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a>执行顺序：</h4><ul><li><p>加载渲染过程：父要等子的挂载</p><p><code>父beforeCreate </code>—-<code>父created</code>——<code>父beforeMounted</code>——<code>子beforeCreate </code>——<code>子created</code>——<code>子beforeMounted</code>—<code>子mounted</code>——<code>父mounted</code></p></li><li><p>子组件更新过程：父要等子的更新</p><p><code>父beforeUpdate</code>—-<code>子beforeUpdate</code>—<code>子updated</code>—<code>父updated</code></p></li><li><p>父组件更新过程</p><p><code>父 beforeUpdate</code> -&gt; <code> 父 updated</code></p></li><li><p>销毁过程</p><p><code>父beforeDestroy</code>—-<code>子beforeDestroy</code>—-<code>子destroyed</code>—-<code>父destroyed</code></p></li></ul></li><li><h4 id="数据传输流程："><a href="#数据传输流程：" class="headerlink" title="数据传输流程："></a>数据传输流程：</h4><ul><li>当子组件被点击后，会向外emit一个事件，父组件会监听这个自定义事件，methods里改变data的list</li><li>这个list会由于单向数据流，传递给子组件</li><li>所以子组件列表渲染好了，此时父组件才整个更新：<code>父beforeUpdate</code>—-<code>子beforeUpdate</code>—<code>子updated</code>—<code>父updated</code></li></ul></li><li><h4 id="场景设计："><a href="#场景设计：" class="headerlink" title="场景设计："></a>场景设计：</h4><p><strong>层级：</strong>父–子–孙  3级层级组件</p><p><strong>需求：</strong>在组件显示在页面上之后，再将数据初始化进行回显。父组件获取数据后传递到子组件，要求子组件根据这个值将内部元数据进行加工，那么<strong>在子组件中什么时机下才能获取父组件传递过来的新值呢？</strong></p><p><strong>分析：</strong></p><ol><li>子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件<code>mounted</code>中获取api的数据，子组件的<code>mounted</code>是拿不到的</li><li>发现<code>created</code>这个钩子是按照从外内顺序执行，所以<strong>回显场景</strong>的解决方案是：在created中发起请求获取数据，依次在子组件的created中会接收到这个数据</li><li>问题在于如何在子组件中知道远程数据回来了，并且通过对远程数据的加工处理，最终形成正确的回显</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的生命周期</title>
      <link href="/2021/12/11/React%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2021/12/11/React%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h2><h3 id="1、组件与虚拟DOM"><a href="#1、组件与虚拟DOM" class="headerlink" title="1、组件与虚拟DOM"></a>1、组件与虚拟DOM</h3><h4 id="虚拟DOM："><a href="#虚拟DOM：" class="headerlink" title="虚拟DOM："></a>虚拟DOM：</h4><ul><li><strong>组件初始化时：</strong><ul><li>调用render方法 — 生成虚拟DOM —再通过ReactDom.render()—生成真实Dom</li></ul></li><li><strong>组件更新时：</strong><ul><li>通过render方法 —– 生成新的虚拟DOM——借助diff算法——-定位出两次虚拟Dom的差异</li></ul></li></ul><h4 id="组件化："><a href="#组件化：" class="headerlink" title="组件化："></a>组件化：</h4><p>React中所有可见、不可见的都可以被抽象为组件，每个组件既是“封闭”的，也是“开放”的；</p><p><strong>封闭</strong>：针对渲染工作流而言</p><ul><li>在每个组件自身的渲染工作流中，每个组件都只处理它内部的逻辑，各自为政</li><li><strong>渲染工作流：</strong>组件数据改变到组件实际更新发生的过程</li></ul><p><strong>开放</strong>：针对组件通信而言</p><ul><li>React允许开发者基于“单向数据流”的原则完成组件的通信</li><li>而组件之间的通信又将改变通信双方/某一方内部的数据流，进而对渲染结果构成影响；</li></ul><h4 id="组件的分类"><a href="#组件的分类" class="headerlink" title="组件的分类"></a>组件的分类</h4><ul><li>这些概念有很多重叠，但是他们最主要是关注数据逻辑和UI展示的分离：<ul><li>函数组件、无状态组件、UI组件主要关注UI的展示;</li><li>类组件、有状态组件、容器组件主要关注数据逻辑</li></ul></li></ul><h5 id="1-无状态、有状态组件"><a href="#1-无状态、有状态组件" class="headerlink" title="1. 无状态、有状态组件"></a>1. 无状态、有状态组件</h5><p>根据组件内部是否有状态需要维护</p><ul><li><h5 id="无状态组件："><a href="#无状态组件：" class="headerlink" title="无状态组件："></a>无状态组件：</h5><ol><li><p>是一个函数，组件中只有一个render函数，会接受一个props，返回组件，只负责展示，例如函数组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloComponent</span>(<span class="params">props</span>) </span>&#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：简单清晰，容易理解，可读性较好；</p><p>缺点：满足不了复杂的应用，往往需要结合<strong>高阶组件</strong>使用，利用高阶组件托管所需状态数据；</p></li><li><p>举例：例如redux中就是将组件分为<strong>容器组件</strong>和<strong>ui组件</strong></p><p>容器组件作为一个高阶组件，<strong>提供数据和行为给ui组件或者其他的容器组件</strong>，负责调用action，并作为回调给展示组件，因此容器组件通常是有状态的，往往作为数据源；</p><p>而ui组件关心组件的展示，通过props接收数据和回调很少有它们自己的state，有也是UI状态而不是数据</p></li></ol></li><li><h5 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h5><ol><li><p><strong>特点：</strong>组件内部包含状态，并且状态随着事件或者外部的消息而发生改变，这就构成了有状态组件。使用有状态组件通常会结合react的生命周期钩子控制组件状态更新的时机</p></li><li><p>react中，有两种更新组件的方式：props和state。</p><p>props是只读的，只能由父组件控制；而state是由组件内部维护的。</p><p>无状态组件通常只通过props来存储数据，而有状态组件使用state来存储数据</p></li></ol></li></ul><h5 id="2-UI-容器组件"><a href="#2-UI-容器组件" class="headerlink" title="2. UI/容器组件"></a>2. UI/容器组件</h5><ul><li><h5 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h5><p>负责页面的渲染，将todolist关于页面渲染相关的内容全部放到ToDoListUI.js文件中，只负责页面的显示而不是逻辑，所以也叫傻瓜组件</p></li><li><h5 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h5><p>负责业务逻辑的代码，而不是组件的页面。所以也叫聪明组件，ToDoList组件</p></li></ul><h5 id="3-函数组件-类组件"><a href="#3-函数组件-类组件" class="headerlink" title="3. 函数组件/类组件"></a>3. 函数组件/类组件</h5><ul><li><h5 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h5><ol><li>本质是JS函数，只是return的内容是描述页面展示内容的React元素</li><li>也会被更新并挂载，但是没有生命周期函数;可以通过hooks来模拟一些生命周期</li><li>没有this(组件实例);</li><li>没有内部状态(state); </li></ol></li><li><h5 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h5><ol><li>必须实现render函数， class 组件中唯一必须实现的方法</li><li>constructor：可选，常用来初始化数据</li></ol></li></ul><h5 id="4-受控-非受控组件"><a href="#4-受控-非受控组件" class="headerlink" title="4.  受控/非受控组件"></a>4.  受控/非受控组件</h5><ul><li><h5 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h5><ol><li><p><strong>可变状态</strong>通常保存在组件的状态属性中，并且只能使用 setState() 更新；</p></li><li><p>而包裹着受控表单组件的React父组件控制着在后续用户输入时该表单中发生的情况；</p></li><li><p>以这种<strong>由React控制的输入表单元素而改变其值的方式</strong>，称为：“受控组件”。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="built_in">this</span>.state.value /&gt;;</span><br></pre></td></tr></table></figure></li><li><h5 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h5><ul><li><p>受控与非受控，关键在于站在哪个视角去看，</p></li><li><p>对于一组包含关系的父子组件，如果子组件的状态不受父组件控制，而是子组件在其内部维护了自己的状态state，对于父组件来说，子组件就是一个非受控组件。</p></li><li><p>相反的，如果父组件可以通过props控制子组件的展示状态，那他就是一个受控组件。</p></li></ul></li></ul><h3 id="2、生命周期的本质：render方法为react组件的“灵魂“；"><a href="#2、生命周期的本质：render方法为react组件的“灵魂“；" class="headerlink" title="2、生命周期的本质：render方法为react组件的“灵魂“；"></a>2、生命周期的本质：render方法为react组件的“灵魂“；</h3><ul><li><p>虚拟DOM、组件化这两个概念，都在围绕这render方法，虚拟DOM的生成需要render、而组件化中跟的渲染工作流这个过程同样离不开render；</p></li><li><p>如果将render方法比喻为灵魂，render之外的生命周期可以理解为组件的躯干</p></li><li><p>躯干和灵魂共同构成了完整而不可分割的生命时间轴</p></li></ul><h3 id="3、15生命周期"><a href="#3、15生命周期" class="headerlink" title="3、15生命周期"></a>3、15生命周期</h3><img src="https://img-blog.csdnimg.cn/20210713213159633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhZ256b25n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h4 id="1-初始化：初次渲染阶段"><a href="#1-初始化：初次渲染阶段" class="headerlink" title="1. 初始化：初次渲染阶段"></a>1. 初始化：初次渲染阶段</h4><ol><li><p><code>constructor</code> 构造函数：主要2件事</p><ul><li>给 this.state 赋值对象来初始化内部的state;</li><li>为事件绑定实例(this);</li></ul><ul><li>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数</li></ul></li><li><p><code>componentWillMount</code> 组件初始化渲染前调用1次</p></li><li><p><strong><code>render</code> 组件渲染</strong>                 <strong>重要 高频</strong></p><ul><li>注意：render在执行过程中并不会真实操作Dom，它的工作是把需要渲染的内容返回出来</li><li>真实的Dom渲染工作在初始化阶段是由ReactDOM.render()干的；</li></ul></li><li><p><strong><code>componentDidMount</code> 组件挂载到 <code>DOM</code> 后调用</strong>                      <strong>高频</strong></p><ul><li><strong>只执行1次，后续修改数据，不会执行</strong>,可做的操作：<ul><li>依赖于DOM的操作、开启定时器、发送网络请求、订阅消息</li></ul></li></ul></li></ol><h4 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2. 更新阶段"></a>2. 更新阶段</h4><ul><li><h5 id="情况1：state触发更新的流程：-状态更新-this-state"><a href="#情况1：state触发更新的流程：-状态更新-this-state" class="headerlink" title="情况1：state触发更新的流程： 状态更新   this.state"></a>情况1：state触发更新的流程： 状态更新   this.state</h5><ol><li><p><code>shouldComponentUpdate</code> 组件是否需要更新</p></li><li><p><code>componentWillUpdate</code> 组件更新前调用：</p></li><li><p><code>render</code> 组件渲染                                             <strong>重要 高频</strong></p></li><li><p><code>componentDidUpdate</code> 组件更新后调用：</p></li></ol></li><li><h5 id="情况2：父组件render触发的更新流程：-父组件更新"><a href="#情况2：父组件render触发的更新流程：-父组件更新" class="headerlink" title="情况2：父组件render触发的更新流程： 父组件更新"></a>情况2：父组件render触发的更新流程： 父组件更新</h5><ol><li><p><code>componentWillReceiveProps</code> ：</p><p>注意：如果父组件导致组件重新渲染，即使props没有更改，也会调用此方法；如果只是想处理更改，请确保进行当前值与变更值的比较；（官网）</p><ul><li>所以这个钩子的触发并不是props更新触发的，而是父组件触发的。即使props并没有更新</li></ul></li><li><p><code>shouldComponentUpdate</code> 组件是否需要更新：                 <strong>性能优化</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br><span class="line">* 返回值：默认true；并且只要写了这个钩子，就必须写true/false，不允许你不写</span><br><span class="line">* 如果这个函数返回fasle，类比于阀门关闭，后面的所有流程都不往下走</span><br></pre></td></tr></table></figure></li><li><p><code>componentWillUpdate</code> 组件更新前调用</p></li><li><p><code>render</code> 组件渲染                                                <strong>重要 高频</strong></p></li><li><p><code>componentDidUpdate</code> 组件更新后调用</p></li></ol></li><li><h5 id="情况3：forceUpdate触发更新的流程：强制更新"><a href="#情况3：forceUpdate触发更新的流程：强制更新" class="headerlink" title="情况3：forceUpdate触发更新的流程：强制更新"></a>情况3：forceUpdate触发更新的流程：强制更新</h5><p>通过调用<code>this.forceUpdate()</code>，不更改任何数据，强制更新</p><ol><li><code>componentWillUpdate</code> 组件更新前调用</li><li><code>render</code> 组件渲染                                                <strong>重要 高频</strong></li><li><code>componentDidUpdate</code> 组件更新后调用：<ul><li>基于组件更新后的Dom操作</li><li>基于props的更新，来进行新的网络请求</li></ul></li></ol></li></ul><h4 id="3、卸载"><a href="#3、卸载" class="headerlink" title="3、卸载"></a>3、卸载</h4><ul><li><code>componentWillUnmount</code> 组件卸载前调用：             <strong>高频</strong></li><li>调用场景：<ol><li>组件在父组件中被移除了</li><li>组件中设置了key属性，父组件在render的过程中，发现key和上一次不一致</li><li>清除 timer、取消网络请求或清除、取消在 componentDidMount() 中创建的订阅</li></ol></li></ul><h3 id="4、生命周期16-3"><a href="#4、生命周期16-3" class="headerlink" title="4、生命周期16.3"></a>4、生命周期16.3</h3><img src="https://img-blog.csdnimg.cn/2021071322465195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhZ256b25n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /><h4 id="1、初始化阶段"><a href="#1、初始化阶段" class="headerlink" title="1、初始化阶段"></a>1、初始化阶段</h4><p>对比15：</p><ol><li><p>将<code>componentWillMount</code>替换为<code>getDerivedStateFromProps</code>：但只是工作流程的废弃，而不是替代。</p><p><code>getDerivedStateFromProps</code>：只有一个用途，使用props来更新/派生state。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getDerivedStateFromProps(props, state)</span><br><span class="line"><span class="comment">// 1. 当前组件接收到的来自父组件的props,自身的 state；</span></span><br><span class="line"><span class="number">2.</span> 需要一个对象格式的返回值，否则会警告。因为react需要这个返回值更新组件的state；因此当你不需要派生state时，最好不要写这钩子，否则<span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>挂载、更新</strong>的两个阶段都会调用；</p></li><li><p>是一个静态方法，不是实例调用的，是类自身调用的，static；在这个组件内部访问不到this，否则报错</p></li><li><p>必须返回值</p><p>返回null则说明不需要更新 <code>state</code> ；返回状态对象（对象，且必须得和state里面对应）</p></li><li><p>该方法对state的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新；更新后，原属性与更新属性并存；</p></li><li><p>从接收到的props中，得到一个派生的状态：每次接收新的props之后都会返回一个对象作为新的 <code>state</code> 。<strong>你的状态state什么时候都会完全取决于props</strong>，初始化之类的不起作用</p></li></ul></li><li><p>render方法改进：</p><p>16之前render方法必须返回单个元素，而16允许返回元素数组和字符串</p></li></ol><h4 id="2、更新阶段"><a href="#2、更新阶段" class="headerlink" title="2、更新阶段"></a>2、更新阶段</h4><p>对比15：</p><ol><li><p>废弃了<code>componentWillReceivePorps</code>，增加了<code>getDerivedStateFromProps</code></p></li><li><p>废弃了<code>componentWillUpdate</code>，新增了<code>getSnapshotBeforeUpdate</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate（参数1， 参数2）</span><br><span class="line">参数1：是之前的props；</span><br><span class="line">参数2：是之前的state，都不是最新的；</span><br><span class="line">返回值：必须有，否则警告。返回null</span><br></pre></td></tr></table></figure><ul><li><p>触发时间: 在 <code>render</code> 之后，在真实 <code>dom</code> 渲染之前</p></li><li><p>返回值会传递给下个钩子：<code>componentDidUpdat</code>的第三个参数</p></li><li><p>使用的场景：可以用于获取前后更新的dom的某些状态，例如高度、滚动高度等等</p><p>实现一个内容会发生变化的滚动列表，要求根据滚动列表的内容是否发生变化来决定是否要记录滚动条的当前位置</p></li></ul></li></ol><h5 id="3、卸载：相同"><a href="#3、卸载：相同" class="headerlink" title="3、卸载：相同"></a>3、卸载：相同</h5><h4 id="5、为什么废弃某些钩子？"><a href="#5、为什么废弃某些钩子？" class="headerlink" title="5、为什么废弃某些钩子？"></a>5、为什么废弃某些钩子？</h4><ol><li><p>废弃了componentWillMount</p></li><li><p>getDerivedStateFromProps代替了componentWillUpdate</p></li></ol><p>与componentWillUpdate一起，这个新生命周期涵盖过时componentWillReceivePorps的所有用例。</p><ul><li><p>getDerivedStateFromProps代替了componentWillReceivePorps，但不是百分之百cover到</p></li><li><p>为啥不能完全cover住呢？</p><p>它做一件事：实现基于props派生state；</p><p>这个方法被封装为静态方法，使得你不能直接获取this，所以也无法操作this.state这类可能产生副作用的工作，因此这个钩子替换是react强制推行getDerivedStateFromProps，使用props到state的映射，再确保生命周期函数的行为更加可控，帮开发者避免不合理的编程方式，同时也是在为新的fiber架构铺路；</p></li></ul><p><code>componentWillMount</code>的存在鸡肋且危险，因此它不值得被替代，应该废弃；为什么呢？</p><ul><li><p>与fiber有关，出于render阶段，因此都可能被反复执行；另一方面，这些钩子常年被滥用的过程中，存在风险</p></li><li><p>比如某些骚操作：</p><ol><li>setState()：</li><li>发起异步请求</li><li>操作真实Dom</li></ol></li><li><p>不合理的原因：</p><ol><li><p>完全可以转移到其他生命周期里去做：</p><p>比如发起异步请求，会有人错认为这样就可以让异步请求早点回来，避免渲染白屏；</p><p>但异步请求再怎么快也快不过同步的生命周期，componentwillmount结束后，render会迅速的触发，首次渲染依然会在数据返回之前执行；</p><p>这样做，不仅达不到预想的目的，还会造成服务端的冗余请求等额外问题，得不偿失；</p></li><li><p>fiber带来的异步渲染机制下，可能会导致非常严重bug：</p><p>假如你在这个钩子里发了个付款请求：</p><p>由于render阶段的生命周期都可以重复执行，在componentwill***被打断+重启多次后，就会发出多个付款请求。</p><p>假如商品只要10元，用户也只点了一次付款，却因为钩子的打断重启，导致接口频繁调用，导致多付了钱；</p><p>再比如，在componentWillReceivePorps里操作Dom，若该钩子执行了2次，可能会删除两个符合某特征的元素</p></li><li><p>getDerivedStateFromProps封装设计</p><p>这个方法被封装为静态方法，使得你不能直接获取this，所以也无法操作this.state这类可能产生副作用的工作，因此这个钩子替换是react强制推行getDerivedStateFromProps，使用props到state的映射，再确保生命周期函数的行为更加可控，帮开发者避免不合理的编程方式，同时也是在为新的fiber架构铺路；</p></li><li><p>即使你没有开启异步，15下也能把自己玩死</p><p><strong>16改造的主要动机是为了配合Fiber架构带来的异步渲染机制；</strong></p><p>比如：componentWillReceivePorps、componentWillUpdate里重复滥用state导致死循环</p></li></ol></li></ul><h4 id="6、Fiber"><a href="#6、Fiber" class="headerlink" title="6、Fiber"></a>6、Fiber</h4><p>fiber是16对核心算法的一次重写：会使原本的同步的渲染过程变成异步的；</p><ul><li><p>在16之前，每当触发react的更新，react都会重新生成一个虚拟DOM树，通过与之前的diff，通过递归的方式实现定向更新；</p><p>同步渲染的递归调用栈很深，只有最底层的返回，才会开始逐层返回；这个漫长且不可打断的过程将会一直占有渲染线程，浏览器此期间处于不能做别的事情，用户体验也不好；</p></li><li><p>16的架构：将一个大的更新任务拆分为几个小任务，每当执行完一个小任务时，都会把主线程交换，让更高优先级的执行，<strong>实行可中断的更新</strong>，避免卡顿；</p></li></ul><h4 id="7、同步、与异步如何影响生命周期？"><a href="#7、同步、与异步如何影响生命周期？" class="headerlink" title="7、同步、与异步如何影响生命周期？"></a>7、同步、与异步如何影响生命周期？</h4><p>Fiber架构的重要特征就是可被打断的异步渲染模式；根据“能否被打断”这一标准，16的生命周期分为了render、commit两个阶段：</p><ul><li><p>render阶段：render及以前：纯净且无副作用，可能会被暂停、终止、重新启动</p><ol><li>因此，该阶段可能打断，为什么呢？</li></ol><p>render阶段的操作对用户来说是不可见的，即使打断再重启，也是0感知；</p><ol start="2"><li><p>被暂停的细节：</p><p>当执行该任务抢回执行的线程时，任务重启的方式并不是从之前暂停的地方执行，而是重新执行该任务，这就导致render阶段的生命周期都是有可能被重复执行的；</p><p><strong>按照这个结论，为什么react打算废弃那几个钩子呢？</strong></p></li></ol></li><li><p>pre-commit阶段：可以读取Dom</p></li><li><p>conmit阶段：可以使用Dom运行副作用、安排更新；</p><p>该阶段总是同步执行的，为什么这样设计呢？</p><p>因为commit阶段涉及到真实Dom渲染，带来视图的更改，求稳</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> React&amp;&amp;Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的过渡transition</title>
      <link href="/2021/12/11/CSS%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
      <url>/2021/12/11/CSS%E7%9A%84%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="1、过渡transition"><a href="#1、过渡transition" class="headerlink" title="1、过渡transition"></a>1、过渡transition</h3><h4 id="1、所有属性都执行"><a href="#1、所有属性都执行" class="headerlink" title="1、所有属性都执行"></a>1、所有属性都执行</h4><ul><li><p>如果希望所有属性都执行过渡动画：</p><ul><li>注意：无先后顺序。如存在持续和延迟两种时间，第一个是持续，第二个是等待</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">简写属性：</span><br><span class="line"><span class="attribute">transition</span>: transition-property | transition-duration | timing-function | delay</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> id = &#x27;box&#x27;&gt; 你好呀，你好&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">3s</span> ease-out <span class="number">1s</span>; // 此时hover里面的所有属性都会发生过渡效果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#box</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、指定属性执行"><a href="#2、指定属性执行" class="headerlink" title="2、指定属性执行"></a>2、指定属性执行</h4><ul><li><p>如果不希望所有的属性都执行过渡动画，可以分开写</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: width, height;</span><br><span class="line"><span class="attribute">transition-duration</span>: 可分别指定时间，用 , 号隔开,单位可秒和毫秒;</span><br><span class="line"><span class="attribute">transition-timing-function</span>: 为过渡效果指定过渡的执行方式</span><br><span class="line">- ease 默认值，慢速开始，先加速，后减速  </span><br><span class="line">- ease-in 加速运动  ease-out 减速运动   ease-in-out 先加速后减速</span><br><span class="line">- linear 匀速运动</span><br><span class="line">- <span class="built_in">cublic-bezier</span>() 贝塞尔曲线</span><br><span class="line">- <span class="built_in">step</span>(步数, start/end) 分步执行过渡效果   start / end 时间开始/结束时执行，默认值</span><br><span class="line">transition-delay: 延迟时间</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id = <span class="string">&#x27;box&#x27;</span>&gt; qwwe&lt;/div&gt;</span><br><span class="line">#box &#123;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  height: 30px;</span><br><span class="line">  background-color: red;</span><br><span class="line">  </span><br><span class="line">  transition-property: width, height;</span><br><span class="line">  transition-duration: 3s, 5s;</span><br><span class="line">  transition-timingfunction: ease-<span class="keyword">in</span>, linear;</span><br><span class="line">  transition-delay: 1s, 3s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#box:hover&#123;</span><br><span class="line">  <span class="attr">width</span>: 400px;</span><br><span class="line">  height: 60px;</span><br><span class="line">  background-color: green;  <span class="comment">// 不会有过渡效果，hover后马上变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、触发方式："><a href="#3、触发方式：" class="headerlink" title="3、触发方式："></a>3、触发方式：</h4><ul><li>常见3种：hover、active（鼠标按下、松开）、focus（表单）</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的flex布局</title>
      <link href="/2021/12/11/CSS%E7%9A%84flex%E5%B8%83%E5%B1%80/"/>
      <url>/2021/12/11/CSS%E7%9A%84flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="弹性盒"><a href="#弹性盒" class="headerlink" title="弹性盒"></a>弹性盒</h2><p>弹性盒：布局手段，代替浮动布局，可以跟随页面大小的改变而改变</p><h3 id="1、弹性容器"><a href="#1、弹性容器" class="headerlink" title="1、弹性容器"></a>1、弹性容器</h3><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img" style="zoom:50%;" /><ul><li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）</li><li><strong>项目默认沿主轴排列</strong>。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</li><li>display: flex; 设置块级弹性容器</li><li>display: inline-flex 设置行内弹性容器（少用）</li><li>弹性元素：<ol><li>弹性容器的子元素是弹性元素，不包含后代元素；</li><li>一个元素可以是弹性盒同时也是弹性元素</li></ol></li></ul><h3 id="2、弹性容器属性"><a href="#2、弹性容器属性" class="headerlink" title="2、弹性容器属性"></a>2、弹性容器属性</h3><h4 id="1、flex-direction-主轴的方向"><a href="#1、flex-direction-主轴的方向" class="headerlink" title="1、flex-direction 主轴的方向"></a>1、flex-direction 主轴的方向</h4><ul><li>row（默认排列方向）、row-reverse、column、column-reverse<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img" style="zoom:50%;" /></li></ul><h4 id="2、flex-wrap-子元素换行"><a href="#2、flex-wrap-子元素换行" class="headerlink" title="2、flex-wrap    子元素换行"></a>2、flex-wrap    子元素换行</h4><p>一条轴线排不下，设置子元素是否换行</p><ul><li>nowrap（默认不换行）<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img" style="zoom: 33%;" /></li><li>wrap：换行，第一行在上方<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img" style="zoom: 33%;" /></li><li>wrap-reverse：换行，但是第一行会在下面<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img" style="zoom: 33%;" /></li></ul><h4 id="3、flex-flow-前2者简写"><a href="#3、flex-flow-前2者简写" class="headerlink" title="3、flex-flow 前2者简写"></a>3、flex-flow 前2者简写</h4><ul><li><code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></li></ul><h4 id="4、justify-content-主轴子元素排列"><a href="#4、justify-content-主轴子元素排列" class="headerlink" title="4、justify-content 主轴子元素排列"></a>4、justify-content 主轴子元素排列</h4><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img" style="zoom: 33%;" /><p>主轴上的子元素的排列方式</p><ul><li>flex-start、center、flex-end    默认 从main start对齐</li><li>space-between，两边贴边，中间平分</li><li>space-evenly，item之间、item和container之间距离都相等</li><li>space-around，平分。所以，<strong>项目之间的间隔比项目与边框的间隔大一倍</strong>。</li></ul><h4 id="5、align-content-侧轴多子元素排列"><a href="#5、align-content-侧轴多子元素排列" class="headerlink" title="5、align-content  侧轴多子元素排列"></a>5、align-content  侧轴多子元素排列</h4><p>侧轴上<strong>子元素的排列方式</strong>（多行） <strong>使用前提是flex-wrap:wrap，要换行</strong></p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img" style="zoom:33%;" /><ul><li>flex-start、flex-end、center（<strong>垂直对齐</strong>）</li><li>space-around、space-between</li><li>stretch：默认值，将元素的长度设置为相同的值</li></ul><h4 id="6、align-items-侧轴单子元素排列"><a href="#6、align-items-侧轴单子元素排列" class="headerlink" title="6、align-items 侧轴单子元素排列"></a>6、align-items 侧轴单子元素排列</h4><p>侧轴上<strong>子元素的排列方式</strong>（单行）</p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img" style="zoom:33%;" /><ul><li>flex-start、flex-end、center（<strong>垂直对齐</strong>）：交叉轴顶部对齐，item有高度的情况下，就是顶部对齐</li><li>stretch：<strong>默认值</strong>，如果项目未设置高度或设为auto，item纵向拉伸，将占满整个容器的高度</li><li>baseline：item<strong>第一行文字</strong>基线对齐</li></ul><h3 id="3、弹性元素属性"><a href="#3、弹性元素属性" class="headerlink" title="3、弹性元素属性"></a>3、弹性元素属性</h3><h4 id="1、-flex-grow"><a href="#1、-flex-grow" class="headerlink" title="1、 flex-grow"></a>1、 flex-grow</h4><ul><li><p>定义项目的放大比例，默认为<code>0</code>，即如果<strong>存在剩余空间，也不放大</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>放大规则：</p><ol><li>所有项目的<code>flex-grow</code>设置为1，则它们将等分剩余空间（如果有的话）</li><li>如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</li></ol></li></ul><h4 id="2、-flex-shrink"><a href="#2、-flex-shrink" class="headerlink" title="2、 flex-shrink"></a>2、 flex-shrink</h4><ul><li><p>定义了项目的缩小比例，默认为<code>1</code>，即<strong>如果空间不足，该项目将自动缩小</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缩小规则：</p><ol><li>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小</li><li>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小</li><li>负值对该属性无效</li></ol></li></ul><h4 id="3、-flex-basis"><a href="#3、-flex-basis" class="headerlink" title="3、 flex-basis"></a>3、 flex-basis</h4><ul><li><p>定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>auto</code>：首先检索该子元素的主尺寸，如果主尺寸不为 <code>auto</code>，则使用值采取主尺寸之值；如果也是 <code>auto</code>，则使用值为 <code>content</code>。</li><li><code>content</code>：指根据该子元素的内容自动布局。有的用户没有实现取 <code>content</code> 值，等效的替代方案是 <code>flex-basis</code> 和主尺寸都取 <code>auto</code>。</li><li>百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 <code>auto</code> 一样</li></ul></li><li><p>剩余空间的计算：</p><p>剩余空间＝父容器空间－子容器1.flex-basis或width - 子容器2.flex-basis或width - …</p></li></ul><h4 id="4、flex"><a href="#4、flex" class="headerlink" title="4、flex"></a>4、flex</h4><ul><li><code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写</li></ul><blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">flex</span>的可选值：</span><br><span class="line"><span class="attribute">initial</span>  --默认值、表示<span class="attribute">flex</span>：<span class="number">0</span>、<span class="number">1</span>、<span class="attribute">auto</span></span><br><span class="line"><span class="attribute">auto</span> --<span class="attribute">flex</span>：<span class="number">1</span>、<span class="number">1</span>、<span class="attribute">auto</span></span><br><span class="line"><span class="attribute">none</span>  --<span class="attribute">flex</span>：<span class="number">0</span>、<span class="number">0</span>、<span class="attribute">auto</span>，此时表示元素没有弹性</span><br></pre></td></tr></table></figure></blockquote><ul><li><h4 id="flex取值情况"><a href="#flex取值情况" class="headerlink" title="flex取值情况"></a>flex取值情况</h4></li></ul><ol><li><code>默认取值：0 1 auto</code><ul><li>有剩余空间时，不会放大；没有剩余空间时，会缩小</li><li>剩余空间的计算，按指定宽度属性width计算</li></ul></li><li><code>flex：auto（1 1 auto）</code><ul><li>有剩余空间时，会放大；没有剩余空间时，会缩小</li><li>剩余空间的计算按指定宽度属性width计算</li></ul></li><li><code>flex：none（0 0 auto）</code><ul><li>有剩余空间时，不会放大；没有剩余空间时，不会缩小，所以会超出容器</li><li>剩余空间的计算按指定宽度属性width计算</li></ul></li><li><code>flex：1（1 1 0%）</code><ul><li>有剩余空间时，会放大；没有剩余空间时，会缩小</li><li>flex中此元素占据宽度为0，不论flex-shrink为多少，都不再起作用，不会再压缩</li></ul></li><li><code>flex：百分比（1 1 百分比）</code><ul><li>百分比则视为 <code>flex-basis</code> 值，<code>flex-grow</code> 取 <code>1</code>，<code>flex-shrink</code> 取 <code>1</code></li><li>flex中此元素占据宽度为0，不论flex-shrink为多少，都不再起作用，不会再压缩</li></ul></li><li><code>flex：0 （0 0 0）</code><ul><li>有剩余空间时，不会放大；不会缩小，所以会超出容器</li><li>剩余空间的计算按元素内容撑开的宽度</li></ul></li></ol><h4 id="5、其他子项属性"><a href="#5、其他子项属性" class="headerlink" title="5、其他子项属性"></a>5、其他子项属性</h4><ul><li><p><code>align-self</code>：允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img" style="zoom:33%;" /><blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">align-self</span>: auto | flex-start | flex-end | center </span><br><span class="line">   | baseline |  stretch;</span><br><span class="line">&#125;</span><br><span class="line">该属性可能取<span class="number">6</span>个值，除了<span class="attribute">auto</span>，其他都与<span class="attribute">align-items</span>属性完全一致。</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong><code>order</code>：定义项目的排列顺序。数值越小，排列越靠前，默认为0</strong></p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img" style="zoom:33%;" /></li></ul><h3 id="4、flex解决了什么"><a href="#4、flex解决了什么" class="headerlink" title="4、flex解决了什么"></a>4、flex解决了什么</h3>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的定位</title>
      <link href="/2021/12/11/CSS%E7%9A%84%E5%AE%9A%E4%BD%8D/"/>
      <url>/2021/12/11/CSS%E7%9A%84%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="1、定位position"><a href="#1、定位position" class="headerlink" title="1、定位position"></a>1、定位position</h3><ul><li><p><strong>static：</strong>         正常文档流的位置（从上到下，从左到右）</p></li><li><p><strong>relative</strong>：    不脱标， 相对于原本占据的位置，且占用原位    不会改变元素的性质</p></li><li><p><strong>absolute</strong>       脱标   </p><ul><li><p>会改变元素的性质：行内元素变行内块元素，在不手动设置宽高的情况下，该元素的大小为内容的大小，在设置宽高时，大小变为设置的宽高</p></li><li><p>会提升元素层级：可以进行覆盖</p></li><li><p>绝对定位元素是<strong>相对于包含块进行定位的：</strong>其实就是，相对于第一个不是static的父元素定位，如果没有，就以html元素为基准</p><p><strong>包含块概念</strong>：离当前元素最近的祖先块元素</p><p>这里的<strong>包含块概念</strong>：离当前元素最近的，开启了定位的祖先元素。如果所有的祖先元素都没有开启，就相对于html根元素，也是初始包含块</p></li></ul></li><li><p><strong>fixed：</strong>          脱标        相对于浏览器窗口</p><ul><li>大部分特点跟绝对定位很像，唯一不同的是他们的参考系一定是视口（不会随滚动条，固定不动）</li><li>会改变元素的性质：行内元素变行内块元素，在不手动设置宽高的情况下，该元素的大小为内容的大小，在设置宽高时，大小变为设置的宽高</li></ul></li><li><p><strong>sticky：</strong>  基于用户的滚动位置来定位，在 <strong>relative</strong> 与 <strong>fixed</strong> 之间切换</p><ul><li><p>一般它的行为就像 <strong>relative</strong></p></li><li><p>而当页面滚动超出目标区域（特定阈值top, right, bottom 或 left 之一）时，表现就像 <strong>fixed</strong>固定在目标位置</p></li><li><p>指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同</p></li><li><p>相对于：一个sticky元素会“固定”在离它最近的一个有“滚动机制”的祖先上（当该祖先的<code>overflow</code> 是 <code>hidden</code>, <code>scroll</code>, <code>auto</code>, 或 <code>overlay</code>时），即便这个祖先不是最近的真实可滚动祖先</p></li></ul></li></ul><h3 id="2、绝对定位的水平垂直方向布局"><a href="#2、绝对定位的水平垂直方向布局" class="headerlink" title="2、绝对定位的水平垂直方向布局"></a>2、绝对定位的水平垂直方向布局</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子元素Σmargin +border + padding + width +绝对定位的left right=父元素宽度</span><br></pre></td></tr></table></figure><h4 id="水平方向："><a href="#水平方向：" class="headerlink" title="水平方向："></a>水平方向：</h4><ul><li><p>当发生过度约束的时候：</p><ol><li><p>如果9个值没有auto就调整right</p></li><li><p>如果有auto就调整auto，可以设置auto的值是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width、margin、left、right</span><br></pre></td></tr></table></figure></li><li><p>left right的默认值是auto，如果不指定这几个值，默认有auto的值。当等式不满足时，会自动调整这两个值。所以使用margin auto设置居中时，要写上left、right为0。否则会调默认的left、right</p></li></ol></li></ul><h4 id="垂直方向："><a href="#垂直方向：" class="headerlink" title="垂直方向："></a>垂直方向：</h4><p>垂直方向的等式也必须满足：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top + margin2 + padding2 + height + buttom = h</span><br></pre></td></tr></table></figure><ul><li><p>当过度约束时，</p><ol><li><p>如果9个值没有auto就调整buttom</p></li><li><p>如果有auto就调整auto，可以设置auto的值是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height、margin、top、buttom</span><br></pre></td></tr></table></figure></li><li><p>top、buttom的默认值是auto，如果不指定这几个值，默认有auto的值。当等式不满足时，会自动调整这两个值。所以使用margin auto设置居中时，要写上top、buttom为0。否则会调默认的top、buttom</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> position </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的浮动及其应用问题</title>
      <link href="/2021/12/11/CSS%E7%9A%84%E6%B5%AE%E5%8A%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/11/CSS%E7%9A%84%E6%B5%AE%E5%8A%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><h3 id="1、浮动元素"><a href="#1、浮动元素" class="headerlink" title="1、浮动元素"></a>1、浮动元素</h3><h4 id="1、浮动元素的特点"><a href="#1、浮动元素的特点" class="headerlink" title="1、浮动元素的特点"></a>1、浮动元素的特点</h4><ol><li>浮动元素会完全脱离文档流，不再占据文档流中的位置；</li><li>设置浮动后，元素会向父元素的左侧或右侧移动；</li><li>浮动元素默认不会从父元素中移出，边界就是父元素；</li><li>浮动元素，向左或向右移动时，不会超过其他浮动元素；</li><li>如果浮动元素上边是一个不浮动的块级元素，则浮动元素无法上移；（垂直）</li><li>浮动元素不会超过它上边的浮动的兄弟元素，最多就是和它一行；（水平）</li></ol><p><code>float</code>设计的初衷就是为了“文字环绕”效果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、脱离文档流的特点"><a href="#2、脱离文档流的特点" class="headerlink" title="2、脱离文档流的特点"></a>2、脱离文档流的特点</h4><ul><li>块元素<ol><li>块元素不在独占一行</li><li>脱离文档流以后宽度和高度被内容撑开</li></ol></li><li>行内元素<ol><li>行内元素脱离文档流之后会变成块元素，可以设置宽高；也就是不区分行内和块了</li></ol></li></ul><h3 id="2、高度塌陷、清除浮动"><a href="#2、高度塌陷、清除浮动" class="headerlink" title="2、高度塌陷、清除浮动"></a>2、高度塌陷、清除浮动</h3><h4 id="出现场景："><a href="#出现场景：" class="headerlink" title="出现场景："></a>出现场景：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box1 clearfix&quot;&gt;  //无高度</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;box2&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;  //浮动</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>子浮动、父无高度塌陷</p><ul><li><p>浮动布局中，父元素的高度默认是子元素撑开的；</p></li><li><p>当子元素浮动后，其完全脱离文档流，此时子元素无法撑起父元素的高度，导致父元素高度丢失；</p></li><li><p>父元素高度丢失，导致其下的元素会自动上移，导致页面的布局混乱；</p></li></ul><h4 id="怎么解决："><a href="#怎么解决：" class="headerlink" title="怎么解决："></a>怎么解决：</h4><ul><li><h4 id="解决1：clear属性"><a href="#解决1：clear属性" class="headerlink" title="解决1：clear属性"></a>解决1：clear属性</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box1 clearfix&quot;&gt;  // 没有高度</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;box2&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;  // 浮动</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box3&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;  // 会跑到跟box2一行，父元素没有高度</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>为后面的元素添加：clear：both</p><p>效果：这种方式并不能改变前面元素的浮动属性，但是后面的元素不会再受到影响。</p><p><strong>原理：</strong>设置清除后，浏览器会自动为元素添加<strong>上外边距</strong>，使其位置不受其他元素的影响。both属性会清除两侧中，最大影响的那侧；</p></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  // 这种情况下，box3会<span class="attribute">margin-top</span>，撑起来父元素的高度，此时并不是box2撑开的</span><br><span class="line"><span class="attribute">clear</span>：both  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="解决2：原理同上"><a href="#解决2：原理同上" class="headerlink" title="解决2：原理同上"></a>解决2：原理同上</h4><p>解决方式1，在用结构去修改样式，新添加样式。但我们希望css的问题就css解决。</p><ul><li>可以使用css中伪元素选择器</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; //伪元素选择器，行内元素，不会独占一行，要转换一下</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用这种方式，同样可以解决外边距重叠问题</li></ul></li><li><h4 id="解决3：BFC-不是很推荐"><a href="#解决3：BFC-不是很推荐" class="headerlink" title="解决3：BFC       不是很推荐"></a>解决3：BFC       不是很推荐</h4><ul><li><p>方法1：<strong>父元素也设置浮动</strong>               <strong>不推荐</strong></p></li><li><p>方法2：<strong>父级添加overflow</strong>   BFC，在IE6中还需要触发 hasLayout    不是很推荐</p><ul><li>优点：代码简洁，不存在结构和语义化问题</li><li>缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素；</li></ul></li><li><p>方法3：**父元素设置display:table **      <strong>不推荐</strong></p><ul><li> 优点：结构语义化完全正确，代码量极少</li><li> 缺点：盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用</li></ul></li></ul></li></ul><h3 id="3、BFC"><a href="#3、BFC" class="headerlink" title="3、BFC"></a>3、BFC</h3><h4 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h4><p>块级盒子渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用</p><ul><li>BFC本身不会发生<code>margin</code>重叠。</li><li><strong>BFC可以彻底解决子元素浮动带来的的高度坍塌和文字环绕问题。</strong></li></ul><h4 id="2、规则："><a href="#2、规则：" class="headerlink" title="2、规则："></a>2、规则：</h4><ol><li><p>内部<code>box</code>在垂直方向，一个接一个的放置</p><ul><li>内部bx就是块级元素，所以平常div、p是独占一行</li></ul></li><li><p>box的垂直方向由<code>margin</code>决定，<strong>属于同一个BFC的两个box间的margin会重叠</strong></p><ul><li><p>HTML是BFC，所以内部垂直方向的元素margin会发生重叠；</p></li><li><p>但子孙元素与该BFC上下边界margin不能重叠，保证了BFC内部的元素不会影响外部的元素；</p></li><li><p>两个上下相邻的BFC之间折不折叠要看具体情况：</p><p>如display: inline-block、float: left不会折叠；而overflow: hidden会折叠</p></li></ul></li><li><p>每一个盒子的左外边距应该和<strong>包含块</strong>的左边缘相接触。即使存在浮动也是如此，除非子盒子形成了一个新的BFC。</p><ul><li><p>是普通的流布局和定位布局默认贴着“左侧”思想的总结：</p><ol><li><p>包含块未必就是父级元素。对于<code>position: absolute</code>来说，包含块是指第一个<code>positoin</code>不为<code>static</code>的祖先元素</p></li><li><p>BFC中的盒子应该与其自身的包含块相接触，而非与BFC盒子本身相接触</p></li><li><p>BFC中的盒子是与其包含块的 左边缘 相接触，而不是包含块的 <code>left-border</code> 相接触</p><p>左边缘可能是<code>content box</code>的左边缘（非绝对定位如<code>position: relative</code> <code>float: left</code>，也可能是<code>padding box</code>的左边缘（如绝对定位<code>position: absolute</code> <code>position: fixed</code>）</p></li></ol></li></ul></li><li><p>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；</p></li><li><p>一个隔离独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</p></li><li><p>BFC的区域不会与<code>float box</code>重叠；</p></li></ol><h4 id="3、如何触发："><a href="#3、如何触发：" class="headerlink" title="3、如何触发："></a>3、如何触发：</h4><ol><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>overflow</code>不为<code>visible</code></li><li><code>display</code>为<code>inline-block</code>, <code>flex</code>，<code>table</code>，<code>table-cell</code></li></ol><h3 id="4、IFC"><a href="#4、IFC" class="headerlink" title="4、IFC"></a>4、IFC</h3><h4 id="1、包含块"><a href="#1、包含块" class="headerlink" title="1、包含块"></a>1、包含块</h4><ul><li>概念：离当前元素最近的祖先块元素</li><li>作用：元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系</li><li>举例：<ul><li>元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li><li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li><li>fixed的包含块是当前可视窗口</li><li>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li></ul></li></ul></li></ul><h4 id="2、控制框"><a href="#2、控制框" class="headerlink" title="2、控制框"></a>2、控制框</h4><p>块级元素和块框以及行内元素和行框的相关概念</p><p><strong>块框:</strong></p><ul><li><p><strong>块级元素</strong>会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</p></li><li><p><strong>块框</strong>同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被<strong>匿名块框</strong>包围</p></li><li><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">Some text</span><br><span class="line">&lt;P&gt;More text</span><br><span class="line">&lt;/DIV&gt;</span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含</p></li><li><p><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p></li></ul><p><strong>行内框：</strong></p><ul><li><p>一个行内元素生成一个<strong>行内框</strong>，行内元素能排在一行，允许左右有其它元素</p></li><li><p>关于<strong>匿名行内框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/EM&gt; text&lt;/P&gt;</span><br></pre></td></tr></table></figure><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some </code>，<code> text</code>，此时会专门为这些文本生成匿名行内框</p></li></ul><h4 id="3、display属性的影响"><a href="#3、display属性的影响" class="headerlink" title="3、display属性的影响"></a>3、display属性的影响</h4><p><code>display</code>的几个属性也可以影响不同框的生成：</p><ul><li><code>block</code>，元素生成一个块框</li><li><code>inline</code>，元素产生一个或多个的<strong>行内框</strong></li><li><code>inline-block</code>，元素产生一个<strong>行内级块框</strong>，行内块框的内部会被当作块框来格式化（这也是为什么会产生<code>BFC</code>），而此元素本身会被当作行内框来格式化（）</li><li><code>none</code>，<strong>不生成框</strong>，不在格式化结构中，另一个<code>visibility: hidden</code>则<strong>会产生一个不可见的框</strong></li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列</li></ul><h4 id="4-IFC"><a href="#4-IFC" class="headerlink" title="4. IFC"></a>4. IFC</h4><ul><li><p>IFC即行内框产生的格式上下文，行内元素自身如何显示以及在框内如何摆放的渲染规则</p></li><li><p>特点：</p><ul><li>框一个接一个地水平排列，起点是包含块的顶部。</li><li>水平方向上的 margin，border 和 padding 在框之间得到保留</li><li>框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</li></ul></li><li><p><strong>行框</strong></p><p><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong></p></li><li><p>行框的规则：</p><ul><li>行内框的分割：如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中</li><li>行框在堆叠时没有垂直方向上的分割且永不重叠</li><li>行框的宽度由它的包含块和其中的浮动元素决定，高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框</li><li>行框的左边接触到其包含块的左边，右边接触到其包含块的右边</li></ul></li><li><p>补充下IFC规则：</p><ul><li>浮动元素可能会处于包含块边缘和行框边缘之间</li><li>尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</li><li>同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</li><li>当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 <code>text-align</code> 特性</li><li>空的行内框应该被忽略。即不包含文本，保留空白符，margin/padding/border非0的行内元素，<br>以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，并且不是以换行结束的行框，必须被当作零高度行框对待</li></ul></li></ul><h4 id="5、总结："><a href="#5、总结：" class="headerlink" title="5、总结："></a>5、总结：</h4><ul><li>行内元素总是会应用IFC渲染规则</li><li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li><li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li><li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li><li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮动 </tag>
            
            <tag> 高度塌陷 </tag>
            
            <tag> BFC </tag>
            
            <tag> IFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的选择器</title>
      <link href="/2021/12/11/CSS%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2021/12/11/CSS%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS选择器"><a href="#一、CSS选择器" class="headerlink" title="一、CSS选择器"></a>一、CSS选择器</h2><h3 id="1、CSS选择器"><a href="#1、CSS选择器" class="headerlink" title="1、CSS选择器"></a>1、CSS选择器</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/613b29f0bfb74f8e84947e243f865875~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 50%;" /><h4 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h4><ul><li><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* ID 选择器， 如 <span class="selector-id">#id</span>&#123;&#125;</span><br><span class="line">* 类选择器， 如 <span class="selector-class">.class</span>&#123;&#125;</span><br><span class="line">* 标签选择器， 如 <span class="selector-tag">span</span>&#123;&#125;</span><br><span class="line">* 通配选择器， 如 *&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/* 后代选择器  空格隔开   匹配所有符合的后代元素*/</span></span><br><span class="line">    <span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">background</span>: <span class="number">#ff8585</span>  &#125;</span><br><span class="line">    <span class="comment">/* 子元素选择器  &gt; 连接; 匹配符合的直接子元素; 不包括子元素的子元素 */</span></span><br><span class="line">    <span class="selector-class">.div1</span>&gt;<span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: <span class="number">#6155a6</span> &#125;</span><br><span class="line">    <span class="comment">/* 群组选择器  逗号隔开 */</span></span><br><span class="line">    <span class="selector-class">.div1</span>, <span class="selector-class">.div2</span> &#123; <span class="attribute">color</span>: <span class="number">#a7c5eb</span> &#125;</span><br><span class="line">    <span class="comment">/* 相邻兄弟元素选择器  + 连接; 匹配某元素后紧邻的兄弟元素 */</span></span><br><span class="line">    <span class="selector-class">.div3</span> + <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: <span class="number">#fd3a69</span> &#125;</span><br><span class="line">    <span class="comment">/* 兄弟选择器   ~ 连接; 匹配某元素后所有同级的指定元素，强调的是所有的 */</span></span><br><span class="line">    <span class="selector-class">.div5</span> ~ <span class="selector-tag">div</span> &#123;  <span class="attribute">color</span>: <span class="number">#008891</span> ; &#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="伪元素选择器-略"><a href="#伪元素选择器-略" class="headerlink" title="伪元素选择器         略"></a>伪元素选择器         略</h4></li><li><h4 id="伪类选择器-略"><a href="#伪类选择器-略" class="headerlink" title="伪类选择器             略"></a>伪类选择器             略</h4></li><li><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[属性名]</span> 选择含有指定属性的元素</span><br><span class="line"><span class="selector-attr">[属性名=属性值]</span> 选择含有指定属性和属性值的元素</span><br><span class="line"><span class="selector-attr">[属性名^=属性值]</span> 以属性值开头的元素</span><br><span class="line"><span class="selector-attr">[属性名$=属性值]</span> 以属性值结尾的元素</span><br><span class="line"><span class="selector-attr">[属性名*=属性值]</span> 以属性值含有某值的元素</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title^=abc]</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、选择器优先级"><a href="#2、选择器优先级" class="headerlink" title="2、选择器优先级"></a>2、选择器优先级</h4><ul><li>!important（最强势） &gt; 内联(1000) &gt; id(100) &gt; class(10) = 属性选择器 = 伪类选择器 &gt; 标签选择器(1) = 伪元素选择器 &gt; 通用</li><li>权重计算important不参与；它高于没有important的，多个会互相抵消，具体不知道</li><li>权重值相同时，写在后面的样式生效</li><li>如果针对同一元素样式存在冲突且同时存在 !important ，那么选择器总权重值高者生效</li><li>权重即使无限叠加也不能跨层级</li><li>指定大于继承，继承最低</li></ul><h4 id="3、样式优先级"><a href="#3、样式优先级" class="headerlink" title="3、样式优先级"></a>3、样式优先级</h4><ul><li>内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表&gt; @import导入</li></ul><h3 id="2、伪元素选择器"><a href="#2、伪元素选择器" class="headerlink" title="2、伪元素选择器"></a>2、伪元素选择器</h3><ul><li><p>特点：无中生有，用于创建一些不在DOM树中的元素，并为其添加样式</p><p>比如：通过:before 来在一个元素前增加一些文本，并为其添加样式。虽然用户可以看到这些文本，但是实际上不在文档树中</p></li><li><p>用途：</p><ol><li>清除浮动</li><li>辅助生成一些装饰性的箭头之类，保证html语义，不会出现无意义的空元素</li></ol></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ::after 在选中元素的最后添加一个子元素，默认为行内元素 (替换元素上不生效) */</span></span><br><span class="line"><span class="selector-class">.div1</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">content</span>: <span class="string">&#x27;div1 的 after&#x27;</span>; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">color</span>: <span class="number">#ef4f4f</span> &#125;</span><br><span class="line"><span class="comment">/* ::before 在选中元素的第一个位置添加一个子元素 (其他用法同 ::after) */</span></span><br><span class="line"><span class="selector-class">.div2</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content</span>: <span class="string">&#x27;div2 的 before&#x27;</span>; <span class="attribute">margin-right</span>: <span class="number">10px</span>; <span class="attribute">color</span>: <span class="number">#ee9595</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ::first-letter 匹配选中块级元素的第一行的第一个字符 */</span></span><br><span class="line"><span class="selector-class">.div3</span><span class="selector-pseudo">::first-letter</span> &#123; <span class="attribute">color</span>: <span class="number">#ff4646</span> &#125;</span><br><span class="line"><span class="comment">/* ::first-line 匹配选中块级元素的第一行 */</span></span><br><span class="line"><span class="selector-class">.div4</span><span class="selector-pseudo">::first-line</span> &#123; <span class="attribute">color</span>:  <span class="number">#9dab86</span> &#125;</span><br><span class="line"><span class="comment">/* ::marker 匹配选中有序或无序列表的序号或符号 */</span></span><br><span class="line"><span class="selector-class">.div5</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">::marker</span> &#123; <span class="attribute">color</span>: <span class="number">#fdb827</span> &#125;</span><br><span class="line"><span class="comment">/* ::selection 匹配元素中被选中高亮的部分 */</span></span><br><span class="line"><span class="selector-class">.div6</span><span class="selector-pseudo">::selection</span> &#123; <span class="attribute">background</span>: <span class="number">#9dab86</span>; <span class="attribute">color</span>: white &#125;</span><br></pre></td></tr></table></figure><h3 id="3、伪类选择器"><a href="#3、伪类选择器" class="headerlink" title="3、伪类选择器"></a>3、伪类选择器</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/310652ad0bf040cda0b17b4054cecaa1~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 80%;" /><ul><li><p>特点：</p><ol><li>当已有元素处于的某个状态时，为其添加对应的样式</li><li>虽然和普通css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类</li></ol></li><li><p>用途：改变超链接的样式</p></li></ul><h4 id="1、动态伪类"><a href="#1、动态伪类" class="headerlink" title="1、动态伪类"></a>1、动态伪类</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="attribute">color</span>: <span class="number">#11698e</span>; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: <span class="number">#9fb8ad</span>; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123; <span class="attribute">color</span>: <span class="number">#383e56</span>; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123; <span class="attribute">color</span>: <span class="number">#fb743e</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="2、结构性伪类"><a href="#2、结构性伪类" class="headerlink" title="2、结构性伪类"></a>2、结构性伪类</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/* 父元素的第一个子元素且该子元素为 p 的元素 */</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123; <span class="attribute">background</span>: <span class="number">#046582</span>; &#125;</span><br><span class="line">    <span class="comment">/* 父元素中第 2n 个子元素且为 p 的元素 */</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n) &#123; <span class="attribute">background</span>: <span class="number">#bb8082</span>; &#125;</span><br><span class="line">    <span class="comment">/* 父元素中唯一子元素的 i 元素 */</span></span><br><span class="line">    <span class="selector-tag">i</span><span class="selector-pseudo">:only-child</span> &#123; <span class="attribute">background</span>: <span class="number">#865858</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 父元素中第一个 span 元素 */</span></span><br><span class="line">    <span class="selector-tag">span</span><span class="selector-pseudo">:first</span>-of-type &#123; <span class="attribute">background</span>: <span class="number">#6e7582</span>; &#125;</span><br><span class="line">    <span class="comment">/* 父元素中第 2n 个 span 元素 */</span></span><br><span class="line">    <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>n) &#123; <span class="attribute">background</span>: <span class="number">#f39189</span>; &#125;</span><br><span class="line">    <span class="comment">/* 父元素有且仅有一个为 i 的元素 */</span></span><br><span class="line">    <span class="selector-tag">strong</span><span class="selector-pseudo">:only-of-type</span> &#123; <span class="attribute">background</span>: <span class="number">#8e7f7f</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 没有子元素的元素 */</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:empty</span> &#123; <span class="attribute">height</span>: <span class="number">16px</span>; <span class="attribute">background</span>: <span class="number">#bbb</span>; &#125;</span><br><span class="line">    <span class="comment">/* 根元素   HTML 中相当于 &lt;html&gt; */</span></span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123; <span class="attribute">background</span>: <span class="number">#e2d5d5</span>; <span class="attribute">color</span>: <span class="number">#fff</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="3、目标伪类、否定伪类、语言伪类"><a href="#3、目标伪类、否定伪类、语言伪类" class="headerlink" title="3、目标伪类、否定伪类、语言伪类"></a>3、目标伪类、否定伪类、语言伪类</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 目标伪类 :target: 代表一个唯一的页面元素(目标元素)，其 id 与当前URL片段匹配 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:target</span> &#123; <span class="attribute">color</span>: <span class="number">#f05454</span>; &#125;</span><br><span class="line"><span class="comment">/* 否定伪类 :not   注: 仅 Chrome、Firefox 和 Safari 高版本浏览器适用*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:not</span>(<span class="selector-id">#p1</span>)&#123; <span class="attribute">color</span>: <span class="number">#e27802</span>; &#125;</span><br><span class="line"><span class="comment">/* 语言伪类 :lang */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:lang</span>(zh) &#123; <span class="attribute">color</span>: <span class="number">#ffc1b6</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="4、表单类伪类"><a href="#4、表单类伪类" class="headerlink" title="4、表单类伪类"></a>4、表单类伪类</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* :enabled 可用状态 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:enabled</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#7c9473</span>; &#125;</span><br><span class="line">   <span class="comment">/* :disabled 禁用状态 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:disabled</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#cfdac8</span>;  <span class="attribute">cursor</span>: not-allowed; &#125;</span><br><span class="line">   <span class="comment">/* :checked radio 或 checkbox 表单被勾选状态 */</span></span><br><span class="line">   <span class="comment">/* 注意书写顺序，选择元素相同时 :checked 应写在 :enabled/:disabled 后面 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:checked</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#c0e218</span> ; &#125;</span><br><span class="line">   <span class="comment">/* :default 表示一组相关元素中的默认(选中)表单元素   此处 :default 应用于默认设置了 checked 的 radio 表单上 */</span></span><br><span class="line">   <span class="comment">/* 该选择器可以在 &lt;button&gt;, &lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 以及 &lt;option&gt; 上使用 */</span></span><br><span class="line">    <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:default</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#86aba1</span>;&#125;</span><br><span class="line">   <span class="comment">/* :read-write 可读及可写状态。 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-pseudo">:read-write</span> &#123; <span class="attribute">background</span>: <span class="number">#7c9473</span>; &#125;</span><br><span class="line">   <span class="comment">/* :read-only 只读状态 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-pseudo">:read-only</span> &#123; <span class="attribute">background</span>: <span class="number">#cfdac8</span>; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择器 </tag>
            
            <tag> 选择器优先级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的样式隔离</title>
      <link href="/2021/12/11/CSS%E7%9A%84%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB/"/>
      <url>/2021/12/11/CSS%E7%9A%84%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="1、为什么需要css隔离"><a href="#1、为什么需要css隔离" class="headerlink" title="1、为什么需要css隔离"></a>1、为什么需要css隔离</h3><p>基于组件化的搭建系统在提升研发效率的同时，组件化面临着一个痛点—组件样式隔离的问题</p><ul><li>全局污染：CSS 选择器的作用域是全局的，所以很容易引起选择器冲突；而为了避免全局冲突，又会导致类命名的复杂度上升</li><li>复用性低：CSS 缺少抽象的机制，选择器很容易出现重复，不利于维护和复用</li></ul><p>css隔离就是为了解决这个问题，vue 框架已经帮我们实现了 css 模块化, 通过 style 标签的 scoped 指令定义作用域，通过编译为该作用域所有标签生成唯一的属性。如图： </p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b86cc72b94e4df49adb0fba1ffee3eb~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 33%;" /><p> 但是 react 并未给我们实现，解决方案主要有以下几种：</p><img src="https://segmentfault.com/img/bVcQ2Nm" alt="image.png" style="zoom:50%;" /><h3 id="做法1、命名空间-代码维护困难"><a href="#做法1、命名空间-代码维护困难" class="headerlink" title="做法1、命名空间          代码维护困难"></a>做法1、命名空间          代码维护困难</h3><ul><li><p>做法：</p><p>给每个不同模块使用的css规划好命名，以不同的前缀代表不同的含义，实现样式分组，文件分块，达到模块化的目的</p><p>第三方组件在导出 css 文件时，很多都使用的是这种方式：</p><p>比如，<a href="https://link.segmentfault.com/?url=https://github.com/ant-design/ant-design">ant-design</a> 导出的 css 中使用 <code>ant-</code> 前缀标识，<a href="https://link.segmentfault.com/?url=https://github.com/dcloudio/mui">mui</a> 导出的 css 中使用 <code>mui-</code> 前缀标识等等</p></li><li><p>缺点：</p><ol><li>并不是真正意义上的模块化，因为无法避免全局冲突的问题</li><li>编写起来很繁琐，维护成本会很高</li></ol></li></ul><h4 id="最佳实践："><a href="#最佳实践：" class="headerlink" title="最佳实践："></a>最佳实践：</h4><p>比如网易的 css 规范框架 <a href="https://link.segmentfault.com/?url=http://nec.netease.com/">NEC</a>，<a href="https://link.segmentfault.com/?url=http://www.h-ui.net/">H-ui</a></p><ul><li>一个 css 文件不宜过大，可以使用 <code>@import</code> 进行文件分块；</li><li>样式渲染尽量不要使用 <code>#id</code> <code>[attr]</code>，应尽量使用 <code>.class</code>；</li><li>使用 js 库操作 dom 时，尽量不要用 <code>.class</code>，应尽量用 <code>#id</code> <code>data-set</code>，如 <code>$(&#39;#main&#39;), $(&#39;[data-tab=&quot;1&quot;]&#39;)</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-tab</span>=<span class="string">&quot;1&quot;</span>&gt;</span>tab1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-tab</span>=<span class="string">&quot;2&quot;</span>&gt;</span>tab2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-tab-container</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-tab-container</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="做法2-css-modules（导出为-js-）-代码维护困难"><a href="#做法2-css-modules（导出为-js-）-代码维护困难" class="headerlink" title="做法2. css-modules（导出为 js ） 代码维护困难"></a>做法2. css-modules（导出为 js ） 代码维护困难</h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/30/16f5477372d2bee3~tplv-t2oaga2asx-watermark.awebp" alt="总结" style="zoom: 80%;" /><h4 id="1、思想"><a href="#1、思想" class="headerlink" title="1、思想"></a>1、思想</h4><ul><li>使用 <code>js</code> 来加载 <code>css</code> 文件，并将 <code>css</code> 的内容导出为一个对象，使用 <code>js</code> 来渲染整个 dom 树和匹配相应的样式到对应的元素上</li><li>在这个过程中，我们便有机会对 css 做额外的处理，来达到模块化的目的。</li></ul><h4 id="2、做法"><a href="#2、做法" class="headerlink" title="2、做法"></a>2、做法</h4><p><strong>它需要在 jsx 中进行 className 的动态绑定：</strong>，其中对 css 书写需求主要是：</p><ol><li>应用 <code>.class</code>，而非<code>#id</code> <code>[attr]</code>（因为只有 <code>.class</code> 才能导出为对象的属性）；</li><li>推荐用 <code>.className</code> 书写，而非 <code>.class-name</code>（前者可以通过 <code>styles.className</code> 访问，后者需要通过 <code>styles[&#39;class-name&#39;]</code> 才能访问）</li><li>这个功能需要构建工具的支持，如果使用 <a href="https://link.segmentfault.com/?url=http://webpack.js.org">webpack</a> 构建工程的话，可以使用 <a href="https://link.segmentfault.com/?url=https://github.com/webpack-contrib/css-loader">css-loader</a>，并设置 <code>options.modules</code> 为 <code>true</code>， 便可使用模块化的功能了</li></ol><h4 id="3、它的问题："><a href="#3、它的问题：" class="headerlink" title="3、它的问题："></a>3、它的问题：</h4><ol><li><p>问题1：需要先编写样式而不是先编写元素结构和定义 className</p></li><li><p>问题2：在 className 写法上由于需要使用获取对象属性的写法，会导致一些使用连字符的样式类名需要用中括号才行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.container-title &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#123;style[</span>&quot;<span class="attr">container-title</span>&quot;]&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      Hello World</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>问题3：其编译产物中 className 的值会变成一个哈希字符串，类名确实独一无二了，但可读性极差、且如果在作为其他组件的子组件使用时，如果父组件想要覆盖子组件样式，就没法儿支持了</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;_3zyde4l1yATCOkgn-DBWEL&quot;</span>&gt;</span><br><span class="line">Hello World</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">._3zyde4l1yATCOkgn-DBWEL &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4、webpack配置-这个配置已过时，请看excel解析说的"><a href="#4、webpack配置-这个配置已过时，请看excel解析说的" class="headerlink" title="4、webpack配置   这个配置已过时，请看excel解析说的"></a>4、webpack配置   这个配置已过时，请看excel解析说的</h4><p>这个功能需要构建工具的支持，如果使用 <a href="https://link.segmentfault.com/?url=http://webpack.js.org">webpack</a> 构建工程的话，可以 配置 css-loader 或者 scss-loader , module 为 true</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">modules</span>: <span class="literal">true</span>, <span class="comment">// 开启模块化</span></span><br><span class="line">        <span class="attr">localIdentName</span>: <span class="string">&#x27;[path][name]-[local]-[hash:base64:5]&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e81eff3bce7b4d168b7cf72899d75325~tplv-k3u1fbpfcp-watermark.awebp" alt="效果图"></p><p>localIdentName 自定义生成的类名格式，可选参数有：</p><ul><li>[path]表示样式表相对于项目根目录所在的路径(默认不拼接)</li><li>[name] 表示样式表文件名称</li><li>[local] 表示样式表的类名定义名称</li><li>[hash:length] 表示 32 位的 hash 值 注意：只有类名选择器和 ID 选择器才会被模块化控制，类似 body h2 span 这些标签选择器是不会被模块化控制</li></ul><h4 id="4-2-补充"><a href="#4-2-补充" class="headerlink" title="4.2 补充"></a>4.2 补充</h4><h5 id="1、引入css文件："><a href="#1、引入css文件：" class="headerlink" title="1、引入css文件："></a>1、引入css文件：</h5><p>【注意1】：create-react-app, 默认已支持CSS Modules，所以不需webpack做开启模块化的添加配置了；</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#123;styles[<span class="string">&#x27;upload-wrap&#x27;</span>]&#125;&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Upload</span> &#123;<span class="attr">...uploadProps</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">icon</span>=<span class="string">&#123;</span>&lt;<span class="attr">UploadOutlined</span>/&gt;</span>&#125; &gt;上传文件<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">file-text</span>&#x27;]&#125;&gt;</span>支持扩展名: .doc .docx .jpg .png <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Upload</span>&gt;</span></span> </span><br><span class="line">  <span class="comment">// 这两种方式完全一样的：注意cssModule推荐使用驼峰</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">&#123;styles[</span>&#x27;<span class="attr">upload-end</span>&#x27;]&#125;&gt;</span>蛤蛤蛤11<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">&#123;styles.uploadEnd&#125;</span>&gt;</span>蛤蛤蛤22<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>【注意2】：</p><ol><li>以styles[‘upload-end’]形式写的：样式也要这样写</li><li>以styles.uploadEnd形式写的：样式也是uploadEnd，形式对应   <strong>推荐√</strong></li></ol><p>【注意3】：引入方式，这种方式下，<strong>样式不生效的</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>将index.css文件名改为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./style.module.css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>【疑问】：为什么要带module呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2、引入less文件-？"><a href="#2、引入less文件-？" class="headerlink" title="2、引入less文件          ？"></a>2、引入less文件          ？</h5><p>要解决的问题：</p><ol><li><p>配置webpack，让less文件生效：</p><p>配置less-loader，注意less-loader版本降级</p></li><li><p>less文件模块化：</p><p>开启less的模块化</p></li></ol><p>【这部分还没有配置好，~~】</p><h4 id="5、css-module-作用域"><a href="#5、css-module-作用域" class="headerlink" title="5、css module 作用域"></a>5、css module 作用域</h4><ul><li>作用域默认为 local 即只在当前模块生效</li><li>global 被 :global 包裹起来的类名，不会被模块化</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 加上 :global 会全局样式 */</span></span><br><span class="line">:<span class="function"><span class="title">global</span>(<span class="params">.<span class="built_in">global</span>-color</span>)</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: blue;</span><br><span class="line">  :<span class="function"><span class="title">global</span>(<span class="params">.common-width</span>)</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、css-module-高级使用"><a href="#6、css-module-高级使用" class="headerlink" title="6、css module 高级使用"></a>6、css module 高级使用</h4><h5 id="1、和外部样式混用"><a href="#1、和外部样式混用" class="headerlink" title="1、和外部样式混用"></a>1、和外部样式混用</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapperClassNames = classNames(&#123;</span><br><span class="line">  <span class="string">&#x27;common-show&#x27;</span>: visible,</span><br><span class="line">  <span class="string">&#x27;common-hide&#x27;</span>: !visible,</span><br><span class="line">  [styles1[<span class="string">&#x27;view-wrapper&#x27;</span>]]: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用classNames库</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;wrapperClassNames&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 使用模板字符串</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">styles1.content</span>&#125; $&#123;<span class="attr">styles1.color</span>&#125; <span class="attr">common-show</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">  我是文章内容我是文章内容我是文章内容我是文章内容我是文章内容我是文章内容</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2、覆盖第三方-UI-库"><a href="#2、覆盖第三方-UI-库" class="headerlink" title="2、覆盖第三方 UI 库"></a>2、覆盖第三方 UI 库</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 覆盖第三方UI库 样式*/</span>&#125;</span><br><span class="line">&lt;div className=&#123;styles1[<span class="string">&#x27;am-button-custom-wrapper&#x27;</span>]&#125;&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">primary</span>&#x27;&#125; <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> toggle()&#125;&gt;</span></span><br><span class="line"><span class="xml">     &#123;visible ? &#x27;隐藏&#x27; : &#x27;显示&#x27;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  覆盖第三方UI库的 样式</span></span><br><span class="line">.am-button-custom-wrapper &#123;</span><br><span class="line">  :<span class="built_in">global</span> &#123;</span><br><span class="line">    .am-button-primary &#123;</span><br><span class="line">      <span class="attr">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做法3-CSS-in-JS（内置-js，绑定组件）"><a href="#做法3-CSS-in-JS（内置-js，绑定组件）" class="headerlink" title="做法3. CSS-in-JS（内置 js，绑定组件）"></a>做法3. CSS-in-JS（内置 js，绑定组件）</h3><h4 id="1、思想-1"><a href="#1、思想-1" class="headerlink" title="1、思想"></a>1、思想</h4><ul><li><p>思路1：把整个组件的资源进行封装，并只对外暴露一个对象，而调用者无需关心组件的内部实现和资源，直接调用这个对象就够了</p></li><li><p>思路2：就是将 css 内置 js 中，成为 js 的一部分，这样做的目的，一是 css 的模块化，二是直接绑定到组件上</p><p>比如，<a href="https://link.segmentfault.com/?url=https://github.com/mui-org/material-ui">material-ui</a>、<a href="https://link.segmentfault.com/?url=https://github.com/zeit/styled-jsx">styled-jsx</a>、<a href="https://link.segmentfault.com/?url=https://github.com/cssinjs/jss">jss</a>、<a href="https://link.segmentfault.com/?url=https://github.com/vuejs/vue">vue style scoped</a> 便是使用的这种方式</p></li><li><p><strong>缺点</strong>：</p><ol><li>不太符合关注点分离的开发习惯</li><li>不仅会导致js文件的膨胀，并且其构建产物中样式大多是通过 style 内联的形式，这种方式对于样式复写也会造成较高的成本</li></ol></li></ul><h4 id="2、实践1"><a href="#2、实践1" class="headerlink" title="2、实践1"></a>2、实践1</h4><p>比如（以 react 为例），一个 Welcome 组件，包括一个 js 文件、一个 css 文件、图片：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># Welcome 组件</span><br><span class="line">|-- welcome.js</span><br><span class="line">|-- welcome.css</span><br><span class="line">|-- images/</span><br></pre></td></tr></table></figure><p>在 <code>welcome.js</code> 中便可如下加载（使用“导出为 js 对象”的 css 模块化）：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./welcome.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> image1 <span class="keyword">from</span> <span class="string">&#x27;./images/1.jpg&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="3、实践2：styled-jsx"><a href="#3、实践2：styled-jsx" class="headerlink" title="3、实践2：styled-jsx"></a>3、实践2：styled-jsx</h4><p><a href="https://zhuanlan.zhihu.com/p/188318692">jsx组件样式隔离的最佳实践 - 知乎 (zhihu.com)</a></p><ul><li><p><code>styled-jsx</code> 的原理：</p><p>根据当前文件的位置、内容生成一个全局唯一的标识，然后把这个标识追加到组件每一个元素上，每一个样式选择器上，达到模块化的目的</p></li></ul><h5 id="1、安装工具（babel-转码所需）"><a href="#1、安装工具（babel-转码所需）" class="headerlink" title="1、安装工具（babel 转码所需）"></a>1、安装工具（babel 转码所需）</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">npm install --save styled-jsx</span><br></pre></td></tr></table></figure><h5 id="2、配置-babel-plugins（如-babelrc）"><a href="#2、配置-babel-plugins（如-babelrc）" class="headerlink" title="2、配置 babel plugins（如 .babelrc）"></a>2、配置 babel plugins（如 <code>.babelrc</code>）</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;styled-jsx/babel&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、添加源文件代码"><a href="#3、添加源文件代码" class="headerlink" title="3、添加源文件代码"></a>3、添加源文件代码</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">container</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">hello</span>&#x27;&#125;&gt;</span>Hello! Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">hi</span>&#x27;&#125;&gt;</span>Hi!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">jsx</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">            &#123;`</span></span></span><br><span class="line"><span class="css"><span class="xml">            <span class="selector-class">.container</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">              <span class="attribute">color</span>: blue;</span></span></span><br><span class="line"><span class="css"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">            <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">              <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="css"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">            <span class="selector-class">.hello</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">              <span class="attribute">color</span>: yellow;</span></span></span><br><span class="line"><span class="css"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">            <span class="selector-id">#hi</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">              <span class="attribute">color</span>: green;</span></span></span><br><span class="line"><span class="css"><span class="xml">            &#125;`</span></span></span><br><span class="line"><span class="css"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="4、转码"><a href="#4、转码" class="headerlink" title="4、转码"></a>4、转码</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">babel path/to/hello.js -d target/dir</span><br></pre></td></tr></table></figure><p>转码后的文件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _JSXStyle <span class="keyword">from</span> <span class="string">&#x27;styled-jsx/style&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">jsx-234963469</span>&#x27; + &#x27; &#x27; + &#x27;<span class="attr">container</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">jsx-234963469</span>&#x27; + &#x27; &#x27; + &#x27;<span class="attr">hello</span>&#x27;&#125;&gt;</span>Hello! Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">hi</span>&#x27;&#125; <span class="attr">className</span>=<span class="string">&#123;</span>&quot;<span class="attr">jsx-234963469</span>&quot;&#125;&gt;</span>Hi!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">_JSXStyle</span> <span class="attr">styleId</span>=<span class="string">&#123;</span>&quot;<span class="attr">234963469</span>&quot;&#125; <span class="attr">css</span>=<span class="string">&#123;</span>&quot;<span class="attr">.container.jsx-234963469</span>&#123;<span class="attr">color:blue</span>;&#125;<span class="attr">p.jsx-234963469:first-child</span>&#123;<span class="attr">color:red</span>;&#125;<span class="attr">.hello.jsx-234963469</span>&#123;<span class="attr">color:yellow</span>;&#125;#<span class="attr">hi.jsx-234963469</span>&#123;<span class="attr">color:green</span>;&#125;&quot;&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="5、运行"><a href="#5、运行" class="headerlink" title="5、运行"></a>5、运行</h5><p>实际渲染效果</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">data-styled-jsx</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span><span class="selector-class">.jsx-234963469</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:blue;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span><span class="selector-class">.jsx-234963469</span><span class="selector-pseudo">:first</span>-child&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.hello</span><span class="selector-class">.jsx-234963469</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:yellow;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#hi</span><span class="selector-class">.jsx-234963469</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:green;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jsx-234963469 container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;jsx-234963469 hello&quot;</span>&gt;</span>Hello! Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;jsx-234963469&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4、实践2：styled-components"><a href="#4、实践2：styled-components" class="headerlink" title="4、实践2：styled-components"></a>4、实践2：styled-components</h4><ul><li>针对 React 写的一套 css in js 框架, 在你使用 styled-components 进行样式定义的同时，你也就创建了一个 React 组件</li><li>优势: 支持将 props 以插值的方式传递给组件,以调整组件样式, 跨平台可在 RN 和 next 中使用</li><li>缺点： 预处理器和后处理器不兼容</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">const DivWrapper = styled<span class="selector-class">.div</span>`</span><br><span class="line">  <span class="attribute">width</span>: <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: $&#123;(props) =&gt; props.color&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 封装第三方组件库</span><br><span class="line">const AntdButtonWrapper = styled(<span class="selector-tag">Button</span>)`</span><br><span class="line">  <span class="attribute">color</span>: <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 通过属性动态定义样式</span><br><span class="line">const MyButton = styled<span class="selector-class">.button</span>`</span><br><span class="line">  <span class="attribute">background</span>: $&#123;(props) =&gt; (props.primary ? <span class="string">&#x27;palevioletred&#x27;</span> : <span class="string">&#x27;white&#x27;</span>)&#125;;</span><br><span class="line">  <span class="attribute">color</span>: $&#123;(props) =&gt; (props.primary ? <span class="string">&#x27;white&#x27;</span> : <span class="string">&#x27;palevioletred&#x27;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.25em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid palevioletred;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 样式复用</span><br><span class="line">const TomatoButton = styled(MyButton)`</span><br><span class="line">  <span class="attribute">color</span>: tomato;</span><br><span class="line">  <span class="attribute">border-color</span>: tomato;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建动画组件</span><br><span class="line">const Rotate = styled<span class="selector-class">.div</span>`</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">animation</span>: $&#123;rotate&#125; <span class="number">2s</span> linear infinite;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2rem</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><h3 id="做法4：预处理器的嵌套语法和CSS-属性选择器"><a href="#做法4：预处理器的嵌套语法和CSS-属性选择器" class="headerlink" title="做法4：预处理器的嵌套语法和CSS 属性选择器"></a>做法4：预处理器的嵌套语法和CSS 属性选择器</h3><p>借鉴Vue中的Scoped的做法：</p><ul><li>通过 style 标签的 scoped 指令定义作用域，通过编译为该作用域所有标签生成唯一的属性</li></ul><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b86cc72b94e4df49adb0fba1ffee3eb~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 33%;" /><h4 id="1、做法"><a href="#1、做法" class="headerlink" title="1、做法"></a>1、做法</h4><ul><li><h4 id="JS文件："><a href="#JS文件：" class="headerlink" title="JS文件："></a>JS文件：</h4><p>data-component可以限制为每个组件的名字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app&quot;</span> <span class="attr">data-component</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>隔离css<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="预处理器文件：less、sass"><a href="#预处理器文件：less、sass" class="headerlink" title="预处理器文件：less、sass"></a>预处理器文件：less、sass</h4><p>这样就解决了css class全局污染的问题。简单易用，不用引入新的概率和扩展。</p><p>create-react-app脚手架默认也支持引入scss、less</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[data-component=app]</span> &#123;</span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="selector-class">.title</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">      <span class="attribute">font-weight</span>: bold;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#333333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.text</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#333333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 样式污染 </tag>
            
            <tag> cssModule </tag>
            
            <tag> CSS-in-JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的执行编译过程</title>
      <link href="/2021/12/11/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/12/11/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JS执行过程、垃圾、内存泄漏"><a href="#JS执行过程、垃圾、内存泄漏" class="headerlink" title="JS执行过程、垃圾、内存泄漏"></a>JS执行过程、垃圾、内存泄漏</h2><img src="https://img-blog.csdnimg.cn/20201129121945306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdmZWlqaXU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="1、JS执行过程—-编译"><a href="#1、JS执行过程—-编译" class="headerlink" title="1、JS执行过程—-编译"></a>1、JS执行过程—-编译</h3><ul><li>JS是解释型语音，所以它无需提前编译，而是由解释器实时运行</li><li>JS代码执行时，两个过程：编译阶段和执行阶段</li><li>在编译阶段 <code>JS</code> 引擎主要做了三件事：词法分析、语法分析和代码生成</li></ul><h4 id="1、词法分析"><a href="#1、词法分析" class="headerlink" title="1、词法分析"></a>1、词法分析</h4><ul><li><code>JS</code> 引擎会将代码将代码分解成词元（token），每个词法单元<code>token</code>不可再分割</li><li>例如，<code>var a = 2</code> ，这段程序会被分解成：“var、a、=、2、；” 五个 <code>token</code> </li></ul><h4 id="2、语法分析"><a href="#2、语法分析" class="headerlink" title="2、语法分析"></a>2、语法分析</h4><ul><li>对词元（token）转换成树状结构的 “抽象语法树（AST）”</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/7/170b245d2c0ba592~tplv-t2oaga2asx-watermark.awebp" alt="2语法分析.png" style="zoom:25%;" /><h4 id="3、生成可执行代码"><a href="#3、生成可执行代码" class="headerlink" title="3、生成可执行代码"></a>3、生成可执行代码</h4><p><strong>将<code>AST</code>转换为可执行代码的过程</strong></p><ul><li><p>使用翻译器（translator），将代码转为字节码（bytecode）</p></li><li><p>使用字节码解释器（bytecode interpreter），将字节码转为机器码，最终计算机执行的就是机器码</p></li><li><p>即时编译：</p><p>为了提高运行速度，现代浏览器一般采用即时编译，即<strong>字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存</strong></p></li></ul><h3 id="2、执行上下文分类"><a href="#2、执行上下文分类" class="headerlink" title="2、执行上下文分类"></a>2、执行上下文分类</h3><ul><li>执行程序需要有执行环境， 同样解析 <code>JavaScript</code> 也需要执行环境，称它为“执行上下文”</li><li>JS是解释型语言，所以它无需提前编译，而是由解释器实时运行</li></ul><h4 id="1、全局执行上下文"><a href="#1、全局执行上下文" class="headerlink" title="1、全局执行上下文"></a>1、全局执行上下文</h4><ul><li>是默认的、最基础的执行上下文，一个程序中只能存在一个全局执行上下文</li><li>做的事情：<ol><li>在执行全局代码前，创建一个全局对象，在浏览器中就是 <code>window</code> 对象</li><li>对全局数据进行预处理：<ul><li>var定义的全局变量==&gt;undefined, 添加为window的属性</li><li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li><li>将 <code>this</code> 指针指向这个全局对象(window)</li></ul></li><li>开始执行全局代码</li></ol></li></ul><h4 id="2、函数执行上下文"><a href="#2、函数执行上下文" class="headerlink" title="2、函数执行上下文"></a>2、函数执行上下文</h4><ul><li><p>每次<strong>调用函数时</strong>，都会为该函数<strong>创建</strong>对应的函数执行上下文对象(虚拟的, 存在于栈中)</p></li><li><p>一个程序中可以存在任意数量的函数执行上下文，每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤</p></li><li><p>对局部数据进行预处理：</p><ol><li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li><li><code>arguments</code>==&gt;赋值(实参列表), 添加为执行上下文的属性 –&gt;<a href="https://developer.mozilla.org/zh-CN/docs/orphaned/Web/JavaScript/Reference/Functions/arguments">不懂的同学看这里</a></li><li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性</li><li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li><li>this==&gt;赋值(调用函数的对象)</li></ol></li><li><p>每个函数都拥有自己的执行上下文，但是只有<strong>在函数被调用的时候</strong>才会被创建</p></li><li><p>开始执行函数体代码</p></li></ul><h3 id="3、管理执行上下文–执行栈"><a href="#3、管理执行上下文–执行栈" class="headerlink" title="3、管理执行上下文–执行栈"></a>3、管理执行上下文–执行栈</h3><ul><li>执行栈：栈结构，用来存储代码运行时创建的所有执行上下文</li><li>JS引擎如何创建执行上下文：<ol><li>当 <code>JavaScript</code> 引擎首次读取脚本时，会创建一个全局执行上下文(window)并将其推入当前执行栈</li><li>每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端</li><li>引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出</li><li>上下文控制权将移到当前执行栈的下一个执行上下文</li><li>当所有的代码执行完后, 栈中只剩下window：<code>上下文栈数==函数调用数+1</code></li></ol></li></ul><p>【注意】：作用域与执行上下文不是同一概念：</p><ul><li>执行上下文在运行时，随时可变，甚至没有过上下文（从不调用），调用完毕销毁。而作用域不改变</li></ul><h3 id="4、创建执行上下文"><a href="#4、创建执行上下文" class="headerlink" title="4、创建执行上下文"></a>4、创建执行上下文</h3><p>JS引擎创建执行上下文分为两个阶段：<strong>创建阶段 和 执行阶段</strong></p><h4 id="1、创建阶段：在JS代码执行之前，该阶段会发生三件事："><a href="#1、创建阶段：在JS代码执行之前，该阶段会发生三件事：" class="headerlink" title="1、创建阶段：在JS代码执行之前，该阶段会发生三件事："></a>1、创建阶段：在JS代码执行之前，该阶段会发生三件事：</h4><h5 id="1、This-绑定："><a href="#1、This-绑定：" class="headerlink" title="1、This 绑定："></a>1、This 绑定：</h5><ol><li><p>全局执行上下文中，<code>this</code> 的值指向全局对象</p></li><li><p>函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的</p><p>如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象</p><p>否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）</p></li></ol><h5 id="2、创建词法环境组件："><a href="#2、创建词法环境组件：" class="headerlink" title="2、创建词法环境组件："></a>2、创建词法环境组件：</h5><p>词法环境：是一种持有<strong>标识符（变量/函数的名字）—变量映射（对实际对象[包含函数类型对象]或原始数据的引用）</strong>的结构，内部组成两部分：</p><ol><li><strong>环境记录器</strong>：存储变量和函数声明的实际位置</li><li><strong>外部环境的引用</strong>：意味着它可以访问其父级词法环境（作用域）</li></ol><p>词法环境的2种类型：</p><ol><li><p><strong>全局环境</strong>：</p><p>（在全局执行上下文中）是没有外部环境引用的词法环境，外部环境引用是 <strong>null</strong></p><p>它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 <code>this</code>的值指向全局对象</p></li><li><p><strong>函数环境</strong></p><p>函数内部用户定义的变量存储在<strong>环境记录器</strong>中</p><p>并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数</p></li></ol><p><strong>环境记录器</strong>也有两种类型：</p><ul><li><strong>声明式环境记录器</strong>存储变量、函数和参数。注意他还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。               函数环境</li><li><strong>对象环境记录器</strong>用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系。     全局环境</li></ul><h5 id="3、创建变量环境组件"><a href="#3、创建变量环境组件" class="headerlink" title="3、创建变量环境组件"></a>3、<strong>创建</strong>变量环境组件</h5><ul><li><p>变量环境：</p><p>也是一个词法环境，有着上面定义的词法环境的所有属性</p><p>在 ES6 中，<strong>词法环境</strong>组件和<strong>变量环境</strong>的一个不同就是前者被用来存储函数声明和变量（<code>let</code> 和 <code>const</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定</p></li><li><p>为什么可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>）?</p><ul><li>因为在创建阶段时，<strong>引擎检查代码找出变量和函数声明，</strong>变量最初设置为 <code>undefined</code>（<code>var</code> 情况下）</li><li>而<code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值</li><li>所以在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。这也是所说的变量提升</li></ul></li></ul><h4 id="2、执行阶段：完成对所有这些变量的分配，最后执行代码"><a href="#2、执行阶段：完成对所有这些变量的分配，最后执行代码" class="headerlink" title="2、执行阶段：完成对所有这些变量的分配，最后执行代码"></a>2、执行阶段：完成对所有这些变量的分配，最后执行代码</h4><ul><li>变量对象和作用域链是ES3规范中的内容，ES5之后就不再用了</li><li><strong>注意</strong> — 在执行阶段，如果 JS 引擎不能在源码中声明的实际位置（说明已经被声明过了）找到 <code>let</code> 变量的值，它会被赋值为 <code>undefined</code></li></ul><h3 id="3、执行上下文-—–-执行阶段-ES3规范"><a href="#3、执行上下文-—–-执行阶段-ES3规范" class="headerlink" title="3、执行上下文 —– 执行阶段      ES3规范"></a>3、执行上下文 —– 执行阶段      ES3规范</h3><p>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><img src="https://img-blog.csdnimg.cn/20201129121945306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdmZWlqaXU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li><p>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</p></li><li><p><strong>VO（变量对象）和AO（活动对象）</strong></p><ul><li>VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）</li><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>变量对象：</p><ol><li>每个执行上下文都会分配一个变量对象</li><li>变量对象的属性由变量和函数声明构成，在函数上下文情况下，参数列表也会被加入到变量对象中作为属性</li><li>变量对象与当前作用域息息相关：不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量</li></ol></li><li><p><strong>作用域链</strong>：</p><ul><li>在函数上下文中，查找一个变量foo，如果函数的VO中找到了，就直接使用</li><li>否则去它的父级作用域链中（__parent__）找</li><li>如果父级中没找到，继续往上找，直到全局上下文中也没找到就报错</li></ul></li><li><p><strong>this机制等</strong>：</p><ul><li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li>this的值只取决中进入上下文时的情况</li></ul></li><li><p>每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object，VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul></li></ul><h3 id="4、作用域与执行上下文的区别与联系"><a href="#4、作用域与执行上下文的区别与联系" class="headerlink" title="4、作用域与执行上下文的区别与联系"></a>4、作用域与执行上下文的区别与联系</h3><blockquote><ol><li>区别1:</li></ol><ul><li>全局作用域之外，每个函数都会创建自己的作用域，<code>作用域在函数定义时就已经确定了。而不是在函数调用时</code></li><li>全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建</li><li>函数执行上下文是在调用函数时, 函数体代码执行之前创建</li></ul><ol start="2"><li>区别2:</li></ol><ul><li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</li><li>执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放</li></ul><ol start="3"><li>联系:</li></ol><ul><li>执行上下文(对象)是从属于所在的作用域</li><li>全局上下文环境==&gt;全局作用域</li><li>函数上下文环境==&gt;对应的函数使用域</li></ul><p><img src="C:/Users/小虎牙/Desktop/JavaScript笔记/A_JavaScript进阶学习笔记中的图片/image-20210727141319410.png" alt="image-20210727141319410"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数组</title>
      <link href="/2021/12/11/JS%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2021/12/11/JS%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1、对象、数组遍历-√"><a href="#1、对象、数组遍历-√" class="headerlink" title="1、对象、数组遍历 √"></a>1、对象、数组遍历 √</h3><h4 id="1、对象√"><a href="#1、对象√" class="headerlink" title="1、对象√"></a>1、对象√</h4><h5 id="1、for-in-：可枚举属性，包括实例属性、原型属性（无序）"><a href="#1、for-in-：可枚举属性，包括实例属性、原型属性（无序）" class="headerlink" title="1、for ...in ：可枚举属性，包括实例属性、原型属性（无序）"></a>1、<code>for ...in </code>：可枚举属性，包括实例属性、原型属性（无序）</h5><ul><li><p>可以拿到constructor：原型上是不可枚举属性但<strong>在实例属性中对它进行了屏蔽</strong></p></li><li><p><code>Object.propertyIsEnumberable()</code>: true/false检测自身属性是否可枚举，对继承来的属性无效</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置属性是否可枚举：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(对象，修改或新增的属性名，&#123;</span><br><span class="line"><span class="attr">value</span>:修改或新增的属性的值,</span><br><span class="line"><span class="attr">writable</span>:<span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">false</span>,<span class="comment">//enumerable 如果值为false 则不允许遍历</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>  <span class="comment">//configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、Object-keys："><a href="#2、Object-keys：" class="headerlink" title="2、Object.keys："></a>2、<code>Object.keys</code>：</h5><p>实例上的可枚举属性，原型继承的不会被遍历，不包含symbol属性</p><h5 id="3、Object-getOwnPropertyNames-："><a href="#3、Object-getOwnPropertyNames-：" class="headerlink" title="3、Object.getOwnPropertyNames()："></a>3、<code>Object.getOwnPropertyNames()</code>：</h5><p>遍历实例上的所有属性，不论是否枚举，但不包含Symbol属性，返回一个属性字符串数组</p><h5 id="4、Reflect-ownKeys-："><a href="#4、Reflect-ownKeys-：" class="headerlink" title="4、Reflect.ownKeys()："></a>4、<code>Reflect.ownKeys()</code>：</h5><p>遍历实例上的所有属性，不论是否枚举，包含Symbol属性</p><h4 id="2、数组√"><a href="#2、数组√" class="headerlink" title="2、数组√"></a>2、数组√</h4><h5 id="1、forEach"><a href="#1、forEach" class="headerlink" title="1、forEach"></a>1、<code>forEach</code></h5><ul><li><p>迭代中间无法跳出，break，contine均无效；</p></li><li><p>参数是函数，对每个元素做了处理，返回值<strong>undefined</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>currentValue—数组当前值</p></li><li><p>index—当前值索引（可选）</p></li><li><p>arr—该数组（可选）</p></li></ul></li></ul><h5 id="2、for-of"><a href="#2、for-of" class="headerlink" title="2、for...of"></a>2、<code>for...of</code></h5><ul><li>可迭代对象（Array、Map、Set、String、Arguments等）</li></ul><h5 id="3、map、filter、Some、reduce、every"><a href="#3、map、filter、Some、reduce、every" class="headerlink" title="3、map、filter、Some、reduce、every"></a>3、<code>map</code>、<code>filter</code>、<code>Some</code>、<code>reduce</code>、<code>every</code></h5><h4 id="3、-for-in-与for-of的区别"><a href="#3、-for-in-与for-of的区别" class="headerlink" title="3、 for ...in 与for...of的区别"></a>3、 <code>for ...in </code>与<code>for...of</code>的区别</h4><ul><li><p><code>for...in</code>：本身是为了对象的迭代，但也可用于数组，对象拿到的是key，数组拿到的是value</p></li><li><p><code>for...of</code> ：遍历<strong>可迭代对象</strong>定义要迭代的数据</p></li></ul><h3 id="2、类数组√"><a href="#2、类数组√" class="headerlink" title="2、类数组√"></a>2、类数组√</h3><ul><li><p>是一个对象，不是数组。可以索引取值、length属性、for遍历</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;job&#x27;</span>];</span><br></pre></td></tr></table></figure><p><strong>Arguments</strong>对象：是经典的类数组对象：</p><ul><li>函数传递的参数</li><li>length属性：实参的长度</li><li>callee属性：指向的函数自身，可以通过它来调用自身函数</li></ul></li><li><p>区别在于它不能直接使用数组的方法，如果想使用，则需要借助call/apply</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript权威指南判断是否为类数组对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                    <span class="comment">// o不是null、undefined等</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp;                <span class="comment">// o是对象</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp;                   <span class="comment">// o.length是有限数值</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp;                        <span class="comment">// o.length为非负值</span></span><br><span class="line">        o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;    <span class="comment">// o.length是整数</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span>)                  <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、类数组转为数组√"><a href="#2、类数组转为数组√" class="headerlink" title="2、类数组转为数组√"></a>2、类数组转为数组√</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. slice  (有副本 ，截取start+end)</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. splice (原数组会被修改，返回删除元素构成的数组，0表示没有删除)</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. ES6 Array.from</span></span><br><span class="line"><span class="comment">// Array.from可以把类数组对象和可遍历（interable）对象（包括set和map）转换为数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. concat</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 ES6 ...运算符 作为函数参数的时候可以吧arguments转换成数组</span></span><br><span class="line"><span class="comment">// 扩展运算符...，有Interator接口的对象都可用，对象就不行了，函数的arguments对象就可用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateArray</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、数组方法"><a href="#3、数组方法" class="headerlink" title="3、数组方法"></a>3、数组方法</h3><h4 id="1、splice"><a href="#1、splice" class="headerlink" title="1、splice"></a>1、splice</h4><p>作用：向数组中添加/删除项目，然后返回被删除的项目构成的新数组，同时原数组也发生了改变</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure><ul><li><p>index：添加/删除项目的位置，使用负数可从数组结尾处规定位置 —必需</p></li><li><p>howmany：要删除的项目数量。<strong>如果设置为 0</strong>，<strong>则不会删除项目</strong> –必需</p></li><li><p>第3项：向数组添加的新项目      –可选</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;William&quot;</span>)<span class="comment">//创建一个新数组，并将索引为2的那项添加wiliam，后面的索引依次后移</span></span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;William&quot;</span>) <span class="comment">//删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素</span></span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;William&quot;</span>) <span class="comment">//删除从 index 2 (&quot;Thomas&quot;) 开始的三个元素，并添加一个新元素 (&quot;William&quot;) 来替代被删除的元素</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、slice：没有修改原数组，返回新数组"><a href="#2、slice：没有修改原数组，返回新数组" class="headerlink" title="2、slice：没有修改原数组，返回新数组"></a>2、slice：没有修改原数组，返回新数组</h4><p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</p><ul><li>若传参为空，则返回数组拷贝</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arrayObject.slice(start,end)</span><br></pre></td></tr></table></figure><ul><li>start：从何处开始选取。负数，从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。  —必需</li><li>end：从何处结束选取。如果没有指定，那么start到数组结束的所有元素，负数，从数组尾部开始算起   –可选</li></ul><h4 id="3、filter"><a href="#3、filter" class="headerlink" title="3、filter"></a>3、filter</h4><ul><li><p>遍历数组中每一个元素，返回所有函数返回结果为true的元素，这些元素构成的数组就是filter()方法的返回值</p></li><li><p>```js<br>// 定义数组<br>var names = [“abc”, “cb”, “mba”, “dna”]</p><p>// 获取names中所有包含’a’字符的元素<br>var newNames = names.filter(function (t) {</p><pre><code>return t.indexOf(&quot;a&quot;) != -1</code></pre><p>})</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">array.filter(function(value,index,array),contetx)</span><br><span class="line">- value—当前数组值，必须</span><br><span class="line">- index—数组索引，非必须</span><br><span class="line">- array—当前数组，非必须</span><br><span class="line">- context—指定回调函数的this值，一般不穿，默认是undefined的</span><br></pre></td></tr></table></figure></li></ul><ul><li>实现如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span>(<span class="params">fn,context</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 调用.myFilter方法的那个数组</span></span><br><span class="line">      <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">var</span> newArr = []</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fn.call(context,arr[i],i,arr))&#123;</span><br><span class="line">          newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToFilter = <span class="function"><span class="keyword">function</span> (<span class="params">fn,context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.call(<span class="built_in">this</span>, current, index)) &#123;</span><br><span class="line">      target.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、map"><a href="#4、map" class="headerlink" title="4、map"></a>4、map</h4><ul><li>遍历数组，每个元素经过某函数的作用后，变成新元素，最后形成一个新数组</li><li>与forEach的区别：<ol><li>forEach返回的是undefined，因此它也不支持链式调用；而map不改变原数组但是会 返回新数组</li><li>forEach没有返回值，不可以中断，不能使用return返回到外层函数；map可以break中断循环，可以return返回到外层函数<ul><li>forEach() 对于空数组是不会执行回调函数的。</li><li>for可以用continue跳过循环中的一个迭代，forEach用continue会报错。</li><li>forEach() 需要用 return 跳过循环中的一个迭代，跳过之后会执行下一个迭代。</li></ul></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,array</span>), <span class="title">context</span>)</span></span><br><span class="line"><span class="function">- <span class="title">value</span>—当前数组值，必须</span></span><br><span class="line"><span class="function">- <span class="title">index</span>—数组索引，非必须</span></span><br><span class="line"><span class="function">- <span class="title">array</span>—该数组，非必须</span></span><br><span class="line"><span class="function">- <span class="title">context</span>—指定回调函数的<span class="title">this</span>值</span></span><br></pre></td></tr></table></figure><ul><li>实现如下</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="comment">//map处理完就push</span></span><br><span class="line">    newArr.push(fn.call(context, arr[i], i, arr))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">用reduce实现map</span><br><span class="line"><span class="built_in">Array</span>.prototype.reduceToMap = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line"><span class="comment">// this就是使用map的数组实例</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">target.push(fn.call(<span class="built_in">this</span>, current, index))</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5、reduce"><a href="#5、reduce" class="headerlink" title="5、reduce"></a>5、reduce</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur,index,arr</span>),<span class="title">initalval</span>)</span></span><br><span class="line"><span class="function">- <span class="title">pre</span>—当前累加值，必须</span></span><br><span class="line"><span class="function">- <span class="title">cur</span>—当前数组值，必须</span></span><br><span class="line"><span class="function">- <span class="title">index</span>—数组索引，非必须</span></span><br><span class="line"><span class="function">- <span class="title">arr</span>—该数组，非必须</span></span><br><span class="line"><span class="function">- <span class="title">initalVal</span>—累加值初始值，非必须，**不传值的话，数组第一个元素为默认值**</span></span><br></pre></td></tr></table></figure><ul><li>实现核心：没有传入initalVal时，初始值设为数组第1个元素，并从第2个元素开始便利。回到函数应该处理第二个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myReduce=<span class="function"><span class="keyword">function</span>(<span class="params">fn,inital</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">var</span> total = inital?inital:arr[<span class="number">0</span>]  <span class="comment">//关键</span></span><br><span class="line">      <span class="keyword">var</span> startIndex = inital?<span class="number">0</span>:<span class="number">1</span>       <span class="comment">//关键</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=startIndex;i&lt;arr.length;i++)&#123;</span><br><span class="line">        total = fn.call(<span class="literal">null</span>,total,arr[i],i,arr)  <span class="comment">//注意要传入一个null，第二个是total</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="6、Sort"><a href="#6、Sort" class="headerlink" title="6、Sort"></a>6、Sort</h4><p>在原数组上排序，不生成副本</p><ul><li><p>若参数为空，按照字符编码的顺序进行排序</p></li><li><p>其他标准：提供比较函数</p><ul><li><p>该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数 a 和 b，其返回值如下：</p><ul><li><p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</p></li><li><p>若 a 等于 b，则返回 0。</p></li><li><p>若 a 大于 b，则返回一个大于 0 的值</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="built_in">Array</span>.from(map).sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 如果a是较小的，那么b[1]-a[1]就是正的。a应该在b之后。所以输出是降序排列</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7、some"><a href="#7、some" class="headerlink" title="7、some"></a>7、some</h4><p>只要有一个元素比对结果为true，返回结果就为true</p><h4 id="8、every"><a href="#8、every" class="headerlink" title="8、every"></a>8、every</h4><ul><li><p>使用指定函数检测数组中的所有元素是否都符合指定条件，所有符合，return true，否则返回false</p></li><li><p>不会改变原始数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9、Array-from"><a href="#9、Array-from" class="headerlink" title="9、Array.from"></a>9、Array.from</h4><ul><li>从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例<ul><li>伪数组对象（拥有一个 <code>length</code> 属性和若干索引属性的任意对象）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/iterable">可迭代对象</a>（可以获取对象中的元素,如 Map和 Set 等）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">// [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ] 从 String 生成数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]);  从 <span class="built_in">Set</span> 生成数组</span><br><span class="line"><span class="built_in">Array</span>.from(set);     <span class="comment">// [ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapper = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]);  <span class="comment">//从 Map 生成数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(map);    <span class="comment">//[[&#x27;1&#x27;, &#x27;a&#x27;], [&#x27;2&#x27;, &#x27;b&#x27;]]</span></span><br><span class="line"><span class="built_in">Array</span>.from(mapper.values());  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;];</span></span><br><span class="line"><span class="built_in">Array</span>.from(mapper.keys());   <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;];</span></span><br><span class="line"></span><br><span class="line">从类数组对象（<span class="built_in">arguments</span>）生成数组</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">x</span> =&gt;</span> x + x);       <span class="comment">// [2, 4, 6] 在 Array.from 中使用箭头函数</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i);    <span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="built_in">Array</span>.from(map).sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="4、是否改变数组"><a href="#4、是否改变数组" class="headerlink" title="4、是否改变数组"></a>4、是否改变数组</h3><ul><li><h4 id="改变：push、unshift、pop、shift、reverse-、sort、splice"><a href="#改变：push、unshift、pop、shift、reverse-、sort、splice" class="headerlink" title="改变：push、unshift、pop、shift、reverse 、sort、splice"></a>改变：push、unshift、pop、shift、reverse 、sort、splice</h4></li><li><h4 id="不改变：concat-、map、every、some-、filter、toString、slice-、join、indexOf"><a href="#不改变：concat-、map、every、some-、filter、toString、slice-、join、indexOf" class="headerlink" title="不改变：concat 、map、every、some 、filter、toString、slice 、join、indexOf"></a>不改变：concat 、map、every、some 、filter、toString、slice 、join、indexOf</h4></li></ul><h3 id="5、数组去重"><a href="#5、数组去重" class="headerlink" title="5、数组去重"></a>5、数组去重</h3><h4 id="法1：双层for-splice-基本数据类型"><a href="#法1：双层for-splice-基本数据类型" class="headerlink" title="法1：双层for+splice            基本数据类型"></a>法1：双层for+splice            基本数据类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]===arr[j])&#123;</span><br><span class="line">        arr.splice(j,<span class="number">1</span>)  <span class="comment">//splice是能改变原数组的，slice不行</span></span><br><span class="line">        j--  <span class="comment">//如果有重复元素，删除之后一定要j--</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法2：用额外空间存储已经出现过的元素"><a href="#法2：用额外空间存储已经出现过的元素" class="headerlink" title="法2：用额外空间存储已经出现过的元素"></a>法2：用额外空间存储已经出现过的元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.indexOf(arr[i])==-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//  if(!res.includes(arr[i]))&#123;</span></span><br><span class="line">      res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">版本<span class="number">2</span>：对象的键名存储(能对NAN去重，对象只留前面一个，基本数据类型：)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj.hasOwnProperty(<span class="keyword">typeof</span> item + item))&#123;</span><br><span class="line">      res.push(item)</span><br><span class="line">      obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">版本<span class="number">3</span>：<span class="built_in">Map</span> 的键名可以是任意类型，而不是像对象那样必须是字符串类型，所以利用这一点，简化版本<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(item))&#123;  <span class="comment">//map没有当前元素键名</span></span><br><span class="line">      res.push(item)</span><br><span class="line">      map.set(item,<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法3：filter-indexOf，基本数据类型："><a href="#方法3：filter-indexOf，基本数据类型：" class="headerlink" title="方法3：filter+indexOf，基本数据类型："></a>方法3：filter+indexOf，基本数据类型：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">法<span class="number">1</span>：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">cur,index</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// indexOf:返回的是元素在数组中跟的索引位置，-1代表不存，</span></span><br><span class="line">    <span class="comment">// 否则结果是索引位置，且是从左到右第一次找到的与该元素相等或就是该元素的位置</span></span><br><span class="line">    <span class="comment">// 所以arr.indexOf(cur) == index说明是第一次出现的元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(cur) == index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">法<span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> unique = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  arr.filter(<span class="function"><span class="params">i</span> =&gt;</span> arr.indexOf(i) === arr.lastIndexOf(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法4：Set，基本数据类型：NaN能去重，对象不可以"><a href="#方法4：Set，基本数据类型：NaN能去重，对象不可以" class="headerlink" title="方法4：Set，基本数据类型：NaN能去重，对象不可以"></a>方法4：Set，基本数据类型：NaN能去重，对象不可以</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">  <span class="comment">// 或者：return Array.from(new Set(arr))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、扁平化数组"><a href="#6、扁平化数组" class="headerlink" title="6、扁平化数组"></a>6、扁平化数组</h3><h4 id="法1：递归-支持指定深度写这个"><a href="#法1：递归-支持指定深度写这个" class="headerlink" title="法1：递归                   支持指定深度写这个"></a>法1：递归                   支持指定深度写这个</h4><p>遍历数组元素，遇到元素是数组时，递归flatten函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr, deep = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i]) &amp;&amp; deep &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      res = res.concat(flatten(arr[i]))    <span class="comment">//这里一定要连接数组</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flatten(array, <span class="number">2</span>); <span class="comment">//[1, 2, 3, Array(2), 6, 7]</span></span><br></pre></td></tr></table></figure><h4 id="法2：reduce-递归-支持指定深度-重点√"><a href="#法2：reduce-递归-支持指定深度-重点√" class="headerlink" title="法2：reduce+递归                 支持指定深度  重点√"></a>法2：reduce+递归                 支持指定深度  重点√</h4><p>因为是遍历数组所有元素，最终返回一个值-数组，可以用reduce来简化递归代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">total,current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total.concat(<span class="built_in">Array</span>.isArray(current)? flatten(current) : current)</span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定深度版本：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenByDeep</span>(<span class="params">array, deep = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(</span><br><span class="line">    <span class="function">(<span class="params">previousValue, current</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">Array</span>.isArray(current) &amp;&amp; deep &gt; <span class="number">1</span> ?</span><br><span class="line">previousValue.concat(flattenByDeep(current, deep - <span class="number">1</span>)) :previousValue.concat(current)</span><br><span class="line">   , [])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="法3：扩展运算符-不支持指定深度"><a href="#法3：扩展运算符-不支持指定深度" class="headerlink" title="法3：扩展运算符                       不支持指定深度"></a>法3：扩展运算符                       不支持指定深度</h4><ul><li>拍平一层</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>]</span><br><span class="line"><span class="built_in">console</span>.log([].concat(...array)); <span class="comment">//[1,2,3,[4,5],6,7]</span></span><br></pre></td></tr></table></figure><ul><li>检查数组每个元素，如果有元素是数组就要拍平一次，所以这里用到了数组的some方法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">Array</span>.isArray(item)))&#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法4：es6的flat-支持指定深度-快手手写实现"><a href="#法4：es6的flat-支持指定深度-快手手写实现" class="headerlink" title="法4：es6的flat     支持指定深度    快手手写实现"></a>法4：es6的flat     支持指定深度    快手手写实现</h4><p>es6中的新方法，数组拍平用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> a = array.flat(<span class="number">1</span>)     <span class="comment">//拍平一层   </span></span><br><span class="line"><span class="keyword">var</span> b = array.flat(<span class="literal">Infinity</span>)  <span class="comment">//完全拍平</span></span><br></pre></td></tr></table></figure><h4 id="法5：toString-数组元素均为数字-不支持指定深度"><a href="#法5：toString-数组元素均为数字-不支持指定深度" class="headerlink" title="法5：toString    数组元素均为数字  不支持指定深度"></a>法5：toString    数组元素均为数字  不支持指定深度</h4><ul><li>toString效果如下</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> a = array.toString()         <span class="comment">//&#x27;1,2,3,4,5,6,7&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>字符串的split方法以’,’分割，得到字符串数组，然后把数组每个元素数转换为数字</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.toString().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> +item)  </span><br><span class="line">  <span class="comment">//用到了类型转换，+item把item字符串变成数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组API </tag>
            
            <tag> 去重 </tag>
            
            <tag> 扁平化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端的模块化</title>
      <link href="/2021/12/11/%E5%89%8D%E7%AB%AF%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2021/12/11/%E5%89%8D%E7%AB%AF%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="模块化总结"><a href="#模块化总结" class="headerlink" title="模块化总结"></a>模块化总结</h2><h3 id="一、模块化背景"><a href="#一、模块化背景" class="headerlink" title="一、模块化背景"></a>一、模块化背景</h3><ul><li><h4 id="早期的JS发展："><a href="#早期的JS发展：" class="headerlink" title="早期的JS发展："></a>早期的JS发展：</h4><ul><li>要实现的功能少：JS仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，代码量少，只需要将JS代码写到script标签中即可；并没有必要放到多个文件中来编写；</li></ul></li><li><h4 id="问题出现："><a href="#问题出现：" class="headerlink" title="问题出现："></a>问题出现：</h4><p>要实现的业务越来越复杂，传统开发模式不能再满足，于是出现了模块化的思想；</p><ul><li>前端技术发展飞速，ajax的出现，前后端开发分离，意味着后端返回数据后，用JS前端页面的渲染；</li><li>SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要JS来实现；</li><li>Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；</li></ul></li><li><h4 id="什么叫模块"><a href="#什么叫模块" class="headerlink" title="什么叫模块"></a>什么叫模块</h4><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul></li><li><h4 id="模块化的价值："><a href="#模块化的价值：" class="headerlink" title="模块化的价值："></a>模块化的价值：</h4><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性：公共模块可以促进代码复用，业务模块可以提升项目的可维护性；</li><li>高可维护性：为了满足高内聚低耦合，需要将不具备复用价值的代码抽离成相互独立的模块，有很多关于函数不要超过多少行的经验，所以要做有意义的代码拆分</li></ul></li></ul><h3 id="二、模块化演变"><a href="#二、模块化演变" class="headerlink" title="二、模块化演变"></a>二、模块化演变</h3><h4 id="1-阶段1：全局function模式-将不同的功能封装成不同的全局函数"><a href="#1-阶段1：全局function模式-将不同的功能封装成不同的全局函数" class="headerlink" title="1. 阶段1：全局function模式 : 将不同的功能封装成不同的全局函数"></a>1. 阶段1：全局function模式 : 将不同的功能封装成不同的全局函数</h4><ul><li>编码: 将不同的功能封装成不同的全局函数</li><li>问题: <ol><li>污染全局作用域，容易引起命名冲突或数据不安全，变量可以在外部访问和修改；</li><li>无法管理模块间的依赖关系；模块成员之间看不出直接关系</li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-阶段2：namespace模式-简单对象封装"><a href="#2-阶段2：namespace模式-简单对象封装" class="headerlink" title="2. 阶段2：namespace模式 : 简单对象封装"></a>2. 阶段2：namespace模式 : 简单对象封装</h4><ul><li>作用: 减少了全局变量，解决命名冲突</li><li>问题: 只解决了命名冲突问题，数据不安全(外部可以直接修改模块内部的数据)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;www.baidu.com&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.data = <span class="string">&#x27;other data&#x27;</span> <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.foo() <span class="comment">// foo() other data</span></span><br><span class="line">这样的写法会暴露所有模块成员，内部状态可以被外部改写</span><br></pre></td></tr></table></figure><h4 id="3-阶段3：IIFE模式：匿名函数自调用-闭包"><a href="#3-阶段3：IIFE模式：匿名函数自调用-闭包" class="headerlink" title="3. 阶段3：IIFE模式：匿名函数自调用(闭包)"></a>3. 阶段3：IIFE模式：匿名函数自调用(闭包)</h4><ul><li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li><li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li><li>问题: 如果当前这个模块依赖另一个模块怎么办?</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myModule.foo()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myModule.bar()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myModule.foo() <span class="comment">//没有改变</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    otherFun() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000017466124?w=419&h=105" alt="img"></p><h4 id="4-阶段4：IIFE模式增强-引入依赖"><a href="#4-阶段4：IIFE模式增强-引入依赖" class="headerlink" title="4. 阶段4：IIFE模式增强 : 引入依赖"></a>4. 阶段4：IIFE模式增强 : 引入依赖</h4><p>现代模块实现的基石</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    otherFun() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery)</span><br><span class="line"> <span class="comment">// index.html文件</span></span><br><span class="line">  &lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    myModule.foo()</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p><ul><li><h4 id="阶段5：各种规范出现"><a href="#阶段5：各种规范出现" class="headerlink" title="阶段5：各种规范出现"></a>阶段5：各种规范出现</h4><p><strong>引入多个<code>script</code>后出现问题</strong></p><ul><li>请求过多</li></ul><p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p><ul><li>依赖模糊</li></ul><p>不知道他们的具体依赖关系，很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p><ul><li>难以维护</li></ul><p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。<br>模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。</p><p>而这些问题可以通过模块化规范来解决，目前主流的 <code>JavaScript</code> 模块化规范有 <strong>CommonJS</strong>，AMD，CMD，<strong>ES6 Module</strong> 四种规范</p></li></ul><h3 id="三、CommonJS"><a href="#三、CommonJS" class="headerlink" title="三、CommonJS"></a>三、CommonJS</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h4><ol><li><strong>node提出</strong>的标准，<strong>在node服务端运行</strong>，但<strong>不适合浏览器</strong>中使用；</li><li>在服务器端，模块的加载是<strong>运行时同步加载</strong>的；在<strong>浏览器端，模块需要提前编译打包处理</strong></li><li>核心变量：exports、module.exports、require；</li><li>Node中每个js文件都是个单独的模块，单独的作用域，在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见；</li></ol><h4 id="2-特点："><a href="#2-特点：" class="headerlink" title="2. 特点："></a>2. 特点：</h4><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块<strong>可多次加载</strong>，但是<strong>只会在第一次加载时运行一次，然后运行结果就被缓存了</strong>，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序</li></ul><h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3. 基本语法"></a>3. 基本语法</h4><ul><li><p>暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></p></li><li><p>引入模块：<code>require(xxx)</code></p><p>如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径；</p><p><strong>require命令，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错</strong></p></li><li><p><strong>CommonJS暴露的模块到底是什么?</strong> </p><p>CJS规定，每个模块内部，module变量代表当前模块。</p><p>这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。</p><p><strong>加载某个模块，其实是加载该模块的module.exports属性</strong>。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><p>上面代码通过module.exports输出变量x和函数addX。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="4. 模块的加载机制"></a>4. 模块的加载机制</h4><ul><li><p><strong>输入的是被输出的值的拷贝</strong></p><p>一旦输出一个值，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。<strong>这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p><h3 id="四、ES6-Module"><a href="#四、ES6-Module" class="headerlink" title="四、ES6 Module"></a>四、ES6 Module</h3><p>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p><h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><ul><li><p>export命令用于规定模块的对外接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br></pre></td></tr></table></figure></li><li><p>import命令用于输入其他模块提供的功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载，为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<strong>export default</strong>命令，为模块指定默认输出，其他模块加载该模块时，import命令可以为该匿名函数指定任意名字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-动态加载"><a href="#2-动态加载" class="headerlink" title="2. 动态加载"></a>2. 动态加载</h4><ul><li><p>通过import加载一个模块，是不可以在其放到逻辑代码中的，比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./xxx&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：unexpected identifier（语法错误）</p><p>原因：解析阶段执行的放在运行阶段执行，导致报错</p><ul><li>JS代码时交给JS引擎执行经过：Parse — AST — 字节码 — 二进制代码 — 执行</li><li>parse过程只是对语法进行了分析，并没有执行，此时就必须知道它的依赖关系，就已经确定了依赖关系。</li><li>这个时候js代码没有任何的运行，所以无法在进行类似于if判断中根据代码的执行情况；</li></ul></li><li><p><strong>那如何动态地加载模块呢？</strong>  –import() 函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./xxx.js&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">res.fun1();</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(err)&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./xxx.js&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">res.fun2();</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(err)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>import函数返回的是一个promise；</p></li><li><p>export default {}的形式导出，此时promise 的res.default是一个对象，结果存放在这里</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取得时候：res.default.fun1</span><br></pre></td></tr></table></figure></li><li><p>脚手架中的import 基于webpack ，所以webpack会对import函数进行解析，将（）里面的内容单独打包到JS文件，到时候多个JS文件在首屏渲染的时候，就不需一次性加载一个非常大的文件，等到用这个文件时再加载即可</p></li><li><p>在webpack环境下，一般用require，它支持ES CJS。若在es module环境下用import函数</p></li></ul></li></ul><h3 id="五、对比差异"><a href="#五、对比差异" class="headerlink" title="五、对比差异"></a>五、对比差异</h3><h4 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</h4><ul><li><strong>CommonJS</strong><ul><li>通过module.exports导出的是一个对象，可以将这个对象的引用在其他模块中赋值给其他变量；</li><li>但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；</li></ul></li><li><strong>ES Module</strong><ul><li>export在导出一个变量时，js引擎会解析这个语法，并且创建<strong>模块环境记录</strong>；</li><li><strong>模块环境记录</strong>会和变量进行实时绑定；</li><li>在导入的地方，可以实时获取到绑定的最新值；所以，如果在导出的模块中修改了变化，那么导入的地方可实时获取最新的变量；</li><li>JS引擎在实时绑定时，一旦发现值发生改变，并不是直接赋值，而是将之前的值删除，用新的值绑定，再将新的值放入记录中，用的时候也是拿这个值。</li><li>注意：在导入的地方不可以修改变量，因为它只是被绑定到了这个变量上（其实是一个常量）<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210126224604142.png" alt="image-20210126224604142" style="zoom:50%;" /></li></ul></li></ul><h4 id="2-CommonJS-模块是运行时同步加载，ES6-模块是编译时输出接口，异步加载"><a href="#2-CommonJS-模块是运行时同步加载，ES6-模块是编译时输出接口，异步加载" class="headerlink" title="2. CommonJS 模块是运行时同步加载，ES6 模块是编译时输出接口，异步加载"></a>2. CommonJS 模块是运行时同步加载，ES6 模块是编译时输出接口，异步加载</h4><ul><li><p><strong>CommonJS</strong></p><ul><li>运行时：CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。js引擎在<strong>执行js代码的过程</strong>中加载模块；</li><li>同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；</li></ul></li><li><p><strong>ES Module</strong></p><ul><li><p>编译时（解析）时加载，意味着import不能和运行时相关内容一起使用，所以也称ES Module是静态解析的，而不是动态或者运行时解析的；</p><ul><li>比如from后面的路径需要动态获取；</li><li>比如不能将import放到if等语句的代码块中；</li></ul></li><li><p>异步：JS引擎遇到import时会去获取这个js文件，但是这个获取过程是异步的，并不会阻塞主线程继续执行；</p><ul><li>也就是说<strong>设置了 type=module 的代码，相当于在script标签上也加上了 async 属性</strong>；</li><li>如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；结果：② — ①<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210126224230472.png" alt="image-20210126224230472" style="zoom:67%;" /></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
            <tag> CommonJS </tag>
            
            <tag> ESModule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios的源码的一些妙用</title>
      <link href="/2021/12/11/%E5%85%B3%E4%BA%8EAxios/"/>
      <url>/2021/12/11/%E5%85%B3%E4%BA%8EAxios/</url>
      
        <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><ul><li>基于 xhr + promise 的异步 ajax 请求库 ，前端最流行的 ajax 请求库 </li><li>浏览器端/node 端都可以使用 </li><li>支持请求／响应拦截器 、支持请求取消 </li><li>请求/响应数据转换 </li><li>批量发送多个请求</li></ul><h2 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h2><img src="C:/Users/小虎牙/Desktop/hongs-study-notes/编程_前端开发学习笔记/Ajax、Axios学习笔记/Axios入门与源码解析笔记中的图片/Axios系统学习笔记原理图.png" alt="Axios系统学习笔记原理图" style="zoom: 80%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. axios(config): `通用/最本质`的发任意类型请求的方式 </span><br><span class="line">2. axios(url[, config]): 可以只指定 url 发 get 请求 </span><br><span class="line"></span><br><span class="line">3. axios.request(config): 等同于 axios(config) </span><br><span class="line">4. axios.get(url[, config]): 发 get 请求 </span><br><span class="line">5. axios.delete(url[, config]): 发 delete 请求 </span><br><span class="line">6. axios.post(url[, data, config]): 发 post 请求</span><br><span class="line">7. axios.put(url[, data, config]): 发 put 请求 </span><br><span class="line"></span><br><span class="line">8. axios.defaults.xxx: 请求的默认全局配置 </span><br><span class="line"></span><br><span class="line">9. axios.interceptors.request.use(): 添加请求拦截器 </span><br><span class="line">10. axios.interceptors.response.use(): 添加响应拦截器 </span><br><span class="line"></span><br><span class="line">11. axios.create([config]): 创建一个新的 axios(它没有下面的功能) </span><br><span class="line"></span><br><span class="line">12. axios.Cancel(): 用于创建取消请求的错误对象 </span><br><span class="line">13. axios.CancelToken(): 用于创建取消请求的 token 对象 </span><br><span class="line">14. axios.isCancel(): 是否是一个取消请求的错误 </span><br><span class="line"></span><br><span class="line">15. axios.all(promises): 用于批量执行多个异步请求 </span><br><span class="line">16. axios.spread(): 用来指定接收所有成功数据的回调函数的方法</span><br></pre></td></tr></table></figure><h2 id="3-重点用法"><a href="#3-重点用法" class="headerlink" title="3. 重点用法"></a>3. 重点用法</h2><h3 id="1、axios-create-config"><a href="#1、axios-create-config" class="headerlink" title="1、axios.create(config)"></a>1、axios.create(config)</h3><blockquote><ol><li><p>根据指定配置创建一个新的 axios, 也就是每个新 axios 都有自己的配置 </p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 </p></li><li><p>为什么要设计这个语法?</p></li></ol><p>  (1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理 </p><p>  (2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line"><span class="keyword">const</span> duanzi = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> onather = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://b.com&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line"><span class="comment">// duanzi(&#123;</span></span><br><span class="line"><span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(response);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line">duanzi.get(<span class="string">&#x27;/getJoke&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、拦截器"><a href="#2、拦截器" class="headerlink" title="2、拦截器"></a>2、拦截器</h3><blockquote><ol><li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 </li><li><strong>流程:</strong> 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器 2 =&gt; 请求的回调 </li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// Promise</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 设置请求拦截器  config 配置对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//修改 config 中的参数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  config.params = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">a</span>: <span class="number">100</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> config;  <span class="comment">// 必须传config</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//修改 config 中的参数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  config.timeout = <span class="number">2000</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> config;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 设置响应拦截器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> response.data;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">// return response;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> response;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">axios(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(response);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3、取消请求"><a href="#3、取消请求" class="headerlink" title="3、取消请求"></a>3、取消请求</h3><blockquote><ol><li>基本流程 配置 cancelToken 对象 </li><li>缓存用于取消请求的 cancel 函数 </li><li>在后面特定时机调用 cancel 函数取消请求 </li><li>在错误回调中判断如果 error 是 cancel, 做相应处理</li><li>实现功能 点击按钮, 取消某个正在请求中的请求,</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//获取按钮</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//2.声明全局变量</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//检测上一次的请求是否已经完成</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//取消上一次的请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    cancel();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//1. 发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  axios(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//1.1请求配置： 添加配置对象的属性，必须先配置好cancelToken</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//3. 将 c 的值赋值给 cancel</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      cancel = c;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(response);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//将 cancel 的值初始化</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    cancel = <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//绑定第二个事件取消请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;cancel(); &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="4-默认配置"><a href="#4-默认配置" class="headerlink" title="4. 默认配置"></a>4. 默认配置</h3><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//默认配置</span></span><br><span class="line">&gt;axios.defaults.method = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">&gt;axios.defaults.baseURL = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">&gt;axios.defaults.params = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;</span><br><span class="line">&gt;axios.defaults.timeout = <span class="number">3000</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&gt;btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;axios(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">&gt;&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(response);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4. 问题"></a>4. 问题</h2><h3 id="1-axios-与-Axios-的关系"><a href="#1-axios-与-Axios-的关系" class="headerlink" title="1. axios 与 Axios 的关系"></a>1. axios 与 Axios 的关系</h3><blockquote><ol><li>从<code>语法</code>上来说: axios 不是 Axios 的实例</li><li>从<code>功能</code>上来说: axios 是 Axios 的实例</li></ol><ul><li>axios 是 <code>Axios.prototype.request</code> 函数 bind()返回的函数</li><li>axios 作为对象，有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性</li></ul></blockquote><h3 id="2-instance-与-axios-的区别"><a href="#2-instance-与-axios-的区别" class="headerlink" title="2. instance 与 axios 的区别?"></a>2. instance 与 axios 的区别?</h3><blockquote><ol><li>相同:<br>(1) 都是一个能发任意请求的函数: request(config)<br>(2) 都有发特定请求的各种方法: get()/post()/put()/delete()<br>(3) 都有默认配置和拦截器的属性: defaults/interceptors</li><li>不同:<br>(1) 默认配置很可能不一样<br>(2) instance 是通过createInstance创建出来的对象，但创建新对象的instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all()</li></ol></blockquote><h3 id="3-axios运行的整体流程"><a href="#3-axios运行的整体流程" class="headerlink" title="3. axios运行的整体流程"></a>3. axios运行的整体流程</h3><blockquote><ol><li><p>整体流程:<br>request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config)</p></li><li><p>request(config):<br>将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,<br>返回 promise</p></li><li><p>dispatchRequest(config):<br>转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数<br>据. 返回 promise</p></li><li><p>xhrAdapter(config):<br>创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br>返回 promise </p></li><li><p>流程图:</p></li></ol><img src="C:/Users/小虎牙/Desktop/hongs-study-notes/编程_前端开发学习笔记/Ajax、Axios学习笔记/Axios入门与源码解析笔记中的图片/Axios系统学习流程图.png" alt="Axios系统学习流程图" style="zoom: 80%;" /></blockquote><h3 id="4-axios-的请求-响应拦截器是什么"><a href="#4-axios-的请求-响应拦截器是什么" class="headerlink" title="4. axios 的请求/响应拦截器是什么?"></a>4. axios 的请求/响应拦截器是什么?</h3><blockquote><ol><li>请求拦截器:<br>Ⅰ- 在真正发送请求前执行的回调函数<br>Ⅱ- 可以对请求进行检查或配置进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li><li>响应拦截器<br>Ⅰ- 在请求得到响应后执行的回调函数<br>Ⅱ- 可以对响应数据进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 response<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li></ol></blockquote><h3 id="5-axios-的请求-响应数据转换器是什么"><a href="#5-axios-的请求-响应数据转换器是什么" class="headerlink" title="5. axios 的请求/响应数据转换器是什么?"></a>5. axios 的请求/响应数据转换器是什么?</h3><blockquote><ol><li>请求转换器: 对请求头和请求体数据进行特定处理的函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (utils.isObject(data)) &#123;</span><br><span class="line">setContentTypeIfUnset(headers, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;response.data = <span class="built_in">JSON</span>.parse(response.data)</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-response与error-的整体结构"><a href="#6-response与error-的整体结构" class="headerlink" title="6. response与error  的整体结构"></a>6. response与error  的整体结构</h3><blockquote><ol><li>response的整体结构</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;data, status,statusText,headers,config,request</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>error  的整体结构</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;message,response,request,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="7-如何取消未完成的请求"><a href="#7-如何取消未完成的请求" class="headerlink" title="7. 如何取消未完成的请求?"></a>7. 如何取消未完成的请求?</h3><blockquote><ol><li>当配置了 cancelToken 对象时, 保存 cancel 函数<br>(1) 创建一个用于将来中断请求的 cancelPromise<br>(2) 并定义了一个用于取消请求的 cancel 函数<br>(3) 将 cancel 函数传递出来</li><li>调用 cancel()取消请求<br>(1) 执行 cacel 函数, 传入错误信息 message<br>(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象<br>(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,<br>失败的 reason 为 Cancel 对象</li></ol></blockquote><h2 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><blockquote><p>├── /dist/ # 项目输出目录<br>├── /lib/ # 项目源码目录    核心目录<br>│ ├── /adapters/ # 定义请求的适配器 xhr.js、http.js<br>│ │ ├── http.js # 实现 http 适配器(包装 http 包)，远端爬虫<br>│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)，网页中发送ajax请求<br>│ ├── /cancel/ # 定义取消功能<br>│ ├── /core/ # 一些核心功能<br>│ │ ├── Axios.js # axios 的<strong>核心主类</strong><br>│ │ ├── dispatchRequest.js # <strong>用来调用 http 请求适配器方法发送请求的函数</strong><br>│ │ ├── InterceptorManager.js # 拦截器的管理器<br>│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态<br>│ ├── /helpers/ # 一些辅助方法<br>│ ├── axios.js # 对外暴露接口<br>│ ├── defaults.js # axios 的默认配置<br>│ └── utils.js # 公用工具<br>├── package.json # 项目信息<br>├── index.d.ts # 配置 TypeScript 的声明文件<br>└── index.js # 入口文件</p></blockquote><h3 id="Ⅰ-axios-的创建过程模拟实现"><a href="#Ⅰ-axios-的创建过程模拟实现" class="headerlink" title="Ⅰ- axios 的创建过程模拟实现"></a>Ⅰ- axios 的创建过程模拟实现</h3><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//2.2 Axio内部做的事：</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//2.3 默认配置属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="built_in">this</span>.defaults = config; <span class="comment">//为了创建 default 默认属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// 2.4 添加拦截器的属性request、response，这属性就是在new 拦截器的时候加的属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// 至此defaults、intercepters完成了配置</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="built_in">this</span>.intercepters = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;request: &#123;&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;response: &#123;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//2.5 原型添加相关的方法（源码不止这几个），这样axios上面就有很多方法，实例就可以调用他们的方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;Axios.prototype.request = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;发送 AJAX 请求 请求的类型为 &#x27;</span> + config.method);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;Axios.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">return</span> <span class="built_in">this</span>.request(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;method: <span class="string">&#x27;GET&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;Axios.prototype.post = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">return</span> <span class="built_in">this</span>.request(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;method: <span class="string">&#x27;POST&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//2. createInstance函数的</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//2.1 实例化Axios的一个对象 --&gt; Axios</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> context = <span class="keyword">new</span> Axios(config); <span class="comment">// context.get()  context.post()  但是不能当做函数使用 context() X</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//2.6 创建请求函数 bind会返回新的函数，它与 Axios.prototype.request的作用是一样的，而这个方法是用来发送请求的，并修改了this指向，指向实例对象身上</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> instance = Axios.prototype.request.bind(context); </span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// 2.7 源码中使用extends做到的：可以当对象去使用，调用某些方法，而不是只能做函数调用</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// instance 是一个函数 并且可以 instance(&#123;&#125;)  此时 instance 不能 instance.get X</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....，</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// 思想：先造一个函数，再去函数身上添加对应的属性，形成最终的结构  </span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="built_in">Object</span>.keys(Axios.prototype).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// 2.8 保证内部的this始终执行实例</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;instance[key] = Axios.prototype[key].bind(context); <span class="comment">// this.default  this.interceptors</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//2.9 为 instance 函数对象添加属性 default 与 interceptors</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;Obect.keys(context).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;instance[key] = context[key];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//3. 完成返回</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">return</span> instance;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// 1. axios是通过createInstance创造出来的</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> axios = createInstance();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// axios(&#123;method:&#x27;POST&#x27;&#125;);// 可以当函数使用</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;axios.get(&#123;&#125;); <span class="comment">// 可以当对象，调方法使用</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;axios.post(&#123;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-axios发送请求过程详解"><a href="#Ⅱ-axios发送请求过程详解" class="headerlink" title="Ⅱ-axios发送请求过程详解"></a>Ⅱ-axios发送请求过程详解</h3><ol><li><p>判断传入的config是什么类型，做mergeConfig，，将用户配置的config与默认的合并</p></li><li><p>判断请求方法，都没有传方法，默认值是get，小写设置</p></li><li><p>声明一个数组chains，第一个元素dispatchRequest，它是一个用来发请求的函数，它来调http或xhr这两个打工仔</p></li><li><p>用promise.resolve()创建一个promise对象，传入config（因为它是普通对象，所以状态成功的）</p></li><li><p>请求拦截/响应拦截  略</p></li><li><p>chains的长度做循环，执行回调函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(chain.length)&#123;</span><br><span class="line">  <span class="comment">// 一开始promise是成功的，执行第一个回调，shift出来的是第一个元素dispatchRequest</span></span><br><span class="line">  <span class="comment">// dispatchRequest的结果决定then的返回值，进而决定下一个promise的值</span></span><br><span class="line">promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在dispatchRequest函数中：</p><ol><li><p>取消请求 略</p></li><li><p>确保头信息存在</p></li><li><p>对请求体内容进行转化</p></li><li><p>对请求头信息整合</p></li><li><p>获取适配器对象：要么是http适配器要么是xhr适配器</p><p><strong>xhrAdapter：</strong>函数内部new XMLHttpRequest，发ajax请求，返回的是promise</p></li><li><p>最终返回：适配器返回的promise，并指定响应成功的函数：</p><p>对响应的结果格式化处理，return response，他是一个普通对象，所以最上面的promise的then返回就是一个成功的promise</p></li></ol></li><li><p>此时request函数执行完毕—–axios执行结果完成</p></li></ol><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// axios 发送请求   axios  Axios.prototype.request  bind</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//1. 声明构造函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="built_in">this</span>.config = config;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;Axios.prototype.request = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//1.1创建一个 promise 对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(config);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//声明一个数组</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> chains = [dispatchRequest, <span class="literal">undefined</span>]; <span class="comment">// undefined 占位</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//调用 then 方法指定回调</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> result = promise.then(chains[<span class="number">0</span>], chains[<span class="number">1</span>]);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//返回 promise 的结果</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">return</span> result;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//2. dispatchRequest 函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//调用适配器发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">return</span> xhrAdapter(config).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//响应的结果进行转换处理</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//....</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">return</span> response;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">throw</span> error;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//3. adapter 适配器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;xhrAdapter 函数执行&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//发送 AJAX 请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//初始化</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;xhr.open(config.method, config.url);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//发送</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;xhr.send();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//绑定事件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//判断成功的条件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//成功的状态</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  resolve(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//配置对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">config</span>: config,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//响应体</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">data</span>: xhr.response,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//响应头</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">headers</span>: xhr.getAllResponseHeaders(), <span class="comment">//字符串  parseHeaders</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// xhr 请求对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">request</span>: xhr,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//响应状态码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">status</span>: xhr.status,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//响应状态字符串</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">statusText</span>: xhr.statusText</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//失败的状态</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求失败 失败的状态码为&#x27;</span> + xhr.status));</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//4. 创建 axios 函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> axios = Axios.prototype.request.bind(<span class="literal">null</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;axios(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;method: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;url: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="built_in">console</span>.log(response);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-拦截器的模拟实现"><a href="#Ⅲ-拦截器的模拟实现" class="headerlink" title="Ⅲ-拦截器的模拟实现"></a>Ⅲ-拦截器的模拟实现</h3><ol><li><strong>调use的时候：</strong><ul><li>InterceptorManager中会往实例的<strong>handlers属性</strong>（数组）里面<strong>push</strong>两个函数，分别是resolve，reject，其实就是use传参的时候传的两个函数，这对应一组请求拦截器</li><li>如果有第2个请求拦截器，再push第2组：成功、失败的回调函数</li><li>此时request的handlers身上已经有每个请求对应的每组回调了</li></ul></li><li><strong>response的use：</strong><ul><li>同样的，如果有第2个响应拦截器，再push第2组：成功、失败的回调函数此时response的handlers身上已经有每个响应对应的每组回调了</li></ul></li></ol><p>use在执行的时候：只是把两个函数保存在了request的handlers属性里面，response也是这样</p><ol><li><p><strong>真正发请求：</strong></p><ol><li><p>request发送请求，跟之前一样，参数检测合并</p></li><li><p>chain数组  dispatchRequest undefined</p></li><li><p>创建成功promise对象</p></li><li><p>对拦截器的实例对象中的InterceptorManager封装了一个forEach方法来遍历handlers，其实就是遍历request对象身上的handlers的数组，并将请求拦截器回调往chains数组的前面追加<strong>unshift</strong></p><p>此时chains数组就发生了变化：two two one one dispatchRequest undefined</p></li><li><p>forEach方法来遍历handlers：将响应拦截器的每组回调<strong>push</strong>到<strong>chains</strong>数组里面</p><p>此时chains变化：two two one one dispatchRequest undefined one one two two </p></li><li><p>不停的循环：从chains中取出<strong>shift</strong>执行，一组一组的执行</p><p>所以2号响应拦截器先执行：返回promise对象 –取出1号响应器执行，返回promise对象</p><p>dispatchRequest </p><p>响应1号 — 响应2号</p><p>假如这个过程中：发生了失败：失败会穿透</p></li></ol></li></ol><blockquote><ol><li>array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</li><li>思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行</li><li><code>promise = promise.then(chains.shift(), chains.shift());</code> 通过循环使用promise的then链条得到最终的结果–&gt;等式前面的<code>promise</code>将被最终的结果覆盖</li></ol></blockquote><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">&gt;<span class="built_in">this</span>.config = config;</span><br><span class="line">&gt;<span class="comment">// 最后造出来的interceptors属性可以使用request等，use实际是实例对象上面的方法</span></span><br><span class="line">&gt;<span class="built_in">this</span>.interceptors = &#123;</span><br><span class="line"><span class="attr">request</span>: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line"><span class="attr">response</span>: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//发送请求  难点与重点</span></span><br><span class="line">&gt;Axios.prototype.request = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">&gt;<span class="comment">//创建一个 promise 对象</span></span><br><span class="line">&gt;<span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line">&gt;<span class="comment">//创建一个数组</span></span><br><span class="line">&gt;<span class="keyword">const</span> chains = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">&gt;<span class="comment">//处理拦截器</span></span><br><span class="line">&gt;<span class="comment">//请求拦截器 将请求拦截器的回调 压入到 chains 的前面  request.handles = []</span></span><br><span class="line">&gt;<span class="built_in">this</span>.interceptors.request.handlers.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">chains.unshift(item.fulfilled, item.rejected);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//响应拦截器</span></span><br><span class="line">&gt;<span class="built_in">this</span>.interceptors.response.handlers.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">chains.push(item.fulfilled, item.rejected);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">while</span>(chains.length &gt; <span class="number">0</span>)&#123; </span><br><span class="line">promise = promise.then(chains.shift(), chains.shift());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> promise;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//发送请求</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">&gt;<span class="comment">//返回一个promise 队形</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//创建实例</span></span><br><span class="line">&gt;<span class="keyword">let</span> context = <span class="keyword">new</span> Axios(&#123;&#125;);</span><br><span class="line">&gt;<span class="comment">//创建axios函数</span></span><br><span class="line">&gt;<span class="keyword">let</span> axios = Axios.prototype.request.bind(context);</span><br><span class="line">&gt;<span class="comment">//将 context 属性 config interceptors 添加至 axios 函数对象身上</span></span><br><span class="line">&gt;<span class="built_in">Object</span>.keys(context).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">&gt;axios[key] = context[key];</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//拦截器管理器构造函数</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">InterceptorManager</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;<span class="built_in">this</span>.handlers = [];</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;InterceptorManager.prototype.use = <span class="function"><span class="keyword">function</span>(<span class="params">fulfilled, rejected</span>)</span>&#123;</span><br><span class="line">&gt;<span class="built_in">this</span>.handlers.push(&#123;</span><br><span class="line">fulfilled,</span><br><span class="line">rejected</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>​    功能测试代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下为</span></span><br><span class="line"><span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅳ-请求取消功能模拟实现"><a href="#Ⅳ-请求取消功能模拟实现" class="headerlink" title="Ⅳ-请求取消功能模拟实现"></a>Ⅳ-请求取消功能模拟实现</h3><ul><li>原理：未来某个时刻调用cancel() –&gt; promise属性上的promise状态变为成功–&gt; 执行成功回调:xhr.abort()取消请求：</li><li>设计思想：把代码全放在一个promise成功回调之中，在未来想让代码执行的话，你只需要改变这个promsie的状态就可以了，而它将状态改变的函数暴露给了外层，交由程序员去控制</li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//构造函数</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">this</span>.config = config;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//原型 request 方法</span></span><br><span class="line">&gt;Axios.prototype.request = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> dispatchRequest(config);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//dispatchRequest 函数</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> xhrAdapter(config);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//xhrAdapter</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">//发送 AJAX 请求</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">//实例化对象</span></span><br><span class="line">&gt;<span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&gt;<span class="comment">//初始化</span></span><br><span class="line">&gt;xhr.open(config.method, config.url);</span><br><span class="line">&gt;<span class="comment">//发送</span></span><br><span class="line">&gt;xhr.send();</span><br><span class="line">&gt;<span class="comment">//处理结果</span></span><br><span class="line">&gt;xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">&gt;<span class="comment">//判断结果</span></span><br><span class="line">&gt;<span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">&gt;<span class="comment">//设置为成功的状态</span></span><br><span class="line">&gt;resolve(&#123;</span><br><span class="line"><span class="attr">status</span>: xhr.status,</span><br><span class="line"><span class="attr">statusText</span>: xhr.statusText</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>));</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//5. 关于取消请求的处理</span></span><br><span class="line">&gt;<span class="comment">//5.1 如果你之前配置过cancelToken</span></span><br><span class="line">&gt;<span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//5.2 对 cancelToken 对象身上的 promise 对象指定成功的回调</span></span><br><span class="line">&gt;config.cancelToken.promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">&gt;xhr.abort();</span><br><span class="line">&gt;<span class="comment">//将整体结果设置为失败</span></span><br><span class="line">&gt;reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求已经被取消&#x27;</span>))</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//创建 axios 函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> context = <span class="keyword">new</span> Axios(&#123;&#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> axios = Axios.prototype.request.bind(context);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//CancelToken 构造函数</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">//1. 声明一个变量</span></span><br><span class="line">&gt;<span class="keyword">var</span> resolvePromise;</span><br><span class="line">&gt;<span class="comment">//2. 为实例的CancelToken对象身上添加属性promise，它还是一个promise对象</span></span><br><span class="line">&gt;<span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">//3. 将 resolve 赋值给 resolvePromise，它的执行就会改变这个promise的状态，因为有这个赋值了</span></span><br><span class="line">&gt;resolvePromise = resolve</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//4. 调用 executor 函数：它就是你在实例化CancelToken时传入的那个函数，此时执行</span></span><br><span class="line">&gt;<span class="comment">//4.1 而它的参数也是函数，它在运行的时候，改变了CancelToken属性的promsie状态</span></span><br><span class="line">&gt;<span class="comment">// 4.2 这个函数实际上就是c，如果c执行：说明executor内部的函数参数执行，也就是resolvePromise()会执行，相当于resolve执行，promise状态改变        重点</span></span><br><span class="line">&gt;executor(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">//执行 resolvePromise 函数，</span></span><br><span class="line">&gt;resolvePromise();</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取按钮 以上为模拟实现的代码</span></span><br><span class="line"><span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="comment">//2.声明全局变量</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line"> <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">//取消上一次的请求</span></span><br><span class="line">   cancel();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建 cancelToken 的值，是</span></span><br><span class="line"> <span class="keyword">let</span> cancelToken = <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//4.3 在这里c赋值给了cancel，所以cancel函数执行，就会触发cancelToken内部的resolve的执行，改变promise的状态</span></span><br><span class="line">   cancel = c;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> axios(&#123;</span><br><span class="line">   <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">   <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">   <span class="attr">cancelToken</span>: cancelToken</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(response);</span><br><span class="line">   <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">   cancel = <span class="literal">null</span>;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于axios的网络封装"><a href="#基于axios的网络封装" class="headerlink" title="基于axios的网络封装"></a>基于axios的网络封装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://localhost:3000&#x27;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* //封装axios方法,为不需要登录操作时使用,也可以提前传入token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>options 配置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> Axios= <span class="function">(<span class="params">options</span>)=&gt;</span>&#123;</span><br><span class="line">   axios(&#123;</span><br><span class="line">       <span class="attr">url</span>:options.url,</span><br><span class="line">       <span class="attr">method</span>:options.method||<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">       <span class="attr">data</span>: options.data,</span><br><span class="line">       <span class="attr">params</span>: options.data</span><br><span class="line">   &#125;).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (options.success)  options.success(result.data)</span><br><span class="line">   &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> msg = err.response ? err.response.data:<span class="string">&#x27;请求异常&#x27;</span></span><br><span class="line">       <span class="keyword">if</span> (options.error)&#123;</span><br><span class="line">           options.error(msg)</span><br><span class="line">           Message.error(&#123;<span class="attr">message</span>: msg, <span class="attr">offset</span>: <span class="number">150</span>&#125;);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Message.error(&#123;<span class="attr">message</span>: msg, <span class="attr">offset</span>: <span class="number">150</span>&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不拦截的(不带token)往往用在vue创建前的生命周期中</span></span><br><span class="line">Vue.prototype.$Axios = Axios</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ajax、Axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> 网络请求 </tag>
            
            <tag> axios </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Ajax</title>
      <link href="/2021/12/11/%E5%85%B3%E4%BA%8EAjax/"/>
      <url>/2021/12/11/%E5%85%B3%E4%BA%8EAjax/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Ajax是什么"><a href="#一、Ajax是什么" class="headerlink" title="一、Ajax是什么"></a>一、Ajax是什么</h2><h3 id="1-ajax之前"><a href="#1-ajax之前" class="headerlink" title="1. ajax之前"></a>1. ajax之前</h3><ul><li>服务端与客户端的交互方式：</li></ul><img src="http://www.conardli.top/img/wl/wlqq_1.png" alt="image" style="zoom: 67%;" /><ul><li><p>缺点：</p><p>任何和服务器的交互都需要刷新页面，用户体验非常差，<code>Ajax</code>的出现解决了这个问题</p></li></ul><h3 id="2-Ajax是什么"><a href="#2-Ajax是什么" class="headerlink" title="2. Ajax是什么"></a>2. Ajax是什么</h3><p><a href="https://segmentfault.com/a/1190000004322487#articleHeader13">你真的会使用XMLHttpRequest吗？ - SegmentFault 思否</a></p><ul><li><p><code>Async JavaScript And XML</code>，<code>ajax</code>是一种技术方案，但并不是一种<strong>新技术</strong>。它依赖的是现有的<code>CSS</code>/<code>HTML</code>/<code>Javascript</code></p><ul><li><p>而其中最核心的依赖是浏览器提供的<code>XMLHttpRequest</code>对象，是这个对象使得浏览器可以发出<code>HTTP</code>请求与接收<code>HTTP</code>响应</p></li><li><p>总结两者的关系：我们使用<code>XMLHttpRequest</code>对象来发送一个<code>Ajax</code>请求</p></li><li><p>XML：可拓展标记语言，被设计用来传输、存储数据，历史后端中返回的形式，现在被JSON取代了</p></li></ul></li><li><p><strong>最大优势特点：</strong></p><ul><li>页面<strong>不刷新</strong>的情况下与服务器通信</li><li>允许根据用户事件来更新部分页面内容</li></ul></li><li><p><strong>缺点：</strong></p><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源策略限制）</li><li>SEO不友好</li></ol></li></ul><h3 id="3、XMLHttpRequest发展历程"><a href="#3、XMLHttpRequest发展历程" class="headerlink" title="3、XMLHttpRequest发展历程"></a>3、<code>XMLHttpRequest</code>发展历程</h3><p>一开始只是微软浏览器提供的一个接口，后来W3C对它进行了标准化，再后来提出了<a href="https://link.segmentfault.com/?url=https://www.w3.org/TR/XMLHttpRequest/"><code>XMLHttpRequest</code>标准</a>。<code>XMLHttpRequest</code>标准又分为<code>Level 1</code>和<code>Level 2</code></p><h4 id="1、Level-1主要缺点："><a href="#1、Level-1主要缺点：" class="headerlink" title="1、Level 1主要缺点："></a>1、Level 1主要缺点：</h4><ul><li>受同源策略的限制，不能发送跨域请求；</li><li>不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；</li><li>在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</li></ul><h4 id="2、Level-2中新增："><a href="#2、Level-2中新增：" class="headerlink" title="2、Level 2中新增："></a>2、Level 2中新增：</h4><ul><li>可以发送跨域请求，在服务端允许的情况下；</li><li>支持发送和接收二进制数据；</li><li>新增formData对象，支持发送表单数据；</li><li>发送和获取数据时，可以获取进度信息；</li><li>可以设置请求的超时时间；</li></ul><h4 id="3、XMLHttpRequest兼容性"><a href="#3、XMLHttpRequest兼容性" class="headerlink" title="3、XMLHttpRequest兼容性"></a>3、<code>XMLHttpRequest</code>兼容性</h4><p>Can I use”这个网站提供的结果<a href="https://link.segmentfault.com/?url=http://caniuse.com/%23search=XMLHttpRequest">XMLHttpRequest兼容性</a></p><p><img src="https://segmentfault.com/img/bVsiDk" alt="clipboard.png"></p><p>从图中可以看到：</p><ul><li>IE8/IE9、Opera Mini 完全不支持<code>xhr</code>对象</li><li>IE10/IE11部分支持，不支持 <code>xhr.responseType</code>为<code>json</code></li><li>部分浏览器不支持设置请求超时，即无法使用<code>xhr.timeout</code></li><li>部分浏览器不支持<code>xhr.responseType</code>为<code>blob</code></li></ul><h2 id="二、XMLHttpRequest如何使用"><a href="#二、XMLHttpRequest如何使用" class="headerlink" title="二、XMLHttpRequest如何使用"></a>二、<code>XMLHttpRequest</code>如何使用</h2><p>使用<code>XMLHttpRequest</code>发送<code>Ajax</code>请求</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//构造表单数据</span></span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">  formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;johndoe&#x27;</span>);</span><br><span class="line">  formData.append(<span class="string">&#x27;id&#x27;</span>, <span class="number">123456</span>);</span><br><span class="line">  <span class="comment">//创建xhr对象 </span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="comment">//设置xhr请求的超时时间</span></span><br><span class="line">  xhr.timeout = <span class="number">3000</span>;</span><br><span class="line">  <span class="comment">//设置响应返回的数据格式</span></span><br><span class="line">  xhr.responseType = <span class="string">&quot;text&quot;</span>;</span><br><span class="line">  <span class="comment">//创建一个 post 请求，采用异步</span></span><br><span class="line">  xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//注册相关事件回调处理函数</span></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status == <span class="number">200</span>||<span class="built_in">this</span>.status == <span class="number">304</span>)&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; ... &#125;;</span><br><span class="line">  xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; ... &#125;;</span><br><span class="line">  xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; ... &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发送数据</span></span><br><span class="line">  xhr.send(formData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、如何设置request-header"><a href="#1、如何设置request-header" class="headerlink" title="1、如何设置request header"></a>1、如何设置request header</h3><p>在发送<code>Ajax</code>请求（实质是一个<a href="https://link.segmentfault.com/?url=http://www.tutorialspoint.com/http/http_header_fields.htm">HTTP</a>请求）时，我们可能需要设置一些请求头部信息，比如<code>content-type</code>、<code>connection</code>、<code>cookie</code>、<code>accept-xxx</code>等。<code>xhr</code>提供了<code>setRequestHeader</code>来允许我们修改请求 header。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setRequestHeader(DOMString header, DOMString value);</span><br></pre></td></tr></table></figure></blockquote><p><strong>注意点</strong>：</p><ul><li>方法的第一个参数 header 大小写不敏感，即可以写成<code>content-type</code>，也可以写成<code>Content-Type</code>，甚至写成<code>content-Type</code>;</li><li><code>Content-Type</code>的默认值与具体发送的数据类型有关</li><li><strong><code>setRequestHeader</code>必须在<code>open()</code>方法之后，<code>send()</code>方法之前调用，否则会抛错；</strong></li><li><code>setRequestHeader</code>可以调用多次，最终的值不会采用覆盖<code>override</code>的方式，而是采用追加<code>append</code>的方式。下面是一个示例代码：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">client.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;demo.cgi&#x27;</span>);</span><br><span class="line">client.setRequestHeader(<span class="string">&#x27;X-Test&#x27;</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">client.setRequestHeader(<span class="string">&#x27;X-Test&#x27;</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line"><span class="comment">// 最终request header中&quot;X-Test&quot;为: one, two</span></span><br><span class="line">client.send();</span><br></pre></td></tr></table></figure><h3 id="2、如何获取response-header"><a href="#2、如何获取response-header" class="headerlink" title="2、如何获取response header"></a>2、如何获取response header</h3><p><code>xhr</code>提供了2个用来获取响应头部的方法：</p><ol><li><p><code>getAllResponseHeaders</code>：获取 response 中的所有header 字段</p></li><li><p><code>getResponseHeader</code>：只是获取某个指定 header 字段的值，<code>header</code>参数不区分大小写</p></li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOMString getAllResponseHeaders();</span><br><span class="line">DOMString getResponseHeader(DOMString header);</span><br></pre></td></tr></table></figure></blockquote><h4 id="【注意大坑】："><a href="#【注意大坑】：" class="headerlink" title="【注意大坑】："></a>【注意大坑】：</h4><ol><li><p>使用<code>getAllResponseHeaders()</code>看到的所有<code>response header</code>与实际在控制台 <code>Network</code> 中看到的 <code>response header</code> 不一样</p><p>这个方法只能拿到<strong>限制以外</strong>（即被视为<code>safe</code>）的header字段，而不是全部字段</p></li><li><p>使用<code>getResponseHeader()</code>获取某个 <code>header</code> 的值时，浏览器抛错<code>Refused to get unsafe header &quot;XXX&quot;</code></p><p><code>header</code>参数必须是***限制以外***的header字段，否则调用就会报<code>Refused to get unsafe header</code>的错误</p></li></ol><p>经过一番寻找最终在 <a href="https://link.segmentfault.com/?url=http://stackoverflow.com/questions/7462968/restrictions-of-xmlhttprequests-getresponseheader">Stack Overflow找到了答案</a>。</p><ul><li>原因1：<a href="https://link.segmentfault.com/?url=https://www.w3.org/TR/XMLHttpRequest/">W3C的 xhr 标准中做了限制</a>，规定客户端无法获取 response 中的 <code>Set-Cookie</code>、<code>Set-Cookie2</code>这2个字段，无论是同域还是跨域请求；</li><li>原因2：<a href="https://link.segmentfault.com/?url=https://www.w3.org/TR/cors/%23access-control-allow-credentials-response-header">W3C 的 cors 标准对于跨域请求也做了限制</a>，规定对于跨域请求，客户端允许获取的response header字段只限于“<code>simple response header</code>”和“<code>Access-Control-Expose-Headers</code>” <ul><li>“<code>simple response header</code>“包括的 header 字段有：<code>Cache-Control</code>,<code>Content-Language</code>,<code>Content-Type</code>,<code>Expires</code>,<code>Last-Modified</code>,<code>Pragma</code>;</li><li>“<code>Access-Control-Expose-Headers</code>“：首先得注意是”<code>Access-Control-Expose-Headers</code>“进行<strong>跨域请求</strong>时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段</li></ul></li></ul><h3 id="3、如何指定xhr-response的数据类型"><a href="#3、如何指定xhr-response的数据类型" class="headerlink" title="3、如何指定xhr.response的数据类型"></a>3、如何指定<code>xhr.response</code>的数据类型</h3><p>有些时候我们希望<code>xhr.response</code>返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过<code>xhr.response</code>拿到的直接就是一个 js 对象，我们该怎么实现呢？</p><ul><li>一个是<code>level 1</code>就提供的<code>overrideMimeType()</code>方法</li><li>另一个是<code>level 2</code>才提供的<code>xhr.responseType</code>属性</li></ul><h4 id="1、xhr-overrideMimeType"><a href="#1、xhr-overrideMimeType" class="headerlink" title="1、xhr.overrideMimeType()"></a>1、<code>xhr.overrideMimeType()</code></h4><p>作用就是用来重写<code>response</code>的<code>content-type</code></p><p>意义：</p><ol><li>比如：server 端给客户端返回了一份<code>document</code>或者是 <code>xml</code>文档，我们希望最终通过<code>xhr.response</code>拿到的就是一个<code>DOM</code>对象，那么就可以用<code>xhr.overrideMimeType(&#39;text/xml; charset = utf-8&#39;)</code>来实现</li><li>们都知道<code>xhr level 1</code>不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用<code>overrideMimeType</code>方法来解决这个问题的</li></ol><p>下面是一个获取图片文件的代码示例：</p><ul><li>通过将 <code>response</code> 的 <code>content-type</code> 改为’text/plain; charset=x-user-defined’，使得 <code>xhr</code> 以纯文本格式来解析接收到的blob 数据</li><li>最终用户通过<code>this.responseText</code>拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//向 server 端获取一张图片</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这行是关键！</span></span><br><span class="line"><span class="comment">//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集</span></span><br><span class="line">xhr.overrideMimeType(<span class="string">&#x27;text/plain; charset=x-user-defined&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">//通过 responseText 来获取图片文件对应的二进制字符串</span></span><br><span class="line">    <span class="keyword">var</span> binStr = <span class="built_in">this</span>.responseText;</span><br><span class="line">    <span class="comment">//然后自己再想方法将逐个字节还原为二进制数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = binStr.length; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="keyword">var</span> c = binStr.charCodeAt(i);</span><br><span class="line">      <span class="comment">//String.fromCharCode(c &amp; 0xff);</span></span><br><span class="line">      <span class="keyword">var</span> byte = c &amp; <span class="number">0xff</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h4 id="2、xhr-responseType"><a href="#2、xhr-responseType" class="headerlink" title="2、xhr.responseType"></a>2、<code>xhr.responseType</code></h4><ul><li>它有兼容性问题，那么<code>responseType</code>可以设置为哪些格式呢</li></ul><table><thead><tr><th>值</th><th><code>xhr.response</code> 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td><code>String</code>字符串</td><td>默认值(在不设置<code>responseType</code>时)</td></tr><tr><td><code>&quot;text&quot;</code></td><td><code>String</code>字符串</td><td></td></tr><tr><td><code>&quot;document&quot;</code></td><td><code>Document</code>对象</td><td>希望返回 <code>XML</code> 格式数据时使用</td></tr><tr><td><code>&quot;json&quot;</code></td><td><code>javascript</code> 对象</td><td>存在兼容性问题，IE10/IE11不支持</td></tr><tr><td><code>&quot;blob&quot;</code></td><td><code>Blob</code>对象</td><td></td></tr><tr><td><code>&quot;arrayBuffer&quot;</code></td><td><code>ArrayBuffer</code>对象</td><td></td></tr></tbody></table><p>下面是同样是获取一张图片的代码示例，用<code>xhr.response</code>来实现简单得多。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`</span></span><br><span class="line"><span class="comment">//xhr.responseType = &#x27;arrayBuffer&#x27;;</span></span><br><span class="line">xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="built_in">this</span>.response;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><ul><li><code>xhr.responseType</code>就是用来取代<code>xhr.overrideMimeType()</code>的，<code>xhr.responseType</code>功能强大的多</li></ul><h3 id="4、如何获取response数据"><a href="#4、如何获取response数据" class="headerlink" title="4、如何获取response数据"></a>4、如何获取response数据</h3><p><code>xhr</code>提供了3个属性来获取请求返回的数据，分别是：<code>xhr.response</code>、<code>xhr.responseText</code>、<code>xhr.responseXML</code></p><h4 id="1、xhr-response"><a href="#1、xhr-response" class="headerlink" title="1、xhr.response"></a>1、<code>xhr.response</code></h4><ul><li>默认值：空字符串<code>&quot;&quot;</code></li><li>当请求完成时，此属性才有正确的值</li><li>请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></li></ul><h4 id="2、xhr-responseText"><a href="#2、xhr-responseText" class="headerlink" title="2、xhr.responseText"></a>2、<code>xhr.responseText</code></h4><ul><li>默认值为空字符串<code>&quot;&quot;</code></li><li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错</li><li>只有当请求成功时，才能拿到正确值。请求未完成、请求失败值都为空字符串<code>&quot;&quot;</code></li></ul><h4 id="3、xhr-responseXML"><a href="#3、xhr-responseXML" class="headerlink" title="3、xhr.responseXML"></a>3、<code>xhr.responseXML</code></h4><ul><li><p>默认值为 <code>null</code></p></li><li><p>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseXML</code>，否则抛错</p></li><li><p>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为<code>null</code>：</p><p>请求未完成、请求失败、请求成功但返回数据无法被正确解析时</p></li></ul><h3 id="5、如何追踪ajax请求的当前状态"><a href="#5、如何追踪ajax请求的当前状态" class="headerlink" title="5、如何追踪ajax请求的当前状态"></a>5、如何追踪<code>ajax</code>请求的当前状态</h3><p>用<code>xhr.readyState</code>这个属性即可追踪到，总共有5种可能值，分别对应<code>xhr</code>不同的不同阶段，次<code>xhr.readyState</code>的值发生变化时，都会触发<code>xhr.onreadystatechange</code>事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(xhr.readyState)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//OPENED</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//HEADERS_RECEIVED</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//LOADING</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//DONE</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>UNSENT</code> (初始状态，未打开)</td><td>此时<code>xhr</code>对象被成功构造，<code>open()</code>方法还未被调用</td></tr><tr><td><code>1</code></td><td><code>OPENED</code> (已打开，未发送)</td><td><code>open()</code>方法已被成功调用，<code>send()</code>方法还未被调用。注意：只有<code>xhr</code>处于<code>OPENED</code>状态，才能调用<code>xhr.setRequestHeader()</code>和<code>xhr.send()</code>,否则会报错</td></tr><tr><td><code>2</code></td><td><code>HEADERS_RECEIVED</code> (已获取响应头)</td><td><code>send()</code>方法已经被调用, 响应头和响应状态已经返回</td></tr><tr><td><code>3</code></td><td><code>LOADING</code> (正在下载响应体)</td><td>响应体(<code>response entity body</code>)正在下载中，此状态下通过<code>xhr.response</code>可能已经有了响应数据</td></tr><tr><td><code>4</code></td><td><code>DONE</code> (整个数据传输过程结束)</td><td>整个数据传输过程结束，不管本次请求是成功还是失败</td></tr></tbody></table><h3 id="6、如何设置请求的超时时间"><a href="#6、如何设置请求的超时时间" class="headerlink" title="6、如何设置请求的超时时间"></a>6、如何设置请求的超时时间</h3><p>如果请求过了很久还没有成功，为了不会白白占用的网络资源，一般会主动终止请求</p><ul><li>XMLHttpRequest提供了<code>timeout</code>属性来允许设置请求的超时时间</li><li>从*<strong>请求开始*</strong> 算起，若超过 <code>timeout</code> 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.timeout            单位：毫秒     默认值：`0`，即不设置超时</span><br></pre></td></tr></table></figure></blockquote><h4 id="1、什么时候才算是请求开始-？"><a href="#1、什么时候才算是请求开始-？" class="headerlink" title="1、什么时候才算是请求开始 ？"></a>1、什么时候才算是请求开始 ？</h4><p><code>xhr.onloadstart</code>事件触发的时候，也就是你调用<code>xhr.send()</code>方法的时候：</p><ul><li><code>xhr.open()</code>只是创建了一个连接，但并没有真正开始数据的传输</li><li>而<code>xhr.send()</code>才是真正开始了数据的传输过程。只有调用了<code>xhr.send()</code>，才会触发<code>xhr.onloadstart</code> </li></ul><h4 id="2、什么时候才算是请求结束？"><a href="#2、什么时候才算是请求结束？" class="headerlink" title="2、什么时候才算是请求结束？"></a>2、什么时候才算是请求结束？</h4><p> <code>xhr.loadend</code>事件触发的时候</p><h4 id="3、2个坑："><a href="#3、2个坑：" class="headerlink" title="3、2个坑："></a>3、2个坑：</h4><ol><li>可以在 <code>send()</code>之后再设置此<code>xhr.timeout</code>，但计时起始点仍为调用<code>xhr.send()</code>方法的时刻。</li><li>当<code>xhr</code>为一个<code>sync</code>同步请求时，<code>xhr.timeout</code>必须置为<code>0</code>，否则会抛错。原因可以参考本文的【如何发一个同步请求】</li></ol><h3 id="7、如何发一个同步请求"><a href="#7、如何发一个同步请求" class="headerlink" title="7、如何发一个同步请求"></a>7、如何发一个同步请求</h3><p>由<code>xhr.open（）</code>传入的<code>async</code>参数决定，默认发异步true</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(method, url [, async = true [, username = null [, password = null]]])</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>method</code>: 请求的方式，如<code>GET/POST/HEADER</code>等，这个参数不区分大小写</li><li><code>url</code>: 请求的地址，可以是相对地址如<code>example.php</code>，这个<strong>相对</strong>是相对于当前网页的<code>url</code>路径；也可以是绝对地址如<code>http://www.example.com/example.php</code></li><li><code>async</code>: 默认值为<code>true</code>，即为异步请求，若<code>async=false</code>，则为同步请求</li></ul><h4 id="1、同步与异步的区别："><a href="#1、同步与异步的区别：" class="headerlink" title="1、同步与异步的区别："></a>1、同步与异步的区别：</h4><p>当<code>xhr</code>为同步请求时，有如下限制：任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制</p><ul><li><code>xhr.timeout</code>必须为<code>0</code></li><li><code>xhr.withCredentials</code>必须为 <code>false</code></li><li><code>xhr.responseType</code>必须为<code>&quot;&quot;</code>（注意置为<code>&quot;text&quot;</code>也不允许）</li></ul><h4 id="2、为什么尽量避免使用sync同步请求"><a href="#2、为什么尽量避免使用sync同步请求" class="headerlink" title="2、为什么尽量避免使用sync同步请求"></a>2、为什么尽量避免使用<code>sync</code>同步请求</h4><ol><li><p>因为无法设置请求超时时间（<code>xhr.timeout</code>为<code>0</code>，即不限时）</p><p>在不限制超时的情况下，有可能同步请求一直处于<code>pending</code>状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互</p></li><li><p>标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象</p><p>如在 chrome中，当<code>xhr</code>为同步请求时，在<code>xhr.readyState</code>由<code>2</code>变成<code>3</code>时，并不会触发 <code>onreadystatechange</code>事件，<code>xhr.upload.onprogress</code>和 <code>xhr.onprogress</code>事件也不会触发</p></li></ol><h3 id="8、如何获取上传、下载的进度"><a href="#8、如何获取上传、下载的进度" class="headerlink" title="8、如何获取上传、下载的进度"></a>8、如何获取上传、下载的进度</h3><p>在上传或者下载比较大的文件时，可以通过<code>onprogress</code>事件来实时显示进度</p><ul><li><p>默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的<code>onprogress</code>事件：</p></li><li><p>上传触发的是<code>xhr.upload</code>对象的 <code>onprogress</code>事件</p></li><li><p>下载触发的是<code>xhr</code>对象的<code>onprogress</code>事件</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.onprogress = updateProgress;</span><br><span class="line">xhr.upload.onprogress = updateProgress;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">      <span class="keyword">var</span> completedPercent = event.loaded / event.total;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="9、可以发送什么类型的数据"><a href="#9、可以发送什么类型的数据" class="headerlink" title="9、可以发送什么类型的数据"></a>9、可以发送什么类型的数据</h3><h4 id="1、支持的类型"><a href="#1、支持的类型" class="headerlink" title="1、支持的类型"></a>1、支持的类型</h4><p><code>xhr.send(data)</code>的参数data可以是类型：<code>ArrayBuffer</code>、<code>Blob</code>、<code>Document</code>、<code>DOMString</code>、<code>FormData</code>、<code>null</code></p><ul><li><p>GET/HEAD请求：<code>send()</code>方法一般不传参或传 <code>null</code></p><p>即使你真传入了参数，参数也最终被忽略，<code>xhr.send(data)</code>中的data会被置为 <code>null</code></p></li></ul><h4 id="2、如何影响请求头部"><a href="#2、如何影响请求头部" class="headerlink" title="2、如何影响请求头部"></a>2、如何影响请求头部</h4><p><code>xhr.send(data)</code>中data参数的数据类型会影响请求头部<code>content-type</code>的默认值：</p><ul><li>如果<code>data</code>是 <code>Document</code> 类型，同时也是<code>HTML Document</code>类型，则<code>content-type</code>默认值为<code>text/html;charset=UTF-8</code>;否则为<code>application/xml;charset=UTF-8</code>；</li><li>如果<code>data</code>是 <code>DOMString</code> 类型，<code>content-type</code>默认值为<code>text/plain;charset=UTF-8</code>；</li><li>如果<code>data</code>是 <code>FormData</code> 类型，<code>content-type</code>默认值为<code>multipart/form-data; boundary=[xxx]</code></li><li>如果<code>data</code>是其他类型，则不会设置<code>content-type</code>的默认值</li></ul><p>但如果用<code>xhr.setRequestHeader()</code>手动设置了中<code>content-type</code>的值，以上默认值就会被覆盖</p><h4 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h4><p>若在断网状态下调用<code>xhr.send(data)</code>方法，则会抛错：<code>Uncaught NetworkError: Failed to execute &#39;send&#39; on &#39;XMLHttpRequest&#39;</code></p><ul><li>一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 <code>xhr.send(data)</code>方法时，应该用 <code>try-catch</code>捕捉错误</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    xhr.send(data)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">//doSomething...</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="10、xhr-withCredentials与-CORS-什么关系"><a href="#10、xhr-withCredentials与-CORS-什么关系" class="headerlink" title="10、xhr.withCredentials与 CORS 什么关系"></a>10、<code>xhr.withCredentials</code>与 <code>CORS</code> 什么关系</h3><h4 id="1、跨域不自动加cookie？"><a href="#1、跨域不自动加cookie？" class="headerlink" title="1、跨域不自动加cookie？"></a>1、跨域不自动加cookie？</h4><ul><li>在发同域请求时，浏览器会将<code>cookie</code>自动加在<code>request header</code>中</li><li>但，在发送跨域请求时，<code>cookie</code>并没有自动加在<code>request header</code>中</li></ul><h4 id="2、为什么？"><a href="#2、为什么？" class="headerlink" title="2、为什么？"></a>2、为什么？</h4><p>【注意】造成这个问题的原因是：</p><ol><li><p>在<code>CORS</code>标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（<code>credentials</code>）如”<code>cookies</code>“和”<code>HTTP authentication schemes</code>“，除非<code>xhr.withCredentials</code>为<code>true</code>（<code>xhr</code>对象有一个属性叫<code>withCredentials</code>，默认值为<code>false</code>）</p></li><li><p><code>cookies</code>也是一种认证信息，在跨域请求中，<code>client</code>端必须手动设置<code>xhr.withCredentials=true</code>，且<code>server</code>端也必须允许<code>request</code>能携带认证信息（即<code>response header</code>中包含<code>Access-Control-Allow-Credentials:true</code>），这样浏览器才会自动将<code>cookie</code>加在<code>request header</code>中</p></li></ol><p>【特别注意】：</p><ul><li>一旦跨域<code>request</code>能够携带认证信息，<code>server</code>端一定不能将<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，而必须设置为请求页面的域名</li></ul><h2 id="三、xhr相关事件"><a href="#三、xhr相关事件" class="headerlink" title="三、xhr相关事件"></a>三、<code>xhr</code>相关事件</h2><h3 id="1、事件分类"><a href="#1、事件分类" class="headerlink" title="1、事件分类"></a>1、事件分类</h3><p><code>XMLHttpRequestEventTarget</code>接口定义了7个事件：</p><ul><li><code>onloadstart</code>、<code>onprogress</code>、<code>onabort</code>、<code>ontimeout</code>、<code>onerror</code>、<code>onload</code>、<code>onloadend</code></li></ul><h4 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h4><p>总结：<code>xhr</code>一共有8个相关事件：7个<code>XMLHttpRequestEventTarget</code>事件+1个独有的<code>onreadystatechange</code>事件；而<code>xhr.upload</code>只有7个<code>XMLHttpRequestEventTarget</code>事件</p><ol><li>每一个<code>XMLHttpRequest</code>里面都有一个<code>upload</code>属性，而<code>upload</code>是一个<code>XMLHttpRequestUpload</code>对象</li><li><code>XMLHttpRequest</code>和<code>XMLHttpRequestUpload</code>都继承了同一个<code>XMLHttpRequestEventTarget</code>接口，所以<code>xhr</code>和<code>xhr.upload</code>都有第一条列举的7个事件</li><li><code>onreadystatechange</code>是<code>XMLHttpRequest</code>独有的事件</li></ol><h3 id="2、事件触发条件"><a href="#2、事件触发条件" class="headerlink" title="2、事件触发条件"></a>2、事件触发条件</h3><p>下面是我自己整理的一张<code>xhr</code>相关事件触发条件表，其中最需要注意的是 <code>onerror</code> 事件的触发条件。</p><table><thead><tr><th>事件</th><th>触发条件</th></tr></thead><tbody><tr><td><code>onreadystatechange</code></td><td>每当<code>xhr.readyState</code>改变时触发；但<code>xhr.readyState</code>由非<code>0</code>值变为<code>0</code>时不触发。</td></tr><tr><td><code>onloadstart</code></td><td>调用<code>xhr.send()</code>方法后立即触发，若<code>xhr.send()</code>未被调用则不会触发此事件。</td></tr><tr><td><code>onprogress</code></td><td><code>xhr.upload.onprogress</code>在上传阶段(即<code>xhr.send()</code>之后，<code>xhr.readystate=2</code>之前)触发，每50ms触发一次；<code>xhr.onprogress</code>在下载阶段（即<code>xhr.readystate=3</code>时）触发，每50ms触发一次。</td></tr><tr><td><code>onload</code></td><td>当请求成功完成时触发，此时<code>xhr.readystate=4</code></td></tr><tr><td><code>onloadend</code></td><td>当请求结束（包括请求成功和请求失败）时触发</td></tr><tr><td><code>onabort</code></td><td>当调用<code>xhr.abort()</code>后触发</td></tr><tr><td><code>ontimeout</code></td><td><code>xhr.timeout</code>不等于0，由请求开始即<code>onloadstart</code>开始算起，当到达<code>xhr.timeout</code>所设置时间请求还未结束即<code>onloadend</code>，则触发此事件。</td></tr><tr><td><code>onerror</code></td><td>在请求过程中，若发生<code>Network error</code>则会触发此事件（若发生<code>Network error</code>时，上传还没有结束，则会先触发<code>xhr.upload.onerror</code>，再触发<code>xhr.onerror</code>；若发生<code>Network error</code>时，上传已经结束，则只会触发<code>xhr.onerror</code>）。<br /><strong>注意</strong>，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的<code>xhr.statusCode</code>是<code>4xx</code>时，并不属于<code>Network error</code>，所以不会触发<code>onerror</code>事件，而是会触发<code>onload</code>事件。</td></tr></tbody></table><h3 id="3、事件触发顺序"><a href="#3、事件触发顺序" class="headerlink" title="3、事件触发顺序"></a>3、事件触发顺序</h3><p>当请求一切正常时，相关的事件触发顺序如下：</p><ol><li>触发<code>xhr.onreadystatechange</code>(之后每次<code>readyState</code>变化时，都会触发一次)</li><li>触发<code>xhr.onloadstart</code><br>//上传阶段开始：</li><li>触发<code>xhr.upload.onloadstart</code></li><li>触发<code>xhr.upload.onprogress</code></li><li>触发<code>xhr.upload.onload</code></li><li>触发<code>xhr.upload.onloadend</code><br>//上传结束，下载阶段开始：</li><li>触发<code>xhr.onprogress</code></li><li>触发<code>xhr.onload</code></li><li>触发<code>xhr.onloadend</code></li></ol><h3 id="4、发生abort-timeout-error异常处理"><a href="#4、发生abort-timeout-error异常处理" class="headerlink" title="4、发生abort/timeout/error异常处理"></a>4、发生<code>abort</code>/<code>timeout</code>/<code>error</code>异常处理</h3><p>在请求的过程中，有可能发生 <code>abort</code>/<code>timeout</code>/<code>error</code>这3种异常。那么一旦发生这些异常，<code>xhr</code>后续会进行哪些处理呢？后续处理如下：</p><ol><li>一旦发生<code>abort</code>或<code>timeout</code>或<code>error</code>异常，先立即中止当前请求</li><li>将 <code>readystate</code> 置为<code>4</code>，并触发 <code>xhr.onreadystatechange</code>事件</li><li>如果上传阶段还没有结束，则依次触发以下事件：<ul><li><code>xhr.upload.onprogress</code></li><li><code>xhr.upload.[onabort或ontimeout或onerror]</code></li><li><code>xhr.upload.onloadend</code></li></ul></li><li>触发 <code>xhr.onprogress</code>事件</li><li>触发 <code>xhr.[onabort或ontimeout或onerror]</code>事件</li><li>触发<code>xhr.onloadend</code> 事件</li></ol><h3 id="5、在哪个xhr事件中注册成功回调？"><a href="#5、在哪个xhr事件中注册成功回调？" class="headerlink" title="5、在哪个xhr事件中注册成功回调？"></a>5、在哪个<code>xhr</code>事件中注册成功回调？</h3><h4 id="1、onreadystatechange、onload"><a href="#1、onreadystatechange、onload" class="headerlink" title="1、onreadystatechange、onload"></a>1、onreadystatechange、onload</h4><ul><li>若<code>xhr</code>请求成功，就会触发<code>xhr.onreadystatechange</code>和<code>xhr.onload</code>两个事件</li><li>但倾向于 <code>xhr.onload</code>事件，因为<code>xhr.onreadystatechange</code>是每次<code>xhr.readyState</code>变化时都会触发，而不是<code>xhr.readyState=4</code>时才触发</li></ul><h4 id="2、坑"><a href="#2、坑" class="headerlink" title="2、坑"></a>2、坑</h4><p>这样的判断是有坑儿的，比如当返回的<code>http</code>状态码不是<code>200</code>，而是<code>201</code>时，请求虽然也是成功的，但并没有执行成功回调逻辑</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果请求成功</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//do successCallback</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>更靠谱的判断方法应该是：当<code>http</code>状态码为<code>2xx</code>或<code>304</code>时才认为成功</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果请求成功</span></span><br><span class="line">  <span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">    <span class="comment">//do successCallback</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用场景：</strong></p><ul><li>页面上拉加载更多数据，页面没有更新只是把请求来的数据呈现出来</li><li>列表数据无刷新分页</li><li>表单数据离开焦点验证，比如邮箱注册的时候输完地址会自动显示该地址是否已被注册</li><li>搜索框文字自动提示</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 跨域携带cookie</span></span><br><span class="line">   xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 处理请求参数</span></span><br><span class="line">   postData = &#123;<span class="string">&quot;name1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;name2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;;</span><br><span class="line">   postData = (<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> dataString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> value)&#123;</span><br><span class="line">        dataString += key+<span class="string">&quot;=&quot;</span>+value[key]+<span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">   &#125;;</span><br><span class="line">     <span class="keyword">return</span> dataString;</span><br><span class="line">   &#125;(postData));</span><br><span class="line">  </span><br><span class="line">   xhr.open(<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;www.xxx.com&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line">   xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">   xhr.send(postData);</span><br><span class="line">  </span><br><span class="line">   xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> )&#123;</span><br><span class="line">           <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 异常处理</span></span><br><span class="line">   xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;Network request failed&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="http://www.conardli.top/img/wl/wlqq_2.png" alt="image" style="zoom: 67%;" /><h2 id="四、xhr相关API用法"><a href="#四、xhr相关API用法" class="headerlink" title="四、xhr相关API用法"></a>四、xhr相关API用法</h2><h3 id="1、xhr方法"><a href="#1、xhr方法" class="headerlink" title="1、xhr方法"></a>1、xhr方法</h3><h4 id="1-open方法"><a href="#1-open方法" class="headerlink" title="1. open方法"></a>1. open方法</h4><ul><li><p>用于初始化一个请求，为请求做准备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(method,URL,async)</span><br><span class="line">// 注意：只能访问同源URL,域名，端口，协议相同</span><br><span class="line">// 如果请求的URL和发送请求的页面在任何地方有所不同，就会抛出安全错误</span><br></pre></td></tr></table></figure><ul><li><code>method</code>：请求方式，如<code>get、post</code></li><li><code>url</code>：请求的<code>url</code></li><li><code>async</code>：是否为异步请求，true/false</li></ul></li></ul><h4 id="2-send方法"><a href="#2-send方法" class="headerlink" title="2. send方法"></a>2. send方法</h4><ul><li><p>用于发送HTTP请求，即调用该方法后HTTP请求才会被真正发出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.send(param)</span><br></pre></td></tr></table></figure></li><li><p><code>param</code>：http请求的参数，作为请求体发送的数据，可以为<code>string、Blob</code>等类型。null代表不发</p></li><li><p>这个请求是同步的，所以JS代码会等待服务器相应后，再继续执行。</p></li><li><p>收到服务器响应后，XHR对象的某些属性会被填充数据</p><ul><li>ResponseText：作为响应返回的文本</li><li>ResponseXML：如果响应的内容类型是”text\html”，那就是包含响应数据的XML DOM文档</li><li>status：响应HTTP状态</li><li>statusText：响应的HTTP状态描述</li></ul></li></ul><h4 id="3-setRequestHeader"><a href="#3-setRequestHeader" class="headerlink" title="3. setRequestHeader"></a>3. setRequestHeader</h4><ul><li><p>用于设置<code>HTTP</code>请求头，默认情况，会发头部字段，还可以发额外的请求</p></li><li><p>必须在<code>open()</code>方法和<code>send()</code>之间调用</p></li><li><p>可以与通用字段重名（即重写，有的浏览器不支持），或自定义</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(header, value);</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://www.example.com&#x27;</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">xhr.send(<span class="string">&#x27;name=zhangsan&amp;age=12&#x27;</span>) <span class="comment">//请求参数放在send方法中</span></span><br></pre></td></tr></table></figure><ul><li>header：自定义的头部字段的名称</li><li>value：值</li></ul></li></ul><h5 id="设置请求参数格式："><a href="#设置请求参数格式：" class="headerlink" title="设置请求参数格式："></a>设置请求参数格式：</h5><ul><li><p><strong>application/x-www-form-urlencoded</strong></p><p>请求参数就是&amp;连接的<strong>键值对</strong>，如<code>name=zhangsan&amp;age=12</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(&#x27;Content-type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;)</span><br></pre></td></tr></table></figure></li><li><p><strong>application/json</strong></p><p>请求参数是<strong>json对象</strong>，如<code>&#123;name:&#39;zhangsan&#39;,age:&#39;12&#39;&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(&#x27;Content-type&#x27;,&#x27;appliation/json)&#x27;</span><br></pre></td></tr></table></figure><p>但是要把json对象转换为字符串，用JSON.stringify方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.send(JSON.stringify(&#123;name:&#x27;zhangsan&#x27;,age:&#x27;12&#x27;&#125;))</span><br></pre></td></tr></table></figure><p><strong>get是不能传递json对象的请求参数的，表单提交也不支持json数据</strong></p></li></ul><h4 id="4-1-getResponseHeader"><a href="#4-1-getResponseHeader" class="headerlink" title="4.1 getResponseHeader"></a>4.1 getResponseHeader</h4><ul><li><p>用于获取<code>http</code>返回头，如果在返回头中有多个一样的名称，那么返回的值就会是用逗号和空格将值分隔的字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var header = xhr.getResponseHeader(name);</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-getAllResponseHeaders"><a href="#4-2-getAllResponseHeaders" class="headerlink" title="4.2 getAllResponseHeaders"></a>4.2 getAllResponseHeaders</h4><ul><li>用于所有响应头部的字符串</li></ul><h4 id="5-abort"><a href="#5-abort" class="headerlink" title="5. abort"></a>5. abort</h4><ul><li><p>用于终止一个<code>ajax</code>请求，调用此方法后<code>readyState</code>将被设置为<code>0</code>，用法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.abort()</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、xhr属性"><a href="#2、xhr属性" class="headerlink" title="2、xhr属性"></a>2、xhr属性</h3><img src="https://note.youdao.com/yws/public/resource/05ca5e90ee117da30b7751ae1e23528a/xmlnote/331ECC69CEA04C3DA2DFA12B5888B1FB/3581" alt="img" style="zoom:67%;" /><h4 id="1-readyState"><a href="#1-readyState" class="headerlink" title="1. readyState"></a>1. readyState</h4><ul><li><p>标识当前<code>XMLHttpRequest</code>对象所处状态，<code>XMLHttpRequest</code>对象总是位于下列状态之一</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td><code>UNSENT</code></td><td>代理被创建，但尚未调用 <code>open()</code> 方法。</td></tr><tr><td>1</td><td><code>OPENED</code></td><td><code>open()</code> 方法已经被调用。</td></tr><tr><td>2</td><td><code>HEADERS_RECEIVED</code></td><td><code>send()</code>方法已经被调用，并且头部和状态已经可获得。</td></tr><tr><td>3</td><td><code>LOADING</code></td><td>下载中； <code>responseText</code> 属性已经包含部分数据。</td></tr><tr><td>4</td><td><code>DONE</code></td><td>下载操作已完成。   <strong>最关心这个</strong></td></tr></tbody></table></li></ul><h4 id="2-status："><a href="#2-status：" class="headerlink" title="2. status："></a>2. status：</h4><ul><li>表示<code>http</code>请求的状态, 初始值为<code>0</code>。如果服务器没有显式地指定状态码, 那么<code>status</code>将被设置为默认值, 即<code>200</code>。</li></ul><h4 id="3-responseType："><a href="#3-responseType：" class="headerlink" title="3. responseType："></a>3. responseType：</h4><ul><li><p>表示响应的数据类型，并允许我们手动设置，如果为空，默认为<code>text</code>类型，可以有下面的取值</p></li><li><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td>将 <code>responseType</code>设为空字符串与设置为<code>&quot;text&quot;</code>相同， 是默认类型 （实际上是 <code>DOMString</code>）。</td></tr><tr><td><code>&quot;arraybuffer&quot;</code></td><td><code>response</code> 是一个包含二进制数据的<code>JavaScript ArrayBuffer</code> 。</td></tr><tr><td><code>&quot;blob&quot;</code></td><td><code>response</code>是一个包含二进制数据的 <code>Blob</code> 对象 。</td></tr><tr><td><code>&quot;document&quot;</code></td><td>response 是一个<code>HTML Document</code>或<code>XML XMLDocument</code>，这取决于接收到的数据的 MIME 类型。</td></tr><tr><td><code>&quot;json&quot;</code></td><td><code>response</code> 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为<code>JSON</code>解析得到的。</td></tr><tr><td><code>&quot;text&quot;</code></td><td><code>response</code>是包含在<code>DOMString</code>对象中的文本。</td></tr></tbody></table></li></ul><h4 id="4-response"><a href="#4-response" class="headerlink" title="4. response"></a>4. response</h4><h4 id="5-withCredentials"><a href="#5-withCredentials" class="headerlink" title="5. withCredentials"></a>5. withCredentials</h4><ul><li><code>ajax</code>请求默认会携带同源请求的<code>cookie</code>，而跨域请求则不会携带<code>cookie</code>，设置<code>xhr</code>的<code>withCredentials</code>的属性为<code>true</code>将允许携带跨域<code>cookie</code></li></ul><h3 id="3、事件处理"><a href="#3、事件处理" class="headerlink" title="3、事件处理"></a>3、事件处理</h3><h4 id="1-onreadystatechange-进度事件"><a href="#1-onreadystatechange-进度事件" class="headerlink" title="1. onreadystatechange             进度事件"></a>1. onreadystatechange             进度事件</h4><ul><li><p>当<code>readyState</code>属性发生变化时，callback会被触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = callback;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-onloadstart-进度事件"><a href="#2-onloadstart-进度事件" class="headerlink" title="2. onloadstart                               进度事件"></a>2. onloadstart                               进度事件</h4><ul><li><p>在接收到响应的第一个字节时触发，在<code>ajax</code>请求发送之前（<code>readyState==1</code>后, <code>readyState==2</code>前），<code>callback</code>会被触发</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.onloadstart = callback;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-onprogress-进度事件"><a href="#3-onprogress-进度事件" class="headerlink" title="3. onprogress                                进度事件"></a>3. onprogress                                进度事件</h4><ul><li><p>在接收响应期间反复触发，回调函数可以获取资源总大小<code>total</code>，已经加载的资源大小<code>loaded</code>，用这两个值可以计算加载进度。事件处理程序上携带event对象，其target属性是XHR对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.loaded / event.total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-onload-进度事件"><a href="#4-onload-进度事件" class="headerlink" title="4. onload                                      进度事件"></a>4. onload                                      进度事件</h4><ul><li><p>在成功接收完响应时触发，通常在回调中返回值。</p></li><li><p>最初火狐增加了load事件用来代替readystatechange事件，load在响应接收完成后，立即触发，无论状态码是什么，都会触发，所以还需要检查状态码属性才能确定是否有效。并非所有浏览器支持</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onload = callback;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-ontimeout：-请求超时"><a href="#5-ontimeout：-请求超时" class="headerlink" title="5. ontimeout：                                 请求超时"></a>5. ontimeout：                                 请求超时</h4><ul><li><p>当进度由于预定时间到期而终止时，会触发<code>callback</code>，超时时间可使用<code>timeout</code>属性进行设置。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.ontimeout = callback;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-onerror-进度事件"><a href="#6-onerror-进度事件" class="headerlink" title="6. onerror                                           进度事件"></a>6. onerror                                           进度事件</h4><ul><li>在请求出错时会触发<code>callback</code></li></ul><h4 id="7-loadend-进度事件"><a href="#7-loadend-进度事件" class="headerlink" title="7. loadend                                          进度事件"></a>7. loadend                                          进度事件</h4><ul><li>在通信完成时，且在 error、abort 或 load 之后触发。 每次请求都会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后以 loadend 事件结束</li></ul><h3 id="6-低版本IE缓存问题"><a href="#6-低版本IE缓存问题" class="headerlink" title="6. 低版本IE缓存问题"></a>6. 低版本IE缓存问题</h3><h4 id="1-问题："><a href="#1-问题：" class="headerlink" title="1. 问题："></a>1. 问题：</h4><ul><li>在请求地址不发生变化的情况下，ajax只会发送第一次的请求，剩余的多次请求不会再发送给浏览器而是直接加载缓存中的数据</li><li>即使服务器中数据已经发生改变，客户端拿到的依旧是缓存的就数据</li></ul><h4 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h4><ul><li><p>浏览器的缓存是根据url地址来记录的，所以我们只需要修改url地址既可避免缓存问题：添加<strong>请求参数</strong>，每次请求都不相同，该参数是随机数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;GEt&#x27;</span>,<span class="string">&#x27;http://www.example.com&#x27;</span>+<span class="built_in">Math</span>.random())</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;/testAJAX?t=&#x27;</span>+<span class="built_in">Date</span>.now())</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-重复请求问题"><a href="#7-重复请求问题" class="headerlink" title="7. 重复请求问题"></a>7. 重复请求问题</h3><ul><li><p><strong>标识量：</strong>发请求之前判断请求是否在发送中，如果是，就调用abort停止强求，在收到响应之后，标识位变为false</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isSending)&#123;</span><br><span class="line">    xhr.abort();</span><br><span class="line">  &#125;</span><br><span class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  isSending = <span class="literal">true</span>;</span><br><span class="line">  x.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.onreadystateChange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">      isSending = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-发ajax请求的方式："><a href="#8-发ajax请求的方式：" class="headerlink" title="8. 发ajax请求的方式："></a>8. 发ajax请求的方式：</h3><h4 id="1-jquery-略"><a href="#1-jquery-略" class="headerlink" title="1. jquery 略"></a>1. jquery 略</h4><h4 id="2-Fetch-略"><a href="#2-Fetch-略" class="headerlink" title="2. Fetch 略"></a>2. Fetch 略</h4><h4 id="3-axios"><a href="#3-axios" class="headerlink" title="3. axios"></a>3. axios</h4><p>基于<strong>promise的HTTP库</strong>，本质上也是对<strong>原生XHR的封装</strong></p><ul><li><p>常见方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.get(url, data, params);</span><br><span class="line">axios.post(url, data, params)</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-AJAX封装-⭐️⭐️"><a href="#9-AJAX封装-⭐️⭐️" class="headerlink" title="9. AJAX封装 ⭐️⭐️"></a>9. AJAX封装 ⭐️⭐️</h3><ul><li><p>封装函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.处理请求参数，默认请求参数是对象，要弄成键值对形式</span></span><br><span class="line">  <span class="keyword">var</span> params = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> options.data)&#123;</span><br><span class="line">      params += attr+<span class="string">&#x27;=&#x27;</span>+options.data[attr]+<span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  params = params.substr(<span class="number">0</span>,params.length-<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.调用open方法，get请求要把请求参数加入url中，post要把请求参数放入send方法中</span></span><br><span class="line">  <span class="keyword">if</span>(options.type == <span class="string">&#x27;get&#x27;</span>)&#123;</span><br><span class="line">    options.url = options.url+<span class="string">&#x27;?&#x27;</span>+params</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(options.type,options.url)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//4.调用send方法，get请求就直接调用，post请求要设置头字段，请求参数要放入send方法中</span></span><br><span class="line">  <span class="keyword">if</span>(options.type == <span class="string">&#x27;post&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> contentType = options.header[<span class="string">&#x27;Content-Type&#x27;</span>]</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,contentType)</span><br><span class="line">    <span class="keyword">if</span>(contentType == <span class="string">&#x27;application/json&#x27;</span>)&#123;</span><br><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(options.data))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      xhr.send(params)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    xhr.send()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//5.接收响应数据</span></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> contentType = xhr.getResponseHeader(<span class="string">&#x27;Content-Type&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> responseText = xhr.responseText</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(contentType.includes(<span class="string">&#x27;json&#x27;</span>))&#123;</span><br><span class="line">      responseText = <span class="built_in">JSON</span>.parse(responseText)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">      options.success(responseText)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      options.error(responseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">header</span>:&#123;</span><br><span class="line"><span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="attr">error</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ajax、Axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> 网络请求 </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的EventLoop</title>
      <link href="/2021/12/11/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/12/11/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1、JS执行机制"><a href="#1、JS执行机制" class="headerlink" title="1、JS执行机制"></a>1、JS执行机制</h3><ul><li>JS分为同步任务和异步任务，同步任务都在主线程上（JS引擎线程）执行，形成一个<code>执行栈</code></li><li>主线程之外，<strong>事件触发线程</strong>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件</li><li>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到可执行栈中，开始执行</li></ul><h3 id="2、事件循环"><a href="#2、事件循环" class="headerlink" title="2、事件循环"></a>2、事件循环</h3><h4 id="1、流程："><a href="#1、流程：" class="headerlink" title="1、流程："></a>1、流程：</h4><ol><li>首先，执行栈开始顺序执行</li><li>判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行</li><li>执行栈空，询问任务队列中是否有事件回调</li><li>任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行</li><li>任务队列中没有事件回调则不停发起询问</li></ol><h4 id="2、涉及到的线程特点："><a href="#2、涉及到的线程特点：" class="headerlink" title="2、涉及到的线程特点："></a>2、涉及到的线程特点：</h4><ol><li><strong>定时触发线程：</strong>只管理定时器且只关注定时不关心结果，定时结束就把回调扔给事件触发线程</li><li><strong>异步http请求线程：</strong>只管理http请求同样不关心结果，请求结束把回调扔给事件触发线程</li><li><strong>事件触发线程：</strong>只关心异步回调入事件队列</li><li><strong>JS引擎线程：</strong>只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的<strong>事件循环(Event Loop)</strong></li></ol><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/18/16fb7acab03b35fa~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:25%;" /><h3 id="3、宏任务-task"><a href="#3、宏任务-task" class="headerlink" title="3、宏任务         task"></a>3、宏任务         task</h3><ul><li><p>可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p></li><li><p>由于<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</span><br></pre></td></tr></table></figure></li><li><p>常见的宏任务</p><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul></li></ul><h3 id="4、微任务-jobs"><a href="#4、微任务-jobs" class="headerlink" title="4、微任务    jobs"></a>4、微任务    jobs</h3><h4 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h4><ul><li><p>ES6新引入了Promise标准，同时浏览器实现上多了一个<code>microtask</code>微任务概念</p></li><li><p><code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而微任务可以理解成在当前<code>宏任务</code>执行后立即执行的任务</p><p>会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</span><br></pre></td></tr></table></figure></li><li><p>常见微任务</p><ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul></li></ul><h4 id="2、注意点"><a href="#2、注意点" class="headerlink" title="2、注意点"></a>2、注意点</h4><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p></li><li><h4 id="微任务和宏任务不在一个任务队列，不在一个任务队列"><a href="#微任务和宏任务不在一个任务队列，不在一个任务队列" class="headerlink" title="微任务和宏任务不在一个任务队列，不在一个任务队列"></a>微任务和宏任务不在一个任务队列，不在一个任务队列</h4><ul><li>例如<code>setTimeout</code>是一个宏任务，它的事件回调在宏任务队列，<code>Promise.then()</code>是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>有关渲染的都是在渲染进程中执行：<ol><li>渲染进程中的任务（DOM树构建，js解析…等等），其中需要主线程执行的任务都会在主线程中执行</li><li>而浏览器维护了一套事件循环机制，主线程会循环消息队列，并从头部取出任务进行执行</li><li>如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，<strong>消息队列中的任务都是宏任务</strong></li></ol></li></ul></li><li><h4 id="微任务是如何产生的呢？"><a href="#微任务是如何产生的呢？" class="headerlink" title="微任务是如何产生的呢？"></a>微任务是如何产生的呢？</h4><ol><li>当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列</li><li>当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文</li><li>这也就是为什么微任务要早于宏任务</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventLoop </tag>
            
            <tag> 异步任务 </tag>
            
            <tag> 同步 </tag>
            
            <tag> 宏任务 </tag>
            
            <tag> 微任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的异步解决方案</title>
      <link href="/2021/12/11/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2021/12/11/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="异步解决方案"><a href="#异步解决方案" class="headerlink" title="异步解决方案"></a>异步解决方案</h2><h3 id="1、JS的异步任务"><a href="#1、JS的异步任务" class="headerlink" title="1、JS的异步任务"></a>1、JS的异步任务</h3><ul><li>JS各种事件</li><li>setTimeout、setInterval 定时器</li><li>Ajax网络请求</li><li>Promise</li><li>async function</li></ul><h3 id="2、几种异步解决方案"><a href="#2、几种异步解决方案" class="headerlink" title="2、几种异步解决方案"></a>2、几种异步解决方案</h3><ul><li>回调函数</li><li>事件监听(发布/订阅)</li><li>Promise</li><li>Generator</li><li>Async/Await</li></ul><h3 id="3-1、方式1：回调函数"><a href="#3-1、方式1：回调函数" class="headerlink" title="3.1、方式1：回调函数"></a>3.1、方式1：回调函数</h3><p>异步编程最基本的方法，举例</p><ul><li><p>假定有两个函数f1和f2，后者等待前者的执行结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1();  <span class="comment">// 耗时较长的任务，直接这样写会导致阻塞</span></span><br><span class="line">f2();</span><br></pre></td></tr></table></figure></li><li><p>改写：</p><p><strong>把同步操作f1变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;<span class="comment">//此时f1就是一个异步任务</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    ......</span><br><span class="line">    callback(); <span class="comment">// f2的逻辑，会在f1执行完毕后就能执行</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure></li><li><p>优点：简单易理解</p></li><li><p>缺点：</p><ul><li>不利于代码的阅读和维护，各个部分之间高度耦合</li><li>流程会很混乱，而且每个任务只能指定一个回调函数</li><li><strong>异步回调中，回调函数的执行栈与原函数分离，外部无法抓住异常，异常会变得不可控。这会导致什么呢？？？</strong></li></ul></li></ul><h3 id="3-2、方式2：事件监听"><a href="#3-2、方式2：事件监听" class="headerlink" title="3.2、方式2：事件监听"></a>3.2、方式2：事件监听</h3><p>采用事件驱动模式。任务的执行<strong>不取决于代码的顺序，而取决于某个事件是否发生</strong></p><ul><li><p>首先，为f1绑定一个done事件，f2作为回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1.on(<span class="string">&#x27;done&#x27;</span>, f2);  <span class="comment">// f1事件执行完毕后，执行f2</span></span><br></pre></td></tr></table></figure></li><li><p>然后，对f1进行改写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// f1.trigger(&#x27;done&#x27;)手动触发done事件，从而开始执行f2</span></span><br><span class="line">　　　　　　f1.trigger(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">　　　　&#125;, <span class="number">1000</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li>易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li><li>可以去耦合</li><li>有利于模块化</li></ul></li><li><p>缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰</p></li></ul><h3 id="3-3、方式3：发布订阅"><a href="#3-3、方式3：发布订阅" class="headerlink" title="3.3、方式3：发布订阅"></a>3.3、方式3：发布订阅</h3><p><strong>发布/订阅模式：</strong></p><ul><li>存在一个“信号中心”，某个任务执行完成，就向信号中心发布一个信号；</li><li>其他任务可以向信号订阅这个信号，从而知道什么时候自己可以开始执行；</li></ul><h4 id="1、用class实现"><a href="#1、用class实现" class="headerlink" title="1、用class实现"></a>1、用class实现</h4><ol><li><p>创建了一个<code>Emitter</code>类，有两个原型方法<code>on</code>和<code>trigger</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// _listener数组，key为自定义事件名，value为执行回调数组-因为可能有多个</span></span><br><span class="line">    <span class="built_in">this</span>._listener = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, fn</span>)</span> &#123; <span class="comment">// 订阅 监听事件</span></span><br><span class="line">    <span class="comment">// 判断_listener数组中是否存在该事件命</span></span><br><span class="line">    <span class="comment">// 存在将回调push到事件名对应的value数组中，不存在直接新增</span></span><br><span class="line">    <span class="built_in">this</span>._listener[type] </span><br><span class="line">      ? <span class="built_in">this</span>._listener[type].push(fn) </span><br><span class="line">    : (<span class="built_in">this</span>._listener[type] = [fn])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">trigger</span>(<span class="params">type, ...rest</span>)</span> &#123; <span class="comment">// 发布 触发事件</span></span><br><span class="line">    <span class="comment">// 判断该触发事件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._listener[type]) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 遍历执行该事件回调数组并传递参数</span></span><br><span class="line">    <span class="built_in">this</span>._listener[type].forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(...rest))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h4><p>创建一个emitter实例，接着注册事件，再触发事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> Emitter()</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">&quot;done&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2)</span><br><span class="line">&#125;)</span><br><span class="line">emitter.on(<span class="string">&quot;done&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg2, arg1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是主程序&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    emitter.trigger(<span class="string">&quot;done&quot;</span>, <span class="string">&quot;异步参数一&quot;</span>, <span class="string">&quot;异步参数二&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure><ul><li>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行</li></ul><h3 id="3-4、方式4：promise"><a href="#3-4、方式4：promise" class="headerlink" title="3.4、方式4：promise"></a>3.4、方式4：promise</h3><ul><li><p>思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数</p></li><li><p>比如，f1的回调函数f2,可以写成：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">f1().then(f2);</span><br></pre></td></tr></table></figure><p>f1改写为promise：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Pomise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  　　<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// f1的任务代码</span></span><br><span class="line">           ....</span><br><span class="line">  　　　　　　resolve();</span><br><span class="line">  　　　　&#125;, <span class="number">500</span>);</span><br><span class="line">  　　&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ol><li><p>可以指定多个回调、错误的回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1().then(f2).then(f3);</span><br><span class="line">f1().then(f2).catch(f3);</span><br></pre></td></tr></table></figure></li><li><p>其他三个没有的：</p><p>如果一个任务已经完成，<strong>再添加回调函数（指定then），该回调函数会立即执行</strong>。所以，你不用担心是否错过了某个事件或信号</p></li></ol></li></ul><h3 id="3-5、Generator"><a href="#3-5、Generator" class="headerlink" title="3.5、Generator"></a>3.5、Generator</h3><h3 id="3-6、async-await"><a href="#3-6、async-await" class="headerlink" title="3.6、async await"></a>3.6、async await</h3><h2 id="2-1、Promise概念及关键问题"><a href="#2-1、Promise概念及关键问题" class="headerlink" title="2.1、Promise概念及关键问题"></a>2.1、Promise概念及关键问题</h2><p>一句话：用同步的方式写异步的代码，可用来解决回调地狱问题</p><h3 id="1、是什么"><a href="#1、是什么" class="headerlink" title="1、是什么"></a>1、是什么</h3><ul><li><h5 id="抽象表达"><a href="#抽象表达" class="headerlink" title="抽象表达:"></a>抽象表达:</h5><ol><li>Promise <strong>就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。承诺不一定会完成，但是一定都会有一个结果</strong></li><li>Promise 是 JS <code>异步编程</code>的新方案，是一门新技术(ES6 规范) , 备注：旧方案是回调</li></ol></li><li><h5 id="具体表达"><a href="#具体表达" class="headerlink" title="具体表达:"></a>具体表达:</h5><ol><li>从语法上: Promise 是一个<code>构造函数</code>，实例是一个对象，从它可以获取异步操作的消息</li><li>从功能上: promise 对象用来封装一个异步操作，而且Promise 提供统一的 API，可以获取其成功/ 失败的结果值</li></ol></li></ul><h3 id="2、2个特点"><a href="#2、2个特点" class="headerlink" title="2、2个特点:"></a>2、2个特点:</h3><ol><li>Promise对象的状态不受外界影响。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果<ul><li><code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</li><li>只要这两种情况发生，状态就凝固了。</li><li>如果改变已经发生了，再对<code>Promise</code>对象添加回调函数，会立即得到这个结果。这与事件完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul></li></ol><h3 id="3、优-缺点："><a href="#3、优-缺点：" class="headerlink" title="3、优/缺点："></a>3、优/缺点：</h3><h4 id="3-1、优点："><a href="#3-1、优点：" class="headerlink" title="3.1、优点："></a>3.1、优点：</h4><ul><li><h5 id="以往异步编程模式"><a href="#以往异步编程模式" class="headerlink" title="以往异步编程模式"></a>以往异步编程模式</h5><ul><li>普通异步回调：异步函数的返回值只在短时间内存在，需要提前准备好回调函数来接收它</li><li>嵌套异步回调：异步返回值依赖与另一个返回值，多个会造成回调地狱，代码维护很难</li></ul></li><li><h5 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h5><ol><li><p><strong>指定回调函数的方式更加灵活:</strong></p><ul><li><p>启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定/多个)</p></li><li><p>而旧版必须在启动异步任务前指定 </p></li><li><p><code>Promise</code>对象提供统一的接口，使得<strong>控制异步操作更加容易</strong></p></li></ul></li><li><p><strong>支持链式调用, 解决回调地狱问题</strong></p></li></ol></li><li><p>同步的方式写异步的代码，避免了层层嵌套的回调函数</p></li><li><p>promise <code>链式调用</code>：用来解决回调地狱问题，但<code>只是简单改变格式</code>，并没有彻底解决</p></li></ul><h4 id="3-2、缺点："><a href="#3-2、缺点：" class="headerlink" title="3.2、缺点："></a>3.2、缺点：</h4><ol><li><strong>一旦新建它就会立即执行，无法中途取消</strong></li><li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</li><li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li><li>一眼看上去都是promise的API，而且链式语法总觉得不好看，不优雅</li></ol><h3 id="4、onRejected和catch区别"><a href="#4、onRejected和catch区别" class="headerlink" title="4、onRejected和catch区别"></a>4、onRejected和catch区别</h3><p><code>promise.then(onresolved, onRejected)</code>在 <code>onresolved</code>回调中发生异常时：</p><ul><li><p><code>onRejected</code>中是捕获不到这个异常，可以在末尾多加一个<code>then</code>从而达到和<code>catch</code>相同的作用（流转到下一个错误处理）</p></li><li><p><strong>使用<code>catch</code>可以捕获到前面的<code>onRejected</code>的异常</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是对的&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;111&#x27;</span>  <span class="comment">// 抛出异常</span></span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//情况1： 我是对的  111   返回undefined的resolved的promise</span></span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"><span class="comment">// 情况2：    </span></span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 我是对的  err:111   返回undefined的resolved的promise</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err:&quot;</span> + err) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、then中抛错未处理"><a href="#5、then中抛错未处理" class="headerlink" title="5、then中抛错未处理"></a>5、then中抛错未处理</h3><ul><li><p>如果在then中抛错，而没有对错误进行处理(catch)，那么会一直保持reject状态的promise，就不会往下执行了</p></li><li><p>直到catch了错误，状态变为resolved</p></li><li><p>promise的缺点之一就是无法让promise中断，利用这个特性可让Promise中断执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 错误：未声明的变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Task 1&quot;</span>);</span><br><span class="line">&#125;)<span class="comment">//跳过了第二个then</span></span><br><span class="line">  .then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Task 2&quot;</span>);</span><br><span class="line">&#125;)<span class="comment">//如果我们没有处理这个错误(无catch)的话，就不会往下执行了</span></span><br><span class="line">  .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 这时候变成undefined的resolved的promise</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;err:&quot;</span> + err)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;finaltask&quot;</span>, res)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// err:ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// finaltask  undefined</span></span><br></pre></td></tr></table></figure></li><li><h4 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h4></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/14/17041c4ba347afe2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 50%;" /><h3 id="6、异步回调中抛错catch捕捉不到"><a href="#6、异步回调中抛错catch捕捉不到" class="headerlink" title="6、异步回调中抛错catch捕捉不到"></a>6、异步回调中抛错catch捕捉不到</h3><ol><li><p>在Promise对象的处理器函数中直接抛出错误，<code>catch</code>是可以捕捉到的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br></pre></td></tr></table></figure></li><li><p>在Promise对象的处理器函数中异步抛错，<strong>catch捕获不到：</strong>为什么</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br></pre></td></tr></table></figure><p>JS 事件循环列表有宏任务与微任务之分，setTimeOut是宏任务， promise是微任务，执行顺序不同</p><ul><li>执行栈进入promise 触发setTimeOut，setTimeOut回调函数入宏任务队列</li><li>执行promise的catch方法，入微任务队列，此时setTimeOut回调还没执行</li><li>执行栈检查发现当前微任务队列执行完毕，开始执行宏任务队列</li><li>执行<code>throw new Error(&#39;这是一个错误&#39;)</code> 此<strong>时这个异常其实是在promise外部抛出的</strong></li></ul></li></ol><ul><li><p><strong>解决</strong>：使用<code>try catch</code>捕获异常主动触发<code>reject</code>       不太理解？？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>) </span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">       reject(e)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="7、中断-promise-链"><a href="#7、中断-promise-链" class="headerlink" title="7、中断 promise 链?"></a>7、中断 promise 链?</h3><p>场景：有5个then()，但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何？</p><ul><li><p>回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; resolve(<span class="string">&#x27;OK&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;</span><br><span class="line">);</span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);&#125;)<span class="comment">//有且只有这一个方式</span></span><br><span class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">222</span>);&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">333</span>);&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="built_in">console</span>.warn(reason);&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="8、一个-promise-指定多个成功-失败回调函数-都会调用吗"><a href="#8、一个-promise-指定多个成功-失败回调函数-都会调用吗" class="headerlink" title="8、一个 promise 指定多个成功/失败回调函数, 都会调用吗?"></a>8、一个 promise 指定多个成功/失败回调函数, 都会调用吗?</h3><ul><li>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  resolve(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">&gt;<span class="comment">///指定回调1</span></span><br><span class="line">&gt;p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="built_in">console</span>.log(value); &#125;);</span><br><span class="line">&gt;<span class="comment">//指定回调2</span></span><br><span class="line">&gt;p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; alert(value);&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="9、改变-promise-状态和指定回调函数谁先谁后"><a href="#9、改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="9、改变 promise 状态和指定回调函数谁先谁后?"></a>9、改变 promise 状态和指定回调函数谁先谁后?</h3><p>都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 </p><h4 id="1、先指定回调再改变状态"><a href="#1、先指定回调再改变状态" class="headerlink" title="1、先指定回调再改变状态"></a>1、先指定回调再改变状态</h4><ul><li><p>先指定回调–&gt; 再改变状态 –&gt;改变状态后才进入异步队列执行回调函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//异步写法,这样写会先指定回调,再改变状态</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;resolve(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当状态发生改变时, 回调函数就会调用, 得到数据</p></li></ul><h4 id="2、先改状态再指定回调"><a href="#2、先改状态再指定回调" class="headerlink" title="2、先改状态再指定回调"></a>2、先改状态再<code>指定</code>回调</h4><ul><li><p>先改状态再<code>指定</code>回调：</p><p>方法1：在执行器中直接调用 resolve()/reject() </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//这是同步写法,这样写会先改变状态,再指定回调</span></span><br><span class="line">resolve(<span class="string">&#x27;OK&#x27;</span>); </span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>方法2：延迟更长时间才调用 then() ，在<code>.then()</code>外再包一层例如延时器</p></li><li><p>当指定回调时, 回调函数就会调用, 得到数据</p></li></ul><h4 id="3、个人理解–结合源码"><a href="#3、个人理解–结合源码" class="headerlink" title="3、个人理解–结合源码"></a>3、个人理解–结合源码</h4><p>源码中,promise的状态是通过一个<code>默认为padding</code>的变量进行判断：</p><ol><li><p>当你<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是<code>进行中</code>，如果只是这样会导致只有同步操作才能成功</p></li><li><p>所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的</p></li></ol><h2 id="2-2、Promise用法"><a href="#2-2、Promise用法" class="headerlink" title="2.2、Promise用法"></a>2.2、Promise用法</h2><h3 id="1-Promise-构造函数-Promise-excutor"><a href="#1-Promise-构造函数-Promise-excutor" class="headerlink" title="1- Promise 构造函数: Promise (excutor) {}"></a>1- Promise 构造函数: Promise (excutor) {}</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>executor 函数: 执行器 (resolve, reject) =&gt; {}，会在 <strong>Promise 内部立即<code>同步调用</code></strong></li><li>resolve 函数：会将promise状态改成resolved，<strong>参数正常的值/另一个 Promise 实例</strong></li><li>reject 函数：<strong>参数通常是<code>Error</code>对象的实例，表示抛出的错误</strong></li></ul><h4 id="1、参数传递问题："><a href="#1、参数传递问题：" class="headerlink" title="1、参数传递问题："></a>1、参数传递问题：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>p1：正常值，参数p1会作为promise的结果，保存在promise对象的<strong>promiseResult</strong>属性中，被传递给<strong>回调函数的参数</strong></li><li>p1：promise对象，**<code>p1</code>的状态决定了<code>p2</code>的状态**<ul><li>如果<code>p1</code>状态是<code>pending</code>，那<code>p2</code>的回调函数会等待<code>p1</code>的状态改变</li><li>如果<code>p1</code>状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行</li></ul></li></ul><h4 id="2、resolve或reject对执行器函数的执行影响"><a href="#2、resolve或reject对执行器函数的执行影响" class="headerlink" title="2、resolve或reject对执行器函数的执行影响"></a>2、<code>resolve</code>或<code>reject</code>对执行器函数的执行影响</h4><ul><li><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行，后面的仍然是同步任务</p></li><li><p>而then：是在微任务中执行的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为<strong>立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</strong></li></ul></li></ul><h4 id="3、return的影响："><a href="#3、return的影响：" class="headerlink" title="3、return的影响："></a>3、return的影响：</h4><p>一般来说，一个promise对象内部<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了。但执行器本身后面还是执行的，所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-原型方法then"><a href="#2-原型方法then" class="headerlink" title="2-原型方法then"></a>2-原型方法then</h3><p>Promise实例生成以后，可用<code>then</code>方法指定<code>resolved</code>状态和<code>reject</code>状态的回调函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then(onFulfilled [, onRejected])</span><br></pre></td></tr></table></figure><h4 id="1、返回值：返回一个新的-promise-对象"><a href="#1、返回值：返回一个新的-promise-对象" class="headerlink" title="1、返回值：返回一个新的 promise 对象"></a>1、返回值：返回一个新的 promise 对象</h4><ul><li>返回一个新的 promise 对象，因此可用链式写法，即<code>then</code>后面再<code>then</code></li><li>链式写法中，后一个回调函数，会等待前<code>Promise</code>对象的状态发生变化，才会被调用</li></ul><h4 id="2、返回结果promise-对象的状态-重要5条"><a href="#2、返回结果promise-对象的状态-重要5条" class="headerlink" title="2、返回结果promise 对象的状态          重要5条"></a>2、返回结果promise 对象的状态          重要5条</h4><p>总结：由 then()指定<strong>的回调函数执行的结果决定</strong> </p><ol><li><p>如果没有return值，那会返回的新promise变为resolved，传参undefined</p></li><li><p>如果return非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</p></li><li><p>如果<strong>then里抛出异常</strong>，<code>then</code>方法的第二个参数onRejected是监测不到当前<code>then</code>方法回调异常的，promise规范规定调用失败态方法(reject)<strong>流转到下一个<code>then</code>的onRejected</strong></p></li><li><p>如果return另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> result = p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 1. 如果只是执行语句，没有返回，新promise变为resolved，且传参undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line"><span class="comment">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line"><span class="comment">// 3. 抛出错误 ,变为 rejected，流转到下一个then的onRejected</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line"><span class="comment">// 4. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 流转到下一个then的onRejected</span></span><br><span class="line">  <span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">   reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.warn(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(即所谓的值穿透)</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="number">2</span>)</span><br><span class="line">.then()</span><br><span class="line">.then()</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-原型方法catch"><a href="#3-原型方法catch" class="headerlink" title="3-原型方法catch"></a>3-原型方法catch</h3><p>then()的语法糖, 相当于: then(undefined, onRejected)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.catch(onRejected);</span><br><span class="line">p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1、返回值：返回一个新的promise实例，因此后面还可以接着调用then-方法"><a href="#1、返回值：返回一个新的promise实例，因此后面还可以接着调用then-方法" class="headerlink" title="1、返回值：返回一个新的promise实例，因此后面还可以接着调用then()方法"></a>1、返回值：返回一个新的promise实例，因此后面还可以接着调用<code>then()</code>方法</h4><ol><li><p>如果 <code>onRejected</code>回调抛出一个错误或返回一个本身失败的 Promise ，返回rejected的promise</p></li><li><p>否则返回成功的promise</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn1()</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="comment">// 这里只是return了错误信息，并没有抛出错误或者返回一个失败promise</span></span><br><span class="line">  <span class="comment">// 所以第一个`catch`执行返回的promise对象是resolved</span></span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、catch可以捕获什么？"><a href="#2、catch可以捕获什么？" class="headerlink" title="2、catch可以捕获什么？"></a>2、catch可以捕获什么？</h4><ol><li><h5 id="Promise-内部的错误"><a href="#Promise-内部的错误" class="headerlink" title="Promise 内部的错误"></a>Promise 内部的错误</h5><p>如果没有用<code>catch()</code>方法指定错误处理的回调函数，<strong>Promise 对象抛出的错误不会传递到外层代码</strong>，即不会有任何反应</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);<span class="comment">//内部有语法错误。浏览器运行到这一行，会抛错，但不会退出进程、终止脚本执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = someAsyncThing();  <span class="comment">//m是rejected的，promise中的不会执行下去</span></span><br><span class="line">m.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//不执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;everything is great&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">err</span> =&gt;</span> alert(<span class="number">11</span>,err))<span class="comment">//不执行</span></span><br><span class="line">.then(<span class="function"><span class="params">err</span> =&gt;</span> alert(<span class="number">22</span>, err)) <span class="comment">//不执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;, <span class="number">2000</span>); <span class="comment">// 仍然执行</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>但如果将then替换为catch：m.then —m.catch，promise就能继续执行下去</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">everything is great</span><br><span class="line"><span class="number">11</span> <span class="number">22</span></span><br></pre></td></tr></table></figure></li><li><h5 id="then-方法中抛出错误"><a href="#then-方法中抛出错误" class="headerlink" title="then()方法中抛出错误"></a><code>then()</code>方法中抛出错误</h5><p>在<code>then()</code>方法里面定义 Reject 状态的回调函数，捕获不到then里面的错误</p><p>但会被<strong>后面的<code>catch()</code>方法捕获。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn1()</span><br><span class="line">  .then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li><li><h5 id="promise异常穿透"><a href="#promise异常穿透" class="headerlink" title="promise异常穿透"></a>promise异常穿透</h5><p>前面任何操作出了异常, 都会传到最后失败的回调中处理；所以</p><ul><li>可以在每个then()的第二个回调函数中进行err处理</li><li>也可以利用异常穿透特性，到最后用<code>catch</code>去承接统一处理</li><li>两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</li></ul></li><li><p>【注意】：catch无法捕获在它后面出现的错误，案例1：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><ul><li>案例2：resolve之后，在下一轮事件循环中抛错。那时候，<strong>Promise 的运行已经结束了，</strong>所以这个错误是在 Promise 函数体外抛出的，<strong>会冒泡到最外层，成了未捕获的错误</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-原型方法finally"><a href="#4-原型方法finally" class="headerlink" title="4-原型方法finally"></a>4-原型方法finally</h3><ul><li><p>在promise结束时，不管成功还是失败都将执行其<code>onFinally</code>回调</p></li><li><p>不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，与状态无关的，不依赖于 Promise 的执行结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回状态为(resolved 或 rejected)</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-静态方法Promise-resolve"><a href="#1-静态方法Promise-resolve" class="headerlink" title="1-静态方法Promise.resolve :"></a>1-静态方法Promise.resolve :</h3><ul><li>接收一个值，将现有对象转为Promise 对象</li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure></blockquote><h4 id="1、传参情况4种"><a href="#1、传参情况4种" class="headerlink" title="1、传参情况4种"></a>1、传参情况4种</h4><ol><li><p><strong>参数是一个 Promise 实例</strong>：<code>Promise.resolve</code>将原封不动地返回这个实例</p></li><li><p><strong>参数是一个原始值，或一个不具有<code>then()</code>方法的对象</strong>：返回一个新的<code>resolved</code>的 Promise 对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li><li><p><strong>参数是空</strong>：直接返回一个<code>resolved</code>状态的 Promise 对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>参数是一个<code>thenable</code>对象：</strong><code>Promise.resolve()</code>将这个对象转为 Promise 对象，然后立即执行<code>thenable</code>对象的<code>then()</code>方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、执行顺序"><a href="#2、执行顺序" class="headerlink" title="2、执行顺序"></a>2、执行顺序</h4><p>立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”结束时执行，而不是在下一轮“事件循环”开始时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.在下一轮“事件循环”开始时执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//2. Promise.resolve()在本轮“事件循环”结束时执行</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;one&#x27;</span>);  <span class="comment">//1. 立即执行</span></span><br><span class="line"><span class="comment">// one two  three</span></span><br></pre></td></tr></table></figure><h3 id="2-静态方法Promise-reject"><a href="#2-静态方法Promise-reject" class="headerlink" title="2-静态方法Promise.reject :"></a>2-静态方法Promise.reject :</h3><ul><li><p>返回一个失败的 promise 对象,直接改变promise状态</p></li><li><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数</p></li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;&#125;)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3-静态方法Promise-all"><a href="#3-静态方法Promise-all" class="headerlink" title="3-静态方法Promise.all :"></a>3-静态方法Promise.all :</h3><ul><li>iterable类型：代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型 </li><li>应用场景：有一个接口，需要其他两个或多个接口返回的数据作为参数时</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.all(iterable)</span><br></pre></td></tr></table></figure><h3 id="4-静态方法Promise-race"><a href="#4-静态方法Promise-race" class="headerlink" title="4-静态方法Promise.race :"></a>4-静态方法Promise.race :</h3><ul><li>迭代对象中状态全部改变才会执行</li><li>只要迭代对象中有一个状态改变了，它的状态就跟着改变，并将那个改变状态实例的返回值传递给回调函数</li><li>p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race(iterable)</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、Generaor"><a href="#3、Generaor" class="headerlink" title="3、Generaor"></a>3、Generaor</h2><h3 id="1、协程"><a href="#1、协程" class="headerlink" title="1、协程"></a>1、协程</h3><ul><li><p>协程：多个线程互相协作，完成异步任务。它的运行流程大致如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步，协程A开始执行。</span><br><span class="line"></span><br><span class="line">第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</span><br><span class="line"></span><br><span class="line">第三步，（一段时间后）协程B交还执行权。</span><br><span class="line"></span><br><span class="line">第四步，协程A恢复执行。</span><br></pre></td></tr></table></figure><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行</p></li></ul><h4 id="举例文件读取："><a href="#举例文件读取：" class="headerlink" title="举例文件读取："></a>举例文件读取：</h4><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asnycJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...其他代码</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line"><span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线</li><li>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</li></ul><h3 id="2、Generator-函数"><a href="#2、Generator-函数" class="headerlink" title="2、Generator 函数"></a>2、Generator 函数</h3><p>Generator 函数是<strong>协程在 ES6 的实现</strong>，是一种异步解决方案。最大特点就是可以交出函数的执行权（即暂停执行）</p><ul><li>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态</li><li>Generator 函数除了状态机，还是一个遍历器对象生成函数<ul><li>可暂停函数, yield可暂停。next方法可启动</li><li>yield表达式本身没有返回值，或者说总是返回undefined</li><li>next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</li></ul></li></ul><h4 id="运行方式举例"><a href="#运行方式举例" class="headerlink" title="运行方式举例"></a>运行方式举例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>代码分析：</p><ul><li><p>首先 Generator 函数调用和普通函数不同，它会返回一个迭代器</p></li><li><p>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6</p></li><li><p>当执行第二次 next 时，传入的参数12就会被当作上一个yield表达式的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8</p></li><li><p>当执行第三次 next 时，传入的参数13就会被当作上一个yield表达式的返回值，所以 z = 13, x = 5, y = 24，相加等于 42</p></li></ul><h4 id="文件读取举例"><a href="#文件读取举例" class="headerlink" title="文件读取举例"></a>文件读取举例</h4><ul><li>有三个本地文件，分别1.txt,2.txt和3.txt，内容都只有一句话，<strong>下一个请求依赖上一个请求的结果</strong>，想通过Generator函数依次调用三个文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(file, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">r</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> read(<span class="string">&#x27;./1.txt&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> read(r1)</span><br><span class="line">  <span class="keyword">let</span> r3 = <span class="keyword">yield</span> read(r2)</span><br><span class="line">  <span class="built_in">console</span>.log(r1)</span><br><span class="line">  <span class="built_in">console</span>.log(r2)</span><br><span class="line">  <span class="built_in">console</span>.log(r3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = r()</span><br><span class="line"><span class="keyword">let</span> &#123; value, done &#125; = it.next()</span><br><span class="line">value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// value是个promise</span></span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">//data=&gt;2.txt</span></span><br><span class="line">  <span class="keyword">let</span> &#123; value, done &#125; = it.next(data)</span><br><span class="line">  value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">//data=&gt;3.txt</span></span><br><span class="line">    <span class="keyword">let</span> &#123; value, done &#125; = it.next(data)</span><br><span class="line">    value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data) <span class="comment">//data=&gt;结束</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.txt=&gt;3.txt=&gt;结束</span></span><br></pre></td></tr></table></figure><ul><li>手动迭代<code>Generator</code> 函数很麻烦，实现逻辑有点绕，而实际开发一般会配合 <code>co</code> 库去使用</li><li><strong><code>co</code>是一个为Node.js和浏览器打造的基于生成器的流程控制工具，借助于Promise，你可以使用更加优雅的方式编写非阻塞代码</strong></li></ul><h4 id="安装co库后："><a href="#安装co库后：" class="headerlink" title="安装co库后："></a>安装co库后：</h4><ul><li>npm install co，代码更简单</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">r</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> read(<span class="string">&#x27;./1.txt&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> read(r1)</span><br><span class="line">  <span class="keyword">let</span> r3 = <span class="keyword">yield</span> read(r2)</span><br><span class="line">  <span class="built_in">console</span>.log(r1)</span><br><span class="line">  <span class="built_in">console</span>.log(r2)</span><br><span class="line">  <span class="built_in">console</span>.log(r3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>)</span><br><span class="line">co(r()).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.txt=&gt;3.txt=&gt;结束=&gt;undefined</span></span><br></pre></td></tr></table></figure><h4 id="回调地狱问题"><a href="#回调地狱问题" class="headerlink" title="回调地狱问题"></a>回调地狱问题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(url, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url1, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url2, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure><h3 id="3、优缺点"><a href="#3、优缺点" class="headerlink" title="3、优缺点"></a>3、优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>优雅的流程控制方式，可以让函数可中断执行，在某些特殊需求里还是很实用的</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，但co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，只针对<strong>异步处理来说，还是不太方便</strong></li></ul><h2 id="4、async、await"><a href="#4、async、await" class="headerlink" title="4、async、await"></a>4、async、await</h2><p>JS异步操作的最终且最优雅的解决方案</p><h3 id="0、async-await带来了什么"><a href="#0、async-await带来了什么" class="headerlink" title="0、async/await带来了什么"></a>0、async/await带来了什么</h3><p>使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：</p><h4 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h4><ol><li><p>内置执行器</p><p>Generator 函数的执行必须靠执行器，所以才有了 co 函数库；</p><p>而 <code>async</code> 函数自带执行器，也就是说，<code>async</code> 函数的执行，与普通函数一模一样，只要一行</p></li><li><p>更好的语义、结构清晰</p><p><code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚了，几乎跟同步写法一样，十分优雅</p><p><code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果</p></li><li><p>更广的适用性</p><p>co 函数库约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象</p><p>而 <code>async</code> 函数的 <code>await</code> 命令后面，可以跟 Promise 对象和原始类型的值(数值、字符串和布尔值，但这时等同于同步操作)</p></li><li><p>更好的错误处理</p><p>链式调用了很多promises，一级接一级。紧接着，promises链中某处出错。此链条的错误堆栈信息并没用线索指示错误到底出现在哪里</p></li></ol><h4 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h4><ul><li><p>滥用 <code>await</code> 可能会导致性能问题</p><p>因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p></li></ul><h3 id="1、async返回值"><a href="#1、async返回值" class="headerlink" title="1、async返回值"></a>1、async返回值</h3><p>一个函数如果加上 <strong>async</strong> ，那么该函数就会<strong>返回一个 Promise</strong>：return的情况分析</p><ul><li><h5 id="返回值为promise，状态和值取决于这个promise"><a href="#返回值为promise，状态和值取决于这个promise" class="headerlink" title="返回值为promise，状态和值取决于这个promise"></a>返回值为promise，状态和值取决于这个promise</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// resolve(99);</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        reject(<span class="number">66</span>); </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 新的promise状态成功,值为99</span></span><br><span class="line"><span class="comment">// 2 新的promise状态失败,值为66</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值"><a href="#函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值" class="headerlink" title="函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值"></a>函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn()) <span class="comment">// 成功promsie,值为1</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数返回值为undefined-状态成功-值为undefined"><a href="#函数返回值为undefined-状态成功-值为undefined" class="headerlink" title="函数返回值为undefined.状态成功,值为undefined"></a>函数返回值为undefined.状态成功,值为undefined</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());<span class="comment">//  成功promise,值为undefined</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数体内抛出异常"><a href="#函数体内抛出异常" class="headerlink" title="函数体内抛出异常"></a>函数体内抛出异常</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// 失败promise,值为&quot;异常&quot;;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2、await"><a href="#2、await" class="headerlink" title="2、await"></a>2、await</h3><h4 id="1、await在等什么？"><a href="#1、await在等什么？" class="headerlink" title="1、await在等什么？"></a>1、await在等什么？</h4><p><code>await</code> <strong>在等待一个异步完成</strong>，等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值</p><ul><li><p><code>await</code> 后面不是Promise对象，直接返回对应的值，效果等同于直接return</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;   <span class="comment">// 等同于  return 123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>await</code> 后面是Promise对象，会造成异步函数暂停执行先返回，并且等待 promise 的解决，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。所以<strong>会阻塞后面的代码</strong></p></li><li><p><code>await</code>一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），<code>await</code>会将其等同于 Promise 对象</p></li></ul><h4 id="2、为什么await-只能在-async-函数中使用"><a href="#2、为什么await-只能在-async-函数中使用" class="headerlink" title="2、为什么await 只能在 async 函数中使用"></a>2、为什么<code>await</code> 只能在 <code>async</code> 函数中使用</h4><ul><li><code>await</code> 会阻塞后面代码，如果允许我们直接使用 <code>await</code> 的话，假如我们使用<code>await</code>等待一个消耗时间比较长的异步请求，那代码直接就阻塞不往下执行了，只能等待 <code>await</code> 拿到结果才会执行下面的代码，那不乱套了</li><li>而 <code>async</code> 函数调用不会造成阻塞，因为它内部所有的阻塞都被封装在一个 Promise 对象中异步执行，所以才规定 <code>await</code> 必须在 <code>async</code> 函数中</li></ul><h4 id="3、await后面代码是微任务microtask"><a href="#3、await后面代码是微任务microtask" class="headerlink" title="3、await后面代码是微任务microtask"></a>3、await后面代码是微任务microtask</h4><p>实际上<strong>await是一个让出线程的标志</strong>，因为async await 本身就是promise+generator的语法糖。所以await后面的代码是微任务microtask</p><ul><li>await后面的表达式会先执行一遍</li><li>将await后面的代码加入到微任务microtask中</li><li>然后就会跳出整个async函数来执行后面的代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="comment">// 3.1 不会执行，添加到微任务</span></span><br><span class="line">  <span class="comment">// 5 真正执行是在微任务中执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="4、读取文件的例子重写"><a href="#4、读取文件的例子重写" class="headerlink" title="4、读取文件的例子重写"></a>4、读取文件的例子重写</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(file, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readResult</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="keyword">await</span> read(params, <span class="string">&#x27;utf8&#x27;</span>)<span class="comment">//await后面跟的是一个Promise实例</span></span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="keyword">await</span> read(p1, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="keyword">await</span> read(p2, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>, p1)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p2&#x27;</span>, p2)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3&#x27;</span>, p3)</span><br><span class="line">    <span class="keyword">return</span> p3</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">readResult(<span class="string">&#x27;1.txt&#x27;</span>).then( <span class="comment">// async函数返回的也是个promise</span></span><br><span class="line">  <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// p1 2.txt</span></span><br><span class="line"><span class="comment">// p2 3.txt</span></span><br><span class="line"><span class="comment">// p3 结束</span></span><br><span class="line"><span class="comment">// 结束</span></span><br></pre></td></tr></table></figure><h3 id="3、处理异常"><a href="#3、处理异常" class="headerlink" title="3、处理异常"></a>3、处理异常</h3><h4 id="错误导致中断"><a href="#错误导致中断" class="headerlink" title="错误导致中断"></a>错误导致中断</h4><p>任何一个<code>await</code>后面的 <strong>Promise 对象变为<code>reject</code>状态</strong>，那么<strong>整个<code>async</code>函数都会中断执行</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>的回调接收</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);  <span class="comment">//这里如果在await前面加上return，效果是一样的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>,e))</span><br><span class="line"><span class="comment">// error 出错了</span></span><br></pre></td></tr></table></figure><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> ajax()</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>假如希望即使前一个异步操作失败，也不要中断后面的异步操作：</p><ul><li>方法1：第一个<code>await</code>放在<code>try...catch</code>结构里面。这样不管这个异步操作是否成功，第二个<code>await</code>都会执行</li><li>方法2：<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法处理前面可能出现的错误</li></ul><h3 id="4、async-await继、并发、promise-all"><a href="#4、async-await继、并发、promise-all" class="headerlink" title="4、async/await继、并发、promise.all"></a>4、async/await继、并发、promise.all</h3><h4 id="1、继发及其应用场景"><a href="#1、继发及其应用场景" class="headerlink" title="1、继发及其应用场景"></a>1、继发及其应用场景</h4><p>await本身是继发的</p><ul><li>当函数执行的时候，一旦遇到<code>await</code>就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>，比较耗时</li><li>所以如果<strong>多个异步代码没有依赖性</strong>却使<strong>用了 await 会导致性能上的降低</strong></li><li>因此，<strong>代码没有依赖性的话，完全可以并发的方式</strong></li></ul><p><strong>经常会遇到这种业务，多个请求，每个请求依赖于上一个请求的结果。</strong></p><ul><li>用setTimeout模拟异步操作，用Promise和Async/Await分别来实现下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">analogAsync</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(n + <span class="number">500</span>), n);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> analogAsync(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> analogAsync(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> analogAsync(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Promise"><a href="#使用Promise" class="headerlink" title="使用Promise:"></a>使用Promise:</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time1 = <span class="number">0</span></span><br><span class="line">  fn1(time1)</span><br><span class="line">    .then(<span class="function">(<span class="params">time2</span>) =&gt;</span> fn2(time2))</span><br><span class="line">    .then(<span class="function">(<span class="params">time3</span>) =&gt;</span> fn3(time3))</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><h5 id="使用async-await"><a href="#使用async-await" class="headerlink" title="使用async/await"></a>使用async/await</h5><ul><li>输出效果一样，但代码结构看起来清晰得多，几乎跟同步写法一样，十分优雅</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time1 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> time2 = <span class="keyword">await</span> fn1(time1)</span><br><span class="line">  <span class="keyword">let</span> time3 = <span class="keyword">await</span> fn2(time2)</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> fn3(time3)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><h4 id="2、手动实现一个继发："><a href="#2、手动实现一个继发：" class="headerlink" title="2、手动实现一个继发："></a>2、手动实现一个继发：</h4><p>只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure><ul><li><h4 id="for循环实现"><a href="#for循环实现" class="headerlink" title="for循环实现"></a>for循环实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="reduce实现"><a href="#reduce实现" class="headerlink" title="reduce实现"></a>reduce实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> docs.reduce(<span class="keyword">async</span> (_, doc) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> _;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;, <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、并发实现"><a href="#3、并发实现" class="headerlink" title="3、并发实现"></a>3、并发实现</h4><p><code>getFoo</code>和<code>getBar</code>都是同时触发，且没有依赖项，这样就会缩短程序的执行时间</p><ul><li><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function"><span class="params">doc</span> =&gt;</span> db.post(doc));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><ul><li><p>getFoo函数本身是非阻塞的，赋值后<strong>不会停在这里等待它的执行结果</strong></p></li><li><p>而await getFoo()在promise有结果之前不会执行赋值操作，async内部代码在promise返回结果之前会阻塞住</p><p>但整个主线程不会阻塞而是会执行async函数后面的同步代码，等promise有了结果且外面的同步代码执行完了就又会回到async函数原来阻塞的地方继续执行</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> p1 = getFoo();</span><br><span class="line"><span class="keyword">let</span> p2 = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> p1;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> p2;</span><br></pre></td></tr></table></figure></li><li><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123; <span class="comment">//这里不需要 async</span></span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.forEach(<span class="keyword">async</span> doc =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>虽然map方法的参数是async函数，但它是并发执行，因为只有async函数内部是继发执行，外部不受影响</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map( <span class="keyword">async</span> doc =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3、手写promise"><a href="#2-3、手写promise" class="headerlink" title="2.3、手写promise"></a>2.3、手写promise</h2><h4 id="1、Promise的异步实现"><a href="#1、Promise的异步实现" class="headerlink" title="1、Promise的异步实现"></a>1、Promise的异步实现</h4><h4 id="2、promsie的链式调用"><a href="#2、promsie的链式调用" class="headerlink" title="2、promsie的链式调用"></a>2、promsie的链式调用</h4><ol><li><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong><ol><li>在<code>then</code>方法中先实例化了一个Promise对象并返回，我们把原来写的代码放到该实例的处理器函数中</li><li>在每个执行函数处使用<code>try..catch</code>语法，try中<code>resolve</code>执行结果，catch中<code>reject</code>异常</li><li>pending状态判断，逻辑也和resolved相似，但是由于此处为了处理异步，做了push操作，所以我们push时在onFulfilled和onRejected回调外面再套一个回调做操作即可</li></ol></li><li><strong>如果<code>then</code>方法中返回的是一个普通值(如Number、String等)就使用此值包装成一个新的Promise对象返回</strong></li><li>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用Undefined包装的Promise对象</li><li>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的onRejected</li><li><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(值穿透)</strong></li><li>如果<code>then</code>方法中返回了一个Promise对象，那就以这个对象为准，返回它的结果</li></ol><h4 id="3、根据上一个then方法的返回值来生成新Promise对象"><a href="#3、根据上一个then方法的返回值来生成新Promise对象" class="headerlink" title="3、根据上一个then方法的返回值来生成新Promise对象"></a>3、根据上一个<code>then</code>方法的返回值来生成新Promise对象</h4><h3 id="1、基本构成"><a href="#1、基本构成" class="headerlink" title="1、基本构成"></a>1、基本构成</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 托管构造函数的this指向</span></span><br><span class="line">  <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 状态描述 pending resolved rejected</span></span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;pending&quot;</span></span><br><span class="line">  <span class="comment">// 成功结果</span></span><br><span class="line">  <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 失败原因</span></span><br><span class="line">  <span class="built_in">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">//保存成功回调</span></span><br><span class="line">  <span class="built_in">this</span>.onResolvedCallbacks = []</span><br><span class="line">  <span class="comment">//保存失败回调</span></span><br><span class="line">  <span class="built_in">this</span>.onRejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让其处理器函数立即执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前态是否为pending，只有pending时可更该状态</span></span><br><span class="line">    <span class="keyword">if</span> (_this.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 更改为成功态</span></span><br><span class="line">      _this.state = <span class="string">&quot;resolved&quot;</span></span><br><span class="line">      <span class="comment">// 保存成功结果</span></span><br><span class="line">      _this.value = value</span><br><span class="line">      <span class="comment">// 遍历执行成功回调</span></span><br><span class="line">      _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前态是否为pending，只有pending时可更该状态</span></span><br><span class="line">    <span class="keyword">if</span> (_this.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 更改为失败态</span></span><br><span class="line">      _this.state = <span class="string">&quot;rejected&quot;</span></span><br><span class="line">      <span class="comment">// 保存失败原因</span></span><br><span class="line">      _this.reason = reason</span><br><span class="line">      <span class="comment">// 遍历执行失败回调</span></span><br><span class="line">      _this.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(reason))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、then方法"><a href="#2、then方法" class="headerlink" title="2、then方法"></a>2、then方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// then原型方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断参数不为函数时变成普通函数，成功-直接返回接收值 失败-抛出错误</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的Promise实例</span></span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 等待态判断，此时异步代码还未走完，回调入数组队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 将成功回调push入成功队列</span></span><br><span class="line">      <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">            <span class="comment">// 处理返回值</span></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将失败回调push入失败队列</span></span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason)</span><br><span class="line">            <span class="comment">// 处理返回值</span></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">      queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">          <span class="comment">// 处理返回值</span></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">      queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason)</span><br><span class="line">          <span class="comment">// 处理返回值</span></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、解析then返回值与新Promise对象"><a href="#3、解析then返回值与新Promise对象" class="headerlink" title="3、解析then返回值与新Promise对象"></a>3、解析then返回值与新Promise对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析then返回值与新Promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>新的Promise对象，就是我们创建的promise2实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>x 上一个then的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>resolve promise2处理器函数的resolve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>reject promise2处理器函数的reject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 解决循环引用报错</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="comment">// reject报错</span></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;请避免Promise循环引用&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义状态-防止多次调用</span></span><br><span class="line">  <span class="keyword">let</span> called</span><br><span class="line">  <span class="comment">// x不是null 且x是对象或函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 拿到x的then方法</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="comment">// 如果then是函数，就默认是promise</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行then 使用call传递this 第一个参数是this 后面是成功的回调 和 失败的回调</span></span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 防止用户在resolve的时候传入Promise，递归调用</span></span><br><span class="line">            resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、catch、resolve、reject方法"><a href="#4、catch、resolve、reject方法" class="headerlink" title="4、catch、resolve、reject方法"></a>4、catch、resolve、reject方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// catch原型方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 直接执行then方法，onFulfilled为null，传入onRejected</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 直接抛出一个成功状态的Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 直接抛出一个拒绝状态的Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、all方法"><a href="#5、all方法" class="headerlink" title="5、all方法"></a>5、all方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all方法</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有一个目的 获取到所有的promise，都执行then，把结果放到数组，一起返回</span></span><br><span class="line">  <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> results = []</span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> promisesLength = promises.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt; promises.length;i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          results[i] = res;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="comment">// 当所有函数都正确执行了，resolve输出所有返回结果</span></span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promisesLength)  resolve(results);</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">3</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)&#125;)</span><br><span class="line"> );</span><br><span class="line"><span class="keyword">var</span> p2 =<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p3 =<span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1,p2,p3]);</span><br><span class="line">p.then(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(e)&#125;);</span><br></pre></td></tr></table></figure><h3 id="6、race方法"><a href="#6、race方法" class="headerlink" title="6、race方法"></a>6、race方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// race方法</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return一个Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历执行promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="comment">// then只要接收到状态改变，直接抛出</span></span><br><span class="line">      promises[i].then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4、手写Promise-all、allsettled"><a href="#2-4、手写Promise-all、allsettled" class="headerlink" title="2.4、手写Promise.all、allsettled"></a>2.4、手写Promise.all、allsettled</h2><h3 id="1、使用all："><a href="#1、使用all：" class="headerlink" title="1、使用all："></a>1、使用all：</h3><ul><li><p>iterable类型：代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型 </p></li><li><p>应用场景：有一个接口，需要其他两个或多个接口返回的数据作为参数时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.all(iterable)</span><br></pre></td></tr></table></figure></li><li><p>当需要处理多个Promise并行时，大多数情况下Promise.all用起来是非常顺手的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">n</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  delay(<span class="number">100</span>).then(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  delay(<span class="number">200</span>).then(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line"><span class="comment">// 最终输出： [1, 2]</span></span><br></pre></td></tr></table></figure></li><li><p>可是，是一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。</p><p>问题1：任意一个 promise 被 reject ，Promise.all 就会立即被 reject ，其他执行成功的Promise的消息都丢失了</p><p>问题2：大多数场景中，我们期望传入的这组 promise 无论执行失败或成功，都能获取每个 promise 的执行结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">n</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  delay(<span class="number">100</span>).then(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  delay(<span class="number">200</span>).then(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line"><span class="comment">// 最终输出： Uncaught (in promise) 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">.then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))  <span class="comment">// 加入catch语句后，最终输出：3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2、手写Promise-all"><a href="#2、手写Promise-all" class="headerlink" title="2、手写Promise.all"></a>2、手写Promise.all</h3><ul><li><p>将多个Promise 实例<strong>包装成一个新的 Promise实例</strong>，参数为一组 <strong>Promise 实例组成的数组</strong></p></li><li><p>只有所有的 promise <code>都成功才成功</code>, 只要有一 个失败了就直接失败</p></li><li><p>promsie.all的痛点：一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all方法: 只有一个目的 获取到所有的promise，都执行then，把结果放到数组，一起返回</span></span><br><span class="line"><span class="keyword">const</span> PromiseAll = <span class="function"><span class="params">promises</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([]);</span><br><span class="line"><span class="keyword">const</span> newPromises = promises.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="built_in">Promise</span> ? item :  <span class="built_in">Promise</span>.resolve(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> results = []; <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line">newPromises[i].then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        results[i] = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="comment">// 当所有函数都正确执行了，resolve输出所有返回结果</span></span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promiseLen)  resolve(results);</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           results[i] = &#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     &#125;</span><br><span class="line">    reject(results);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">n</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  delay(<span class="number">100</span>).then(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  delay(<span class="number">200</span>).then(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">PromiseAll(promises).then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span> <span class="built_in">console</span>.log(err+<span class="string">&#x27; 捕获的错误&#x27;</span>))<span class="comment">//不然会报错走不下去</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3、使用allsettled"><a href="#3、使用allsettled" class="headerlink" title="3、使用allsettled"></a>3、使用allsettled</h3><ul><li><p>返回的新 Promise 实例，一旦结束，状态总是 fulfilled，不会变成 rejected</p></li><li><p>使用场景：</p><p>不关心异步操作的结果，只关心这些操作有没有结束时，这个方法会比较有用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  delay(<span class="number">100</span>).then(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  delay(<span class="number">200</span>).then(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>)   <span class="comment">//拒绝</span></span><br><span class="line">  ]</span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line"><span class="comment">// 最终输出： </span></span><br><span class="line"><span class="comment">//    [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 2&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, value: 3&#125;,</span></span><br><span class="line"><span class="comment">//    ]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4、手写allsettled"><a href="#4、手写allsettled" class="headerlink" title="4、手写allsettled"></a>4、手写allsettled</h3><ul><li><p>即使是遇到rejec也会等待所有的promise到最后。所以我们只需要用一个array记录各个promise的fulfill或者reject结果即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PromiseAllSettled = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([]);</span><br><span class="line"><span class="keyword">const</span> newPromises = promises.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="built_in">Promise</span> ? item :  <span class="built_in">Promise</span>.resolve(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> results = []; <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line">newPromises[i].then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        results[i] = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promiseLen)  resolve(results);</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           results[i] = &#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     &#125;</span><br><span class="line">           promiseCount++;</span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promiseLen)  resolve(results);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、race实现"><a href="#5、race实现" class="headerlink" title="5、race实现"></a>5、race实现</h3><ul><li><p>最早改变状态）resolve或reject时，就改变自身的状态，并执行响应的回调。</p></li><li><p>跟all同样对于错误的不能处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PromiseRace = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([]);</span><br><span class="line"><span class="keyword">const</span> newPromises = promises.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="built_in">Promise</span> ? item :  <span class="built_in">Promise</span>.resolve(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123;</span><br><span class="line">newPromises[i].then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          reject(&#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5、实现promisify化"><a href="#5、实现promisify化" class="headerlink" title="5、实现promisify化"></a>5、实现promisify化</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><ul><li><p><code>promisify</code>是node的utils模块中的一个函数</p></li><li><p>作用：<strong>将一种函数</strong>（最后一个参数是回调函数的函数，且回调函数中有两个参数：<code>error</code> 和 <code>data</code>）<strong>转换为promise函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用前</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./index.js&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用promisify后</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</span><br><span class="line">readFile(<span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line">   .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">   &#125;)</span><br><span class="line">   .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newFn = promisify(fn)</span><br><span class="line">newFn(a) <span class="comment">// 会执行Promise参数方法</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 除了调用时的传参，还需要提供一个callback函数来供异步方法调用</span></span><br><span class="line">      <span class="keyword">const</span> callback = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</span><br><span class="line">           <span class="keyword">return</span> resolve(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      args.push(callback());</span><br><span class="line">      func.apply(ctx, args);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Promsie </tag>
            
            <tag> Async、await </tag>
            
            <tag> 发布订阅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的继承</title>
      <link href="/2021/12/11/JS%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/12/11/JS%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="ES5继承"><a href="#ES5继承" class="headerlink" title="ES5继承"></a>ES5继承</h2><h3 id="1、原型链-极其重要"><a href="#1、原型链-极其重要" class="headerlink" title="1、原型链             极其重要"></a>1、原型链             极其重要</h3><h4 id="1、-什么是原型链"><a href="#1、-什么是原型链" class="headerlink" title="1、 什么是原型链"></a>1、 什么是原型链</h4><ul><li><strong>构造函数、实例、原型对象的关系</strong><ul><li>构造函数的 prototype 指向原型对象，原型对象有一个 constructor 属性指回构造函数，每个构造函数生成的实例对象都有一个 <em>proto</em> 属性，这个属性指向原型对象</li><li>最后，既然每个对象都有一个<code>_proto_</code>属性指向原型对象，那么原型对象也有_proto_指向原型对象的原型对象，它指向Object 构造函数对应的原型对象，直到<code>null</code>，到达原型链顶端</li></ul></li></ul><h4 id="2、Object、Function的关系"><a href="#2、Object、Function的关系" class="headerlink" title="2、Object、Function的关系"></a>2、Object、Function的关系</h4><img src="file:///C:\Users\小虎牙\Documents\Tencent Files\2575329556\Image\Group\5LOKV2$Q28$JYOMV51%$GAA.jpg" alt="img" style="zoom: 25%;" /><ul><li><code>function</code> ：所有的函数（包括构造函数）是<code>Function</code>的实例，所以所有函数的<code>_proto_</code>都指向<code>Function</code>的原型对象</li><li>所有的原型对象（包括 <code>Function</code>的原型对象）都是Object的实例，所以<code>_proto_</code>都指向 <code>Object</code>（构造函数）的原型对象。而<code>Object</code>构造函数的 <code>_proto_</code>指向 null </li><li><code>Function</code>构造函数本身就是<code>Function</code>的实例，所以<code>_proto_</code>指向<code>Function</code>的原型对象</li></ul><h4 id="3、-原型链应用"><a href="#3、-原型链应用" class="headerlink" title="3、 原型链应用"></a>3、 原型链应用</h4><ul><li><p><strong>搜索机制</strong></p><p>实例属性 — 实例的原型 — 在原型链继承后，搜索可继续向上 原型的原型  – 直到原型链的末端</p></li><li><p><strong>确定原型与继承的关系</strong></p><ul><li>法1：instanceOf</li><li>法2：isPrototypeOf：只要原型链上包含该原型就是true</li></ul></li></ul><h3 id="2、继承方式：7种-√"><a href="#2、继承方式：7种-√" class="headerlink" title="2、继承方式：7种  √"></a>2、继承方式：7种  √</h3><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child  <span class="comment">// Child的constructor属性丢失问题</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure><ul><li><p><strong>优点：</strong>简单</p></li><li><p><strong>缺点：</strong></p><ol><li><p>共享问题，如果一个属性是引用类型，那么该属性被所有实例共享，基本类型的不会</p><p>child1改变了child1.name, child2.name不会被改变</p><p>child改变了child.obj, child2.obj会改变。因为保存了同一份地址</p></li><li><p>子原型被重写</p></li><li><p>不能向父类传参 </p></li></ol></li><li><p><strong>注意：</strong>子实例child1的__proto__ 和 子原型Son.prototye的constructor指向了Father，而不是子构造函数本身</p></li></ul><h4 id="2-借用构造函数（经典继承）"><a href="#2-借用构造函数（经典继承）" class="headerlink" title="2. 借用构造函数（经典继承）"></a>2. 借用构造函数（经典继承）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.names = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心实现继承的手段</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//此处利用call(),将 [Child]的this传递给Parent构造函数</span></span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.name);   <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.name);   <span class="comment">// daisy</span></span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;]</span></span><br></pre></td></tr></table></figure><ul><li>优点：<ol><li>避免引用类型共享，实例都是独立的，不会互相影响   </li><li>子可以向父类传参</li></ol></li><li>缺点：<ol><li>不能重用函数：方法是在构造函数内部定义的，每创建一个实例都会创建一遍方法</li><li><strong>子类无法访问父类原型上的方法</strong>，只能访问构造函数上的方法</li></ol></li></ul><h4 id="3-组合继承（1-2）"><a href="#3-组合继承（1-2）" class="headerlink" title="3. 组合继承（1+2）"></a>3. 组合继承（1+2）</h4><p>属性放在构造函数里，方法放在原型链上</p><ul><li><p>优点：1+2的优点</p></li><li><p>缺点：调用了两次父类构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Parent.call(<span class="built_in">this</span>, name)     <span class="comment">//1. 盗用构造函数继承实例属性</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()  <span class="comment">//2. 原型链继承原型上的属性+方法</span></span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-原型式继承：（1的变种）"><a href="#4-原型式继承：（1的变种）" class="headerlink" title="4. 原型式继承：（1的变种）"></a>4. 原型式继承：（1的变种）</h4><p>实际就是Object.create()，只是Object.create()将原型式继承进一步规范化了，在只传一个参数时，二者等价</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.__proto__ === o; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li><p>优点：简单，不需要再单独创建构造函数</p></li><li><p>缺点：与1一样，属性值如果有引用类型，会互相影响</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kevin&#x27;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;kelly&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">&#x27;person1&#x27;</span>;   <span class="comment">//person1 添加实例属性name</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin是原型上的name</span></span><br><span class="line"><span class="comment">//不是因为person1和person2有独立的name值。</span></span><br><span class="line"><span class="comment">//而是person1.name = &#x27;person1&#x27;给person1添加了name值，而没有修改原型上的name值</span></span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">&#x27;taylor&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-寄生式继承（2的变种）"><a href="#5-寄生式继承（2的变种）" class="headerlink" title="5. 寄生式继承（2的变种）"></a>5. 寄生式继承（2的变种）</h4><p>​    创建一个实现继承的函数，再以某种方式增强对象（添加新方法），再返回这个对象</p><ul><li><p>优点：同样适用于关注对象，而不在乎类型和构造函数的场景</p></li><li><p>缺点：2的缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(o)  <span class="comment">//创建新对象，不是必须这个，任何可以返回新对象的函数都可在这用</span></span><br><span class="line">  clone.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">// 增强</span></span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-寄生式组合继承（3-4）引用类型继承的最佳模式！！"><a href="#6-寄生式组合继承（3-4）引用类型继承的最佳模式！！" class="headerlink" title="6. 寄生式组合继承（3+4）引用类型继承的最佳模式！！"></a>6. 寄生式组合继承（3+4）引用类型继承的最佳模式！！</h4><p>思路：由构造函数继承属性，混合原型链继承方法</p><ul><li><p>混合原型链继承：不再像之前用父类的实例给子类prototype赋值，而是用<strong>父类prototype</strong>的副本</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.action = [<span class="string">&#x27;speak&#x27;</span>, <span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;eat&#x27;</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我被调用了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> , <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old!`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, score</span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);  <span class="comment">// 借用构造函数, 第一次调用父类构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承返回的新对象赋值给子类prototype，使子类原型继承父类prototype</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line">Son.prototype.constructor  = Son;</span><br><span class="line">Son.prototype.showScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my score is <span class="subst">$&#123;<span class="built_in">this</span>.score&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> Son(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;78&#x27;</span>);</span><br><span class="line">xiaoming.action.push(<span class="string">&#x27;panio&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(xiaoming.action);<span class="comment">//[&#x27;speak&#x27;, &#x27;run&#x27;, &#x27;eat&#x27;, &#x27;panio&#x27;]</span></span><br><span class="line">xiaoming.say();<span class="comment">//my name is xiaoming,23 years old!</span></span><br><span class="line">xiaoming.showScore(); <span class="comment">//my score is 78</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaohua = <span class="keyword">new</span> Son(<span class="string">&#x27;xiaohua&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;89&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(xiaohua.action);<span class="comment">//[&#x27;speak&#x27;, &#x27;run&#x27;, &#x27;eat&#x27;]</span></span><br><span class="line">xiaohua.say();<span class="comment">//my name is xiaohua,24 years old!</span></span><br><span class="line">xiaohua.showScore(); <span class="comment">//my score is 89</span></span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ol><li><p>解决了组合继承（3）的<strong>效率问题</strong>：父构造函数被调用两次  </p></li><li><p><strong>原型链不变</strong></p></li></ol></li></ul><h4 id="经典的题："><a href="#经典的题：" class="headerlink" title="经典的题："></a>经典的题：</h4><p>实现：student继承person</p><ol><li>person上面有一个name属性和printName方法</li><li>student上面有一个score属性和printScore方法</li><li>student和person共享一个方法</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    conaole.log(<span class="string">&#x27;我是父&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在原型上定义共享方法</span></span><br><span class="line">Person.prototype.commonMethods = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是共享方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, score</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//子类实现继承属性</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="built_in">this</span>.score = score;</span><br><span class="line">  <span class="built_in">this</span>.printScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    conaole.log(<span class="string">&#x27;我是子&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类继承方法</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 这里传参100给person是没有用的，person并没有这个属性</span></span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> Person(<span class="string">&#x27;小红&#x27;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是父&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个方法要继承</span></span><br><span class="line">  <span class="function"><span class="title">commonMethods</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    conole.log(<span class="string">&#x27;我是公共的方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题： 这样直接继承会导致子会继承父类的所有方法？？</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, score</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name)</span><br><span class="line">    <span class="built_in">this</span>.score = score</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">printScore</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是子&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小红&#x27;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="3、创建对象-6种"><a href="#3、创建对象-6种" class="headerlink" title="3、创建对象  6种"></a>3、创建对象  6种</h3><h4 id="1、直接创建Object实例"><a href="#1、直接创建Object实例" class="headerlink" title="1、直接创建Object实例"></a>1、直接创建Object实例</h4><ul><li>套路: 先创建空Object对象, 再动态添加属性/方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多、代码重复</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">//它没有原型对象，百度问过</span></span><br></pre></td></tr></table></figure><h4 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h4><ul><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个相似对象</li><li>问题: <code>对象没有一个具体的类型</code>, 都是Object类型</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h4><ul><li>套路: 自定义构造函数, 通过new创建对象</li><li>适用场景: 需要创建多个<code>类型确定</code>的对象,与上方工厂模式有所对比</li><li>问题: 每次实例化都会自动重新创建一遍，同名函数也是不相等的，每个对象都有相同的数据, 浪费内存</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、原型式：共享"><a href="#4、原型式：共享" class="headerlink" title="4、原型式：共享"></a>4、原型式：共享</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;zzx&#x27;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、组合式："><a href="#5、组合式：" class="headerlink" title="5、组合式："></a>5、组合式：</h4><ul><li><p>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</p></li><li><p>适用场景: 需要<code>创建多个类型确定</code>的对象</p></li><li><p>放在原型上可以节省空间(只需要加载一遍方法)</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="built_in">this</span>.friends = [<span class="string">&#x27;wc&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: Person,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6、寄生构造函数模式"><a href="#6、寄生构造函数模式" class="headerlink" title="6、寄生构造函数模式"></a>6、寄生构造函数模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    var o = new Object()   //创建空对象</span><br><span class="line">    o.name = name;       //增强其属性、方法</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&#x27;zzx&#x27;, 22, &#x27;Programmer&#x27;);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure><h2 id="class基本语法"><a href="#class基本语法" class="headerlink" title="class基本语法"></a>class基本语法</h2><h3 id="1、类与构造函数"><a href="#1、类与构造函数" class="headerlink" title="1、类与构造函数"></a>1、类与构造函数</h3><p>ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已</p><h4 id="1、相同点"><a href="#1、相同点" class="headerlink" title="1、相同点"></a>1、相同点</h4><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul><li><p>类的<strong>数据类型</strong>就是函数，类本身就指向构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Point<span class="comment">// &quot;function&quot;</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><ul><li>使用的时候，也是直接对类使用**<code>new</code>命令**，跟构造函数的用法完全一致</li></ul><h5 id="属性、方法"><a href="#属性、方法" class="headerlink" title="属性、方法"></a>属性、方法</h5><ul><li><p><strong>构造函数的</strong><code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，<strong>类的所有方法都定义在类的<code>prototype</code>属性</strong>上。在类的实例上面调用方法，其实就是调用<strong>原型上的方法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b =<span class="keyword">new</span> B();</span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>实例上的：</strong></p><ul><li>与 ES5 一样，类的所有实例共享一个原型对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 =<span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 =<span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">p1.__proto__ === p2.__proto__  <span class="comment">//true      它们的原型都是Point.prototype</span></span><br></pre></td></tr></table></figure><ul><li><p>与 ES5 一样，<strong>实例的</strong>属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span><span class="string">&#x27;(&#x27;</span>+<span class="built_in">this</span>.x +<span class="string">&#x27;, &#x27;</span>+<span class="built_in">this</span>.y +<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> point =newPoint(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">point.toString()<span class="comment">// (2, 3)</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;x&#x27;</span>)<span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;y&#x27;</span>)<span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)<span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>x</code>和<code>y</code>是实例<code>point</code>自身属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返<code>true</code></li><li>而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致</li></ul></li></ul></li><li><p><strong><code>prototype</code>对象的</strong></p><ul><li><p><strong><code>prototype</code>对象的</strong><code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Point.prototype.constructor ===Point     <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>一次向类添加多个方法：</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以<strong>类的新方法可以添加在<code>prototype</code>对象上面</strong>。<code>Object.assign</code>可以很方便地一次向类添加多个方法</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype,&#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、不同点"><a href="#2、不同点" class="headerlink" title="2、不同点"></a>2、不同点</h4><h5 id="方法不可枚举"><a href="#方法不可枚举" class="headerlink" title="方法不可枚举"></a>方法不可枚举</h5><ul><li><p><code>class</code> 中定义的方法不能枚举。所以在<strong>遍历类的实例身上的属性</strong>时，<strong>原型上的属性</strong>不会遍历到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure><p>ES5中可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Point=<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Point.prototype.toString =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;toString&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="实例化-1"><a href="#实例化-1" class="headerlink" title="实例化"></a>实例化</h5><ul><li>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行</li></ul><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><ul><li><p><code>class</code> 默认使用<code>strict</code> 严格模式执行，避免无意中，this丢失，指向window</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//严格模式下输出 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><ul><li><p>类不存在变量提升，这一点与 ES5 完全不同。 ES6 不会把类的声明提升到代码头部。这种规定的原因与继承有关，必须保证子类在父类之后定义。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo();<span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、constructor方法"><a href="#2、constructor方法" class="headerlink" title="2、constructor方法"></a>2、constructor方法</h3><ul><li><p><code>constructor</code>类的默认方法，在 new 时自动执行</p></li><li><p>一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加</p></li><li><p><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3、getter、setter"><a href="#3、getter、setter" class="headerlink" title="3、getter、setter"></a>3、getter、setter</h3><p>目的：使用访问器对对象的属性进行访问控制，有效的防止属性随意修改</p><ul><li><p>与 ES5 一样，在“类”的内部可用<code>get</code>和<code>set</code>对某个属性设置存、取值函数，拦截该属性的存取行为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span><span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inst =<span class="keyword">new</span> MyClass();</span><br><span class="line">inst.prop =<span class="number">123</span>;   <span class="comment">// setter: 123</span></span><br><span class="line">inst.prop       <span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>存值函数和取值函数是设置在属性的 Descriptor 对象上的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">html</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">html</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存值函数和取值函数是定义在`html`属性的描述对象上面，这与 ES5 完全一致</span></span><br><span class="line"><span class="keyword">var</span> descriptor =<span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype,<span class="string">&quot;html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;get&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;set&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>类的属性名，可以采用表达式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName =<span class="string">&#x27;getArea&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  [methodName]()&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、类的注意点"><a href="#4、类的注意点" class="headerlink" title="4、类的注意点"></a>4、类的注意点</h3><h4 id="1、严格模式"><a href="#1、严格模式" class="headerlink" title="1、严格模式"></a>1、严格模式</h4><ul><li>类和模块的内部，<strong>默认就是严格模式</strong>，所以不需要使用<code>use strict</code>指定运行模式</li><li>只要你的代码写在类或模块之中，就只有严格模式可用。</li><li>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式</li></ul><h4 id="2、不存在提升"><a href="#2、不存在提升" class="headerlink" title="2、不存在提升"></a>2、不存在提升</h4><ul><li>类不存在变量提升（hoist），这一点与 ES5 完全不同</li><li>这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义</li></ul><h4 id="3、name-属性"><a href="#3、name-属性" class="headerlink" title="3、name 属性"></a>3、name 属性</h4><ul><li><p>本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p></li><li><p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;&#125;</span><br><span class="line">Point.name <span class="comment">// &quot;Point&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4、this-指向"><a href="#4、this-指向" class="headerlink" title="4、this 指向"></a>4、this 指向</h4><ul><li>类的方法内部如果含有<code>this</code>，它默认指向<strong>类的实例。</strong></li><li>但是，必须非常小心，<strong>一旦单独使用该方法，很可能报错。</strong><ul><li><code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。</li><li>但是，<strong>如果将这个方法提取出来单独使用</strong>，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name =<span class="string">&#x27;there&#x27;</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logger =<span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span>&#123; printName &#125;= logger;</span><br><span class="line">printName();<span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure><h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><ul><li><p>在构造方法中绑定<code>this</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.printName =<span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>箭头函数</p><ul><li>箭头函数内部的<code>this</code>总是指向定义时所在的对象</li><li>箭头函数位于构造函数内部，这时所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.getThis =<span class="function">()=&gt;</span><span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myObj =<span class="keyword">new</span> Obj();</span><br><span class="line">myObj.getThis()=== myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> (<span class="params">target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache =<span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="keyword">const</span> handler =&#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params">target, key</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> value =<span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> value !==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cache.has(value))&#123;</span><br><span class="line">          cache.set(value, value.bind(target));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy =newProxy(target, handler);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logger = selfish(newLogger());</span><br></pre></td></tr></table></figure></li></ul><h5 id="Generator-方法"><a href="#Generator-方法" class="headerlink" title="Generator 方法"></a>Generator 方法</h5><ul><li><p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数</p></li><li><p><code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">classFoo&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="built_in">this</span>.args)&#123;</span><br><span class="line">          <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> newFoo(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5、静态方法、静态方法、实例属性写法"><a href="#5、静态方法、静态方法、实例属性写法" class="headerlink" title="5、静态方法、静态方法、实例属性写法"></a>5、静态方法、静态方法、实例属性写法</h3><h4 id="1、静态方法定义及规则"><a href="#1、静态方法定义及规则" class="headerlink" title="1、静态方法定义及规则"></a>1、静态方法定义及规则</h4><ul><li><p><strong>静态方法：</strong></p><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。</p><p>如果<strong>在一个方法前，加上<code>static</code>关键字</strong>，就表示<strong>该方法不会被实例继承</strong>，而是直接通过类来调用，这就<strong>称为“静态方法”。</strong></p></li><li><p><strong>规则：</strong></p><ul><li><p>如果在实例上调用静态方法，会<strong>抛出一个错误</strong>，表示不存在该方法</p></li><li><p>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</p></li><li><p>静态方法可以与非静态方法重名</p></li><li><p><strong>父类</strong>的静态方法，可以被<strong>子类</strong>继承（注意，这里是两个类，不是类与实例）</p></li><li><p>静态方法也是可以从<code>super</code>对象上调用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span><span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">classBar <span class="keyword">extends</span> Foo&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">super</span>.classMethod()+<span class="string">&#x27;, too&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod()<span class="comment">// &quot;hello, too&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3、实例属性新写法"><a href="#3、实例属性新写法" class="headerlink" title="3、实例属性新写法"></a>3、实例属性新写法</h4><ul><li><p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层</p><ul><li>实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</li><li>新写法好处：所有实例对象自身的属性都定义在类的头部，一眼就能看出这个类有哪些实例属性。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span></span>&#123;</span><br><span class="line">  _count =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">  returnthis._count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、静态属性定义及规则"><a href="#4、静态属性定义及规则" class="headerlink" title="4、静态属性定义及规则"></a>4、静态属性定义及规则</h4><ul><li><p><strong>静态属性：</strong></p><p>指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性</p><ul><li>老写法：静态属性定义在类的外部。整个类生成以后，再生成静态属性</li><li>让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  <span class="comment">// 老写法</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p> ES6 明确规定，Class 内部只有静态方法，没有静态属性，所以新提案提供新写法：</p><ul><li><strong>写法是在实例属性的前面，加上<code>static</code>关键字</strong></li><li>显式声明（declarative），而不是赋值处理，语义更好</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6、私有方法、属性"><a href="#6、私有方法、属性" class="headerlink" title="6、私有方法、属性"></a>6、私有方法、属性</h3><ul><li><p>私有方法和私有属性，是<strong>只能在类的内部访问的方法和属性，外部不能访问</strong>。</p></li><li><p>这是常见需求，<strong>有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现</strong></p></li></ul><h4 id="1、私有属性-现有方案："><a href="#1、私有属性-现有方案：" class="headerlink" title="1、私有属性 现有方案："></a>1、私有属性 现有方案：</h4><h5 id="1、命名保护"><a href="#1、命名保护" class="headerlink" title="1、命名保护"></a>1、命名保护</h5><ul><li>将属性定义为以 <code>_</code> 开始，来告诉使用者这是一个私有属性，不要在外部使用，这只是刻意的提示</li><li>外部<strong>修改私有属性时可以使用访问器 <code>setter</code> 操作</strong>，<strong>继承时是可以使用的</strong></li></ul><h5 id="2、将私有方法移出模块"><a href="#2、将私有方法移出模块" class="headerlink" title="2、将私有方法移出模块"></a>2、将私有方法移出模块</h5><p>因为模块内部的所有方法都是对外可见的：</p><ul><li><code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar</code>实际上成为了当前模块的私有方法。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="built_in">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、Symbol"><a href="#3、Symbol" class="headerlink" title="3、Symbol "></a>3、<code>Symbol </code></h5><ul><li><p>利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值；</p></li><li><p>在外部通过查看对象结构无法获取的属性，继承同样可以拿到这个属性：</p><p>bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到<strong>了私有方法和私有属性的效果</strong></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);  </span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">&#x27;snaf&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params">baz</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> myClass();</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(myClass.prototype)  <span class="comment">//Symbol 值的属性名依然可以从类的外部拿到</span></span><br><span class="line"><span class="comment">// [ &#x27;constructor&#x27;, &#x27;foo&#x27;, Symbol(bar) ]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、私有属性-现有提案"><a href="#2、私有属性-现有提案" class="headerlink" title="2、私有属性 现有提案"></a>2、私有属性 现有提案</h4><p>为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示：</p><ul><li><p><code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> IncreasingCounter();</span><br><span class="line">counter.#count  <span class="comment">//代码在类的外部，读取私有属性，就会报错</span></span><br><span class="line">counter.#count = <span class="number">42</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li><li><h4 id="为什么没有采用private关键字？"><a href="#为什么没有采用private关键字？" class="headerlink" title="为什么没有采用private关键字？"></a>为什么没有采用<code>private</code>关键字？</h4><ul><li>是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性</li><li>ES6 没有用<code>@</code>符号而使用<code>#</code>，是因为<code>@</code>已经被留给了 Decorator</li></ul></li><li><p>这种方式样可用于私有方法</p></li><li><h5 id="私有属性也可以设置-getter-和-setter-方法"><a href="#私有属性也可以设置-getter-和-setter-方法" class="headerlink" title="私有属性也可以设置 getter 和 setter 方法"></a>私有属性也可以设置 getter 和 setter 方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  #xValue = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  get #<span class="function"><span class="title">x</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> #xValue; &#125;</span><br><span class="line">  set #<span class="function"><span class="title">x</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#xValue = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性"><a href="#私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性" class="headerlink" title="私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性"></a>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  #privateValue = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getPrivateValue</span>(<span class="params">foo</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo.#privateValue;    <span class="comment">//从实例foo上面引用私有属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getPrivateValue(<span class="keyword">new</span> Foo()); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure></li><li><h5 id="私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法"><a href="#私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法" class="headerlink" title="私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法"></a>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeMath</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> PI = <span class="number">22</span> / <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">static</span> #totallyRandomNumber = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">static</span> #<span class="function"><span class="title">computeRandomNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> FakeMath.#totallyRandomNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">random</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I heard you like random numbers…&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> FakeMath.#computeRandomNumber();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">FakeMath.PI <span class="comment">// 3.142857142857143  </span></span><br><span class="line">FakeMath.random()           <span class="comment">// 只能在`FakeMath`这个类的内部调用，外部调用就会报错</span></span><br><span class="line"><span class="comment">// I heard you like random numbers…</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">FakeMath.#totallyRandomNumber <span class="comment">// 报错  `#totallyRandomNumber`是私有属性</span></span><br><span class="line">FakeMath.#computeRandomNumber() <span class="comment">// 报错  `#computeRandomNumber()`是私有方法</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7、new-target-属性"><a href="#7、new-target-属性" class="headerlink" title="7、new.target 属性"></a>7、new.target 属性</h3><h4 id="1、对构造函数"><a href="#1、对构造函数" class="headerlink" title="1、对构造函数"></a>1、对构造函数</h4><ul><li><p>ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。</p></li><li><p>如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此<strong>这个属性可以用来确定构造函数是怎么调用的</strong>。</p></li><li><p>代码确保构造函数只能通过<code>new</code>命令调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span>.target !==<span class="literal">undefined</span>)&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span>.target === Person)&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person =<span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>);<span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson =Person.call(person,<span class="string">&#x27;张三&#x27;</span>);<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、对类class"><a href="#2、对类class" class="headerlink" title="2、对类class"></a>2、对类class</h4><ul><li><p>Class 内部调用<code>new.target</code>，返回当前 Class</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="built_in">this</span>.length = length;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj =<span class="keyword">new</span> Rectangle(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li><li><p>注意：子类继承父类时，<code>new.target</code>会返回子类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target ===Rectangle);  <span class="comment">//new.target会返回子类</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(length, width);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target ===Square); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj =<span class="keyword">new</span> Square(<span class="number">3</span>);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h4><p>利用这个特点，可以写出<strong>不能独立使用、必须继承后才能使用的类</strong></p><ul><li><code>Shape</code>类不能被实例化，<strong>只能用于继承。</strong></li><li>注意，在函数外部，使用<code>new.target</code>会报错。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.target === Shape)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本类不能实例化&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x =<span class="keyword">new</span> Shape();<span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y =<span class="keyword">new</span> Rectangle(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h2 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h2><p>Class 可以通过<code>extends</code>关键字实现继承，比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><h3 id="1、继承实现"><a href="#1、继承实现" class="headerlink" title="1、继承实现"></a>1、继承实现</h3><h4 id="1、extends关键字"><a href="#1、extends关键字" class="headerlink" title="1、extends关键字"></a>1、extends关键字</h4><ul><li><p>通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法</p><ul><li>父类的静态方法，会被子类继承</li><li></li></ul></li><li><p><strong>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错：</strong></p><ul><li>这是因为：子类自己的<code>this</code>对象，必须先通过父类的构造函数<strong>得到与父类同样的实例属性和方法</strong></li><li>然后再对其进行加工，加上子类自己的实例属性和方法</li><li><strong>如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</strong></li></ul></li><li><p>因此，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是<strong>因为子类实例的构建，基于父类实例</strong>，只有<code>super</code>方法才能调用父类实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(x, y);        <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.color +<span class="string">&#x27; &#x27;</span>+ <span class="built_in">super</span>.toString();<span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、继承的实质分析"><a href="#2、继承的实质分析" class="headerlink" title="2、继承的实质分析"></a>2、继承的实质分析</h4><ul><li><h5 id="ES5-的继承："><a href="#ES5-的继承：" class="headerlink" title="ES5 的继承："></a>ES5 的继承：</h5><p>实质是<strong>先创造子类的实例对象<code>this</code>，然后再将父类的方法添加</strong>到<code>this</code>上面（<code>Parent.apply(this)</code>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  User.call(<span class="built_in">this</span>, name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="ES6-的继承机制："><a href="#ES6-的继承机制：" class="headerlink" title="ES6 的继承机制："></a>ES6 的继承机制：</h5><img src="https://upload-images.jianshu.io/upload_images/675733-c5dd46572ce51840.png?imageMogr2/auto-orient/strip|imageView2/2/w/504/format/webp" alt="img" style="zoom:50%;" /><p>实质是<strong>先将父类实例对象的属性和方法，加到<code>this</code>上面</strong></p><p>因此，在子类构造函数中要先执行<code>super</code>，然后再用子类的构造函数修改<code>this</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、静态方法"><a href="#3、静态方法" class="headerlink" title="3、静态方法"></a>3、静态方法</h4><ul><li>父类的静态方法，也会被子类继承</li></ul><h4 id="4、Object-getPrototypeOf"><a href="#4、Object-getPrototypeOf" class="headerlink" title="4、Object.getPrototypeOf"></a>4、Object.getPrototypeOf</h4><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint)===Point   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2、super关键字"><a href="#2、super关键字" class="headerlink" title="2、super关键字"></a>2、super关键字</h3><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><h4 id="1、作函数调用"><a href="#1、作函数调用" class="headerlink" title="1、作函数调用"></a>1、作函数调用</h4><p><code>super</code>作为函数调用时，<strong>代表父类的构造函数</strong>。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p><ul><li><p><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例：即**<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例**，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);<span class="comment">// `new.target`指向当前正在执行的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A  </span></span><br><span class="line"><span class="comment">//在`super()`执行时，它指向的是子类`B`的构造函数，而不是父类`A`的构造函数，也就是说，`super()`内部的`this`指向的是`B`。</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B  </span></span><br></pre></td></tr></table></figure></li><li><p><code>super()</code>只能用在<strong>子类的构造函数</strong>之中，用在其他地方就会报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(); <span class="comment">// 报错，不是构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、作为对象调用"><a href="#2、作为对象调用" class="headerlink" title="2、作为对象调用"></a>2、作为对象调用</h4><h5 id="普通方法："><a href="#普通方法：" class="headerlink" title="普通方法："></a>普通方法：</h5><ul><li><p><code>super</code>作为对象时，<strong>在普通方法中，指向父类的原型对象</strong>；<strong>在静态方法中，指向父类</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">p</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// 子类B当中的super.p()，就是将super当作一个对象使用。</span></span><br><span class="line">    <span class="comment">//这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure></li><li><p>由于<code>super</code>指向父类的<strong>原型对象</strong>，所以定义在<strong>父类实例上的方法或属性，是无法通过<code>super</code>调用的</strong>。</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.p;  <span class="comment">// p是父类A实例的属性，super.p就引用不到它</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.x) <span class="comment">// 2   此时在原型上，可以取到</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例</p><p>也因此，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值属性会变成子类实例属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.print(); <span class="comment">//实际上执行的是super.print.call(this)</span></span><br><span class="line">    <span class="comment">// 此时this指向子类实例，对子类实例属性赋值了</span></span><br><span class="line">    <span class="built_in">super</span>.x = <span class="number">3</span>;  <span class="comment">//等同于对this.x赋值为3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.x); <span class="comment">// 读的是A.prototype.x，所以返回undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// 3  this是子类实例</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a>静态方法：</h5><ul><li><p>在<strong>子类静态方法</strong>中通过<code>super</code>调<strong>用父类静态方法</strong>时，</p><ul><li><p><code>super</code>将指向<strong>父类</strong>，而不是父类的原型对象。</p></li><li><p>方法内部的**<code>this</code>指向当前的子类**，而不是子类的实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();  </span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.print();  <span class="comment">//这个方法里面的this指向的是B，而不是B的实例。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">B.x = <span class="number">3</span>;</span><br><span class="line">B.m() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3、使用注意"><a href="#3、使用注意" class="headerlink" title="3、使用注意"></a>3、使用注意</h4><ul><li><p>使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错</p></li><li><p>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MyObject: &quot;</span> + <span class="built_in">super</span>.toString(); <span class="comment">//明显是对象来用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.toString(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3、prototype、-proto-属性"><a href="#3、prototype、-proto-属性" class="headerlink" title="3、prototype、__proto__属性"></a>3、prototype、__proto__属性</h3><h4 id="1、类的-prototype-属性和-proto-属性"><a href="#1、类的-prototype-属性和-proto-属性" class="headerlink" title="1、类的 prototype 属性和__proto__属性"></a>1、类的 prototype 属性和__proto__属性</h4><ul><li><p>ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。</p></li><li><p>Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此<strong>同时存在两条继承链</strong></p><p>（1）子类的<code>__proto__</code>属性，表示<strong>构造函数的继承</strong>，总是指向父类</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">B.__proto__ === A <span class="comment">// true 子类`B`的`__proto__`属性指向父类`A`</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true 子类`B`的`prototype`属性的`__proto__`属性指向父类`A`的`prototype`属性</span></span><br></pre></td></tr></table></figure></li><li><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B 的实例继承 A 的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"><span class="comment">// B 继承 A 的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"><span class="keyword">const</span> b =<span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf方法的实现:</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf =<span class="function"><span class="keyword">function</span>(<span class="params">obj, proto</span>)</span>&#123;</span><br><span class="line">    obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>因此，可以这样理解：</p><p>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>）是父类（<code>A</code>）；</p><p>作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>）是父类原型对象（<code>prototype</code>属性）的实例</p></li></ul><h4 id="2、不同个继承类型"><a href="#2、不同个继承类型" class="headerlink" title="2、不同个继承类型"></a>2、不同个继承类型</h4><ul><li><p><code>extends</code>关键字后面可以跟多种类型的值</p><p>只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B extends A &#123;//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="方式1：子类继承Object类"><a href="#方式1：子类继承Object类" class="headerlink" title="方式1：子类继承Object类"></a>方式1：子类继承<code>Object</code>类</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">A.__proto__ ===<span class="built_in">Object</span><span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ ===<span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="方式2：不存在任何继承"><a href="#方式2：不存在任何继承" class="headerlink" title="方式2：不存在任何继承"></a>方式2：不存在任何继承</h5><ul><li><code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。</li><li>但<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">A.__proto__ ===<span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ ===<span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="3、实例的-proto-属性"><a href="#3、实例的-proto-属性" class="headerlink" title="3、实例的 proto 属性"></a>3、实例的 <strong>proto</strong> 属性</h4><ul><li><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。</p></li><li><p>也就是说，子类的原型的原型，是父类的原型。</p><p><code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 =<span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 =<span class="keyword">new</span> ColorPoint(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>应用：</p><p>通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p2.__proto__.__proto__.printName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Ha&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">p1.printName()<span class="comment">// &quot;Ha&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4、Mixin"><a href="#4、Mixin" class="headerlink" title="4、Mixin"></a>4、Mixin</h3><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。</p><ul><li><p><code>JS</code>不能实现多继承，如果要使用多个类的方法时可以使用<code>mixin</code>混合模式来完成</p></li><li><p><code>mixin</code> 类是一个包含许多供其它类使用的方法的类</p></li><li><p><code>mixin</code> 类不用来继承做为其它类的父类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">...mixins</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mix</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins)&#123;</span><br><span class="line">            copyProperties(<span class="built_in">this</span>,<span class="keyword">new</span> mixin());<span class="comment">// 拷贝实例属性</span></span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins)&#123;</span><br><span class="line">      copyProperties(Mix, mixin);<span class="comment">// 拷贝静态属性</span></span><br><span class="line">      copyProperties(Mix.prototype, mixin.prototype);<span class="comment">// 拷贝原型属性</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> Mix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyProperties</span>(<span class="params">target, source</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source))&#123;</span><br><span class="line">      <span class="keyword">if</span>(key !==<span class="string">&#x27;constructor&#x27;</span> &amp;&amp; key !==<span class="string">&#x27;prototype&#x27;</span> &amp;&amp; key !==<span class="string">&#x27;name&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> desc =<span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target, key, desc);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributedEdit</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Loggable</span>,<span class="title">Serializable</span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - 原型链</title>
      <link href="/2021/12/11/%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2021/12/11/%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="原型链-√√√√-极其重要"><a href="#原型链-√√√√-极其重要" class="headerlink" title="原型链  √√√√           极其重要"></a>原型链  √√√√           极其重要</h3><h4 id="1、-什么是原型链"><a href="#1、-什么是原型链" class="headerlink" title="1、 什么是原型链"></a>1、 什么是原型链</h4><ul><li><strong>构造函数、实例、原型对象的关系</strong><ul><li>构造函数的 prototype 指向原型对象，原型对象有一个 constructor 属性指回构造函数，每个构造函数生成的实例对象都有一个 <em>proto</em> 属性，这个属性指向原型对象</li><li>最后，既然每个对象都有一个<code>_proto_</code>属性指向原型对象，那么原型对象也有_proto_指向原型对象的原型对象，它指向Object 构造函数对应的原型对象，直到<code>null</code>，到达原型链顶端</li></ul></li></ul><h4 id="2、Object、Function的关系："><a href="#2、Object、Function的关系：" class="headerlink" title="2、Object、Function的关系："></a>2、Object、Function的关系：</h4><img src="file:///C:\Users\小虎牙\Documents\Tencent Files\2575329556\Image\Group\5LOKV2$Q28$JYOMV51%$GAA.jpg" alt="img" style="zoom: 25%;" /><ul><li><code>function</code> ：所有的函数（包括构造函数）是<code>Function</code>的实例，所以所有函数的<code>_proto_</code>都指向<code>Function</code>的原型对象</li><li>所有的原型对象（包括 <code>Function</code>的原型对象）都是Object的实例，所以<code>_proto_</code>都指向 <code>Object</code>（构造函数）的原型对象。而<code>Object</code>构造函数的 <code>_proto_</code>指向 null </li><li><code>Function</code>构造函数本身就是<code>Function</code>的实例，所以<code>_proto_</code>指向<code>Function</code>的原型对象</li></ul><h4 id="3、-原型链应用"><a href="#3、-原型链应用" class="headerlink" title="3、 原型链应用"></a>3、 原型链应用</h4><ul><li><p><strong>搜索机制</strong></p><p>实例属性 — 实例的原型 — 在原型链继承后，搜索可继续向上 原型的原型  – 直到原型链的末端</p></li><li><p><strong>确定原型与继承的关系</strong></p><ul><li>法1：instanceOf</li><li>法2：isPrototypeOf：只要原型链上包含该原型就是true</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - new操作符</title>
      <link href="/2021/12/11/%E5%AF%B9%E8%B1%A1-new%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2021/12/11/%E5%AF%B9%E8%B1%A1-new%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><h4 id="1、内部做了什么"><a href="#1、内部做了什么" class="headerlink" title="1、内部做了什么"></a>1、内部做了什么</h4><pre><code>1. 在内存中创建一个对象2. 这个新对象内部的[prototype]特性会被赋值为构造函数的prototype属性3. 构造函数内部的this被赋值为这个新对象，即this指向新对象4. 执行构造函数内部的代码，给对象添加属性5. 如果构造函数返回非空对象，就返回该对象，否则就返回刚创建的新对象（判断）</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNnew</span>(<span class="params">F,...arg</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1. 创建新对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;  <span class="comment">// 或new Object()</span></span><br><span class="line">  <span class="comment">//2. __proto__指向原型</span></span><br><span class="line">  obj.__proto__ = F.prototype</span><br><span class="line">  <span class="comment">//3. this指向新对象，执行构造函数F中的代码</span></span><br><span class="line">  <span class="keyword">let</span> result = F.call(obj, arg)</span><br><span class="line">  <span class="comment">//4. 判断</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> result === <span class="string">&quot;Object&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - Object.create</title>
      <link href="/2021/12/11/%E5%AF%B9%E8%B1%A1-Object-create/"/>
      <url>/2021/12/11/%E5%AF%B9%E8%B1%A1-Object-create/</url>
      
        <content type="html"><![CDATA[<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><h4 id="1、参数1：对象、null"><a href="#1、参数1：对象、null" class="headerlink" title="1、参数1：对象、null"></a>1、参数1：对象、null</h4><ul><li><p>如果对象的属性是基本类型，二者互不影响。如果对象的属性值是<strong>引用类型，会互相影响</strong>，因为只传一个参数的情况下本质就是浅复制</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person); </span><br><span class="line">me 会继承person的所有属性和方法，me.__proto__ === person为<span class="literal">true</span></span><br><span class="line">me 可以自己添加新属性和方法，也可将继承过来的属性重写，二者互不影响</span><br></pre></td></tr></table></figure></li><li><p>创造一个没有原型的空对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> my = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">此时my就是彻底的空对象，没有继承<span class="built_in">Object</span>.prototype上的任何属性和方法，如hasOwnProperty()、toString()</span><br><span class="line">my <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// false</span></span><br><span class="line">my.__proto__ === person <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、参数2：可选"><a href="#2、参数2：可选" class="headerlink" title="2、参数2：可选"></a>2、参数2：可选</h4><p>指定要添加到新对象上的可枚举的属性描述符、属性名称</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bb = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.dir(bb); <span class="comment">// &#123;a: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bb.__proto__); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(bb.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(bb <span class="keyword">instanceof</span> <span class="built_in">Object</span>); </span><br><span class="line"><span class="comment">// false 没有继承`Object.prototype`上的任何属性和方法，所以原型链上不会出现Object</span></span><br></pre></td></tr></table></figure><h4 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.mycreate = <span class="function"><span class="keyword">function</span>(<span class="params">proto, properties</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 关键：新生成的对象的__proto__指向参数1proto</span></span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    <span class="comment">// 如果有第2参数</span></span><br><span class="line">    <span class="keyword">if</span>(properties) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(F, properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - 堆与栈</title>
      <link href="/2021/12/11/%E5%AF%B9%E8%B1%A1-%E5%A0%86%E4%B8%8E%E6%A0%88/"/>
      <url>/2021/12/11/%E5%AF%B9%E8%B1%A1-%E5%A0%86%E4%B8%8E%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><h4 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h4><ul><li><p>空间分配：系统自动分配内存空间，自动释放，占据固定大小的空间，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性</p></li><li><p>数</p></li><li><p>据存储：基础变量的值、引用变量的地址会存储在栈中</p></li><li><p>读取速度：相比于堆来说存取速度会快</p></li></ul><h4 id="2、堆"><a href="#2、堆" class="headerlink" title="2、堆"></a>2、堆</h4><ul><li><p>空间分配：系统动态分配的内存，大小不定，也不会自动释放，一般由程序员分配释放，也可由垃圾回收机制回收</p><ul><li><p>基本数据类型在当前执行环境结束时销毁</p></li><li><p>而引用类型不会随执行环境结束而销毁，只有当所有引用他的变量不存在时这个对象才会被回收机制回收</p><p>堆中的对象不会随方法结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)</p></li></ul></li><li><p>存储引用类型的值</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - 你真的区分赋值、浅拷贝、深拷贝吗？</title>
      <link href="/2021/12/11/%E5%AF%B9%E8%B1%A1-%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2021/12/11/%E5%AF%B9%E8%B1%A1-%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="赋值、浅拷贝、深拷贝"><a href="#赋值、浅拷贝、深拷贝" class="headerlink" title="赋值、浅拷贝、深拷贝"></a>赋值、浅拷贝、深拷贝</h3><h4 id="1、赋值："><a href="#1、赋值：" class="headerlink" title="1、赋值："></a>1、赋值：</h4><ul><li><p>基本：直接在栈中开辟新内存，把值赋值到新内存中，互不影响</p></li><li><p>引用：直接<strong>复制栈内存中的地址，指向同一个堆内存</strong>，<strong>指向同一对象</strong>，任何操作都会互相影响</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = xxx, a内存中到底保存的是什么?</span><br><span class="line"></span><br><span class="line">xxx是基本数据, 保存的就是这个数据</span><br><span class="line">xxx是对象, 保存的是对象的地址值</span><br><span class="line">xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、拷贝："><a href="#2、拷贝：" class="headerlink" title="2、拷贝："></a>2、拷贝：</h4><ul><li><p>浅拷贝：                                                                            </p><ul><li>重新在堆内存中开辟新的内存                 <strong>和源对象并不指向同一对象</strong>    </li><li>第一层数据是基本类型：  改变后，<strong>不会一起改变</strong></li><li>第一层数据为引用类型： 改变后，<strong>会一起改变</strong>      </li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="string">&#x27;kk&#x27;</span>: <span class="string">&#x27;hh&#x27;</span>&#125;, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line"></span><br><span class="line">arr === newArr;<span class="comment">//  false</span></span><br><span class="line">newArr.push(<span class="string">&#x27;four&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)    <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>][<span class="string">&#x27;kk&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">//[ &#123; kk: 1 &#125;, &#x27;two&#x27;, &#x27;three&#x27; ]</span></span><br><span class="line"><span class="comment">//[ &#123; kk: 1 &#125;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27; ]</span></span><br></pre></td></tr></table></figure></li><li><p>深拷贝：重新在堆内存中开辟新的内存                <strong>和源对象并不指向同一对象</strong>    </p><ul><li>第一层数据是基本类型：  改变后，<strong>不会一起改变</strong></li><li>第一层数据为引用类型： 改变后，<strong>不会一起改变</strong>   </li></ul></li></ul><h4 id="3、浅拷贝实现"><a href="#3、浅拷贝实现" class="headerlink" title="3、浅拷贝实现"></a>3、浅拷贝实现</h4><ul><li><h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.assign(&#123;&#125;, obj1)</span><br></pre></td></tr></table></figure></li><li><p>loadsh库的clone方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;)</span><br><span class="line">var obj2 = _.clone(obj1);</span><br></pre></td></tr></table></figure></li><li><p>拓展运算符：…</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; name: &#x27;Kobe&#x27;, address:&#123;x:100,y:100&#125;&#125;</span><br><span class="line">let obj2= &#123;... obj1&#125;</span><br><span class="line">console.log(obj1 === obj2) //false</span><br></pre></td></tr></table></figure></li><li><h5 id="Array-prototype-concat-：该方法会有副本"><a href="#Array-prototype-concat-：该方法会有副本" class="headerlink" title="Array.prototype.concat()：该方法会有副本"></a>Array.prototype.concat()：该方法会有副本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr2 = arr1.concat(); </span><br></pre></td></tr></table></figure></li><li><h5 id="Array-prototype-slice-：该方法同样有副本"><a href="#Array-prototype-slice-：该方法同样有副本" class="headerlink" title="Array.prototype.slice()：该方法同样有副本"></a>Array.prototype.slice()：该方法同样有副本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr2 = arr1.slice();</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、手写浅拷贝："><a href="#4、手写浅拷贝：" class="headerlink" title="4、手写浅拷贝："></a>4、手写浅拷贝：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shallowCopy = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 只拷贝对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 根据obj的类型判断是新建一个数组还是对象</span></span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="comment">// 遍历obj，并且判断是obj的属性才拷贝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) newObj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="补充Object-assign-："><a href="#补充Object-assign-：" class="headerlink" title="补充Object.assign()："></a>补充Object.assign()：</h4><ul><li><p>将所有可枚举属性的值从一个或多个源对象复制到目标对象，同时返回目标对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br><span class="line">  -- <span class="string">`target`</span> 是目标对象，<span class="string">`sources`</span> 是源对象，可有多个，返回修改后目标对象 <span class="string">`target`</span></span><br><span class="line">  -- 目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖</span><br><span class="line">  -- 后来的源对象的属性将类似地覆盖早先的属性</span><br></pre></td></tr></table></figure></li><li><p>浅拷贝之后<strong>目标对象 a 的基本类型值没有改变，但是引用类型值发生了改变</strong>，因为 <code>Object.assign()</code> 拷贝的是属性值。<strong>假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用地址。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="built_in">Object</span>.assign(a, b);</span><br><span class="line"><span class="built_in">console</span>.log(a === c);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><h5 id="实现Object-assign-："><a href="#实现Object-assign-：" class="headerlink" title="实现Object.assign()："></a>实现Object.assign()：</h5><p>思路： <code>for..in</code> 循环遍历出所有可枚举的自有属性。并复制给新的目标对象（使用 <code>hasOwnProperty</code> 获取自有属性，即非原型链上的属性）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> assign = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; <span class="built_in">arguments</span>.length; index++) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextSource = <span class="built_in">arguments</span>[index];</span><br><span class="line">        <span class="keyword">if</span> (nextSource != <span class="literal">null</span>) &#123;  <span class="comment">// Attention 2</span></span><br><span class="line">          <span class="comment">// Attention 4</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> nextKey <span class="keyword">in</span> nextSource) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123;</span><br><span class="line">              to[nextKey] = nextSource[nextKey];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、深拷贝实现"><a href="#5、深拷贝实现" class="headerlink" title="5、深拷贝实现"></a>5、深拷贝实现</h4><ul><li><p>JSON.stringify：将对象转成JSON字符串，JSON.parse再将字符串解析成对象，产生新的对象</p><ul><li>可处理数组、对象                                     √</li><li>函数（得到null）、正则（得到空对象）  ×</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify())</span><br></pre></td></tr></table></figure></li><li><p>函数库lodash的_.cloneDeep方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj2 = _.cloneDeep(obj1);</span><br></pre></td></tr></table></figure></li></ul><h4 id="6、手写深拷贝："><a href="#6、手写深拷贝：" class="headerlink" title="6、手写深拷贝："></a>6、手写深拷贝：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 在克隆时遍历键时，不再用for in循环，因为它的效率不如while&gt;for&gt;for in</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> length = array.length;</span><br><span class="line">      <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">          iteratee(array[index], index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray(target);</span><br><span class="line">          <span class="keyword">let</span> cloneTarget = isArray ? [] : &#123;&#125;;</span><br><span class="line">          <span class="keyword">if</span> (map.get(target)) &#123;          <span class="comment">// 克隆前检查是否存在</span></span><br><span class="line">              <span class="keyword">return</span> map.get(target);</span><br><span class="line">          &#125;</span><br><span class="line">          map.set(target, cloneTarget);   <span class="comment">// 添加本次克隆</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 1. 对于数组、对象获取索引的方式不同</span></span><br><span class="line">          <span class="keyword">const</span> keys = isArray ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">      <span class="comment">// 2.若是对象，keys有值，forEach函数遍历的是键形成的数组，从而得到对象的属性</span></span><br><span class="line">      <span class="comment">//   若是数组，即传入的是target， forEach函数遍历的是数组本身，得到索引</span></span><br><span class="line">          forEach(keys || target, <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 处理对象的情况</span></span><br><span class="line">              <span class="keyword">if</span> (keys)  key = value;</span><br><span class="line">            <span class="comment">// 拷贝</span></span><br><span class="line">              cloneTarget[key] = clone(target[key], map);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> cloneTarget;   <span class="comment">// 容易遗漏！！</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- setTimeout、setInterval</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-setTimeout%E3%80%81setInterval/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-setTimeout%E3%80%81setInterval/</url>
      
        <content type="html"><![CDATA[<h3 id="setTimeout-setInterval"><a href="#setTimeout-setInterval" class="headerlink" title="setTimeout / setInterval"></a>setTimeout / setInterval</h3><h4 id="1、setTimeout"><a href="#1、setTimeout" class="headerlink" title="1、setTimeout"></a>1、setTimeout</h4><h5 id="1、使用规则："><a href="#1、使用规则：" class="headerlink" title="1、使用规则："></a>1、使用规则：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutID = scope.setTimeout(<span class="function"><span class="keyword">function</span>[, <span class="title">delay</span>, <span class="title">arg1</span>, <span class="title">arg2</span>, ...])</span>;</span><br><span class="line"><span class="keyword">var</span> timeoutID = scope.setTimeout(<span class="function"><span class="keyword">function</span>[, <span class="title">delay</span>])</span>;</span><br><span class="line"><span class="keyword">var</span> timeoutID = scope.setTimeout(code[, delay]);</span><br></pre></td></tr></table></figure><ul><li>delay：延迟的毫秒数，如果省略该参数，默认值0，意味着“马上”执行，或者尽快执</li><li><code>arg1, ..., argN</code> <strong>可选</strong>：附加参数，一旦定时器到期，它们会作为参数传递给<code>function</code></li><li>code：可选语法，可以使用字符串而不是函数，但不推荐</li><li>返回值：<code>timeoutID</code>是一个正整数，表示定时器的编号。可以传递给<code>clearTimeout()</code>取消该定时器。</li></ul><h5 id="2、this问题："><a href="#2、this问题：" class="headerlink" title="2、this问题："></a>2、this问题：</h5><ul><li><p><code>setTimeout()</code>调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 <code>this</code> 在非严格模式会指向 <code>window</code> (或全局)对象，严格模式下为 undefined</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>];</span><br><span class="line">myArray.myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">sProperty</span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>.length &gt; <span class="number">0</span> ? <span class="built_in">this</span>[sProperty] : <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myArray.myMethod(); <span class="comment">// prints &quot;zero,one,two&quot;</span></span><br><span class="line">myArray.myMethod(<span class="number">1</span>); <span class="comment">// prints &quot;one&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(myArray.myMethod, <span class="number">1000</span>); <span class="comment">//  &quot;[object Window]&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(myArray.myMethod, <span class="number">1500</span>, <span class="string">&quot;1&quot;</span>); <span class="comment">//&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>解决方法1：用包装函数来设置<code>this</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;myArray.myMethod()&#125;, <span class="number">2000</span>); <span class="comment">//&quot;zero,one,two&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;myArray.myMethod(<span class="string">&#x27;1&#x27;</span>)&#125;, <span class="number">2500</span>); <span class="comment">// &quot;one&quot; </span></span><br></pre></td></tr></table></figure></li><li><p>解决方法2：箭头函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;myArray.myMethod()&#125;, <span class="number">2000</span>); <span class="comment">//&quot;zero,one,two&quot; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;myArray.myMethod(<span class="string">&#x27;1&#x27;</span>)&#125;, <span class="number">2500</span>); <span class="comment">// &quot;one&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>解决方法3：bind显式地指定函数调用时 this 所指向的值 。解决 this 指向不确定的问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [<span class="string">&#x27;zero&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>];</span><br><span class="line">myBoundMethod = (<span class="function"><span class="keyword">function</span> (<span class="params">sProperty</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length &gt; <span class="number">0</span> ? <span class="built_in">this</span>[sProperty] : <span class="built_in">this</span>);</span><br><span class="line">&#125;).bind(myArray);</span><br><span class="line"></span><br><span class="line">myBoundMethod(); <span class="comment">// &quot;zero,one,two&quot;</span></span><br><span class="line">myBoundMethod(<span class="number">1</span>); <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(myBoundMethod, <span class="number">1000</span>); <span class="comment">//  &quot;zero,one,two&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(myBoundMethod, <span class="number">1500</span>, <span class="string">&quot;1&quot;</span>); <span class="comment">//&quot;one&quot; </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、setInterval"><a href="#2、setInterval" class="headerlink" title="2、setInterval"></a>2、setInterval</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalID = scope.setInterval(func, delay, [arg1, arg2, ...]);</span><br><span class="line"> <span class="comment">// func:该函数不接受任何参数，也没有返回值。</span></span><br><span class="line"> <span class="comment">// [..arg1, arg2,...] 当定时器过期的时候，将被传递给func指定函数的附加参数</span></span><br><span class="line"><span class="keyword">var</span> intervalID = scope.setInterval(code, delay);</span><br><span class="line"><span class="keyword">var</span> intervalID = <span class="built_in">setInterval</span>(myCallback, <span class="number">500</span>, <span class="string">&#x27;Parameter 1&#x27;</span>, <span class="string">&#x27;Parameter2&#x27;</span>);</span><br></pre></td></tr></table></figure><p>【注意】：</p><ol><li><p>func函数不能传参：如果需要传递参数,可以使用闭包返回一个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(test,<span class="number">1000</span>);    <span class="comment">// 正常 每秒打印1次</span></span><br><span class="line"><span class="built_in">setInterval</span>(test(),<span class="number">1000</span>);   <span class="comment">// test已经同步调用，只会打印一次1</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;test()&quot;</span>,<span class="number">1000</span>);  <span class="comment">//每秒打印1次，</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;  <span class="built_in">console</span>.log(<span class="number">1</span>)   &#125;</span><br></pre></td></tr></table></figure></li><li><p>需要使用<code>clearInterval</code>清除定时器,防止定时器一直执行下去,同时也需要手动释放内存</p></li><li><p><code>this</code>指向问题</p></li></ol><h4 id="3、setTimeout模拟setInterval"><a href="#3、setTimeout模拟setInterval" class="headerlink" title="3、setTimeout模拟setInterval"></a>3、setTimeout模拟setInterval</h4><h5 id="setInterval的执行机制"><a href="#setInterval的执行机制" class="headerlink" title="setInterval的执行机制"></a>setInterval的执行机制</h5><ul><li><code>setTimeout</code> 会将当前异步任务推入队列（<code>setTimeout</code>本身就是一次调用一次执行），而 <code>setInterval</code> 则会在任务<strong>推入异步队列时判断上次异步任务是否被执行。</strong></li><li>这就导致 <code>setInterval</code> 在做<strong>定时轮训时，出现耗时操作，或者调用的异步操作耗时</strong>会导致异步任务<strong>不按照期待的时间间隔</strong>执行。</li></ul><h5 id="版本1：无法清除啊，停不下来"><a href="#版本1：无法清除啊，停不下来" class="headerlink" title="版本1：无法清除啊，停不下来"></a>版本1：无法清除啊，停不下来</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySetInterval = <span class="function">(<span class="params">func, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行原本逻辑func</span></span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="版本2：保存id来清除"><a href="#版本2：保存id来清除" class="headerlink" title="版本2：保存id来清除"></a>版本2：保存id来清除</h5><ul><li>执行 <code>mySetInterval</code> 的时候返回的 <code>id</code> 依然不是最新的 <code>timeId</code>。因为 <code>timeId</code> 只在 <code>fn</code> 内部被更新了，在外部并不知道它的更新,注意内层、外层的也有清除</li><li>由于 <code>timeId</code> 是<code>Number</code>类型，这样使用拿到的是<strong>全局变量 <code>timeId</code> 的值拷贝而不是引用</strong>，</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySetInterval = <span class="function">(<span class="params">func, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timeId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行原本逻辑func</span></span><br><span class="line">    func();</span><br><span class="line">    timeId = <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">  &#125;</span><br><span class="line">  timeId = <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">  <span class="keyword">return</span> timeId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="版本3：闭包"><a href="#版本3：闭包" class="headerlink" title="版本3：闭包"></a>版本3：闭包</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySetInterval = <span class="function">(<span class="params">func, delay, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    func(...args);</span><br><span class="line">    timeId = <span class="built_in">setTimeout</span>(interval, delay,...args);</span><br><span class="line">  &#125;</span><br><span class="line">  timeId = <span class="built_in">setTimeout</span>(interval, delay, ...args);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">cancel</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a=mySetInterval(<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...args);</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b=mySetInterval(<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...args);</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- this指向问题</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>一句话总结：**<code>this</code>指向的是函数运行时的所在的环境对象**，它的绑定机制，就是要找到这个函数的直接调用位置，然后应用绑定的四条规则，当出现满足多个规则时，按照优先级的高低决定最终的绑定规则</p><h4 id="new-gt-显式绑定-gt-隐式绑定-gt-默认绑定"><a href="#new-gt-显式绑定-gt-隐式绑定-gt-默认绑定" class="headerlink" title="new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定"></a>new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</h4><h4 id="1、new-绑定"><a href="#1、new-绑定" class="headerlink" title="1、new 绑定"></a>1、<code>new</code> 绑定</h4><ul><li>new操作符创建的新对象</li></ul><h4 id="2、显式绑定"><a href="#2、显式绑定" class="headerlink" title="2、显式绑定"></a>2、显式绑定</h4><p>当想绑定指定的对象，用call/apply/bind：null、undefined时为window，否则是调用他们的那个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    foo.call(obj1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(bar, <span class="number">100</span>); <span class="comment">//2  3</span></span><br><span class="line">bar.call(obj2); <span class="comment">//4 3 </span></span><br></pre></td></tr></table></figure><ul><li>虽然<code>bar</code>被显示绑定到<code>obj2</code>上，对于<code>bar</code>，<code>function()&#123;…&#125;</code> 中的<code>this</code>确实被绑定到了<code>obj2</code></li><li>而<code>foo</code>因为通过<code>foo.call(obj1)</code>已经显示绑定了<code>obj1</code>，所以在<code>foo</code>函数内，<code>this</code>指向的是<code>obj1</code>，不会因为<code>bar</code>函数内指向<code>obj2</code>而改变自身。所以打印的是<code>obj1.a</code>（即3）。</li></ul><h4 id="3、隐式绑定"><a href="#3、隐式绑定" class="headerlink" title="3、隐式绑定"></a>3、隐式绑定</h4><p>函数的调用是在某个对象上触发的，指向这个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisTo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>:thisTo <span class="comment">//通过属性引用this所在函数 </span></span><br><span class="line">&#125;;</span><br><span class="line">data.foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="4、默认绑定"><a href="#4、默认绑定" class="headerlink" title="4、默认绑定"></a>4、默认绑定</h4><p>将全局对象绑定 <code>this</code> 上</p><ul><li>全局函数调用、变量访问：指向window，严格模式undefined</li></ul><h4 id="5、this绑定的特殊情况"><a href="#5、this绑定的特殊情况" class="headerlink" title="5、this绑定的特殊情况"></a>5、this绑定的特殊情况</h4><h5 id="1-隐式丢失"><a href="#1-隐式丢失" class="headerlink" title="1. 隐式丢失"></a>1. 隐式丢失</h5><p>当进行隐式绑定时，<strong>如果进行一次引用赋值或者传参操作，会造成this的丢失</strong>，从而最后将this绑定到全局对象中去。</p><ul><li><p>引用赋值丢失</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisTo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>:thisTo <span class="comment">//通过属性引用this所在函数 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;<span class="comment">//全局属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar=obj.foo; <span class="comment">//这里进行了一次引用赋值 </span></span><br><span class="line">bar(); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2种写法一样的结果</span></span><br><span class="line"><span class="keyword">var</span> bar;</span><br><span class="line">(bar=obj.foo)();</span><br></pre></td></tr></table></figure><p>因为bar实际上引用的是foo函数本身，跟obj对象没有任何关系,obj对象只是一个中间桥梁。而bar就是一个本身不带a属性的对象，自然最后只能把a绑定到全局对象上了</p></li><li><p>函数传参丢失</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisTo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>:thisTo <span class="comment">//通过属性引用this所在函数 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;<span class="comment">//全局属性</span></span><br><span class="line"><span class="built_in">setTimeout</span>(data.foo,<span class="number">100</span>);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>setTimeout(fn,delay) { fn(); } 实际上fn是一个参数传递的引用(fn=data.foo)，与引用丢失原理一样</p></li></ul><p>bind：<strong>为了解决隐式丢失的问题，ES5提供了bind方法，把参数设置为this的上下文并调用原始函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisTo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> bar=thisTo.bind(data);</span><br><span class="line"><span class="built_in">console</span>.log(bar()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h5 id="2-间接引用"><a href="#2-间接引用" class="headerlink" title="2. 间接引用"></a>2. 间接引用</h5><p>一个定义对象的方法引用另一个对象存在的方法，这种情况下会使得this进行默认绑定</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisTo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>:thisTo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newData=&#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">4</span>;</span><br><span class="line">data.foo(); <span class="comment">//2</span></span><br><span class="line">(newData.foo=data.foo)() <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>newData.foo=data.foo的返回值是目标函数的引用，因此调用的位置实际上是foo(),根据之前的隐式丢失里面说的原则，这里会应用默认绑定</p><h4 id="6、改变this的方法"><a href="#6、改变this的方法" class="headerlink" title="6、改变this的方法"></a>6、改变this的方法</h4><ul><li>call/bind/apply改变this指向</li><li>通过对象的方法来定义一个函数：this指向实例化对象</li><li>new：构造函数被new了，创建了新对象，构造函数内部的this会指向该</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 箭头函数</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="1、箭头函数与普通函数的区别"><a href="#1、箭头函数与普通函数的区别" class="headerlink" title="1、箭头函数与普通函数的区别"></a>1、箭头函数与普通函数的区别</h4><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li><p>参数处理更自由，函数体的返回值只有一句，可以省略大括号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br></pre></td></tr></table></figure></li></ul><p><strong>（2）箭头函数没有自己的this</strong></p><ul><li>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。</li><li>所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</li></ul><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.a();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.b();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br><span class="line"><span class="keyword">new</span> obj.a()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> obj.b()  <span class="comment">// Uncaught TypeError: obj.b is not a constructor</span></span><br></pre></td></tr></table></figure><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> fun1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;;</span><br><span class="line">fun1();                     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.call(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.apply(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);    <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.bind(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;)();   <span class="comment">// &#x27;Global&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><ul><li>构造函数在new的步骤第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</li></ul><p><strong>（6）箭头函数没有自己的arguments</strong></p><ul><li>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</li></ul><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h4 id="2、箭头函数的this指向"><a href="#2、箭头函数的this指向" class="headerlink" title="2、箭头函数的this指向"></a>2、箭头函数的this指向</h4><ul><li><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值</p></li><li><p>由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 柯里化</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="柯里化-√"><a href="#柯里化-√" class="headerlink" title="柯里化 √"></a>柯里化 √</h3><ul><li>概念：把接收带多个参数的函数转换成接收单个参数的函数，并且返回一个新函数，这个函数会接收余下的参数，并将结果返回</li></ul><h4 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h4><ul><li><p>将所有传入的参数收集起来，再最后通过reduce函数，统一进行累加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addCurry = <span class="function">(<span class="params">...args1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> args = args1;</span><br><span class="line">  <span class="keyword">const</span> newFunc = <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//其实每次柯里化的参数都被收集在args里面了。</span></span><br><span class="line">    args = [...args, ...args2]; <span class="comment">//注意这里是args，不是args1</span></span><br><span class="line">    <span class="keyword">return</span> newFunc;<span class="comment">//这里要返回函数，以便能继续传参</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//在传参够了后，再调用这个方法进行累加</span></span><br><span class="line">  newFunc.getResult = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, curv</span>) =&gt;</span> prev+curv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addCurry(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>).getResult())<span class="comment">//12</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="版本2："><a href="#版本2：" class="headerlink" title="版本2："></a>版本2：</h4><ul><li><p>用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addCurry = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt;= fn.length) <span class="keyword">return</span> fn(...args);</span><br><span class="line">     <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> currying(fn, ...args, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a+b;</span><br><span class="line">  <span class="keyword">const</span> curryingFun = currying(fun)</span><br><span class="line">  curryingFun(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);  <span class="comment">// 1 2 3 </span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- call、apply、bind</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-call%E3%80%81apply%E3%80%81bind/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-call%E3%80%81apply%E3%80%81bind/</url>
      
        <content type="html"><![CDATA[<h3 id="call、apply、bind-√"><a href="#call、apply、bind-√" class="headerlink" title="call、apply、bind √"></a>call、apply、bind √</h3><h4 id="1、使用上"><a href="#1、使用上" class="headerlink" title="1、使用上"></a>1、使用上</h4><ul><li><p>传参</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数列表， call与apply的区别就是传参形式不同</span></span><br><span class="line">fun.call(thisArg, param1, param2, ...)</span><br><span class="line">fun.bind(thisArg, param1, param2, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2个参数必须是数组</span></span><br><span class="line">fun.apply(thisArg, [param1,param2,...])</span><br></pre></td></tr></table></figure></li><li><p>返回值</p><p>call/apply：<code>fun</code>执行的结果，改变this上下文后马上执行该函数</p><p>bind：返回<code>fun</code>的拷贝，不执行函数，并指定了fun的this指向，保存了fun的参数</p></li><li><p><code>thisArg</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thisArg的值为null/undefined时，非严格模式下，fun中的this指向window对象，严格模式下，fun的this值为undefined</span><br><span class="line">thisArg的值为原始值时，fun的this指向该原始值的包装对象，如 String、Number、Boolean</span><br></pre></td></tr></table></figure></li><li><p>这3个方法的调用者必须是函数，它们是挂载在Function对象上的3个方法，只有函数才有这些方法</p></li></ul><h4 id="2、功能上"><a href="#2、功能上" class="headerlink" title="2、功能上"></a>2、功能上</h4><ul><li>改变函数执行时的this指向</li><li>带来的好处：可以将任意对象设置为任意函数的作用域，这样对象就不用关心方法，而是<strong>借用方法</strong></li></ul><h4 id="3、apply-call的应用场景："><a href="#3、apply-call的应用场景：" class="headerlink" title="3、apply/call的应用场景："></a>3、apply/call的应用场景：</h4><h5 id="1、判断数据类型"><a href="#1、判断数据类型" class="headerlink" title="1、判断数据类型"></a>1、判断数据类型</h5><p>为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，传递要检查的对象作为第一个参数，称为 <code>thisArg</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure><h5 id="2、类数组借用数组的方法"><a href="#2、类数组借用数组的方法" class="headerlink" title="2、类数组借用数组的方法"></a>2、类数组借用数组的方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;OB&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;Koro1&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(arrayLike, <span class="string">&#x27;添加元素1&#x27;</span>, <span class="string">&#x27;添加元素2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrayLike)</span><br><span class="line"><span class="comment">//&#123;&quot;0&quot;:&quot;OB&quot;,&quot;1&quot;:&quot;Koro1&quot;,&quot;2&quot;:&quot;添加元素1&quot;,&quot;3&quot;:&quot;添加元素2&quot;,&quot;length&quot;:4&#125;</span></span><br></pre></td></tr></table></figure><h5 id="3、apply获取数组最大值最小值"><a href="#3、apply获取数组最大值最小值" class="headerlink" title="3、apply获取数组最大值最小值"></a>3、apply获取数组最大值最小值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [15, 6, 12, 13, 16];</span><br><span class="line">const max = Math.max.apply(Math, arr); // 16</span><br><span class="line">const min = Math.min.apply(Math, arr); // 6</span><br></pre></td></tr></table></figure><h5 id="4、继承"><a href="#4、继承" class="headerlink" title="4、继承"></a>4、继承</h5><p>在子类构造函数中，通过<code>apply/call</code>借用父类构造函数中的属性，并可传参</p><h4 id="4、bind的应用场景"><a href="#4、bind的应用场景" class="headerlink" title="4、bind的应用场景"></a>4、bind的应用场景</h4><h5 id="1、保存函数参数"><a href="#1、保存函数参数" class="headerlink" title="1、保存函数参数"></a>1、保存函数参数</h5><p>原理：bind会返回一个函数，它保存了函数的this指向、初始参数，所以每次i的变量会被bind保存</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;.bind(<span class="literal">null</span>, i)，i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、绑定this指向，用做回调函数，解决回调函数this丢失问题"><a href="#2、绑定this指向，用做回调函数，解决回调函数this丢失问题" class="headerlink" title="2、绑定this指向，用做回调函数，解决回调函数this丢失问题"></a>2、绑定this指向，用做回调函数，解决回调函数this丢失问题</h5><h4 id="5、手写call"><a href="#5、手写call" class="headerlink" title="5、手写call"></a>5、手写call</h4><ul><li>获取方法的调用者，通过this拿到，因为函数myCall内部的this指向的是调用者</li><li>其次，拿到谁调用这个函数，其实就是传参的第一个，也就是context上下文</li><li>为上下文context添加这个属性，属性值就是这个函数，让其具备该函数的功能，使用该功能</li><li>使用完，删除该属性，不能改变其上下文</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span> <span class="comment">// 指定为 null/undefined时this指向全局对象(浏览器中为window)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//1.Object():将值为原始值（数字字符串布尔值）包装成对象</span></span><br><span class="line">      context = <span class="built_in">Object</span>(context)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> testFn = <span class="built_in">Symbol</span>();  <span class="comment">// 保证属性不会出现同名覆盖的情况</span></span><br><span class="line">  context.testFn = <span class="built_in">this</span>;  <span class="comment">//添加属性this, this就是调用call的那个函数</span></span><br><span class="line">  <span class="keyword">let</span> result = context.testFn(...arr); </span><br><span class="line">  <span class="keyword">delete</span> context.testFn;  <span class="comment">// 删除上下文对象的属性</span></span><br><span class="line">  <span class="comment">// 若不删除，result：[ 12, 8, 4, 6, 7, testFn: [Function: push] ]</span></span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">12</span>,<span class="number">8</span>]，;<span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.myCall(arr1,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">// [ 12, 8, 4, 6, 7 ]</span></span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断函数上下文绑定到`window`不够严谨</span></span><br><span class="line">context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">context = context || <span class="built_in">window</span>; </span><br><span class="line"><span class="comment">// 会导致：本应该绑定到原始值的实例对象上，却绑到window上</span></span><br><span class="line">handle.elseCall(<span class="string">&#x27;&#x27;</span>) <span class="comment">// window  </span></span><br><span class="line">handle.elseCall(<span class="number">0</span>) <span class="comment">// window</span></span><br><span class="line">handle.elseCall(<span class="literal">false</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure><h4 id="6、手写Apply"><a href="#6、手写Apply" class="headerlink" title="6、手写Apply"></a>6、手写Apply</h4><ul><li>与call大致相同，但参数形式不一样；增加了类数组的判断</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      context = <span class="built_in">window</span> </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      context = <span class="built_in">Object</span>(context) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// JavaScript权威指南判断是否为类数组对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (o &amp;&amp;                                    <span class="comment">// o不是null、undefined等</span></span><br><span class="line">          <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp;                <span class="comment">// o是对象</span></span><br><span class="line">          <span class="built_in">isFinite</span>(o.length) &amp;&amp;                   <span class="comment">// o.length是有限数值</span></span><br><span class="line">          o.length &gt;= <span class="number">0</span> &amp;&amp;                        <span class="comment">// o.length为非负值</span></span><br><span class="line">          o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;    <span class="comment">// o.length是整数</span></span><br><span class="line">          o.length &lt; <span class="number">4294967296</span>)                  <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  context.testFn = <span class="built_in">this</span>; <span class="comment">// 隐式绑定this指向到context上</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>]; <span class="comment">// 获取参数数组</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="comment">// 处理传进来的第二个参数</span></span><br><span class="line">  <span class="keyword">if</span> (args) &#123;</span><br><span class="line">      <span class="comment">// 是否传递第二个参数</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(args) &amp;&amp; !isArrayLike(args)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;myApply 第二个参数不为数组并且不为类数组对象抛出错误&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          args = <span class="built_in">Array</span>.from(args) <span class="comment">// 转为数组</span></span><br><span class="line">          result = context.testFn(...args); <span class="comment">// 执行函数并展开数组，传递函数参数，注意要展开</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = context.testFn(); <span class="comment">// 执行函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.testFn; <span class="comment">// 删除上下文对象的属性</span></span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、手写bind："><a href="#7、手写bind：" class="headerlink" title="7、手写bind："></a>7、手写bind：</h4><ul><li><p>bind() 方法会创建一个新函数。当这个新函数被调用时，<strong>bind() 的第一个参数将作为它运行时的 this</strong>，之后的一序列参数将会在传递的实参前传入作为它的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context,...args1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> _this = <span class="built_in">this</span>   <span class="comment">// _this就是bind函数的调用者</span></span><br><span class="line">  <span class="comment">// bind函数的调用后，返回一个新函数,既可以new，也可以直接调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否用于构造函数</span></span><br><span class="line">    <span class="comment">// this是F的调用者，当它是普通调用时this指向函数调用者，</span></span><br><span class="line">    <span class="comment">// 做构造函数时指向那个实例对象 context</span></span><br><span class="line">    context = <span class="built_in">this</span> <span class="keyword">instanceof</span> F? <span class="built_in">this</span>: <span class="built_in">Object</span>(context);</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args1.concat(args2))</span><br><span class="line">  &#125;</span><br><span class="line">  F.prototype = <span class="built_in">Object</span>.create(_this.prototype) <span class="comment">//弄个中间值</span></span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">&#x27;v in window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">value</span>: <span class="string">&#x27;v in obj&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFunc = func.bind(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">newFunc(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>); </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 节流、防抖</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-%E8%8A%82%E6%B5%81%E3%80%81%E9%98%B2%E6%8A%96/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-%E8%8A%82%E6%B5%81%E3%80%81%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><h4 id="1、防抖"><a href="#1、防抖" class="headerlink" title="1、防抖"></a>1、防抖</h4><ul><li><p>单位时间n秒内，操作很多次，命中最后一次。会无限的延迟，不断刷新定时器的一个东西</p></li><li><p>应用场景： </p><ul><li>窗口大小变化，调整样式</li><li>搜索框，输入后1000毫秒搜索</li><li>表单验证，输入1000毫秒后验证</li></ul></li></ul><h5 id="1、基本实现："><a href="#1、基本实现：" class="headerlink" title="1、基本实现："></a>1、基本实现：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn 是需要防抖处理的函数,wait 是时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;    <span class="comment">//  let还是var都没有关系，为什么呢？？？</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;透传的参数&#x27;</span>, ...args, <span class="built_in">this</span>); <span class="comment">// 123  document</span></span><br><span class="line">    </span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)  <span class="comment">// 清除定时器，重新设置定时器</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//注意这个箭头函数的this指向的是闭包函数的调用者，而不是debounce的调用者</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;timer&#x27;</span>,<span class="built_in">this</span>);  <span class="comment">// document，疯狂点击后，最后一次才执行1</span></span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args)  </span><br><span class="line">      &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;执行了防抖函数&#x27;</span>, <span class="built_in">this</span>) <span class="comment">// document，疯狂点击后，最后一次才执行1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> betterFn = debounce(test, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, betterFn(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><ul><li>在<code>debounce</code>函数中返回一个闭包，这里用的普通<code>function</code>，里面的<code>setTimeout</code>则用的箭头函数，这样做的意义是让<code>this</code>的指向准确，<code>this</code>的真实指向并非<code>debounce</code>的调用者，而是返回闭包的调用者。<strong>对传入闭包的参数进行透传。</strong></li></ul><h5 id="2、加标志位，触发第一次"><a href="#2、加标志位，触发第一次" class="headerlink" title="2、加标志位，触发第一次"></a>2、加标志位，触发第一次</h5><ul><li><p>有时候需要<strong>让函数立即执行一次，再等后面事件触发后等待<code>n</code>秒执行</strong>，给<code>debounce</code>函数一个<code>flag</code>用于标示是否立即执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait = <span class="number">50</span>, flag</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer) </span><br><span class="line">    <span class="comment">// 当定时器变量timer为空时，说明是第一次执行，我们立即执行它</span></span><br><span class="line">    <span class="keyword">if</span> (!timer &amp;&amp; flag)&#123;</span><br><span class="line">    fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args)  </span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、节流"><a href="#2、节流" class="headerlink" title="2、节流"></a>2、节流</h4><ul><li><p>连续触发事件，n秒内只执行1次函数并一定会执行1次，需要设置标识位，看能不能触发事件</p></li><li><p>应用场景：</p><ul><li>onresize、mousemove、滚动事件等事件中使用，防止过多的请求造成服务器压力</li></ul></li></ul><h5 id="1、定时器版本"><a href="#1、定时器版本" class="headerlink" title="1、定时器版本"></a>1、定时器版本</h5><p>第一次事件不会触发，最后一次一定触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait</span>) </span>&#123;            </span><br><span class="line">      <span class="keyword">var</span> timer = <span class="literal">null</span>;            </span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;                 </span><br><span class="line">          <span class="keyword">if</span> (!timer) &#123;                    </span><br><span class="line">              timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">                  timer = <span class="literal">null</span>;  </span><br><span class="line">                  func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">              &#125;, wait);             </span><br><span class="line">          &#125;            </span><br><span class="line">      &#125;        </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="2、时间戳版本"><a href="#2、时间戳版本" class="headerlink" title="2、时间戳版本"></a>2、时间戳版本</h5><p>第一次事件肯定触发，最后一次不会触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">      <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">Date</span>.now() - previous &gt; wait) &#123;</span><br><span class="line">          previous = <span class="built_in">Date</span>.now();</span><br><span class="line">          fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> betterFn = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fn 函数执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">setInterval</span>(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h5 id="3、定时器和时间戳的结合版"><a href="#3、定时器和时间戳的结合版" class="headerlink" title="3、定时器和时间戳的结合版"></a>3、定时器和时间戳的结合版</h5><ul><li><p>也相当于节流和防抖的结合版，第一次和最后一次都会触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Date</span>.now() - previous &gt; time) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">      previous = <span class="built_in">Date</span>.now();</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 作用域、作用域链</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="作用域、作用域链"><a href="#作用域、作用域链" class="headerlink" title="作用域、作用域链"></a>作用域、作用域链</h3><h4 id="1、全局作用域："><a href="#1、全局作用域：" class="headerlink" title="1、全局作用域："></a>1、全局作用域：</h4><ul><li>直接编写在script标签中的JS代码，都在全局作用域</li><li>全局作用域在页面打开时创建，在页面关闭时销毁</li><li>在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用</li><li>在全局作用域中：创建的变量都会作为window对象的属性保存；创建的函数都会作为window对象的方法保存</li><li>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到</li></ul><h4 id="2、函数作用域："><a href="#2、函数作用域：" class="headerlink" title="2、函数作用域："></a>2、函数作用域：</h4><ul><li><p>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</p></li><li><p>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的</p></li><li><p>在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量</p></li><li><p>当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用；</p><p>如果没有则向上一级作用域中寻找，直到找到全局作用域；</p><p>如果全局作用域中依然没有找到，则会报错ReferenceError</p></li><li><p><strong>【注意大坑】：</strong></p><ol><li><p><strong>使用var关键字声明的变量或函数声明，会在函数中所有的代码执行之前被声明</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在函数中，不适用var声明的变量都会成为全局变量</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;cc&#x27;</span>+c); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">45</span>;</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;cc&#x27;</span>+c); <span class="comment">// 123</span></span><br><span class="line">  c = <span class="number">45</span>;</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  d = <span class="number">123</span>;  <span class="comment">// 没有使用关键字声明，会weiwindow属性</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;dd&#x27;</span>+d); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义形参就相当于在函数作用域中声明了变量</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 相当于 var e;</span></span><br><span class="line">  alert(e);   <span class="comment">//值为undefined</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="3、块级作用域：ES6"><a href="#3、块级作用域：ES6" class="headerlink" title="3、块级作用域：ES6"></a>3、块级作用域：ES6</h4><ul><li><p>不合理性：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量    for循环定时器</li></ul></li><li><p>{}内的只能访问{}内的，不能跨块访问</p></li><li><p><strong>不用担心变量重名，也不用担心外界干扰</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 闭包</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-%E9%97%AD%E5%8C%85/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="2、闭包-√"><a href="#2、闭包-√" class="headerlink" title="2、闭包  √"></a>2、闭包  √</h3><h4 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h4><ul><li><p>概念：有权访问另一个函数作用域中的变量的函数；函数 <code>A</code> 内部有一个函数 <code>B</code>，函数 <code>B</code> 可以访问到函数 <code>A</code> 中的变量，那么函数 <code>B</code> 就是闭包</p></li><li><p>为什么可以访问：</p><p>在一个函数内部定义的函数会将其包含函数的活动对象添加到自己的作用域链中，所以闭包才可以去引用到外部的活动对象</p></li><li><p>优点：</p><ul><li>使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)</li><li>让函数外部可以操作(读写)到函数内部的数据(变量/函数)</li><li>可以<strong>把局部变量驻留在内存</strong>中,可以避免使用全局变量，<strong>JS不推荐使用全局变量</strong></li><li>可以在一个函数中再创建个函数，避免了传参的问题</li></ul></li><li><p>缺点：</p><ul><li>内存过度占用</li></ul></li><li><p>可以赋值为null，解除引用；也可以func()();这样使其成为一个立即执行函数，函数中执行完，变量销毁</p></li></ul><h4 id="2、应用场景："><a href="#2、应用场景：" class="headerlink" title="2、应用场景："></a>2、应用场景：</h4><ul><li>在异步任务例如 <code>timer</code> 定时器，事件回调函数处理，<code>Ajax</code> 请求中被作为回调</li><li>防抖、节流、柯里化、bind、立即执行函数</li><li>模块化：<ul><li>具有特定功能的js文件，将所有的数据和功能都封装在一个函数内部(私有的)，</li><li>只向外暴露一个包信n个方法的对象或函数</li><li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</li></ul></li></ul><h4 id="4、常见的闭包："><a href="#4、常见的闭包：" class="headerlink" title="4、常见的闭包："></a>4、常见的闭包：</h4><h5 id="①-将函数作为另一个函数的返回值"><a href="#①-将函数作为另一个函数的返回值" class="headerlink" title="① 将函数作为另一个函数的返回值"></a>① 将函数作为另一个函数的返回值</h5><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 1. 将函数作为另一个函数的返回值</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;a++</span><br><span class="line">&gt;<span class="built_in">console</span>.log(a)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> fn2</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> f = fn1()</span><br><span class="line">&gt;f() <span class="comment">// 3</span></span><br><span class="line">&gt;f() <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="②-将函数作为实参传递给另一个函数调用"><a href="#②-将函数作为实参传递给另一个函数调用" class="headerlink" title="② 将函数作为实参传递给另一个函数调用"></a>② 将函数作为实参传递给另一个函数调用</h5><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 2. 将函数作为实参传递给另一个函数调用</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">showDelay</span>(<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(msg)</span><br><span class="line">&gt;&#125;, time)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;showDelay(<span class="string">&#x27;atguigu&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></blockquote><h5 id="③-高阶函数与柯里化"><a href="#③-高阶函数与柯里化" class="headerlink" title="③ 高阶函数与柯里化"></a>③ 高阶函数与柯里化</h5><h4 id="5、经典的题："><a href="#5、经典的题：" class="headerlink" title="5、经典的题："></a>5、经典的题：</h4><ul><li><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用闭包：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            btnDom.innerHTML = dp[j]; <span class="comment">// dp是斐波那契数列</span></span><br><span class="line">        &#125;, j*<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fn(i)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用闭包：立即执行函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          btnDom.innerHTML = dp[j];</span><br><span class="line">      &#125;, j*<span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用let</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    btnDom.innerHTML = dp[i];</span><br><span class="line">  &#125;, i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="点击异步回调函数"><a href="#点击异步回调函数" class="headerlink" title="点击异步回调函数"></a>点击异步回调函数</h4></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> op = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; op.length; j++) &#123;</span><br><span class="line">  op[j].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(j);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决1：利用闭包：立即执行函数"><a href="#解决1：利用闭包：立即执行函数" class="headerlink" title="解决1：利用闭包：立即执行函数"></a>解决1：利用闭包：立即执行函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; op.length; j++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    op[j].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决2：闭包"><a href="#解决2：闭包" class="headerlink" title="解决2：闭包"></a>解决2：闭包</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; op.length; j++) &#123;</span><br><span class="line">  op[j].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决3：闭包"><a href="#解决3：闭包" class="headerlink" title="解决3：闭包"></a>解决3：闭包</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; op.length; j++) &#123;</span><br><span class="line">  op[j].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = j;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><h4 id="IIFE-自调用函数"><a href="#IIFE-自调用函数" class="headerlink" title="IIFE (自调用函数)"></a>IIFE (自调用函数)</h4><blockquote><ol><li><p>全称: <code>Immediately-Invoked Function Expression</code> 自调用函数</p></li><li><p>作用:</p></li></ol><ul><li>隐藏实现</li><li>不会污染外部(一般指全局)命名空间</li><li>用它来编码js模块</li></ul><ol start="3"><li>代码示例</li></ol>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//匿名函数自调用</span></span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">   <span class="built_in">console</span>.log(a + <span class="number">3</span>)</span><br><span class="line"> &#125;)()</span><br><span class="line"> <span class="built_in">console</span>.log(a) <span class="comment">// a is not defined</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//此处前方为何要一个`;`--&gt;因为自调用函数外部有一个()包裹,可能与前方以()结尾的代码被一起认为是函数调用</span></span><br><span class="line"> <span class="comment">//不加分号可能会被认为这样 console.log(a)(IIFE)</span></span><br><span class="line"> ;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//不会污染外部(全局)命名空间--&gt;举例</span></span><br><span class="line">   <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(++a) &#125; <span class="comment">//声明一个局部函数test</span></span><br><span class="line">   <span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> &#123;<span class="attr">test</span>: test&#125; &#125;<span class="comment">// 向外暴露一个全局函数</span></span><br><span class="line"> &#125;)()</span><br><span class="line">test ()  <span class="comment">//test is not defined</span></span><br><span class="line"> $().test() <span class="comment">// 1. $是一个函数 2. $执行后返回的是一个对象</span></span><br></pre></td></tr></table></figure></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数-let、const、var</title>
      <link href="/2021/12/11/%E5%87%BD%E6%95%B0-let%E3%80%81const%E3%80%81var/"/>
      <url>/2021/12/11/%E5%87%BD%E6%95%B0-let%E3%80%81const%E3%80%81var/</url>
      
        <content type="html"><![CDATA[<h3 id="let、var、const"><a href="#let、var、const" class="headerlink" title="let、var、const"></a>let、var、const</h3><h4 id="1、var"><a href="#1、var" class="headerlink" title="1、var"></a>1、var</h4><ul><li><p><strong>有变量提升：</strong>变量可以在声明之前使用，值为undefined，没有暂时性死区</p></li><li><p><strong>作用域：</strong>没有块级作用域的概念，可以顺着作用域链查找。</p></li><li><p><strong>声明的时候：</strong></p><ul><li>可重复申明，不会报错</li><li>申明变量时，<strong>不用对其赋值</strong></li><li>声明的全局变量会挂在顶层对象下面（window、global）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，这样的设计缺点：</p><ol><li>没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的</li><li>程序员很容易不知不觉地就创建了全局变量（比如打字出错）；</li><li>顶层对象的属性是到处可以读写的，这非常不利于模块化编程。</li><li>另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</li></ol></li></ul><h4 id="2、Let"><a href="#2、Let" class="headerlink" title="2、Let"></a>2、Let</h4><ul><li><p><strong>变量不提升</strong>：变量不可以在声明之前使用，会报错reference error</p><p><strong>暂时性死区：</strong>只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><p>只要块级作用域内存在let、const命令，它声明的变量就“绑定”这个区域，从一开始就形成了封闭作用域不再受外部影响，即使外部有跟它同名的变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 报错 因为本区域有tmp声明变量</span></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// 绑定if这个块级的作用域 不能出现tmp变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>作用域：</strong>只在声明所在的块级作用域{}有效，与const相同</p></li><li><p><strong>声明的时候：</strong></p><ul><li>同一作用域不能对同一变量重复申明；</li><li>申明变量时，<strong>不用对其赋值</strong></li></ul></li><li><p><strong>let、const不会挂在顶层对象下面</strong></p><p>ES6 为了改变上述缺点，规定：</p><ol><li>为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；</li><li><code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;   全局变量<span class="string">`a`</span>由<span class="string">`var`</span>命令声明，所以它是顶层对象的属性；</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;  全局变量<span class="string">`b`</span>由<span class="string">`let`</span>命令声明，所以它不是顶层对象的属性，返回<span class="string">`undefined`</span>。</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined   </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、const"><a href="#3、const" class="headerlink" title="3、const"></a>3、const</h4><ul><li><p><strong>变量不提升</strong>：变量不可以在声明之前使用，会报错reference error</p><p><strong>暂时性死区：</strong>只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><p>只要块级作用域内存在let、const命令，它声明的变量就“绑定”这个区域，从一开始就形成了封闭作用域不再受外部影响，即使外部有跟它同名的变量</p></li><li><p><strong>作用域：</strong>只在声明所在的块级作用域有效，与let相同</p></li><li><p><strong>声明的时候：</strong></p><ul><li>同一作用域不能对同一变量重复申明；</li><li>申明变量时，<strong>必须对其赋值</strong></li></ul></li><li><p>let、const不会挂在顶层对象下面</p></li><li><p><strong>申明的变量赋值后不可更改</strong></p><ul><li><p>赋值为基本数据类型，就不能改值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">a = <span class="string">&#x27;string&#x27;</span> <span class="comment">//报错</span></span><br></pre></td></tr></table></figure></li><li><p>赋值为引用数据类型，变量是一个指针，指针指向不能改，永远指向堆中某个对象，但是这个对象本身能改，也就是说<strong>不能给这个变量赋值另一个对象</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(&#x27;Hello&#x27;); // 可执行</span><br><span class="line">a.length = 0;    // 可执行</span><br><span class="line">a = [&#x27;Dave&#x27;];    // 报错</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;  </span><br></pre></td></tr></table></figure><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的0.1+0.2</title>
      <link href="/2021/12/11/JS%E7%9A%840-1-0-2/"/>
      <url>/2021/12/11/JS%E7%9A%840-1-0-2/</url>
      
        <content type="html"><![CDATA[<h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2 !=0.3"></a>0.1+0.2 !=0.3</h3><ul><li><p>0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数</p></li><li><p>在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。保存格式如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cb225cf71d748a8b2d6a5615e402711~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 50%;" /><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul></li><li><p>所以双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><ul><li><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="number">10011.</span>..</span><br></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="number">2</span>^-<span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure><p><strong>指数位是负数，该如何保存</strong>呢？</p></li></ul></li><li><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1111111011</span> <span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure><h4 id="如何实现0-1-0-2-0-3呢？"><a href="#如何实现0-1-0-2-0-3呢？" class="headerlink" title="如何实现0.1+0.2=0.3呢？"></a>如何实现0.1+0.2=0.3呢？</h4><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberepsilon</span>(<span class="params">arg1,arg2</span>)</span>&#123;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(arg1 - arg2) &lt; <span class="built_in">Number</span>.EPSILON;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberepsilon(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的Symbol特性</title>
      <link href="/2021/12/10/JS%E7%9A%84Symbol%E7%89%B9%E6%80%A7/"/>
      <url>/2021/12/10/JS%E7%9A%84Symbol%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="4、补充Symbol"><a href="#4、补充Symbol" class="headerlink" title="4、补充Symbol"></a>4、补充Symbol</h3><ul><li><code>ES6</code>中新加入的一种原始类型，每个从Symbol()返回的symbol值都是唯一的。</li><li>一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的</li></ul><h4 id="特性1：独一无二"><a href="#特性1：独一无二" class="headerlink" title="特性1：独一无二"></a>特性1：独一无二</h4><ul><li>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();  <span class="comment">// Symbol() </span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;ConardLi&#x27;</span>&#125;); <span class="comment">// Symbol([object Object])</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 === sym3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</li></ul><blockquote><p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="特性2：原始类型"><a href="#特性2：原始类型" class="headerlink" title="特性2：原始类型"></a>特性2：原始类型</h4><p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="特性3：不可枚举"><a href="#特性3：不可枚举" class="headerlink" title="特性3：不可枚举"></a>特性3：不可枚举</h4><ul><li><p>使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性</p></li><li><p>调用<code>for...in</code>、<code>Object.getOwnPropertyNames、Object.keys()</code>不能获取<code>Symbol</code>属性</p></li><li><p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性，会变成一个数组集</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;ConardLi&#x27;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;name2&#x27;</span>)]:<span class="string">&#x27;code秘密花园&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// [&quot;name&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">// [&quot;name&quot;]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br></pre></td></tr></table></figure><h4 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h4><h5 id="1、应用一：防止XSS"><a href="#1、应用一：防止XSS" class="headerlink" title="1、应用一：防止XSS"></a>1、应用一：防止XSS</h5><ul><li><p>在React中，我们所写的JSX实际上是babel 解析时，调用React.createElement，转换成 <code>ReactElement</code>对象</p></li><li><p>这个对象里，有type、props、key、ref属性，还有一个<code>$$typeof</code>属性，就是在这个过程中添加的：它是一个<code>Symbol</code>类型的变量，值为变量 REACT_ELEMENT_TYPE</p><ul><li><p>如果当前浏览器支持 Symbol ，则 <code>REACT_ELEMENT_TYPE </code>为 Symbol 类型的变量，否则为 16 进制的数字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">&#x27;react.element&#x27;</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>React</code>渲染时会把没有<code>$$typeof</code>标识，以及规则校验不通过的组件过滤掉，通过<code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">&#x27;object&#x27;</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>**添加这个属性的意义： **           安全</p><p>基于以下几个共识：</p><ol><li>数据库是不能存储<code>Symbol</code>类型的变量，所以用户恶意存入的数据是无法带有合法的 <code>$$typeof</code>字段的</li><li>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="keyword">let</span> expectedTextButGotJSON = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">dangerouslySetInnerHTML</span>: &#123;</span><br><span class="line">      <span class="attr">__html</span>: <span class="string">&#x27;/* put your exploit here */&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> message = &#123; <span class="attr">text</span>: expectedTextButGotJSON &#125;;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#123;message.text&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2、应用二：私有属性"><a href="#2、应用二：私有属性" class="headerlink" title="2、应用二：私有属性"></a>2、<strong>应用二：私有属性</strong></h5><ul><li>借助<code>Symbol</code>类型的不可枚举，可以在类中模拟私有属性，控制变量读写</li><li><strong>因为通过 Symbol 作为属性名的属性，在常规的属性遍历和获取方法中，并不能够查询到</strong></li><li>在使用者不看内部代码的情况下，通过正常方法是无法获取和使用到这些属性的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> privateField = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[privateField] = <span class="string">&#x27;ConardLi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getField</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[privateField];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setField</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[privateField] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、应用三：防止属性污染"><a href="#3、应用三：防止属性污染" class="headerlink" title="3、应用三：防止属性污染"></a>3、应用三：防止属性污染</h5><ul><li>为对象添加一个属性，可能造成属性覆盖</li><li>用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。在手写call中有应用</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数据类型转换</title>
      <link href="/2021/12/10/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/12/10/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="3-1、类型转换1-基本"><a href="#3-1、类型转换1-基本" class="headerlink" title="3.1、类型转换1(基本)"></a>3.1、类型转换1(基本)</h3><ul><li>两种转换形式：<strong>显式类型转换</strong>和<strong>隐式类型转换</strong></li><li>三种转换结果：<strong>Number</strong> 、<strong>String</strong> 、<strong>Boolean</strong></li></ul><h4 id="3-1-1、转string"><a href="#3-1-1、转string" class="headerlink" title="3.1.1、转string"></a>3.1.1、转string</h4><h5 id="1、String-函数：强制转换"><a href="#1、String-函数：强制转换" class="headerlink" title="1、String()函数：强制转换"></a>1、String()函数：强制转换</h5><ul><li><strong>对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串；</strong></li><li><strong>对于null值，直接转换为字符串”null”。对于undefined直接转换为字符串”undefined”</strong>  ，结果如下</li></ul><table><thead><tr><th><strong>参数类型</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>Undefined</td><td><strong>“undefined”</strong></td></tr><tr><td>Null</td><td><strong>“null”</strong></td></tr><tr><td>Boolean</td><td><strong>true</strong>返回**”true”<strong>,<strong>false</strong>返回</strong>“false”**</td></tr><tr><td><strong>Number</strong></td><td>情况比较复杂</td></tr><tr><td>String</td><td>没转换</td></tr></tbody></table><ul><li>Number的补充说明：<ol><li>NaN，转换为”NaN”</li><li>+0/-0，转换为”0”</li><li>Infinity，转换为”Infinity”</li><li><strong>会发生进制转换</strong></li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">NaN</span>));         <span class="comment">//&quot;NaN&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(-<span class="number">0</span>));          <span class="comment">//&quot;0&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(+<span class="number">0</span>));          <span class="comment">//&quot;0&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(-<span class="literal">Infinity</span>));   <span class="comment">//&quot;-Infinity&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">Infinity</span>));    <span class="comment">//&quot;Infinity&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">0xf</span>));         <span class="comment">//&quot;15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">070</span>));         <span class="comment">//&quot;56&quot;  转成8进制</span></span><br></pre></td></tr></table></figure><h5 id="2、-toString-方法：强制转换"><a href="#2、-toString-方法：强制转换" class="headerlink" title="2、.toString()方法：强制转换"></a>2、.toString()方法：强制转换</h5><ol><li>Boolean、Number、String是基本包装类型，有toString方法，转换规则和String是一样的</li><li><strong>null和undefined没有toString方法，</strong>所以没法转换，会报错</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((-<span class="number">0</span>).toString());         <span class="comment">//&quot;0&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">NaN</span>).toString());        <span class="comment">//&#x27;NaN&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0xf</span>).toString());        <span class="comment">//&#x27;15&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">070</span>).toString());        <span class="comment">//&#x27;56&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log((-<span class="literal">Infinity</span>).toString());  <span class="comment">//&#x27;-Infinity&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="3、隐式转换："><a href="#3、隐式转换：" class="headerlink" title="3、隐式转换： +"></a>3、隐式转换： +</h5><ul><li><strong>为任意的数据类型 +””</strong>  ， 原理：和String()函数一样    </li></ul><h4 id="3-1-2、转number"><a href="#3-1-2、转number" class="headerlink" title="3.1.2、转number"></a>3.1.2、转number</h4><p><code>Number()</code> / <code>parseFloat()</code> / <code>parseInt()</code></p><h5 id="1、Number-：强制转换"><a href="#1、Number-：强制转换" class="headerlink" title="1、Number()：强制转换"></a>1、Number()：强制转换</h5><p>如果传入参数，调用底层函数**ToNumber()**，如果未传入参数，返回0：</p><table><thead><tr><th><strong>参数类型</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>Undefined</td><td><strong>NaN</strong></td></tr><tr><td>Null</td><td><strong>+0</strong></td></tr><tr><td>Boolean</td><td><strong>true</strong>返回<strong>1</strong>，<strong>false</strong>返回**+0**</td></tr><tr><td>Number</td><td>就是输入的参数了</td></tr><tr><td>String</td><td><strong>情况比较复杂</strong></td></tr></tbody></table><p>补充String类型：</p><ol><li><p>如果字符串中只包含数字**(包括前面带正号或负号的情况)**，则将其转换为十进制数值：</p><p>即”1” 会变成 1，”123”会变成 123，而”011”会变成 11**(注意:前导的零被忽略了)**;</p></li><li><p>如果字符串中包含<strong>有效的浮点格式</strong>，如”1.1”，则将其转换为对应的浮点数值(同样，也会忽略前导零);</p></li><li><p>如果字符串中包含有效的<strong>十六进制格式</strong>，例如”0xf”，则将其转换为相同大小的<strong>十进制整数值</strong>;</p></li><li><p>如果字符串是<strong>空串或纯空格</strong>，则将其转换为0;</p></li><li><p>如果字符串中包含除上述格式之外的字符，则将其转换为NaN。</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;123&quot;</span>)) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;-123&quot;</span>)) <span class="comment">// -123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;1.2&quot;</span>)) <span class="comment">// 1.2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;000123&quot;</span>)) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;-000123&quot;</span>)) <span class="comment">// -123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;0x11&quot;</span>)) <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>)) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot; &quot;</span>)) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;123 123&quot;</span>)) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;foo&quot;</span>)) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;100a&quot;</span>)) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h5 id="2、parseFloat-：强制转换"><a href="#2、parseFloat-：强制转换" class="headerlink" title="2、parseFloat() ：强制转换"></a>2、parseFloat() ：强制转换</h5><p>专门针对<strong>字符串转数字</strong>的情况，因为用Number()转字符串的时候，复杂又不合理</p><ul><li><p>忽略<strong>前导空格</strong>，第一个不为空的字符如果不是<strong>数字/正负号</strong>，就返回NaN；</p></li><li><p>解析后续字符直到遇到不是数字的字符，后面的字符全部忽略，返回之前的数字</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;  +3&#x27;</span>)     <span class="comment">//+3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>)         <span class="comment">//空字符串，NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27; &#x27;</span>)        <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;*12&#x27;</span>)      <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123blue&#x27;</span>)  <span class="comment">//123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">2.25</span>)       <span class="comment">//2，&#x27;.&#x27;不是数字，小数点后面都被忽略了</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xf&#x27;</span>)      <span class="comment">//15，十六进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;070&#x27;</span>)      <span class="comment">//70，八进制，但是ES5认为这是70</span></span><br></pre></td></tr></table></figure></li><li><p>如果对非String使用parseInt()或parseFloat()，它会<strong>先将其转换为String</strong>然后在操作 parseInt() ，可以将<strong>一个字符串中的有效的整数位</strong>提取出来，并转换为Number ， 例子：  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123.456px&quot;</span>;  </span><br><span class="line">a = <span class="built_in">parseInt</span>(a); <span class="comment">//123  </span></span><br></pre></td></tr></table></figure></li><li><p>第二个参数可以指定进制</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;070&#x27;</span>,<span class="number">8</span>)  <span class="comment">//56</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3、parseFloat-强制转换"><a href="#3、parseFloat-强制转换" class="headerlink" title="3、parseFloat()  强制转换"></a>3、parseFloat()  强制转换</h5><p>专门针对<strong>字符串转数字</strong>的情况，因为用Number()转字符串的时候，复杂又不合理</p><ul><li><p>忽略<strong>前导0和空格</strong>，第一个不为空的字符如果不是<strong>数字/正负号</strong>，就返回NaN；</p></li><li><p>解析后续字符，<strong>第一次遇到小数点有效，第二次就无效了</strong>，其他非数字字符第一次就无效，返回前面的数字</p></li><li><p><strong>只解析十进制</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;  +3&#x27;</span>));    <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;  -3&#x27;</span>));    <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>));        <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27; &#x27;</span>));       <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;*12&#x27;</span>));     <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;123blue&#x27;</span>)); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="number">2.25</span>));      <span class="comment">//2.25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;2.25.4&#x27;</span>));  <span class="comment">//2.25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;0xf&#x27;</span>));     <span class="comment">//0，遇到十六进制都是0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;070&#x27;</span>));     <span class="comment">//70</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="4、隐式转换"><a href="#4、隐式转换" class="headerlink" title="4、隐式转换  +"></a>4、隐式转换  +</h5><p>使用一元的+来进行隐式的类型转换，<strong>原理：和Number()函数一样</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123&quot;</span>;  </span><br><span class="line">a = +a;  </span><br></pre></td></tr></table></figure><h4 id="3-1-3、转boolean"><a href="#3-1-3、转boolean" class="headerlink" title="3.1.3、转boolean"></a>3.1.3、转boolean</h4><ul><li>字符串 &gt; 布尔   除了空串其余全是true</li><li>数值 &gt; 布尔      除了0和NaN其余的全是true </li><li>null、undefined &gt; 布尔 都是false  </li><li>对象 &gt; 布尔  ，都是true  </li></ul><h5 id="1、显式转换"><a href="#1、显式转换" class="headerlink" title="1、显式转换"></a>1、显式转换</h5><ul><li>Boolean()：<strong>有6种值会被转换为false，其余均为true</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下都是false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>());  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">false</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(-<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(+<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27; &#x27;</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="2、隐式转换：！！"><a href="#2、隐式转换：！！" class="headerlink" title="2、隐式转换：！！"></a>2、隐式转换：！！</h5><p><strong>为任意的数据类型做两次非运算，即可将其转换为布尔值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">a = !!a; <span class="comment">//true </span></span><br></pre></td></tr></table></figure><h3 id="3-2、如何隐式转换的？"><a href="#3-2、如何隐式转换的？" class="headerlink" title="3.2、如何隐式转换的？"></a>3.2、如何隐式转换的？</h3><h4 id="1、ToPrimitive方法："><a href="#1、ToPrimitive方法：" class="headerlink" title="1、ToPrimitive方法："></a>1、<code>ToPrimitive</code>方法：</h4><ul><li><p><code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值</p><ul><li>如果值为基本类型，则直接返回值本身；</li><li>如果值为对象，则：ToPrimitive(obj,type)</li></ul></li><li><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul></li></ul><p>两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objToNumber = <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">Number</span>(value.valueOf().toString())</span><br><span class="line">objToNumber([]) === <span class="number">0</span></span><br><span class="line">objToNumber(&#123;&#125;) === <span class="literal">NaN</span></span><br></pre></td></tr></table></figure><h5 id="2、toString"><a href="#2、toString" class="headerlink" title="2、toString()"></a>2、toString()</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">val</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">var</span> e = <span class="regexp">/\d+/g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.toString());  <span class="comment">//&#x27;1,2,3&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toString());  <span class="comment">//&quot;[object object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(c.toString());  <span class="comment">//&#x27;function(x)&#123; return x++ &#125;&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(d.toString());  <span class="comment">//Thu Apr 09 2020 17:55:26 GMT+0800 </span></span><br><span class="line"><span class="built_in">console</span>.log(e.toString());  <span class="comment">///\d+/g</span></span><br></pre></td></tr></table></figure><h5 id="3、valueOf"><a href="#3、valueOf" class="headerlink" title="3、valueOf()"></a>3、valueOf()</h5><ol><li>无论是哪种数据类型，返回参数本身，类型也不会变化，唯一特殊的是<strong>Date对象</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf());  <span class="comment">//1586426466217，1970.1.1距今的毫秒数</span></span><br></pre></td></tr></table></figure><ol start="2"><li>包装类型Number、String、Boolean，也是Object类，用valueOf后类型转换为<strong>基本数据类型</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> <span class="built_in">Number</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(c.valueOf());          <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c.valueOf());   <span class="comment">//Number</span></span><br></pre></td></tr></table></figure><h5 id="4、隐式转换发生的场景"><a href="#4、隐式转换发生的场景" class="headerlink" title="4、隐式转换发生的场景"></a>4、隐式转换发生的场景</h5><p>隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而<strong>这些运算符只能操作基本类型值</strong>，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成<strong>基本类型</strong>，再进行操作</p><h4 id="1、-a"><a href="#1、-a" class="headerlink" title="1、+a"></a>1、+a</h4><p>调用**ToNumber()**，对+后面的数据进行转换</p><ul><li><h5 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;12.3&#x27;</span>);    <span class="comment">//12.3</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;-12.3&#x27;</span>);   <span class="comment">//-12.3</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;&#x27;</span>);        <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>);      <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">null</span>);      <span class="comment">//+0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">undefined</span>); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li><li><h5 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+[]);        <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(+[ ]);       <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(+[<span class="number">1</span>]);       <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(+[<span class="number">1</span>,<span class="number">2</span>]);     <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(+&#123;&#125;);        <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(+&#123;<span class="attr">val</span>: <span class="string">&#x27;happy&#x27;</span>&#125;); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Date</span>());     <span class="comment">//1586433193168，1970.1.1距今毫秒数</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、二元运算符a-b-、-、"><a href="#2、二元运算符a-b-、-、" class="headerlink" title="2、二元运算符a+b -、*、\"></a>2、二元运算符a+b <code>-</code>、<code>*</code>、<code>\</code></h4><p>left = ToPrimitive(a)，right = ToPrimitive(b)，a和b是基本数据类型的话，left = a，right = b</p><ol><li><p><strong>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型</strong></p></li><li><p>其他情况下两边的变量都会被转换为数字。</p><p>当一侧为<code>Number</code>类型，另一侧为<strong>原始类型</strong>，则将原始类型转换为<code>Number</code>类型</p><p>两个数字相加遵循以下规则：</p><ol><li>如果有一个操作数是 NaN，则结果是 NaN</li><li>Infinity + Infinity = Infinity、(-Infinity) + (-Infinity )= -Infinity、Infinity + (-Infinity) = NaN</li><li>(+0) + (+0) = +0、(-0) +(-0) = -0、(+0) + (-0) = +0</li></ol></li><li><p>当一侧为<code>Number</code>类型，另一侧为<strong>引用类型</strong>，将引用类型和<code>Number</code>类型转换成字符串后拼接</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>+<span class="number">123</span>);  <span class="comment">//&#x27;1123&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>+<span class="number">1</span>);   <span class="comment">//1，两个都不是字符串，所以null转换为0，和1相加</span></span><br><span class="line"><span class="built_in">console</span>.log([]+[]);    <span class="comment">//&#x27;&#x27;，经过ToPrimitive得到&#x27;&#x27;+&#x27;&#x27; = &#x27;&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">&#x27;1&#x27;</span>]+<span class="number">1</span>);  <span class="comment">//&#x27;11&#x27;，经过ToPrimitive得到&#x27;1&#x27;+1 = &#x27;11&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log([]+&#123;&#125;);    <span class="comment">//&#x27;[object Object]&#x27;，经ToPrimitive得&#x27;&#x27;+&#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>NaN</code>也是一个数字</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="string">&#x27;23&#x27;</span> <span class="comment">// 23</span></span><br><span class="line"> <span class="number">1</span> * <span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"> <span class="number">1</span> / <span class="string">&#x27;aa&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h4 id="3、-、-、"><a href="#3、-、-、" class="headerlink" title="3、==  、 === 、!="></a>3、==  、 === 、!=</h4><ul><li><p>三等号（===）相等判断时，如果两边类型不一致时，不会做强制类型准换，直接返false</p></li><li><p>对于 <code>==</code> 来说，**若类型不同，否则会发生隐式转换： **    重要准则 </p><ul><li>a和b为 String、Number、Boolean 中的某一类型，则使用 <strong>ToNumber</strong> 函数转化为 Number 类型再进行比较；</li><li>有一个是Object，另一个是 String、Number、Boolean 中的某一类型，则**ToPrimitive(Object)**转换为基础数据类型，再按照上一步比较</li></ul></li><li><p>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></p></li><li><p>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></p></li><li><p>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</p></li><li><p>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c451c19e23dd4726b3f36223b6c18a1e~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:50%;" /></li></ul><h5 id="1、准则1：NaN，和其他任何类型比较永远返回false-包括和他自己"><a href="#1、准则1：NaN，和其他任何类型比较永远返回false-包括和他自己" class="headerlink" title="1、准则1：NaN，和其他任何类型比较永远返回false(包括和他自己)"></a>1、准则1：NaN，和其他任何类型比较永远返回<code>false</code>(包括和他自己)</h5><h5 id="2、准则2：Boolean-Boolean-lt-Number"><a href="#2、准则2：Boolean-Boolean-lt-Number" class="headerlink" title="2、准则2：Boolean             Boolean &lt; Number"></a>2、准则2：Boolean             Boolean &lt; Number</h5><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规则3</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">1</span>  <span class="comment">// true </span></span><br><span class="line"><span class="literal">true</span> == <span class="string">&#x27;2&#x27;</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>]  <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;2&#x27;</span>]  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == &#123;&#125;);    </span><br><span class="line"><span class="built_in">console</span>.log([] == <span class="literal">false</span>);   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">0</span>] == <span class="number">0</span>);      <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">&#x27;0&#x27;</span>] == <span class="number">0</span>);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>【注意】：</p><p><code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但他们比较结果是<code>false</code>，原因是**<code>false</code>首先被转换成<code>0</code>：**</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>  <span class="comment">// false   bollean先被转换为number</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="3、准则3：String"><a href="#3、准则3：String" class="headerlink" title="3、准则3：String  :"></a>3、准则3：String  :</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规则3.1</span></span><br><span class="line"><span class="number">123</span> == <span class="string">&#x27;123&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="literal">true</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="literal">false</span>);   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> == <span class="number">1</span>);     <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="4、准则4：null和undefined"><a href="#4、准则4：null和undefined" class="headerlink" title="4、准则4：null和undefined"></a>4、准则4：null和undefined</h5><p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a∈&#123;<span class="literal">null</span>,<span class="literal">undefined</span>&#125;且b∈&#123;<span class="literal">null</span>,<span class="literal">undefined</span>&#125;，返回<span class="literal">true</span>，有一个不属于&#123;<span class="literal">null</span>,<span class="literal">undefined</span>&#125;，返回<span class="literal">false</span></span><br><span class="line"><span class="comment">//规则2</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">null</span>);           <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">undefined</span>); <span class="comment">//true    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == &#123;&#125;);             <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h5 id="5、准则5：引用类型"><a href="#5、准则5：引用类型" class="headerlink" title="5、准则5：引用类型"></a>5、准则5：引用类型</h5><ol><li>a和b为 String、Number、Boolean 中的某一类型，则使用 <strong>ToNumber</strong> 函数转化为 Number 类型再进行比较</li><li>有一个是Object，另一个是 String、Number、Boolean 中的某一类型，则ToPrimitive(Object)转换为基础数据类型，再按照上一步比较</li></ol><ul><li>依照<code>ToPrimitive</code>规则转换为原始类型：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>判断：<code>[] == ![] // true</code><ol><li><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code></li><li><code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等</li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">null</span>] == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">[<span class="literal">undefined</span>] == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">//规则4</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">0</span>] == [<span class="string">&#x27;0&#x27;</span>]);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">0</span>);       <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span> == <span class="number">0</span>);       <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == -<span class="number">0</span>);      <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>根据数组的<code>ToPrimitive</code>规则：</p><ul><li>数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code></li></ul><h4 id="3-2、逻辑运算符"><a href="#3-2、逻辑运算符" class="headerlink" title="3.2、逻辑运算符"></a>3.2、逻辑运算符</h4><ul><li><p>注意[]是为真的，所以在数组if判断时要用length</p></li><li><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面6种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span>  <span class="literal">undefined</span>  <span class="string">&#x27;&#x27;</span>   <span class="literal">NaN</span>  <span class="number">0</span>  <span class="literal">false</span>   </span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1、对象转Number"><a href="#4-1、对象转Number" class="headerlink" title="4.1、对象转Number"></a>4.1、对象转Number</h4><p>对象转数字的过程：</p><ol><li>有**valueOf()**方法，就用，结果为基本数据类型就返回，否则下一步</li><li>有**toString()**方法，就用，结果为基本数据类型就返回，否则报错</li><li>得到基本数据类型后，调用<strong>ToNumber(primValue)</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([]));       <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="number">0</span>]));      <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(&#123;<span class="attr">val</span>:<span class="number">4</span>&#125;));  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(&#123;&#125;));       <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x++ &#125;)); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="regexp">/\d+/g</span>));   <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><p>试着分析[]和[1,2,3]的情况</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[].valueOf() == [],不是基本数据类型</span><br><span class="line">[].toString() == <span class="string">&#x27;&#x27;</span>,是基本数据类型</span><br><span class="line">ToNumber(<span class="string">&#x27;&#x27;</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3].valueOf() == [1,2,3],不是基本数据类型</span><br><span class="line">[1,2,3].toString() == &#x27;1,2,3&#x27;,是基本数据类型</span><br><span class="line">ToNumber(&#x27;1,2,3&#x27;) == NaN</span><br></pre></td></tr></table></figure><h4 id="4-2、对象转字符串"><a href="#4-2、对象转字符串" class="headerlink" title="4.2、对象转字符串"></a>4.2、对象转字符串</h4><p>参考转数字的过程，有</p><ul><li>有**toString()**方法，就用，结果为基本数据类型就返回，否则下一步</li><li>有**valueOf()**方法，就用，结果为基本数据类型就返回，否则报错</li><li>得到基本数据类型primValue后，调用**ToString(primValue)**，下面就很熟悉了</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));    <span class="comment">//&#x27;1,2,3&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>([]));         <span class="comment">//一个空格</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>([<span class="number">0</span>]));        <span class="comment">//&#x27;0&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(&#123;<span class="attr">val</span>:<span class="number">4</span>&#125;));    <span class="comment">//&#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(&#123;&#125;));         <span class="comment">//&#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x++ &#125;));  <span class="comment">//&#x27;function(x)&#123; return x++ &#125;&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()))<span class="comment">//&#x27;Thu Apr 09 2020 19:23:31 GMT+0800 (标准时间)&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="regexp">/\d+/g</span>));     <span class="comment">//&#x27;/\d+/g&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="4-3、对象转布尔值"><a href="#4-3、对象转布尔值" class="headerlink" title="4.3、对象转布尔值"></a>4.3、对象转布尔值</h4><ul><li><strong>都转为true！包装类型也是！</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数据类型判断</title>
      <link href="/2021/12/10/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
      <url>/2021/12/10/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="类型判断5种"><a href="#类型判断5种" class="headerlink" title="类型判断5种"></a>类型判断5种</h3><h4 id="1、typeOf（适合基本类型）"><a href="#1、typeOf（适合基本类型）" class="headerlink" title="1、typeOf（适合基本类型）"></a>1、typeOf（适合基本类型）</h4><p>typeof是操作符，不是函数，返回一个字符串</p><p>唯一要注意的就是：</p><ol><li><strong>null用typeof返回的是object</strong>，但是这并不意味着null是对象</li><li><strong>函数function用typeof返回的是function</strong>，其余对象都返回object</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">typeOf xxx</span><br><span class="line"><span class="attr">object</span>: <span class="keyword">new</span> <span class="built_in">Array</span>()、 [<span class="number">11</span>] 、<span class="built_in">Object</span> 、 <span class="literal">null</span> 、 <span class="keyword">new</span> <span class="built_in">String</span>()、 <span class="keyword">new</span> <span class="built_in">Number</span>()</span><br><span class="line"><span class="attr">undefined</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="attr">boolean</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">string</span>: <span class="string">&#x27;ssss&#x27;</span></span><br><span class="line"><span class="attr">number</span>: <span class="number">123</span></span><br><span class="line"><span class="attr">function</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2、instanceof：及手写"><a href="#2、instanceof：及手写" class="headerlink" title="2、instanceof：及手写"></a>2、instanceof：及手写</h4><img src="file:///C:\Users\小虎牙\Documents\Tencent Files\2575329556\Image\Group\5LOKV2$Q28$JYOMV51%$GAA.jpg" alt="img" style="zoom: 25%;" /><ul><li><p><code>A instanceof B</code>：检测B的 <code>prototype</code> 属性是否在A对象的原型链上，缺点：</p><ol><li>不能检测基本数据类型</li><li>检测不准确，判断数组时需要用Array，而不用Object</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span>  Foo) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span>  <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span>  <span class="built_in">Function</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="instanceof手写"><a href="#instanceof手写" class="headerlink" title="instanceof手写"></a>instanceof手写</h5><ul><li>不断向上取A的__proto__与B的prototype对比</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">A, B</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> A === <span class="string">&#x27;object&#x27;</span>|| A === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> p = A <span class="comment">// 链表遍历</span></span><br><span class="line">  <span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p === B.prototype)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = p.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="3、isArray"><a href="#3、isArray" class="headerlink" title="3、isArray"></a>3、isArray</h4><p><strong>检测数组的比较好的方式</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr2))  <span class="comment">// true  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(obj2))  <span class="comment">// false  </span></span><br></pre></td></tr></table></figure><h4 id="4、constructor属性"><a href="#4、constructor属性" class="headerlink" title="4、constructor属性"></a>4、constructor属性</h4><p>返回创建该对象的构造函数的引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1,2];</span><br><span class="line">console.log(arr.constructor === Array);        //true</span><br><span class="line">console.log(arr.constructor === Object);    //false</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>constructor属性存在原型上面，一旦原型被重写，就不再指向之前的构造函数了</li><li><code>null</code>和<code>undefined</code>是无效的对象,因此是不会有<code>constructor</code>存在的</li></ul><h4 id="5、Object-prototype-toString"><a href="#5、Object-prototype-toString" class="headerlink" title="5、Object.prototype.toString()"></a>5、Object.prototype.toString()</h4><p><code>Object.prototype.toString().call(thisArg)</code></p><h5 id="1、执行流程："><a href="#1、执行流程：" class="headerlink" title="1、执行流程："></a>1、执行流程：</h5><ol><li>如果 this 值是 undefined，就返回 [object Undefined]</li><li>如果 this 的值是 null，就返回 [object Null]</li><li>让 O 成为 ToObject(this) 的结果</li><li>让 class 成为 O 的内部属性 [[Class]] 的值</li><li><strong>最后返回由 “[object “ 和 class 和 “]” 三个部分组成的字符串</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;          <span class="comment">// [object Number]</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;123&#x27;</span>;      <span class="comment">// [object String]</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">true</span>;      <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="keyword">var</span> und = <span class="literal">undefined</span>;     <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="keyword">var</span> nul = <span class="literal">null</span>;          <span class="comment">// [object Null]</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;         <span class="comment">// [object Object]</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// [object Array]</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();   <span class="comment">// [object Date]</span></span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// [object Error]</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;          <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// [object Function]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">       <span class="comment">//注意调用方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>[i]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func)</span><br></pre></td></tr></table></figure><h5 id="2、调用这个方法、直接toString的区别"><a href="#2、调用这个方法、直接toString的区别" class="headerlink" title="2、调用这个方法、直接toString的区别"></a>2、调用这个方法、直接toString的区别</h5><ul><li><h5 id="普通对象Object调用这个方法和直接obj-toString-结果是相同的"><a href="#普通对象Object调用这个方法和直接obj-toString-结果是相同的" class="headerlink" title="普通对象Object调用这个方法和直接obj.toString()结果是相同的"></a>普通对象Object调用这个方法和直接obj.toString()结果是相同的</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.toString());                      <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a)); <span class="comment">//[object Object]</span></span><br></pre></td></tr></table></figure></li><li><h5 id="其他数据类型就不是："><a href="#其他数据类型就不是：" class="headerlink" title="其他数据类型就不是："></a>其他数据类型就不是：</h5><ol><li>字符串 String 的 toString 方法返回还是本身</li><li>数组 Number 的 toString 方法返回字符串的数字</li><li>数组 Array 的 toString 方法将每个数组元素转换成一个字符串，并在<strong>元素之间添加逗号后合并成结果字符串</strong>。</li><li>函数 Function 的 toString 方法返回源代码字符串。</li><li>日期 Date 的 toString 方法返回一个可读的日期和时间字符串。</li><li>正则表达式 RegExp 的 toString 方法返回一个表示正则表达式直接量的字符串。</li><li>Null 和 Undefined 没有 toString 方法</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;123&#x27;</span>.valueOf()</span><br><span class="line"><span class="built_in">console</span>.log(b.toString());                      <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(b)); <span class="comment">//[object String]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(c.toString());                      <span class="comment">//1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(c)); <span class="comment">//[object Array]</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数据类型</title>
      <link href="/2021/12/10/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/12/10/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>八种数据类型，分别是基本引用类型与基本引用类型</p><h4 id="1-1、原始类型"><a href="#1-1、原始类型" class="headerlink" title="1.1、原始类型"></a>1.1、原始类型</h4><ul><li><p><code>Null</code>：只包含一个值：<code>null</code></p></li><li><p><code>Undefined</code>：只包含一个值：<code>undefined</code></p></li><li><p><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></p></li><li><p><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最大能表示的值：Number.MAX_VALUE=1.7976931348623157e+308</span><br><span class="line">Infinity 正无穷 （大于Number.MAX_VALUE的数字）</span><br><span class="line">-Infinity 负无穷 </span><br><span class="line">NaN 非法数字（Not A Number）</span><br><span class="line">0b 开头表示二进制，但是不是所有的浏览器都支持  </span><br><span class="line">0 开头表示八进制  </span><br><span class="line">0x 开头表示十六进制 </span><br></pre></td></tr></table></figure></li><li><p><code>String</code>：一串表示文本值的字符序列</p></li><li><p><code>Symbol</code>：创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</p></li><li><p><code>BigInt</code>：是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p></li></ul><h4 id="1-2、undefined和null的区别"><a href="#1-2、undefined和null的区别" class="headerlink" title="1.2、undefined和null的区别"></a>1.2、undefined和null的区别</h4><ul><li><p>undefined:  表示”缺少值”，就是此处应该有一个值，但是还没有定义，undefined转为数值时为NaN。典型用法：</p><ul><li>变量被声明了，但没有赋值时，就等于undefined</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li><li>对象没有赋值的属性，该属性的值为undefined</li><li>函数没有返回值时，默认返回undefined</li></ul></li><li><p>null:  “没有对象”，即该处不应该有值。<code>null</code>转换为数值时值为<code>0</code>，典型用法：</p><ul><li>作为函数的参数，表示该函数的参数不是对象</li></ul></li><li><p>作为对象原型链的终点</p><ul><li>不会占用内存,在清理内存占用可以使用<code>null</code>赋值</li></ul></li></ul><h4 id="typeof-null"><a href="#typeof-null" class="headerlink" title="typeof null"></a>typeof null</h4><p>typeof null 的结果是Object。</p><ul><li><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  1: int      - 当前存储的数据是一个 31 位的有符号整数。</span><br><span class="line">010: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line">100: string   - 当前存储的数据指向一个字符串。</span><br><span class="line">110: boolean  - 当前存储的数据是布尔值。</span><br></pre></td></tr></table></figure></li></ul><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h4 id="1-3、原始值特点"><a href="#1-3、原始值特点" class="headerlink" title="1.3、原始值特点"></a>1.3、原始值特点</h4><ul><li>按值访问，变量以变量的标识符和变量的值的形式保存在栈内存中，<strong>栈内存的特点</strong>：<ul><li>存储的值大小固定</li><li>空间较小</li><li>可以直接操作其保存的变量，运行效率高</li><li>由系统自动分配存储空间</li></ul></li><li>值本身是不可被改变的，被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间<ul><li>比如操作字符串，是在原字符串的基础上产生了一个新字符串，而非直接去改变<code>str</code></li></ul></li><li>如果值相等，即返回<code>true</code></li><li>函数传参：参数<strong>仅仅是被传入变量复制给了的一个局部变量</strong>，改变这个局部变量不会对外部变量产生影响</li><li>原始类型不能扩展属性和方法，每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而能够调用一些方法和属性。<strong>装箱/拆箱操作</strong></li></ul><h4 id="2-1、引用类型"><a href="#2-1、引用类型" class="headerlink" title="2.1、引用类型"></a>2.1、引用类型</h4><ul><li><p>基本引用类型：并不是由<code>Object</code>构造的，但是它们原型链的终点都是<code>Object</code></p><ul><li><code>Date</code> 日期</li><li><code>RegExp</code> 正则</li></ul></li><li><p>包装类型：基本类型的包装类型:<code>Boolean</code>、<code>Number</code>、<code>String</code></p></li><li><p>单例内置对象：<code>Global</code>、<code>Math</code></p></li><li><p>基本类型和包装类型的主要区别：<strong>对象的生存期</strong></p><ul><li>包装类型使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中</li><li>而基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ConardLi&#x27;</span></span><br><span class="line">name.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.color); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>集合引用类型：</p><ul><li><code>Object</code></li><li><code>Array</code> 数组</li><li><code>Function</code> 函数</li><li><code>Map</code>、<code>WeakMap</code>、<code>Set</code>、<code>WeakSet</code></li></ul></li></ul><h4 id="2-2、引用类型特点"><a href="#2-2、引用类型特点" class="headerlink" title="2.2、引用类型特点"></a>2.2、引用类型特点</h4><ul><li><p>按址访问，该类型的值是同时保存在堆和栈内存中的，这两个栈区共同完成</p><ul><li>存储的值大小不定，可动态调整</li><li>空间较大，运行效率低</li><li>无法直接操作其内部存储，使用引用地址读取</li><li>通过代码进行分配空间</li></ul></li><li><p>具有可变性，赋值的时候两个变量保存了同一对象地址，执行同一对象，二者互相影响</p></li><li><p>值的比较：值相等，类型相同，堆中的地址也要相同</p></li><li><p>函数传参：**<code>ECMAScript</code>中所有的函数的参数都是按值传递的。**</p><p>参数是引用类型时，同样将参数复制了一个副本到局部变量，只不过<strong>复制的这个副本是指向堆内存中的地址</strong>而已。</p><p>在函数内对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但<strong>这并不代表引用传递</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;ConardLi&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">&#x27;code秘密花园&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">&#x27;ConardLi&#x27;</span>;</span><br><span class="line">  obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;code秘密花园&#x27;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的盒模型</title>
      <link href="/2021/12/09/CSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/12/09/CSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="二、盒模型"><a href="#二、盒模型" class="headerlink" title="二、盒模型"></a>二、盒模型</h2><h3 id="0、文档流"><a href="#0、文档流" class="headerlink" title="0、文档流"></a>0、文档流</h3><ul><li><p>网页是一个多层结构，是一层一层的；我们可以通过css为每一层设置样式，而用户只能看到最上面的一层</p></li><li><p>我们称最下面的一层叫<strong>文档流，文档流是网页的基础</strong>，也是<strong>css的一种基本定位和布局机制</strong></p></li><li><p>我们创建的元素默认是在文档流中进行排列：</p><ol><li>比如写的html不用css，默认自上而下（块级元素如<code>div</code>）从左到右（内联元素如<code>span</code>）堆砌的布局方式</li><li>元素主要有两种状态：在文档流中、不在文档流中</li></ol></li></ul><h3 id="1、盒模型"><a href="#1、盒模型" class="headerlink" title="1、盒模型"></a>1、盒模型</h3><ul><li>盒子构成4部分：content（有width和height）、padding、border、margin</li><li>分类上：<ol><li>块级元素的盒模型、行内元素的盒模型</li><li>标准盒模型、怪异盒模型</li></ol></li></ul><h4 id="1、盒子尺寸计算"><a href="#1、盒子尺寸计算" class="headerlink" title="1、盒子尺寸计算"></a>1、盒子尺寸计算</h4><h5 id="IE盒模型：border-box"><a href="#IE盒模型：border-box" class="headerlink" title="IE盒模型：border-box"></a>IE盒模型：border-box</h5><ul><li>css指定的width、height指的是：实际盒子的大小（<strong>内容区域+border+padding</strong>）；不是内容区大小</li><li>属性控制：<strong>box-sizing</strong>：<strong>border-box</strong></li><li>所以这种模式下，<strong>增加border和padding会减小内容区域的大小</strong>，而实际盒子大小不变</li></ul><h5 id="标准模型（默认）：content-box"><a href="#标准模型（默认）：content-box" class="headerlink" title="标准模型（默认）：content-box"></a>标准模型（默认）：content-box</h5><ol><li>css指定的width、height指的是：内容区content的大小；</li><li>此时<strong>实际盒子</strong>的大小：<strong>内容区域+border+padding</strong></li><li>属性控制：<strong>box-sizing</strong>为<strong>content-box</strong>（默认值）</li><li>所以，这种模式下，<strong>增加border和padding不会影响内容区域的大小</strong>，只是会影响实际盒子的大小</li><li>声明了DOCTYPE类型，会解读为标准盒模型；</li></ol><h4 id="2、盒子宽高尺寸获取"><a href="#2、盒子宽高尺寸获取" class="headerlink" title="2、盒子宽高尺寸获取"></a>2、盒子宽高尺寸获取</h4><h5 id="1-方式一：通过DOM节点的-style-样式获取：element-style-width-height"><a href="#1-方式一：通过DOM节点的-style-样式获取：element-style-width-height" class="headerlink" title="1. 方式一：通过DOM节点的 style 样式获取：element.style.width/height"></a>1. 方式一：通过DOM节点的 style 样式获取：element.style.width/height</h5><ul><li>缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px&quot;</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oDiv1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span></span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(oDiv1.style.width ) ;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-方式二（通用型）：window-getComputedStyle-element-width-height"><a href="#2-方式二（通用型）：window-getComputedStyle-element-width-height" class="headerlink" title="2. 方式二（通用型）：window.getComputedStyle(element).width/height"></a>2. 方式二（通用型）：window.getComputedStyle(element).width/height</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> &gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log( <span class="built_in">window</span>.getComputedStyle(oDiv1).width ) ;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-方式三：IE独有的element-currentStyle-width-height"><a href="#3-方式三：IE独有的element-currentStyle-width-height" class="headerlink" title="3. 方式三：IE独有的element.currentStyle.width/height"></a>3. 方式三：IE独有的element.currentStyle.width/height</h5><ul><li>获取到的是运行完之后的宽高，三种css样式都可以获取</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log( oDiv1.currentStyle.width);</span><br></pre></td></tr></table></figure><h5 id="4-方式四（通用型）：element-getBoundingClientRect-width-height"><a href="#4-方式四（通用型）：element-getBoundingClientRect-width-height" class="headerlink" title="4. 方式四（通用型）：element.getBoundingClientRect().width/height"></a>4. 方式四（通用型）：element.getBoundingClientRect().width/height</h5><ul><li>这种方式获得到的宽度是内容content+padding+border</li><li>此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(oDiv1.getBoundingClientRect().width);</span><br></pre></td></tr></table></figure><h3 id="2、块级元素的盒模型"><a href="#2、块级元素的盒模型" class="headerlink" title="2、块级元素的盒模型"></a>2、块级元素的盒模型</h3><h4 id="1、盒模型水平方向布局规则："><a href="#1、盒模型水平方向布局规则：" class="headerlink" title="1、盒模型水平方向布局规则："></a>1、盒模型水平方向布局规则：</h4><p>元素在父元素的位置由以下属性决定：</p><p>margin-left、border-left、padding-left   width、padding-right、border-right、margin-right</p><p>这7个值构成了父元素的content内容区；</p><p>必须满足的条件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子元素margin-left+border-left+padding-left+width+padding-right+border-right=父元素宽度</span><br></pre></td></tr></table></figure><ul><li><p>当等式不成立时，称为过度约束，浏览器会自动调整：</p><p>这7个值中有三个可以设置为auto：width (默认是auto)、margin-left、margin-right</p><ol><li>如果7个值中没有auto会先调整margin-right；所以即使设置margin-right是无效的；</li><li>如果某一个值为auto就会先自动调整那个值；</li><li>如果一个宽度和一个外边距是auto，那么宽度会调整到最大</li><li>如果三个都是auto，那么宽度会是最大；</li><li>如果外边距都是auto，那么两个auto会赋相同的值(常用这个特点实现水平居中)</li></ol></li></ul><h4 id="2、盒模型垂直方向布局"><a href="#2、盒模型垂直方向布局" class="headerlink" title="2、盒模型垂直方向布局"></a>2、盒模型垂直方向布局</h4><ul><li><p><strong>默认情况下，如果父元素不设置高度，父元素是被子元素撑开的</strong>。如果父元素指定了高度，设置多少就是多少；</p></li><li><p>子元素在内容区中排列：</p><ol><li><p>如果子元素的大小超过父元素：则子元素会从父元素中溢出；</p></li><li><p>使用overflow属性来设置父元素如何处理溢出的子元素：</p><p>visible：(默认值)子元素从父元素中溢出，在父元素的外部显示<br>hidden:溢出的元素将会被裁减而不显示<br>scroll:生成两个滚动条，通过两个滚动条实现浏览<br>auto：根据需要生成两个滚动条</p></li></ol></li></ul><h4 id="3、垂直外边距塌陷"><a href="#3、垂直外边距塌陷" class="headerlink" title="3、垂直外边距塌陷"></a>3、垂直外边距塌陷</h4><p><strong>概念：</strong>两个或多个相邻普通流中的盒子（父子或兄弟元素）在<strong>垂直方向</strong>上的外边距会发生叠加</p><h5 id="兄弟元素：外边距的计算"><a href="#兄弟元素：外边距的计算" class="headerlink" title="兄弟元素：外边距的计算"></a>兄弟元素：外边距的计算</h5><ul><li>两数为正，取最大值</li><li>两数为负，取绝对值最大的数</li><li>一正一负：取二者之和</li></ul><p>怎么解决：（兄弟元素的外边距重叠问题不用处理，因为就希望这样的效果）</p><ul><li><h5 id="为什么这样设计："><a href="#为什么这样设计：" class="headerlink" title="为什么这样设计："></a>为什么这样设计：</h5><p>解决垂直方向的多个段落之间的间隔：为了兼顾顶部、底部的没有空隙，所以添加了margin-bottom，margin-top ，由于外边距的合并这样的设计，不会让每个段落之间多出来一份宽度，这样整体间距一样，整齐布局</p></li></ul><h5 id="父子元素："><a href="#父子元素：" class="headerlink" title="父子元素："></a>父子元素：</h5><p>外边距计算：</p><ul><li>父子元素之间的外边距子元素会传递给父元素（子会将父带下来，这样不好，需要解决）</li></ul><p>怎么解决：</p><ol><li><p>不用margin，换用padding，再将高度减去（需要计算）</p></li><li><p>改父元素定义上边框，设置透明，还需要减去高度，margin-top</p></li><li><p>解决思路：用一个东西，将上边的外边距与下边的外边距隔开，不要互相影响</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box1 clearfix&quot;&gt;</span><br><span class="line">// 阻隔的添加在这里</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;box2&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,  //<span class="number">1</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;  //<span class="number">4</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;  //<span class="number">2</span></span><br><span class="line">    <span class="attribute">display</span>: table; //<span class="selector-tag">table</span>可以隔开，本身不占据位置，既可以解决高度塌陷、外边距重叠问题 //<span class="number">3</span></span><br><span class="line">    <span class="attribute">clear</span>: both; //<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span> 其实是解决了 外边距重叠问题；</span><br><span class="line">// <span class="number">4</span>、<span class="number">5</span>是解决 高度塌陷问题</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>什么时候用before的问题？</p><ul><li><strong>其实它是用来处理margin边距重叠的，由于内部元素 float 创建了BFC，导致内部元素的margin-top和 上一个盒子的margin-bottom 发生叠加</strong>。如果这不是你所希望的，那么就可以加上before</li></ul></li></ul><h3 id="3、行内、替换元素"><a href="#3、行内、替换元素" class="headerlink" title="3、行内、替换元素"></a>3、行内、替换元素</h3><h4 id="1、行内元素"><a href="#1、行内元素" class="headerlink" title="1、行内元素"></a>1、行内元素</h4><ul><li>不会独占一行，多个行内元素从左到右(行内元素可以共处一行)，从上到下排列；</li><li>不能设置宽高：宽高是由其文本内容撑开</li><li>可以设置margin、padding、border，但<strong>垂直方向</strong>上均不影响页面的布局，下面一行的元素不受影响</li><li>行内元素<strong>左右margin和padding</strong>有效，直接相加</li><li>行内元素使用float属性后，设置宽高生效</li><li>a、span、img、br、strong</li></ul><h4 id="2、行内块元素"><a href="#2、行内块元素" class="headerlink" title="2、行内块元素"></a>2、行内块元素</h4><ul><li>结合了inline和block特性，既能设置宽高也不会换行</li><li>行内块级元素起始就是行内元素设置宽高可以生效</li><li>img、input、button、textarea、select</li></ul><h4 id="3、display-none"><a href="#3、display-none" class="headerlink" title="3、display:none"></a>3、display:none</h4><ul><li>此时元素<strong>仍存在于DOM</strong>结构中</li><li>但<strong>不存在于render tree</strong> 中，<strong>不会被渲染</strong>，就<strong>不会占据空间</strong>，后面的元素会顶上来</li><li>会引起回流</li><li>不能点击</li></ul><h4 id="5、display-flex"><a href="#5、display-flex" class="headerlink" title="5、display:flex"></a>5、display:flex</h4><ul><li>弹性元素：更像是移动端的布局方式</li><li>设为flex布局后，子元素的float，clear和vertical-align属性将失效</li><li>此元素即为弹性布局容器，会按弹性布局规则</li></ul><h4 id="6、可替换元素："><a href="#6、可替换元素：" class="headerlink" title="6、可替换元素："></a>6、可替换元素：</h4><ul><li><p>特点：展现效果不是由 CSS 来控制的，外观渲染独立于CSS</p></li><li><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><ol><li><p>典型的可替换元素：iframe、video</p><p><strong>img</strong>：浏览器去下载 src 属性给到的图片，并用该图片资源替换掉 <code>img</code> 标签，而且浏览器在下载前并不知道图片的宽高。所以，可替换元素比较特殊，它的宽高是由其加载的内容决定的。（当然 CSS 可以覆盖其样式）</p><ul><li>display 属性的默认值是 inline，默认分辨率是由被嵌入的图片的原始宽高来确定的，使得它就像 inline-block 一样</li></ul></li></ol></li><li><p>没有基线：使用 vertical-align: baseline 时，图像的底部将会与容器的文字基线对齐</p></li></ul><ol start="2"><li><p>仅在特定情况下被作为可替换元素处理：audio、canvas</p></li><li><p>特殊的 input</p><ul><li><p>根据<code>type</code>属性来决定是显示输入框，还是单选按钮等</p></li><li><p>规范说明了input元素可替换，除了其他形式的控制元素，包括其他类型的 <input> 元素，被明确地列为非可替换元素</p></li></ul></li></ol><h4 id="7、不可替换元素："><a href="#7、不可替换元素：" class="headerlink" title="7、不可替换元素："></a>7、不可替换元素：</h4><ul><li><code>html</code> 的大多数元素是不可替换元素，即其内容直接表现给用户端：div、p、h1</li></ul><h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><ol><li><p>几乎所有的<strong>替换元素</strong>都是<strong>行内元素</strong></p><p>不过元素的类型也不是固定的，通过设定CSS 的display属性，可以使行内元素变为块级元素，也可以让块级元素变为行内元素</p></li><li><p>替换元素一般有内在尺寸，所以具有width和height</p><p>不指定img的width和height时，就按其内在尺寸显示</p><p>对于表单元素，浏览器也有默认的样式，包括宽度和高度</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盒模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配</title>
      <link href="/2021/12/09/CSS%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
      <url>/2021/12/09/CSS%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><h3 id="1、媒体查询"><a href="#1、媒体查询" class="headerlink" title="1、媒体查询"></a>1、媒体查询</h3><ul><li><p>使用媒体查询的方式：</p><ol><li>可以使用 <strong>link 与 style</strong> 中定义媒体查询</li><li>也可以用 <code>@import url(screen.css) screen</code> 形式媒体使用的样式</li></ol><p>可以用逗号分隔同时支持多个媒体设备，未指定媒体设备时等同于all</p></li></ul><h4 id="1、style"><a href="#1、style" class="headerlink" title="1、style"></a>1、style</h4><ul><li><p>常用的：一般并不会写media=”screen”，其实是默认了media=”all”</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style media=&quot;screen&quot;&gt;  //可以指定别的设备</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、link"><a href="#2、link" class="headerlink" title="2、link"></a>2、link</h4><ul><li><p>在 <code>link</code> 标签中通过 <code>media</code> 属性可以设置样式使用的媒体设备。</p></li><li><p>要写很多link标签，不太方便。不推荐使用</p></li><li><p>此外我们更多的时候是针对页面中某块区域，来单独写个样式控制其响应</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;common<span class="selector-class">.css</span>&quot;&gt; //没有指定媒体所以全局应用</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;screen<span class="selector-class">.css</span>&quot; media=&quot;screen&quot;&gt; //在屏幕设备</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;print<span class="selector-class">.css</span>&quot; media=&quot;print&quot;&gt; //在打印设备</span><br><span class="line"> <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;screen<span class="selector-class">.css</span>&quot; media=&quot;screen,print&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、-import"><a href="#3、-import" class="headerlink" title="3、@import"></a>3、@import</h4><ul><li><p>相比于link，我们更多的时候是针对页面中某块区域，来单独写个样式控制其响应</p></li><li><p>此时就可以在文件中<strong>引入一个样式文件</strong>，在这个文件中<strong>再引入其他媒体的样式文件。</strong>用<code>@import</code> ，引入指定设备的样式规则。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style<span class="selector-class">.css</span>&quot;&gt;  //这样就可以只有一个link了</span><br></pre></td></tr></table></figure><p><strong>style.css</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(screen.css) screen;</span><br><span class="line"><span class="keyword">@import</span> url(print.css) print;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(screen.css) screen,print; <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4、-media"><a href="#4、-media" class="headerlink" title="4、@media"></a>4、@media</h4><ul><li> <code>@media</code> 可以做到更细的控制，即<strong>在一个样式表中为多个媒体设备定义样式</strong></li></ul>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype 关键字 (media feature)  &#123;...&#125;</span><br><span class="line"><span class="keyword">@media</span> screen,print &#123;...&#125;  <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br><span class="line"></span><br><span class="line">media (<span class="attribute">min-width</span>: <span class="number">500px</span>), (max-width: <span class="number">700px</span>) &#123;....&#125;</span><br><span class="line">media only screen and (<span class="attribute">min-width</span>: <span class="number">500px</span>) and (max-width: <span class="number">700px</span>) &#123;....&#125;</span><br></pre></td></tr></table></figure><ul><li><p>mediatype：常用媒体类型还是screen</p><ul><li>all：所有媒体类型</li><li>screen：电脑屏幕，平板电脑，智能手机等</li><li>print：打印设备</li><li>speech：屏幕阅读器等发声设备</li></ul></li><li><p>and|or|not|only：关键字，实际使用3选1</p><ul><li>not：必须将not写在查询的最前面，表示不应用样式，即所有条件<strong>都满足</strong>时<strong>不应用</strong>样式</li><li>only：用来排除不支持媒体查询的浏览器<ul><li>only 和 not 一样只能出现在媒体查询的开始</li><li>对支持媒体查询的设备，正常调用样式，此时就当only不存在</li><li>对不支持媒体查询的设备不使用样式</li></ul></li></ul></li><li><p>media feature：width、min-width、max-width（布局视口的宽度、最小宽度…）</p></li><li><p>断点：样式切换的分界点，常用断点</p><ul><li>小于768 超小屏幕     大于768 小屏幕   大于992 中型屏幕    大于1200 大屏幕</li></ul></li></ul><h4 id="5、查询条件"><a href="#5、查询条件" class="headerlink" title="5、查询条件"></a>5、查询条件</h4><ul><li><p>可以使用不同条件限制使用的样式，条件表达式需要放在<strong>扩号</strong>中</p></li><li><p>style：设置查询条件的媒体查询：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style media=&quot;screen and (<span class="attribute">min-width</span>: <span class="number">768px</span>),screen and (orientation:landscape)<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">/*  orientation 属性可以定义设备的方向 */</span></span><br><span class="line"><span class="string">/* portrait竖屏设备即高度大于宽度    landscape横屏设备即宽度大于高度*/</span></span><br><span class="line"><span class="string">  body &#123;</span></span><br><span class="line"><span class="string">    color: blue;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>@media：设置查询条件的媒体查询：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#8e44ad</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、rem布局"><a href="#2、rem布局" class="headerlink" title="2、rem布局"></a>2、rem布局</h3><ul><li>作用：当设备尺寸发生改变的时候，等比例适配当前设备</li><li>rem计算：1rem = HTML的font-size  也是:root的font-size<ul><li>HTML的font-size：屏幕宽度 / 划分的份数</li></ul></li><li>做法：<ul><li>不同的媒体查询方式，不同的设备设置不同的HTML的font-size</li><li>然后页面元素用rem做尺寸单位</li><li>当html字体大小变化，元素尺寸也会发生变化，从而达到等比缩放的效果</li></ul></li></ul><h3 id="3、vw适配"><a href="#3、vw适配" class="headerlink" title="3、vw适配"></a>3、vw适配</h3><ul><li><p><code>vh、vw</code>方案即将视觉视口宽度 <code>window.innerWidth</code>和视觉视口高度 <code>window.innerHeight</code> 等分为 100 份。</p><ul><li><code>1vw</code>等于视觉视口的<code>1%</code>，<code>1vh</code> 为视觉视口高度的<code>1%</code></li><li><code>vmin</code> : <code>vw</code> 和 <code>vh</code> 中的较小值、较大值</li><li>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 3.75 = 20vw</code></li></ul></li><li><p>缺陷：</p><ul><li><code>px</code>转换成<code>vw</code>不一定能完全整除，因此有一定的像素差。</li><li>比如当容器使用<code>vw</code>，<code>margin</code>采用<code>px</code>时，很容易造成整体宽度超过<code>100vw</code>，从而影响布局效果。当然我们也是可以避免的，例如使用<code>padding</code>代替<code>margin</code>，结合<code>calc()</code>函数使用等等…</li></ul></li></ul><h3 id="4、视口"><a href="#4、视口" class="headerlink" title="4、视口"></a>4、视口</h3><h4 id="1、viewport的概念"><a href="#1、viewport的概念" class="headerlink" title="1、viewport的概念"></a>1、viewport的概念</h4><ul><li><p>通俗的讲，移动设备上的viewport：就是设备的<strong>屏幕上能用来显示网页的那块区域：</strong></p></li><li><p>但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大或小；</p></li><li><p>默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的：</p><ul><li>因为考虑到移动设备的分辨率相对于桌面来说都较小；</li><li>所以为了能在移动设备上正常显示为传统的为桌面设计的网站；</li><li>移动设备上的浏览器都会把自己默认的viewport设为980px或其他值</li><li>但后果就是浏<strong>览器会出现横向滚动条</strong>，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/18030682-a963ada3b9aed8fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/653/format/webp" alt="img"></p><h4 id="2、css的1px-设备1px"><a href="#2、css的1px-设备1px" class="headerlink" title="2、css的1px !== 设备1px"></a>2、css的1px !== 设备1px</h4><p>css中的像素只是一个抽象单位，在不同的设备或环境中<strong>，css中的1px代表的设备物理像素是不同的</strong></p><ul><li><p>css中一般使用px作为单位，对应电脑浏览器就是1px，一个物理像素；</p></li><li><p>但<strong>移动设备</strong>中并非如此：</p><ul><li>早期设备，屏幕像素比低。iphone3分辨率为320x480，一个css像素等于一个屏幕物理像素</li><li>但后期苹果推出了Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化：<ul><li>这意味着，同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的；</li></ul></li></ul></li><li><p><strong>用户缩放行为：</strong></p><ul><li>当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；</li><li>反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍</li></ul></li><li><p>**devicePixelRatio(设备像素比)**属性：window对象的</p><ul><li>设备物理像素和设备独立像素的比例，也就是 <strong>dpr = dp/ dips</strong>：<ul><li> <strong>dp(device pixels)：</strong>设备物理像素        css中的px</li><li> <strong>dips(device-independent pixels)：</strong>设备独立像素，dips = css像素/scale（缩放比例），所以dpr=(dp/css像素)*scale</li></ul></li><li>因此，通过devicePixelRatio可以知道该设备上一个css像素代表多少个物理像素。</li><li>但注意的是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题</li></ul></li></ul><h4 id="3、布局视口"><a href="#3、布局视口" class="headerlink" title="3、布局视口"></a>3、布局视口</h4><img src="https:////upload-images.jianshu.io/upload_images/18030682-07a1ff787499c9f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/497/format/webp" alt="img" style="zoom:50%;" /><ul><li><p>出现的目的：</p><p>浏览器默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。</p><ol><li>首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即便不是专为移动设备设计的网页</li><li>但移动设备的屏幕都不是很宽，如果以浏览器的可视区域作为viewport的话，那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团</li><li>因此，。。。</li></ol></li><li><p>ppk把这个浏览器默认的viewport叫做<strong>layout viewport(布局视口)</strong></p></li><li><p>获取：<code>document.documentElement.clientWidth / clientHeight</code></p></li></ul><h4 id="4、视觉视口"><a href="#4、视觉视口" class="headerlink" title="4、视觉视口"></a>4、视觉视口</h4><img src="https:////upload-images.jianshu.io/upload_images/18030682-d92903bf680a85cd.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp" alt="img" style="zoom:50%;" /><ul><li>layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 <strong>浏览器可视区域的大小</strong>：<strong>视觉视口</strong></li><li>用户可以缩放来查看网站的内容。<ul><li>缩小网站，看到的网站区域将变大，此时视觉视口也变大了，反之亦然</li><li>不管用户如何缩放，都不会影响到布局视口的宽度</li></ul></li><li>调用<code>window.innerWidth / innerHeight</code>来获取</li></ul><h4 id="5、理想视口"><a href="#5、理想视口" class="headerlink" title="5、理想视口"></a>5、理想视口</h4><ul><li><p>现在主流网站会为移动设备单独的设计，所以必须还要有一个能完美适配移动设备的viewport</p></li><li><p>完美适配指的是：</p><ol><li>不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；</li><li>显示的文字（图片等）的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清</li><li>理想的情况是这段14px的文字无论是在何种密度屏，何种分辨率，显示出来的都差不多的</li></ol></li><li><p><code>window.screen.width / height</code>来获取</p></li><li><p>ideal viewport 并没有固定的尺寸，不同的设备有不同的 ideal viewport：</p><ul><li><p>所有的 iphone 的 ideal viewport 宽度都是 320px，无论它的屏幕宽度是 320 还是 640</p></li><li><p>也就是说，在 iphone 中，css 中的 320px 就代表 iphone 屏幕的宽度。</p><img src="https:////upload-images.jianshu.io/upload_images/18030682-8a400bd06174edfa.png?imageMogr2/auto-orient/strip|imageView2/2/w/270/format/webp" alt="img" style="zoom:33%;" /></li></ul></li><li><p>这3类视口， ideal viewport 是最适合移动设备的viewport：只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。</p></li><li><p>ideal viewport 的意义：</p><p>无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。</p></li></ul><h3 id="5、meta标签"><a href="#5、meta标签" class="headerlink" title="5、meta标签"></a>5、meta标签</h3><h4 id="标准写法："><a href="#标准写法：" class="headerlink" title="标准写法："></a>标准写法：</h4><ul><li><p>移动设备<strong>默认的viewport是layout viewport</strong>，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport，常见的作法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>该meta标签的作用：</p><p>让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。</p></li><li><p>meta viewport 标签：在苹果的规范中，meta viewport 有6个属性</p><p>安卓还支持 target-densitydpi 私有属性，表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素，即将废弃。</p><img src="https:////upload-images.jianshu.io/upload_images/18030682-839f41e5291f76f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/549/format/webp" alt="img" style="zoom:50%;" /><p><img src="https://upload-images.jianshu.io/upload_images/18030682-76c58332c2eefc4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/657/format/webp" alt="img"></p></li></ul></li></ul><h4 id="不同的写法："><a href="#不同的写法：" class="headerlink" title="不同的写法："></a>不同的写法：</h4><ol><li> 这样写也能达到同样的效果：为什么？</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  // IE 会横竖屏不分</span><br></pre></td></tr></table></figure><ul><li>因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果；</li><li>因为缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport吗</li></ul><ol start="2"><li><strong>但如果 width 和 initial-scale=1 同时出现，并且还出现了冲突呢？</strong>比如：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=400, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  // iphone、ipad会横竖屏不分</span><br></pre></td></tr></table></figure><ul><li><p>width=400：把当前viewport的宽度设为400px</p></li><li><p>initial-scale=1：把当前viewport的宽度设为ideal viewport的宽度，<code>= 理想视口宽度 / 视觉视口宽度</code></p></li><li><p><strong>当遇到这种情况时，浏览器会取它们两个中较大的那个值</strong>：</p><p>ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度</p></li></ul><h4 id="用户缩放："><a href="#用户缩放：" class="headerlink" title="用户缩放："></a>用户缩放：</h4><p><code>initial-scale= 理想视口宽度 / 视觉视口宽度</code></p><ul><li><p>缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。</p><p>例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了</p><ul><li>原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了</li></ul></li><li><p>另一点，initial-scale：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</p></li></ul><h3 id="6、rem、em、vm"><a href="#6、rem、em、vm" class="headerlink" title="6、rem、em、vm"></a>6、rem、em、vm</h3><ul><li><p>px：像素，固定</p></li><li><p>em：</p><ul><li>相对于自己的字体大小；有继承的属性</li><li>如果自己没有，<strong>相对于父元素字体大小</strong></li></ul></li><li><p>rem：相对于<strong>根元素的字体font-size大小</strong>,任意浏览器默认字体都是16px</p><ul><li>html根元素的获取方式 <code>document.getElementsByTagName(&#39;html&#39;)[0]</code></li><li>Htmlfont-size：屏幕宽度 / 划分的份数</li><li>页面元素的rem值：页面元素值（px）/（屏幕宽度 / 划分的份数）</li></ul></li><li><p>百分比：</p><ul><li>用在字体中，相对于<strong>父元素</strong>字体大小</li><li>用在尺寸中，相对于父元素的width和height</li></ul></li><li><p>vm、vh</p><ul><li><code>1vw</code>等于视觉视口的<code>1%</code>，<code>1vh</code> 为视觉视口高度的<code>1%</code></li><li>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 3.75 = 20vw</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的常见布局</title>
      <link href="/2021/12/09/CSS%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/"/>
      <url>/2021/12/09/CSS%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><h3 id="1-左定宽右适应-6种"><a href="#1-左定宽右适应-6种" class="headerlink" title="1. 左定宽右适应                              6种"></a>1. 左定宽右适应                              6种</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box-left&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box-right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>解法1：float+margin，利用浮动，这样两侧就在同一行了，因为左侧宽度已知，那么右侧margin-left等于左侧宽度即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line"> height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &gt; div &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  float: left;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-right &#123;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：flex布局，其实和两栏自适应的方法二一模一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  height: 200px;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &gt; div &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-right &#123;</span><br><span class="line">  flex: 1; // 设置flex-grow属性为1，默认为0</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法3：float+overflow</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line"> height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &gt; div &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  float: left;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-right &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法4：cal计算</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">200px</span>);</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法5：左侧绝对定位，脱离标准流，那么两侧就能在同一行，右侧margin-left等于左侧宽度</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-right</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法6:右侧绝对定位，那么两侧就能在同一侧，右侧定位的时候要把left等于左侧宽度</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-left</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-right</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-两列自适应"><a href="#2-两列自适应" class="headerlink" title="2. 两列自适应"></a>2. <strong>两列自适应</strong></h3><p><strong>左侧宽度由内容撑开，右侧撑满剩余宽度</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outter&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">  如果是普通的两列布局，浮动+普通元素的margin便可以实现，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    但如果是自适应的两列布局，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    利用float+overflow:hidden便可以实现，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    这种办法主要通过overflow触发BFC,<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    而BFC不会重叠浮动元素。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>方法一：左侧浮动，右侧BFC</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outter</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left; //关键</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">overflow</span>: hidden; //关键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：flex布局，右侧flex-grow:1，使其能放大，从而占满剩余宽度</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outter</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;  //关键</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>flex-grow</strong></p><ul><li><p>定义item的放大比例，<strong>默认值为0，如果有空余空间也不会放大</strong>。</p></li><li><p>container在main axis方向上<strong>有剩余空间</strong>时，才生效</p></li><li><p>如果item的flex-grow总和sum&gt;1，每个item<strong>扩展的size</strong>为</p><p>container剩余size*flex-grow/sum</p></li></ul><p>如果所有项目的flex-grow属性都为1，则它们将<strong>等分剩余空间</strong>（如果有的话）。</p><p>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的<strong>剩余空间</strong>将比其他项多一倍。</p></li></ul><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><h3 id="1-三栏自适应"><a href="#1-三栏自适应" class="headerlink" title="1.三栏自适应"></a>1.三栏自适应</h3><p><strong>中间自适应宽度，两侧固定宽度</strong></p><h4 id="1-圣杯布局"><a href="#1-圣杯布局" class="headerlink" title="1.圣杯布局"></a><strong>1.圣杯布局</strong></h4><ul><li>结构</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;center&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //center在前面，从而最先渲染出来</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;right&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>实现步骤</p><ul><li>center、right、left均为<code>float:left</code>，center宽度100%，则独自占据一行</li><li>left和right设置负margin，使得和center同一行</li><li>包裹三者的container设置padding-left和padding-right，为left和right留位置</li><li>left和right设置相对定位，移到container留出的空白位置中</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  //为<span class="attribute">left</span>和<span class="attribute">right</span>留位置</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;  </span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-双飞翼布局"><a href="#2-双飞翼布局" class="headerlink" title="2.双飞翼布局"></a><strong>2.双飞翼布局</strong></h4><ul><li><p>结构</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&#x27;container&#x27;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;center&#x27;&gt; //center在前面，从而最先渲染出来</span><br><span class="line">      &lt;<span class="selector-tag">div</span> class=&#x27;inner&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">left</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">right</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>实现步骤</p><ul><li>center、right、left均为<code>float:left</code>，center宽度100%，则独自占据一行</li><li>left和right设置负margin，使得和center同一行</li><li>inner设置<code>margin:0 200px</code>，为left和right留位置</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-flex布局⭐️⭐️"><a href="#3-flex布局⭐️⭐️" class="headerlink" title="3.flex布局⭐️⭐️"></a><strong>3.flex布局</strong>⭐️⭐️</h4><ul><li><p>结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;center&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  //center在前面，从而最先渲染出来</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;right&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实现步骤</p><ul><li>container设置flex</li><li>此时显示center、left、right的顺序，要把center调整到中间，设置left和right的order属性</li><li>center要扩充页面剩余部分，故<code>flex-grow: 1;</code></li><li>left和right宽度通过flex-basis设置，从而在拓宽center前宽度正常</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;//<span class="attribute">flex-grow</span>:<span class="number">0</span>;<span class="attribute">flex-shrink</span>:<span class="number">0</span>;<span class="attribute">flex-basis</span>:<span class="number">200px</span></span><br><span class="line"></span><br><span class="line">  width: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-非自适应"><a href="#2-非自适应" class="headerlink" title="2. 非自适应"></a><strong>2. 非自适应</strong></h3><ul><li><p>流式布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&#x27;container&#x27;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">left</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">right</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;center&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;  //center最后渲染</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">210px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">210px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BFC</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&#x27;container&#x27;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">left</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">right</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;center&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;  //center最后渲染</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;   //center变成BFC，不会与浮动元素重叠</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>绝对定位</p><ul><li>container相对定位，子元素left和right绝对定位</li><li>center设置margin为left和right留位置</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&#x27;container&#x27;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;center&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt; //center可以先渲染</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">left</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">right</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;  //脱离了文档流，后代元素也脱离了文档流，高度未知会有问题</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
