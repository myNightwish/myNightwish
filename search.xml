<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>来跟我玩个游戏吧~</title>
      <link href="/posts/privateGame.html"/>
      <url>/posts/privateGame.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉,夸奖力度不足，所以密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="29af94e1f9f2900bf007285c03100bc9894efcf28dac03f7df367dbc5eb38e9e">dd71236f3cb77f11acf8f54e1793814c37dbc9ad88ea683b923a1081e89a7bf067ab4840291a3649ae8e84c4a9c41d09a41515cf3233488f60ab26c81958817b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">有东西被加密了, 请输入密码(夸奖博主)才能查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配方案总结</title>
      <link href="/posts/855735627.html"/>
      <url>/posts/855735627.html</url>
      
        <content type="html"><![CDATA[<h2 id="移动端适配">移动端适配<a class="anchor" href="#移动端适配">·</a></h2><blockquote><p>前言：最近公司官网项目需要做移动端适配，所以借此机会对移动端的适配方案进行调研。本期分享内容主要包括一下几点：</p><ol><li>我们为什么要做适配？<ul><li>这里涉及适配的前置概念：例如像素、dpr等</li></ul></li><li>如何适配？<ul><li>都有哪些适配方案？</li><li>它们是如何工作的？</li></ul></li><li>对不同的项目需求，我们做技术评审时如何选择合适的方案？</li></ol></blockquote><h3 id="1、前置知识">1、前置知识<a class="anchor" href="#1、前置知识">·</a></h3><h4 id="1-1-尺寸、像素">1.1 尺寸、像素<a class="anchor" href="#1-1-尺寸、像素">·</a></h4><blockquote><h5 id="英寸：">英寸：<a class="anchor" href="#英寸：">·</a></h5><ul><li>描述屏幕尺寸的物理单位，且是屏幕对角线的长度</li><li>英寸和厘米的换算单位是：<code>1英寸 = 2.54厘米</code></li></ul><h5 id="像素：">像素：<a class="anchor" href="#像素：">·</a></h5><ul><li>具有特定的位置和颜色的小方块，而图片、电子屏幕是由无数个像素拼接而成的</li><li>可以说，作为图片或电子屏幕的最小组成单位</li></ul></blockquote><h4 id="1-2-分辨率">1.2 分辨率<a class="anchor" href="#1-2-分辨率">·</a></h4><h5 id="1-2-1-屏幕分辨率：">1.2.1 屏幕分辨率：<a class="anchor" href="#1-2-1-屏幕分辨率：">·</a></h5><ul><li>指一个屏幕具体由多少个像素点组成，比如：<code>iPhone XS Max</code> 和 <code>iPhone SE</code>的分辨率分别为<code>2688 x 1242</code>和<code>1136 x 640</code>。这表示手机分别在垂直和水平上所具有的像素点数。</li><li>分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。这是很好理解的嘛~必须以用一尺寸在有比较的意义</li></ul><h5 id="1-2-2-图像分辨率：">1.2.2 图像分辨率：<a class="anchor" href="#1-2-2-图像分辨率：">·</a></h5><ul><li>是指图片含有的<code>像素数</code>，比如一张图片的分辨率为<code>800 x 400</code>。这表示图片分别在垂直和水平上所具有的像素点数为<code>800</code>和<code>400</code></li><li>同一尺寸的图片，分辨率越高，图片越清晰</li></ul><h5 id="1-2-3-PPI">1.2.3 PPI<a class="anchor" href="#1-2-3-PPI">·</a></h5><ul><li><p><code>PPI(Pixel Per Inch)</code>：每英寸包括的像素数，描述<strong>屏幕的清晰度</strong>以及一张图片的质量</p></li><li><p><code>PPI</code>越高，屏幕、图片越清晰：</p><p><code>iPhone XS Max</code> 和 <code>iPhone SE</code>的<code>PPI</code>分别为<code>458</code>和<code>326</code>，前者屏幕更清晰</p></li></ul><h5 id="1-2-4-DPI">1.2.4 DPI<a class="anchor" href="#1-2-4-DPI">·</a></h5><ul><li><code>DPI(Dot Per Inch)</code>：即每英寸包括的点数。</li><li>这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点、打印机的墨点</li><li>常用于描述打印机：<ul><li>当打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是<code>DPI</code>所描述的：打印点的密度</li><li>打印机的<code>DPI</code>越高，打印图像的精细程度就越高，会消耗更多的墨点和时间</li></ul></li></ul><h4 id="1-3-像素">1.3 像素<a class="anchor" href="#1-3-像素">·</a></h4><h5 id="1-3-1-物理像素">1.3.1 物理像素<a class="anchor" href="#1-3-1-物理像素">·</a></h5><ul><li>其实就是设备上真实的物理单元，上面我们描述的像素都是<code>物理像素</code><ul><li>显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色使屏幕显示出不同的图像</li></ul></li><li>从屏幕出厂的那天起，它的物理像素点就确定了，</li></ul><h5 id="1-3-2-设备独立像素">1.3.2 设备独立像素<a class="anchor" href="#1-3-2-设备独立像素">·</a></h5><blockquote><p>智能机初期，分辨率低：</p><ul><li>比如<code>iPhone3</code>，分辨率是<code>320x480</code>，看到的内容都是“真实”的，<code>1px = 1px</code>，<code>iPhone3</code>屏幕上最多只能展示一个<code>320px</code>宽的元素</li><li>但仔细观察，会在<code>iPhone3</code>的屏幕上发现有很多细小的发光点，也即是“颗粒感”。这一颗一颗的发光点就是真实的像素物理单元，也就是物理像素</li></ul><p>后期高分辨率手机出现：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/17/16ac3a6576e564d5~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="iPhone3和iPhone4对比" style="zoom: 25%;" /><ul><li><code>iPhone4</code>分辨率是<code>640*960</code>，正好是<code>iPhone3</code>的两倍。然而尺寸是一样的</li><li><code>iPhone4</code>是怎么做到把两倍的分辨率使用在同一物理尺寸的屏幕上的呢？<ul><li>按理说，因为它的分辨率提高了一倍：白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍。但事实并不是</li><li>不管分辨率多高，他们所展示的界面比例都是基本类似的</li></ul></li></ul><p>原因：</p><ul><li>在<code>iPhone4</code>使用的视网膜屏幕中，把<code>2x2</code>个像素当1个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。</li><li>比如列表的宽度为300个像素：</li><li>在一条水平线上，白色手机会用300个物理像素去渲染它，而黑色手机实际上会用600个物理像素去渲染它</li></ul><p>因此：设备独立像素的概念出来了</p><ul><li>我们需要用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少。设备独立像素(Device Independent Pixels)简称<code>DIP</code>或<code>DP</code>就是做这件事的</li><li>列表的宽度为300个像素，实际上可以说：列表的宽度为300个设备独立像素</li></ul><p><code>chrome</code>的devtools：</p><ul><li>模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸；</li><li>比如<code>iPhone X</code>显示的尺寸是<code>375x812</code>，实际<code>iPhone X</code>的分辨率会比这高很多，这里显示的就是设备独立像素。</li></ul></blockquote><h5 id="1-3-3-设备像素比（dpr）">1.3.3 设备像素比（dpr）<a class="anchor" href="#1-3-3-设备像素比（dpr）">·</a></h5><ul><li><p>即物理像素和设备独立像素的比值，获取方法：</p><ol><li><p><code>window.devicePixelRatio</code>的api</p></li><li><p>通过媒体查询<code>min-device-pixel-ratio</code>，区分<code>dpr</code>：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>),(<span class="attribute">min-device-pixel-ratio</span>: <span class="number">2</span>)&#123; &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>从苹果提出视网膜屏幕开始，才出现设备像素比这个概念。由于<code>Android</code>屏幕尺寸、分辨率高低跨度非常大，所以，为保证各种设备的显示效果，<code>Android</code>按照设备的像素密度将设备分成了几个区间：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/17/16ac3a6649f8d53a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom: 25%;" /><ul><li>所有的<code>Android</code>设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以各种<code>Android</code>设备仍然不能做到在展示上完全相等</li></ul></li></ul><h5 id="1-3-4-像素-px">1.3.4 像素 px<a class="anchor" href="#1-3-4-像素-px">·</a></h5><blockquote><p>在CSS规范中，长度单位可以分为两类，绝对单位、相对单位。</p><ul><li>px是一个相对单位，相对的是设备像素(<code>device pixel</code>)，满足：<ol><li>同一设备，每1个CSS像素代表的物理像素是可以变化的(即CSS像素的第一方面的相对性)</li><li>不同设备间，每1个CSS像素所代表的物理像素是可以变化的(即CSS像素的第二方面的相对性)</li></ol></li><li>css像素是一种虚拟像素，可以理解为“直觉”像素，单位是<code>px</code></li><li>浏览器内的一切长度都是以CSS像素为单位的，所以CSS和JS使用的抽象单位</li></ul></blockquote><p>在移动端浏览器中以及某些桌面浏览器中，<code>window</code>对象有一个<code>devicePixelRatio</code>(设备像素比)属性，而它的官方的定义为：设备物理像素和设备独立像素的比例： <code>dpr = dp / dips</code></p><ul><li>设备独立像素，<code>dips = css像素 / scale（缩放比例）</code>，在没有缩放的情况下，1个css像素等同于一个设备独立像素</li><li>CSS像素在视觉上可以改变大小：比如缩放浏览器页面，就是改变的CSS像素：<ul><li>当放大一倍，那么一个CSS像素在横向、纵向上会覆盖两个设备独立像素</li><li>例如宽度<code>100px</code>，当页面放大一倍，它会在横向上由原本占据100个设备独立像素，变成占据200个设备独立像素；如果缩小，则恰好相反，只能占据50个设备独立像素</li></ul></li><li>无论CSS像素是缩小还是放大，它是像素数目是不变的，比如<code>100px</code>，无论缩放，它依然是<code>100px</code>，只不过它占据的设备独立像素发生了变化（体积发生了变化，视觉大小上发生了变化而已）</li></ul><h4 id="1-4-视口viewport：">1.4 视口viewport：<a class="anchor" href="#1-4-视口viewport：">·</a></h4><blockquote><p>表示的是用户网页的可视范围（指页面能够被浏览的范围）</p></blockquote><h5 id="1-4-1-布局视口">1.4.1 布局视口<a class="anchor" href="#1-4-1-布局视口">·</a></h5><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce11243ea8b54da68c1b899a235c83d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom: 25%;" /><blockquote><p>为什么会有布局视口？</p><ul><li>移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为<code>viewport</code>的话，那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的<code>viewport</code>太窄，而挤作一团，甚至布局什么的都会乱掉</li><li>如果把移动设备上浏览器的可视区域设为<code>viewport</code>的话，某些网站就会因为<code>viewport</code>太窄而显示错乱</li><li>所以这些浏览器就决定**默认情况下把<code>viewport</code>设为一个较宽的值，比如<code>980px</code>，**这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了</li><li>ppk把这个<strong>浏览器默认的viewport</strong>叫做<code>layout viewport</code>(布局视口)</li><li>获取：<code>document.documentElement.clientWidth / clientHeight</code></li></ul><p>布局视口是网页布局的基准窗口：</p><ul><li><p>在<code>PC</code>上，布局视口就等于当前浏览器的窗口大小（不包括<code>borders</code> 、<code>margins</code>、滚动条）</p></li><li><p>在移动端，布局视口被赋予一个默认值，大部分为<code>980px</code>，这保证<code>PC</code>的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大</p></li></ul></blockquote><h5 id="1-4-2-视觉视口：">1.4.2 视觉视口：<a class="anchor" href="#1-4-2-视觉视口：">·</a></h5><blockquote><p>将<code>layout viewport</code>想象为一个不会改变大小或形状的大图像。现在想象你有一个较小的框架，通过它你可以看到这个大图片。小框架由不透明的材料构成，通过它你只能看到大图像的一部分，这一部分就叫做 <code>visual viewport</code> .你可以拿着这个框架和图像拉开一定的距离(zoom out)看到整个图像，你也可以让自己离图像更近(zoom in)看到其中的一部分。你也可以旋转这个框架的方向，但是这个图片(<code>layout viewport</code>)的大小和形状永远不会改变。</p></blockquote><img src="https:////upload-images.jianshu.io/upload_images/18030682-d92903bf680a85cd.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp" alt="img" style="zoom:50%;" /><blockquote><p>布局视口宽度是大于浏览器可视区域的宽度的，所以还需要一个<code>viewport</code>来代表 <strong>浏览器可视区域的大小</strong>：<strong>视觉视口</strong></p><ul><li>用户可以缩放来查看网站的内容。<ul><li>缩小网站，看到的网站区域将变大，此时视觉视口也变大了，反之亦然</li><li>不管用户如何缩放，都不会影响到布局视口的宽度</li></ul></li><li>调用<code>window.innerWidth / innerHeight</code>来获取</li></ul></blockquote><h5 id="1-4-3-理想视口">1.4.3 理想视口<a class="anchor" href="#1-4-3-理想视口">·</a></h5><blockquote><p>为什么会有它？</p><ul><li><p>越来越多的网站都会为移动设备单独设计，所以必须还要有一个能完美适配移动设备的<code>viewport</code></p></li><li><p>理想视口并没有固定的尺寸，不同的设备理想视口不同：</p><p>只要在css中把某一元素的宽度设为<code>ideal viewport</code>的宽度(单位用<code>px</code>)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为<code>100%</code>的效果</p></li><li><p><code>deal viewport</code> 的意义在于，无论在何种分辨率的屏幕下，那些针对<code>ideal viewport</code> 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户</p></li><li><p><code>window.screen.width / height</code>来获取</p></li></ul><p>完美适配指的是:</p><ol><li>首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；</li><li>显示的文字的大小是合适，比如一段<code>14px</code>大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段<code>14px</code>的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。</li></ol></blockquote><h5 id="1-4-4-Meta-viewport">1.4.4 Meta viewport<a class="anchor" href="#1-4-4-Meta-viewport">·</a></h5><blockquote><p><meta> 元素表示那些不能由其它HTML元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面</p><p>借助<code>&lt;meta&gt;</code>元素的<code>viewport</code>来设置视口、缩放等，从而让移动端得到更好的展示效果</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条</p></li><li><p>缩放：</p><ul><li><p>缩放是相对于<strong>理想视口</strong>来缩放的，缩放值越大，当前viewport的宽度就会越小</p><p>例如在iphone中，理想视口的宽度是320px，如果设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了</p><ul><li>原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了</li></ul></li><li><p>另一点，initial-scale：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</p></li></ul></li><li><p>这样写也能达到同样达到了<strong>理想视口</strong>的效果：为什么？</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1&quot;</span>&gt;</span> // IE 会横竖屏不分</span><br></pre></td></tr></table></figure><ul><li>因为缩放是相对于 <strong>理想视口</strong>来缩放的，当缩放值为1，不就是<strong>理想视口吗</strong></li></ul></li><li><p>**但如果 width 和 initial-scale=1 同时出现，并且还出现了冲突呢？**比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=400, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  //iphone、ipad会横竖屏不分</span><br></pre></td></tr></table></figure><ul><li>width=400：把当前viewport的宽度设为400px</li><li>initial-scale=1：把当前viewport的宽度设为<strong>理想视口</strong>的宽度，<code>= 理想视口宽度 / 视觉视口宽度</code></li><li>**当遇到这种情况时，浏览器会取它们两个中较大的那个值：</li><li>width=400，<strong>理想视口</strong>宽度为320时，取的是400；理想视口<strong>宽度为480时，取的是</strong>480</li></ul></li></ul><table><thead><tr><th><code>Value</code></th><th>可能值</th><th>描述</th></tr></thead><tbody><tr><td><code>width</code></td><td>正整数或<code>device-width</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的宽度。</td></tr><tr><td><code>height</code></td><td>正整数或<code>device-height</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的高度。</td></tr><tr><td><code>initial-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义页面初始缩放比率=<code>理想视口宽度 / 视觉视口宽度</code></td></tr><tr><td><code>minimum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最小值；必须小于或等于<code>maximum-scale</code>的值。</td></tr><tr><td><code>maximum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最大值；必须大于或等于<code>minimum-scale</code>的值。</td></tr><tr><td><code>user-scalable</code></td><td>一个布尔值（<code>yes</code>或者<code>no</code>）</td><td>如果设置为 <code>no</code>，用户将不能放大或缩小网页。默认值为 yes。</td></tr></tbody></table><h4 id="1-5-获取浏览器大小">1.5 获取浏览器大小<a class="anchor" href="#1-5-获取浏览器大小">·</a></h4><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21f5c4626ccf481cb0e026a8608e7284~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:33%;" /><blockquote><ul><li><code>window.innerHeight</code>：浏览器视觉视口高度（包括垂直滚动条）。</li><li><code>window.outerHeight</code>：浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。</li></ul></blockquote><blockquote><ul><li><code>window.screen.Height</code>：获取获屏幕取理想视口高度，这个数值是固定的，`设备的分辨率/设备像素比</li><li><code>window.screen.availHeight</code>：浏览器窗口可用的高度</li></ul></blockquote><blockquote><ul><li><code>document.documentElement.clientHeight</code>：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距</li><li><code>document.documentElement.offsetHeight</code>：包括内边距、滚动条、边框和外边距。</li><li><code>document.documentElement.scrollHeight</code>：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与<code>clientHeight</code>相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条</li></ul></blockquote><h4 id="1-6-rem、em、vm">1.6 rem、em、vm<a class="anchor" href="#1-6-rem、em、vm">·</a></h4><ul><li><p>px：像素，固定</p></li><li><p>em：</p><ul><li>相对于自己的字体大小；有继承的属性</li><li>如果自己没有，<strong>相对于父元素字体大小</strong></li></ul></li><li><p>rem：相对于<strong>根元素的字体font-size大小</strong>,任意浏览器默认字体都是16px</p><ul><li>html根元素的获取方式 <code>document.getElementsByTagName('html')[0]</code></li><li>Htmlfont-size：屏幕宽度 / 划分的份数</li><li>页面元素的rem值：页面元素值（px）/（屏幕宽度 / 划分的份数）</li></ul></li><li><p>百分比：</p><ul><li>用在字体中，相对于<strong>父元素</strong>字体大小</li><li>用在尺寸中，相对于父元素的width和height</li></ul></li><li><p>vm、vh</p><ul><li><code>1vw</code>等于视觉视口的<code>1%</code>，<code>1vh</code> 为视觉视口高度的<code>1%</code></li><li>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 3.75 = 20vw</code></li></ul></li></ul><h3 id="2、Why适配？">2、Why适配？<a class="anchor" href="#2、Why适配？">·</a></h3><blockquote><p>其实，到这里已经有了第一种适配方案：meta标签的做法。但我认为这种方案只适合纯移动端web页面，并不合适与PC端的页面：尤其是pc端与web端不完全相同的布局：</p><ul><li>我们可以在官网项目中验证：</li></ul><p>但尽管我们可以使用设备独立像素来保证各个设备在不同手机上显示的效果类似，但这并不能保证它们显示完全一致，我们需要一种方案来让设计稿得到更完美的适配</p></blockquote><h4 id="常见的布局方案">常见的布局方案<a class="anchor" href="#常见的布局方案">·</a></h4><h5 id="固定布局：">固定布局：<a class="anchor" href="#固定布局：">·</a></h5><ul><li>做法1：<strong>以像素作为页面的基本单位</strong>，不管设备屏幕及浏览器宽度，只设计一套尺寸；</li><li>做法2：同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过识别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局；</li></ul><h5 id="弹性布局：">弹性布局：<a class="anchor" href="#弹性布局：">·</a></h5><ul><li><strong>以百分比作为页面的基本单位</strong>，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；</li></ul><h5 id="混合布局：">混合布局：<a class="anchor" href="#混合布局：">·</a></h5><ul><li>同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；<strong>只是混合像素、和百分比两种单位作为页面单位</strong>。</li></ul><h5 id="布局响应：">布局响应：<a class="anchor" href="#布局响应：">·</a></h5><ul><li><p><strong>对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计</strong></p></li><li><p>有两种方式：</p><ul><li>pc优先（从pc端开始向下设计）；</li><li>移动优先（从移动端向上设计）；</li></ul><p>无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点）</p></li></ul><h3 id="3、How适配-pc">3、How适配-pc?<a class="anchor" href="#3、How适配-pc">·</a></h3><h4 id="3-1-viewport方案">3.1 viewport方案<a class="anchor" href="#3-1-viewport方案">·</a></h4><blockquote><p>对设计稿还原时不关注屏幕尺寸的差异，而是直接按设计稿的标注来开发。</p><ul><li><p>比如设计稿里标注的文字字号是30px，CSS里就设置文字字号30px。</p></li><li><p>页面开发好后，在HTML的head标签里加入 <meta name="viewport" content="width={设计稿宽度}, initial-scale={屏幕逻辑像素宽度/设计稿宽度}" ></p><ul><li><p>设计稿宽度是750px，设计稿上一个标题字号标注的是32px 、margin是20px，我们以标注的大小来写CSS</p></li><li><p>之后需要通过JS计算获取屏幕的宽度（假设需要适配逻辑像素宽度是428px的屏幕），在HTML的head里添加 <meta name="viewport" content="width=750px, initial-scale=0.57" > 即可（428/750 = 0.57）。</p><p>意思是：设置布局视口(layout viewport)的宽度为750px（此时页面一般会超出屏幕），再缩放页面（initial-scale）使其恰好撑满屏幕</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="variable constant_">WIDTH</span> = <span class="number">750</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">mobileAdapter</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> scale = screen.<span class="property">width</span>/<span class="variable constant_">WIDTH</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> content = <span class="string">`width=<span class="subst">$&#123;WIDTH&#125;</span>, initial-scale=<span class="subst">$&#123;scale&#125;</span>, maximum-scale=<span class="subst">$&#123;scale&#125;</span>, minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> meta = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=viewport]&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span>(!meta) &#123;</span></span><br><span class="line"><span class="language-javascript">        meta = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;meta&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        meta.<span class="title function_">setAttribute</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(meta)</span></span><br><span class="line"><span class="language-javascript">      &#125; </span></span><br><span class="line"><span class="language-javascript">      meta.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, content)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">mobileAdapter</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onorientationchange</span> = mobileAdapter;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p>优点： 开发流程很简单，工程师只需根据设计稿标注还原页面，不需要额外计算。适配范围广。</p></li><li><p>缺点： 页面整体放大缩小，对于不想缩放的元素无法控制。比如边框在大屏手机下显得很粗，在小屏手机下显得很细</p><p>更需要一种<strong>既能整体缩放，又能个性化控制某些元素不缩放</strong>的方案:<strong>动态REM方案</strong></p></li></ul><h4 id="3-2-动态rem方案">3.2 动态rem方案<a class="anchor" href="#3-2-动态rem方案">·</a></h4><p>只要调整html标签的font-size，就能让所有使用rem单位的元素跟随着发生变化，而使用px单位的元素不受影响。问题的关键在于如何根据屏幕尺寸跳转html标签的font-size。</p><ul><li><p>基于上一种方案的兼容问题，我们引入了rem+媒体查询结合来做：设置html的fontsize=100；将页面分为100份，然后媒体查询区分移动与PC，移动端单位采用rem做单位即可；</p></li><li><p>此外，为了简化rem值的计算，只需要将设计稿的px移动小数点即可；</p></li><li><p>由于插件不能限制生效设备，因此，没有采用插件的方式；</p><p>rem：相对于<strong>根元素的字体font-size大小</strong>,任意浏览器默认字体都是16px</p><ul><li>html根元素的获取方式 <code>document.getElementsByTagName('html')[0]</code></li><li>Htmlfont-size：屏幕宽度 / 划分的份数</li><li>页面元素的rem值：页面元素值（px）/（屏幕宽度 / 划分的份数）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, </span></span></span><br><span class="line"><span class="string"><span class="tag">  initial-scale=1, maximum-scale=1, minimum-scale=1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="variable constant_">WIDTH</span> = <span class="number">750</span>  <span class="comment">//如果是尺寸的设计稿在这里修改</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">setView</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//设置html标签的fontSize</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = (<span class="number">100</span>*screen.<span class="property">width</span>/<span class="variable constant_">WIDTH</span>) + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onorientationchange</span> = setView</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setView</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 需要随屏幕等比缩放，使用rem单位，比如设计稿中标注的32px这里写成0.32rem */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">3.75rem</span>; </span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="comment">/*不需要缩放的部分用px*/</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-vw方案">3.3 vw方案<a class="anchor" href="#3-3-vw方案">·</a></h4><blockquote><p><strong>不需要JavaScript即可实现动态Rem方案类似的效果</strong></p></blockquote><ul><li><p><code>vh、vw</code>方案即将视觉视口宽度 <code>window.innerWidth</code>和视觉视口高度 <code>window.innerHeight</code> 等分为 100 份。</p><ul><li><code>1vw</code>等于视觉视口的<code>1%</code>，<code>1vh</code> 为视觉视口高度的<code>1%</code></li><li><code>vmin</code> : <code>vw</code> 和 <code>vh</code> 中的较小值、较大值</li><li>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），只需要将它设置为<code>75 / 3.75 = 20vw</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.button</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">16vw</span>;        <span class="comment">/*  100vw*120/750  */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">3.73vw</span>;  <span class="comment">/*  100vw*28/750  */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">6.4vw</span>; <span class="comment">/*  100vw*48/750  */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>; <span class="comment">/*不需要缩放的部分用px*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>虽然不用写JS做适配，但标注尺寸换算为vw又麻烦又不直观。可以在CSS里使用calc来换算换，只不过需要注意新语法的兼容性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--ratio</span>: <span class="built_in">calc</span>(<span class="number">100vw</span>/<span class="number">750</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">100vw</span>*<span class="number">28</span>/<span class="number">750</span>);  <span class="comment">/* 可以直接用calc */</span></span><br><span class="line">  <span class="attribute">line-height</span>: <span class="built_in">calc</span>(<span class="number">100vw</span>*<span class="number">48</span>/<span class="number">750</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">120</span>*<span class="built_in">var</span>(--ratio));  <span class="comment">/* 也可以用calc配合var使用，IE不支持var */</span>     </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>; <span class="comment">/*不需要缩放的部分用px*/</span></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正式的项目里也可以用SCSS，把换算交给预处理器</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> px2vw($px) &#123;</span><br><span class="line">  <span class="keyword">@return</span> $px * <span class="number">100vw</span> / <span class="number">750</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">px2vw</span>(<span class="number">120</span>);</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">px2vw</span>(<span class="number">28</span>);</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="built_in">px2vw</span>(<span class="number">48</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缺陷：</p><ul><li><code>px</code>转换成<code>vw</code>不一定能完全整除，因此有一定的像素差。</li><li>比如当容器使用<code>vw</code>，<code>margin</code>采用<code>px</code>时，很容易造成整体宽度超过<code>100vw</code>，从而影响布局效果。当然我们也是可以避免的，例如使用<code>padding</code>代替<code>margin</code>，结合<code>calc()</code>函数使用等等…</li></ul></li></ul><h4 id="3-4-媒体查询">3.4 媒体查询<a class="anchor" href="#3-4-媒体查询">·</a></h4><ul><li><p>使用媒体查询的方式：</p><ol><li>可以用 <strong>link 与 style</strong> 中定义媒体查询</li><li>也可以用 <code>@import url(screen.css) screen</code> 形式媒体使用的样式</li></ol></li><li><p>可以用逗号分隔同时支持多个媒体设备，未指定媒体设备时等同于all</p></li></ul><h5 id="3-4-1-style">3.4.1 style<a class="anchor" href="#3-4-1-style">·</a></h5><ul><li><p>常用的：一般并不会写media=“screen”，其实是默认了media=“all”</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style media=&quot;screen&quot;&gt;  //可以指定别的设备</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">3em</span>;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-4-2-link">3.4.2 link<a class="anchor" href="#3-4-2-link">·</a></h5><ul><li><p>在 <code>link</code> 标签中通过 <code>media</code> 属性设置样式使用的媒体设备</p></li><li><p>不推荐使用，缺点：</p><ul><li>要写很多link标签，不太方便</li><li>更多的是针对页面中某块区域，来单独写个样式控制其响应</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;common<span class="selector-class">.css</span>&quot;&gt; //没有指定媒体所以全局应用</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;screen<span class="selector-class">.css</span>&quot; media=&quot;screen&quot;&gt; //在屏幕设备</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;print<span class="selector-class">.css</span>&quot; media=&quot;print&quot;&gt; //在打印设备</span><br><span class="line"> <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;screen<span class="selector-class">.css</span>&quot; media=&quot;screen,print&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-4-3-import">3.4.3 @import<a class="anchor" href="#3-4-3-import">·</a></h5><ul><li><p>相比于link，更多的是针对页面中某块区域，来单独写个样式控制其响应</p></li><li><p>此时就可以在文件中<strong>引入一个样式文件</strong>，在这个文件中**再引入其他媒体的样式文件。**用<code>@import</code> ，引入指定设备的样式规则</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style<span class="selector-class">.css</span>&quot;&gt;  //这样就可以只有一个link了</span><br></pre></td></tr></table></figure><p><strong>style.css</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(screen.css) screen;</span><br><span class="line"><span class="keyword">@import</span> url(print.css) print;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(screen.css) screen,print; <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3-4-4-media">3.4.4 @media<a class="anchor" href="#3-4-4-media">·</a></h5><ul><li><p><code>@media</code> 可以更细的控制，即<strong>在一个样式表中为多个媒体设备定义样式</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype 关键字 (media feature)  &#123;...&#125;</span><br><span class="line"><span class="keyword">@media</span> screen,print &#123;...&#125;  <span class="comment">/* 多设备支持，逗号分隔 */</span></span><br><span class="line"></span><br><span class="line">media (<span class="attribute">min-width</span>: <span class="number">500px</span>), (max-width: <span class="number">700px</span>) &#123;....&#125;</span><br><span class="line">media only screen and (<span class="attribute">min-width</span>: <span class="number">500px</span>) and (max-width: <span class="number">700px</span>) &#123;....&#125;</span><br></pre></td></tr></table></figure><ul><li><p>mediatype：常用媒体类型还是screen</p><ul><li>all：所有媒体类型</li><li>screen：电脑屏幕，平板电脑，智能手机等</li><li>print：打印设备  speech：屏幕阅读器等发声设备</li></ul></li><li><p>and|or|not|only：关键字，实际使用3选1</p><ul><li>not：必须将not写在查询的最前面，表示不应用样式，即所有条件<strong>都满足</strong>时<strong>不应用</strong>样式</li><li>only：用来排除不支持媒体查询的浏览器<ul><li>only 和 not 一样只能出现在媒体查询的开始</li><li>对支持媒体查询的设备，正常调用样式，此时就当only不存在</li><li>对不支持媒体查询的设备不使用样式</li></ul></li></ul></li><li><p>media feature：width、min-width、max-width（布局视口的宽度、最小宽度…）</p></li><li><p>断点：样式切换的分界点，常用断点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">手机 ---- 768 ---- 小屏幕 ---- 992 ---- 中屏幕 ---- 1200 --- 大屏幕</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-5-Flexible方案">3.5 Flexible方案<a class="anchor" href="#3-5-Flexible方案">·</a></h4><h5 id="3-5-1-核心思想：">3.5.1 核心思想：<a class="anchor" href="#3-5-1-核心思想：">·</a></h5><ul><li><p>Flexible方案主要借助JS控制<code>viewport</code>的能力，用<code>rem</code>模拟<code>vw</code>的特性从而达到适配目的</p></li><li><p><code>rem</code>是相对于<code>html</code>元素的<code>font-size</code>来做计算的计算属性值。通过设置<code>documentElement</code>的<code>fontSize</code>属性值就可以统一整个页面的布局标准。</p></li></ul><h5 id="3-5-2-核心代码：">3.5.2 核心代码：<a class="anchor" href="#3-5-2-核心代码：">·</a></h5><ul><li>Flexible将整个页面的宽度切成了10份，然后将计算出来的页面宽度的<code>1/10</code>设置为<code>html</code>节点的<code>fontSize</code></li><li>也就意味着，之后在当前页面的<code>html</code>节点的子节点上应用<code>rem</code>为单位时都是按照页面比例来计算的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set 1rem = viewWidth / 10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setRemUnit</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// docEl为document.documentElement，即html元素</span></span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setRemUnit</span>();</span><br></pre></td></tr></table></figure><h5 id="3-5-3-Flexible配合的PostCSS-px2rem">3.5.3 Flexible配合的PostCSS-px2rem<a class="anchor" href="#3-5-3-Flexible配合的PostCSS-px2rem">·</a></h5><blockquote><ul><li><p>Flexible使用了<code>rem</code>作为统一页面布局标准的布局单位，且把页面宽度等分为了10份，那么在写css代码时就需要去计算当前<code>px</code>单位在当前设计稿上对应的<code>rem</code>值应该是多少</p></li><li><p>以iPhone6为例：布局视口为<code>375px</code>，则<code>1rem = 37.5px</code>，这时设计稿上给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 37.5 = 2rem</code>即可</p></li></ul></blockquote><ul><li><p>当然，以上的工作方式显然低效。借助PostCSS的<code>pxtorem</code>插件<code>postcss.config.js</code>中完成这个计算过程:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: &#123;</span><br><span class="line">    ...,</span><br><span class="line">    <span class="string">&#x27;postcss-pxtorem&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// 750设计标准</span></span><br><span class="line">        <span class="attr">rootValue</span>: <span class="number">75</span>,</span><br><span class="line">        <span class="comment">// 转换成的rem后，保留小数点后几位</span></span><br><span class="line">        <span class="attr">unitPrecision</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将会被转换的css属性列表，</span></span><br><span class="line"><span class="comment">        * 设置为*表示全部，[&#x27;*&#x27;,&#x27;*position*&#x27;,&#x27;!letter-spacing&#x27;,&#x27;!font*&#x27;]</span></span><br><span class="line"><span class="comment">        * *position* 表示所有包含 position 的属性</span></span><br><span class="line"><span class="comment">        * !letter-spacing 表示非 letter-spacing 属性</span></span><br><span class="line"><span class="comment">        * !font* 表示非font-size font-weight ... 等的属性</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="attr">propList</span>: [<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;!letter-spacing&#x27;</span>],</span><br><span class="line">        <span class="comment">// 不会被转换的class选择器名，支持正则</span></span><br><span class="line">        <span class="attr">selectorBlackList</span>: [<span class="string">&#x27;.rem-&#x27;</span>],</span><br><span class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 允许在媒体查询中转换`px`</span></span><br><span class="line">        <span class="attr">mediaQuery</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 小于1px的将不会被转换</span></span><br><span class="line">        <span class="attr">minPixelValue</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>postcss-pxtorem</code>可以把需要转的px值计算转换为对应的<code>rem</code>值，如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.name-item</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">56px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">144px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1PX</span> solid <span class="number">#eeeeee</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后是这个样子：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.name-item</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">53333rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: .<span class="number">74667rem</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1.92rem</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-5-4-Flexible的缺陷">3.5.4 Flexible的缺陷<a class="anchor" href="#3-5-4-Flexible的缺陷">·</a></h5><ul><li><p><strong>PC与移动兼容问题：</strong></p><p>在写好PC端页面后，移动端设备适配时，此插件会影响到PC端，不能只限制它在移动端工作；</p></li><li><p><strong>对iframe的使用不兼容：</strong></p><p>即<code>iframe</code>中展示的内容依然使用的是<code>css</code>像素，在高倍屏下会出问题，如我们在使用<code>iframe</code>引用一个腾讯视频的视频播放资源时，该视频播放器的播放按钮在不同<code>dpr</code>的设备上展示差异很大：</p></li><li><p><strong>对高倍屏的安卓手机没做适配处理</strong>：</p><p><code>lib-flexible</code>对安卓手机的特殊处理，即：一律按<code>dpr = 1</code>处理</p></li><li><p><strong>不兼容响应式布局</strong></p><p>响应式布局，其实质性做法就是结合<code>css3</code>媒体查询<code>@media</code>对一些不同尺寸阈值做特定的布局设计，如对<code>768px</code>以下屏幕的使用紧凑型布局，对<code>769px</code>到<code>992px</code>的屏幕做图文混排型布局，对大于<code>992px</code>的屏幕做富元素、多元素布局等。</p><p>其中，<code>@media</code>语法中涉及到的尺寸查询语句，查询的尺寸依据是当前设备的物理像素，和Flexible的布局理论（即针对不同<code>dpr</code>设备等比缩放视口的<code>scale</code>值，从而同时改变布局视口和视觉视口大小）相悖，因此响应式布局在“等比缩放视口大小”的情境下是无法正常工作的。</p></li><li><p><strong>无法正确响应系统字体大小</strong></p><p>在微信环境（或其他可设置字体大小的Web浏览器中，如Safari）下，设置微信的字体大小（调大）后再打开使用Flexible技术适配的Web页面，你会发现页面布局错乱了，所有使用<code>rem</code>设置大小的元素都变大了，此时<code>html</code>的<code>font-size</code>还是原来的大小，但元素就是变大了，这是为什么呢？</p><ul><li>虽然Flexible帮我们使用<code>&lt;meta/&gt;</code>标签设置了<code>width=device-width</code>和<code>user-scalable=no</code>以及对应的<code>scale</code>缩放值以保证我们的元素大小在高倍屏下（<code>dpr &gt;= 2</code> ）正常展示，</li><li>但在调整Web浏览器的字体大小后，我们的&quot;视口&quot;也响应的等比缩小了，即视觉视口(<code>window.innerWidth</code>)。并不是元素变大了，而是视觉视口变小了！在Flexible方案下毫无办法</li></ul></li></ul><h3 id="4、how-to-pick">4、how to pick<a class="anchor" href="#4、how-to-pick">·</a></h3><blockquote><p>那在开发中，如何为我们的项目选择合适的适配方案呢？总的来说，看适配设备、布局差异等：</p><ul><li><p>如果是PC与移动同时兼容，需要考虑的点：不能互相影响，所以不能粗暴的上插件</p><ul><li>rem+媒体查询</li><li>vw+媒体查询</li></ul></li><li><p>如果是纯移动端，那可选的方案更多了，这时候目光更多的是聚焦在设备多样性中，布局差异</p><ul><li><p>大的话：可以直接媒体查询，不同的设备引入一套</p></li><li><p>小的话：</p><ul><li><p>viewport缩放方案</p></li><li><ul><li>适配原理简单</li><li>需要使用JS</li><li>直接使用设计稿标注无需换算</li><li>方案死板只能实现页面级别整体缩放</li></ul></li><li><p>动态REM方案</p></li><li><ul><li>适配原理稍复杂</li><li>需要使用JS</li><li>设计稿标注的px换算到CSS的rem计算简单</li><li>方案灵活技能实现整体缩放又能实现局部不缩放</li></ul></li><li><p>vw方案</p></li><li><ul><li>适配原理简单</li><li>不需要JS即可适配</li><li>设计稿标注的px换算到CSS的vw计算复杂</li><li>方案灵活技能实现整体缩放又能实现局部不缩放</li></ul></li></ul></li></ul></li></ul></blockquote><h3 id="5、可能遇到的问题">5、可能遇到的问题<a class="anchor" href="#5、可能遇到的问题">·</a></h3><h4 id="5-1-手机1px问题">5.1 手机1px问题<a class="anchor" href="#5-1-手机1px问题">·</a></h4><blockquote><h4 id="问题及原因：">问题及原因：<a class="anchor" href="#问题及原因：">·</a></h4><ul><li><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。</p></li><li><p>原因——CSS 中的 1px 并不能和移动设备的 1px 划等号。它们之间的比例关系有一个属性描述</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br></pre></td></tr></table></figure></li><li><p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8af7dca29f84b7e9d1f94232713ef07~tplv-k3u1fbpfcp-watermark.awebp" alt="img"> 这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 <strong>解决1px 问题的三种思路：</strong></p></li></ul></blockquote><blockquote><h4 id="解决：">解决：<a class="anchor" href="#解决：">·</a></h4><h4 id="解决1：直接写-0-5px">解决1：直接写 0.5px<a class="anchor" href="#解决1：直接写-0-5px">·</a></h4><p>如果之前 1px 的样式这样写：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span></span><br></pre></td></tr></table></figure><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>&#125;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0.5px</span> solid <span class="number">#333</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><h4 id="解决2：伪元素先放大后缩小">解决2：伪元素先放大后缩小<a class="anchor" href="#解决2：伪元素先放大后缩小">·</a></h4><ul><li>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</li></ul><p>思路是<strong>先放大、后缩小：</strong></p><ul><li>在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。</li><li>接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">      <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路三：viewport-缩放">思路三：viewport 缩放<a class="anchor" href="#思路三：viewport-缩放">·</a></h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>;</span><br><span class="line"><span class="comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span></span><br><span class="line">metaEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, <span class="string">`width=device-width,user-scalable=no,initial-scale=<span class="subst">$&#123;scale&#125;</span>,maximum-scale=<span class="subst">$&#123;scale&#125;</span>,minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了</p></blockquote><h4 id="5-2-细-1px-0-5px边框">5.2 细/1px/0.5px边框<a class="anchor" href="#5-2-细-1px-0-5px边框">·</a></h4><p>有几种方法能实现0.5px边框：</p><ol><li><p>直接设置 border-width: 0.5px；使用方便，但兼容性很差，不推荐使用</p></li><li><p>用阴影代替边框，设置阴影box-shadow: 0 0 0 .5px #000; 使用方便，能正常展示圆角，兼容性一般。</p></li><li><p>给容器设置伪元素，设置绝对定位，高度为1px，背景图为线性渐变，一半有颜色，一半透明。视觉上宽度只有0.5px。这种方法适合设置一条边框，没法展示圆角。</p></li><li><p>给容器内设置伪元素，设置绝对定位，宽、高是200%，边框是1px，然后使用transform: scale(0.5) 让伪元素缩小原来的一半，这时候伪元素的边框和容器的边缘重合，视觉上宽度只有0.5px。这种方法兼容性最好，4个边框都能一次性设置，能正常展示圆角，<strong>推荐使用</strong>。</p></li><li><p><strong>采用meta viewport的方式</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-scale=<span class="number">0.5</span>, minimum-scale=<span class="number">0.5</span>, maximum-scale=<span class="number">0.5</span>&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p></li></ol><h4 id="5-3、12px字体问题">5.3、12px字体问题<a class="anchor" href="#5-3、12px字体问题">·</a></h4><p>chrome不支持12px以下的中文，属性-webkit-text-size-adjust也已失效</p><h5 id="1、测试代码：">1、测试代码：<a class="anchor" href="#1、测试代码：">·</a></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">   <span class="attribute">text-align</span>: center;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.content</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="2、法1：transform">2、法1：transform<a class="anchor" href="#2、法1：transform">·</a></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">0.875</span>);</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br></pre></td></tr></table></figure><ul><li><p>问题：如果这个<p>元素有背景bgc的话，这个属性会使背景也随着变化，所以，可以给<p>标签里再套个<span></p><p>但此时不会生效：因为**transform:scale()**属性只为可以定义宽高的元素缩放，而span是行内元素；可以给span元素定义一个display:block、inline-block也可以</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="comment">/* font-size: 10px; */</span></span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">0.875</span>);</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>此时PC端正常显示，但ios显示的字体比10px更小：</p></li></ul><h5 id="3、法2：svg">3、法2：svg<a class="anchor" href="#3、法2：svg">·</a></h5><ul><li><p>SVG由于是矢量的，再怎么拉伸文字效果都是清晰细腻的：可能多行字体换行问题还需要解决</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div class=&quot;content&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;14&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 150 14&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>  <span class="attr">font-size</span>=<span class="string">&quot;10&quot;</span> <span class="attr">x</span>=<span class="string">&quot;4&quot;</span> <span class="attr">y</span>=<span class="string">&quot;1em&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#cd0000&quot;</span>&gt;</span></span><br><span class="line">      测试测试测试测试测试十四个字</span><br><span class="line">    <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS tricks-2</title>
      <link href="/posts/CSStricks-2.html"/>
      <url>/posts/CSStricks-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="center-开发中的CSS-tricks-2-center"><center>开发中的CSS tricks-2</center><a class="anchor" href="#center-开发中的CSS-tricks-2-center">·</a></h2><h3 id="1、100vw横向滚动条：">1、100vw横向滚动条：<a class="anchor" href="#1、100vw横向滚动条：">·</a></h3><h4 id="100vw的问题：">100vw的问题：<a class="anchor" href="#100vw的问题：">·</a></h4><ul><li><p>在容器宽度设置为100vw，高度很小时：没有滚动条，任意调整窗口</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;wrapper&quot;&gt;testContent&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">* &#123;<span class="attribute">padding</span>: <span class="number">0</span>;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/CSS/100vw-1.webp" style="zoom: 33%;" /></li><li><p>在容器宽度设置为100vw，高度很大时，内容不能完整显示出来：横向、纵向都出现了滚动条</p><p>为什么纵向内容超出了，横向也会受影响呢？</p><p>https://stackoverflow.com/questions/23367345/100vw-causing-horizontal-overflow-but-only-if-more-than-one/23367686#23367686</p><ul><li>纵向滚动条是占用浏览器宽度的</li><li>为了让宽度为 100vw 的元素的最右边能完整的展示出来，浏览器会展示一个横向滚动条让用户滚动看到最右侧内容</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;wrapper&quot;&gt;testContent&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">* &#123;<span class="attribute">padding</span>: <span class="number">0</span>;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5000px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/CSS/100vw-2.webp" style="zoom:33%;" /></li></ul><h4 id="如何解决：">如何解决：<a class="anchor" href="#如何解决：">·</a></h4><ul><li><p>方式1：100%</p><p>100%是指的父元素的宽度的100%</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5000px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/CSS/100%-resolve.webp" alt="image-20220612202320476" style="zoom:33%;" /></li><li><p>方式2：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5000px</span>;</span><br><span class="line">  <span class="attribute">max-width</span>:<span class="number">100%</span>;  <span class="comment">/* added */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="注意：">注意：<a class="anchor" href="#注意：">·</a></h4><p>Mac系统上，如果：系统偏好设置–&gt;通用 --&gt; 显示滚动条：</p><ul><li>勾选第1个：在 Chrome 下只有滚动页面的时候才会出现滚动条，而且这个临时的滚动条不会占用页面宽度的，滚动完成后自动消失</li><li>勾第2个：滚动条会一直显示并且占用页面宽度</li></ul><h3 id="2、溢出省略">2、溢出省略<a class="anchor" href="#2、溢出省略">·</a></h3><h4 id="单行文本省略：">单行文本省略：<a class="anchor" href="#单行文本省略：">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  // <span class="attribute">width</span>会定死，而<span class="attribute">max-width</span>实现根据自身宽度展开：达到宽度时缩略，不够时不缩略</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">700px</span>;   </span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;// 不换行</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis; // 溢出省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多行溢出省略">多行溢出省略<a class="anchor" href="#多行溢出省略">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-webkit-line-clamp限制在一个块元素显示的文本的行数 </span><br><span class="line">需要组合其他的WebKit属性,常见结合属性：</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box; 必须结合的属性，将对象作为弹性伸缩盒子模型显示</span><br><span class="line">  -webkit-box-orient 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式。</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ellipsis</span>&#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;    </span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">text-overflow</span>:ellipsis;    </span><br><span class="line">  -webkit-line-clamp:<span class="number">2</span>;</span><br><span class="line">  -webkit-box-orient: vertical</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充卡片折叠效果实现：">补充卡片折叠效果实现：<a class="anchor" href="#补充卡片折叠效果实现：">·</a></h4><h5 id="需求">需求<a class="anchor" href="#需求">·</a></h5><ul><li>点击展开：同层级卡片全部展开，被点击的卡片文字展开，未被点击的不展开；</li><li>点击折叠：被点击的折叠，不被点击的维持不动：</li><li>两列卡片</li></ul><h5 id="实现：">实现：<a class="anchor" href="#实现：">·</a></h5><ul><li><p>需要状态记录当前被展开的是哪行，因为可能是多行，所以应该是数组；我们使用了ref的current属性：rowRef.current[index] = 。。。。</p><ul><li><p>初始时，所有list数除以2这么多子项，为false；</p></li><li><p>更新时，交互发生时，去更新点击卡片对应的行：因此涉及函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据index ---&gt; 映射出行row</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">indexToRow</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">ceil</span>(index+<span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> curRow = <span class="title function_">indexToRow</span>(index);</span><br><span class="line">  <span class="comment">//更新最新的行</span></span><br><span class="line">  <span class="title function_">setCardStatus</span>(!cardStatus)</span><br><span class="line">  rowRef.<span class="property">current</span>[curRow] = cardStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了记录卡片的切换状态：还需要状态记录打开关闭问题：cardStatus</p></li></ul></li><li><p>遍历所有的index，匹配是当前行的高度展开，不是的高度不变；</p><p>因此还需要判断函数,决定每个item的class —&gt; 高度</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isMatchRow</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> curRow = <span class="title function_">indexToRow</span>(index);</span><br><span class="line">  <span class="comment">//遍历所有row，找到是否有匹配的：</span></span><br><span class="line"><span class="keyword">return</span> rowArr.<span class="title function_">indexOf</span>(curRow) !== -<span class="number">1</span>;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="遗留难点：">遗留难点：<a class="anchor" href="#遗留难点：">·</a></h5><ul><li>要求溢出最后一行截断的70px，之后的溢出隐藏显示</li></ul><h3 id="3、待续。。。。补充">3、待续。。。。补充<a class="anchor" href="#3、待续。。。。补充">·</a></h3>]]></content>
      
      
      <categories>
          
          <category> 2.3-实现Tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小工具</title>
      <link href="/posts/toolsTest.html"/>
      <url>/posts/toolsTest.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 3.4-Tool&amp;Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools&amp;Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>功能实现trick1</title>
      <link href="/posts/feature-tricks1.html"/>
      <url>/posts/feature-tricks1.html</url>
      
        <content type="html"><![CDATA[<h1 id="center-开发中的功能实现trick-center"><center>开发中的功能实现trick</center><a class="anchor" href="#center-开发中的功能实现trick-center">·</a></h1><hr><h2 id="滚动吸顶的实现">滚动吸顶的实现<a class="anchor" href="#滚动吸顶的实现">·</a></h2><h4 id="1-1-功能及分析：">1.1 功能及分析：<a class="anchor" href="#1-1-功能及分析：">·</a></h4><blockquote><ul><li><p>滚动过程中，滚至对应区域，对应nav高亮显示；</p><p>所以，要记录页面滚动的高度，这样切换到对应高度区间时，通知该区间对应的子项，激活显示，so，这里还涉及消息传递；</p></li><li><p>点击nav中的子项，跳转至该区域</p><p>相反的，知道了子项，可以得到对应高度区间，再scroll到该区间的左值即可</p></li></ul></blockquote><h4 id="1-2-自定义Hook：useWindowScroll">1.2 自定义Hook：useWindowScroll<a class="anchor" href="#1-2-自定义Hook：useWindowScroll">·</a></h4><ul><li>拿到每一帧中滚动的位置；</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isClient &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils/common&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useWindowScroll = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> frame = <span class="title function_">useRef</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: isClient ? <span class="variable language_">window</span>.<span class="property">scrollX</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: isClient ? <span class="variable language_">window</span>.<span class="property">scrollY</span> : <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">cancelAnimationFrame</span>(frame.<span class="property">current</span>);</span><br><span class="line">      frame.<span class="property">current</span> = <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">x</span>: <span class="variable language_">window</span>.<span class="property">scrollX</span>,</span><br><span class="line">          <span class="attr">y</span>: <span class="variable language_">window</span>.<span class="property">scrollY</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handler, &#123;</span><br><span class="line">      <span class="attr">capture</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">passive</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cancelAnimationFrame</span>(frame.<span class="property">current</span>);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-3-Context">1.3 Context:<a class="anchor" href="#1-3-Context">·</a></h4><ul><li>功能：？</li><li>为啥要这样做？</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个文件layout.js中导出了两个函数：LayoutStateProvider、useLayout</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">headerRef</span>: <span class="literal">null</span>&#125;;  </span><br><span class="line"><span class="keyword">const</span> layoutContext = <span class="title function_">createContext</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span> &#125; = layoutContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LayoutStateProvider</span> = (<span class="params">&#123; children &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;updateHeaderRef&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123; ...state, <span class="attr">headerRef</span>: action.<span class="property">data</span> &#125;;</span><br><span class="line">      <span class="attr">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> [layoutState, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">layoutState</span>, <span class="attr">dispatch</span> &#125;&#125;&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义Hook：获取上下文</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useLayout</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(layoutContext);</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">undefined</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;useLayout 必须被使用 within a LayoutStateProvider&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-Nav导航组件：">1.4 Nav导航组件：<a class="anchor" href="#1-4-Nav导航组件：">·</a></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useLayout &#125; <span class="keyword">from</span> <span class="string">&#x27;../../context/layout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useWindowScroll <span class="keyword">from</span> <span class="string">&#x27;../../hooks/useWindowScroll&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; scroller, <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-scroll&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ScalebleNav</span> = <span class="function">(<span class="params">&#123; outerStyle, navItem &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; layoutState &#125; = <span class="title function_">useLayout</span>();   <span class="comment">// 拿到layoutContext相关的东西</span></span><br><span class="line">  <span class="keyword">const</span> &#123; y &#125; = <span class="title function_">useWindowScroll</span>();</span><br><span class="line">  <span class="keyword">const</span> navRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;    </span><br><span class="line">    <span class="comment">// 1. 首次进入页面，拿到导航组件距离顶部的高度</span></span><br><span class="line">    <span class="keyword">const</span> nav = navRef.<span class="property">current</span>;</span><br><span class="line">    <span class="keyword">const</span> topDistance = nav.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span>;</span><br><span class="line">    <span class="comment">// 2. 判断其</span></span><br><span class="line">    <span class="keyword">if</span> (topDistance &lt; <span class="number">300</span> &amp;&amp; topDistance &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">450</span> &amp;&amp; layoutState.<span class="property">headerRef</span>) &#123;</span><br><span class="line">      nav.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;inherit&#x27;</span>;</span><br><span class="line">      <span class="comment">// 2.1 控制滚动过程中，按钮的样式改变问题</span></span><br><span class="line">      <span class="comment">// 这个距离怎么计算的</span></span><br><span class="line">      <span class="keyword">const</span> offsetW = (<span class="number">100</span> - (topDistance / <span class="number">300</span>) * <span class="number">100</span>) * <span class="number">0.1666667</span>;</span><br><span class="line">      <span class="keyword">const</span> offsetH = (<span class="number">100</span> - (topDistance / <span class="number">300</span>) * <span class="number">100</span>) * <span class="number">0.12</span>;</span><br><span class="line">      nav.<span class="property">style</span>.<span class="property">width</span> = <span class="number">83.33</span> + offsetW + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      nav.<span class="property">style</span>.<span class="property">height</span> = <span class="number">60</span> + offsetH + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> headerTopOffset = <span class="number">100</span> - (topDistance / <span class="number">300</span>) * <span class="number">100</span>;</span><br><span class="line">      <span class="comment">// layoutState.headerRef是什么？</span></span><br><span class="line">      layoutState.<span class="property">headerRef</span>.<span class="property">style</span>.<span class="property">top</span> = -headerTopOffset + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (topDistance &gt; <span class="number">300</span> &amp;&amp; layoutState.<span class="property">headerRef</span>) &#123;</span><br><span class="line">      nav.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;83.33%&#x27;</span>;</span><br><span class="line">      layoutState.<span class="property">headerRef</span>.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&#x27;0px&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; <span class="number">450</span> &amp;&amp; topDistance &lt;= <span class="number">0</span> &amp;&amp; layoutState.<span class="property">headerRef</span>) &#123;</span><br><span class="line">      nav.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">      nav.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;72px&#x27;</span>;</span><br><span class="line">      nav.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span>;</span><br><span class="line">      nav.<span class="property">style</span>.<span class="property">top</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [y]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section style=&#123;outerStyle&#125;&#125;&gt;</span><br><span class="line">      &lt;nav ref=&#123;navRef&#125;&gt;</span><br><span class="line">        &#123;navItem.map((item, index) =&gt; &#123;</span><br><span class="line">          return ( &lt;section&gt;</span><br><span class="line">              &lt;Link</span><br><span class="line">                activeClass=&#123;styles[&#x27;item-link-active&#x27;]&#125; to=&#123;item&#125; </span><br><span class="line">                offset=&#123;-navRef.current?.offsetHeight&#125;</span><br><span class="line">              &gt;&#123;item&#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-使用导航组件的页面：">1.5 使用导航组件的页面：<a class="anchor" href="#1-5-使用导航组件的页面：">·</a></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Events</span>, scrollSpy &#125; <span class="keyword">from</span> <span class="string">&#x27;react-scroll&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">EntertainmentSolution</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  architectureData,advantageData,useCaseData, navItem, //导航的每个tab</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Events</span>.<span class="property">scrollEvent</span>.<span class="title function_">register</span>(<span class="string">&#x27;begin&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">    <span class="title class_">Events</span>.<span class="property">scrollEvent</span>.<span class="title function_">register</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">    scrollSpy.<span class="title function_">update</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Events</span>.<span class="property">scrollEvent</span>.<span class="title function_">remove</span>(<span class="string">&#x27;begin&#x27;</span>);</span><br><span class="line">      <span class="title class_">Events</span>.<span class="property">scrollEvent</span>.<span class="title function_">remove</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Nav</span> <span class="attr">outerStyle</span>=<span class="string">&#123;&#123;</span> <span class="attr">top:</span> &#x27;<span class="attr">450px</span>&#x27;&#125;&#125; <span class="attr">navItem</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Architecture</span> <span class="attr">elementName</span>=<span class="string">&#123;navItem[0]&#125;</span> <span class="attr">architectureData</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Advantage</span> <span class="attr">elementName</span>=<span class="string">&#123;navItem[1]&#125;</span> <span class="attr">advantageData</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">UseCase</span> <span class="attr">elementName</span>=<span class="string">&#123;navItem[2]&#125;</span> <span class="attr">useCaseData</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="伸缩折叠实现">伸缩折叠实现<a class="anchor" href="#伸缩折叠实现">·</a></h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Element</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-scroll&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Collapsible</span> <span class="keyword">from</span> <span class="string">&#x27;react-collapsible&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FadeIn</span> <span class="keyword">from</span> <span class="string">&#x27;../../commonComponents/fadeIn&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CollapseList</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  list,</span></span><br><span class="line"><span class="params">  loaded,</span></span><br><span class="line"><span class="params">  setCurrentOpenIndex,</span></span><br><span class="line"><span class="params">  currentOpenIndex,</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> list.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Collapsible</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onTriggerOpening</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            loaded.current = false;</span></span><br><span class="line"><span class="language-xml">            setCurrentOpenIndex(index);</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          onTriggerClosing=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            loaded.current = false;</span></span><br><span class="line"><span class="language-xml">            setCurrentOpenIndex(-1);</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          open=&#123;index === currentOpenIndex&#125;</span></span><br><span class="line"><span class="language-xml">          easing=&#123;&#x27;ease-in-out&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">          transitionTime=&#123;200&#125;</span></span><br><span class="line"><span class="language-xml">          trigger=&#123;<span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">collapse-trigger-container</span>&#x27;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;item.useCaseTitle&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">          &gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">useCase-content-container</span>&#x27;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">useCase-content</span>&#x27;]&#125;&gt;</span>&#123;item.useCaseContent&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">useCase-label</span>&#x27;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">draggable</span>=<span class="string">&#123;false&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">src</span>=<span class="string">&quot;/img/useCaseLabel.png&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">alt</span>=<span class="string">&quot;useCaseLabel&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">layout</span>=<span class="string">&#123;</span>&#x27;<span class="attr">fill</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Collapsible</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.divider&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UseCase</span> = (<span class="params">&#123; elementName, useCaseData &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [currentOpenIndex, setCurrentOpenIndex] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> loaded = <span class="title function_">useRef</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [, forceUpdate] = <span class="title function_">useReducer</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onImageLoad</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    loaded.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">forceUpdate</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Element</span> <span class="attr">name</span>=<span class="string">&#123;elementName&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">FadeIn</span> <span class="attr">distance</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">repeat</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">main</span> <span class="attr">className</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.title&#125;</span>&gt;</span>&#123;useCaseData.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">use-case-content-wrapper</span>&#x27;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">section</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">style</span>=<span class="string">&#123;&#123;height:</span> (<span class="attr">useCaseData.content.length</span> <span class="attr">-</span> <span class="attr">1</span>) * <span class="attr">67</span> + <span class="attr">383</span> + &#x27;<span class="attr">px</span>&#x27;,&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">use-case-left-content</span>&#x27;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">content-list-container</span>&#x27;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">CollapseList</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">loaded</span>=<span class="string">&#123;loaded&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">currentOpenIndex</span>=<span class="string">&#123;currentOpenIndex&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">setCurrentOpenIndex</span>=<span class="string">&#123;setCurrentOpenIndex&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">list</span>=<span class="string">&#123;useCaseData.content&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">use-case-right-content</span>&#x27;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">style</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">loaded.current</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    ? &#123; <span class="attr">opacity:</span> <span class="attr">1</span>, <span class="attr">transition:</span> &#x27;<span class="attr">opacity</span> <span class="attr">0.6s</span> <span class="attr">ease</span>&#x27; &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">:</span> &#123; <span class="attr">opacity:</span> <span class="attr">0</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">use-case-right-img-container</span>&#x27;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">onLoad</span>=<span class="string">&#123;onImageLoad&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">alt</span>=<span class="string">&quot;配图&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">src</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">useCaseData.content</span>[<span class="attr">currentOpenIndex</span>]?<span class="attr">.imgUrl</span> ||</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">useCaseData.content</span>[<span class="attr">0</span>]?<span class="attr">.imgUrl</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">draggable</span>=<span class="string">&#123;false&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">layout</span>=<span class="string">&quot;fill&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">objectFit</span>=<span class="string">&quot;cover&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">FadeIn</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Element</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">UseCase</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="切换效果实现总结">切换效果实现总结<a class="anchor" href="#切换效果实现总结">·</a></h2><blockquote><p>预期效果：切换按钮，展示对应的内容。记录开发过程中：</p><ul><li>遇见的不同同学写的几种实现方式；</li><li>自己写的方式，优化问题；</li><li>在此过程中，学习到的新的React概念，比如组件复用问题等；</li></ul></blockquote><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/CSS/css-tab.png" alt="image-css-tab" style="zoom: 100%;" /><p>待展示的数据设计：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">DEMO_LIST</span> = [&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;大猫&#x27;</span>,</span><br><span class="line">    <span class="attr">subTitle</span>: <span class="string">&#x27;大猫睡觉了&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: [</span><br><span class="line">      <span class="string">&#x27;大猫实时在线直播，打造混血网红猫&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;大猫实时睡觉，满足猫猫睡觉的多样拍摄睡姿&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;大猫通过卖萌，完美融合直播生态，打造百万up猫&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">videoUrl</span>: staticFileMap[<span class="string">&#x27;cat-demo1&#x27;</span>],</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;二猫&#x27;</span>,</span><br><span class="line">    <span class="attr">subTitle</span>: <span class="string">&#x27;二猫睡觉了吗&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: [</span><br><span class="line">      <span class="string">&#x27;二猫实时在线直播，打造混血网红猫&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;二猫实时睡觉，满足猫猫睡觉的多样拍摄睡姿&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;二猫通过卖萌，完美融合直播生态，打造百万up猫&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">videoUrl</span>: staticFileMap[<span class="string">&#x27;cat-demo2&#x27;</span>],</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;三猫&#x27;</span>,</span><br><span class="line">    <span class="attr">subTitle</span>: <span class="string">&#x27;三猫其实已经睡觉了呀&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: [</span><br><span class="line">      <span class="string">&#x27;三猫实时在线直播，打造混血网红猫&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;三猫实时睡觉，满足猫猫睡觉的多样拍摄睡姿&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;三猫通过卖萌，完美融合直播生态，打造百万up猫&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">videoUrl</span>: staticFileMap[<span class="string">&#x27;cat-demo3&#x27;</span>],</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;四猫&#x27;</span>,</span><br><span class="line">    <span class="attr">subTitle</span>: <span class="string">&#x27;四猫睡觉了哈哈哈&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: [</span><br><span class="line">      <span class="string">&#x27;四猫实时在线直播，打造混血网红猫&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;四猫实时睡觉，满足猫猫睡觉的多样拍摄睡姿&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">videoUrl</span>: staticFileMap[<span class="string">&#x27;cat-demo4&#x27;</span>],</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><h3 id="1、方式1：通过antd库">1、方式1：通过antd库<a class="anchor" href="#1、方式1：通过antd库">·</a></h3><h4 id="1-1-封装思路">1.1 封装思路<a class="anchor" href="#1-1-封装思路">·</a></h4><ul><li><p>思路：tab切换通过antd的Tab组件实现，内容展示再单独封装成组件：https://ant.design/components/tabs-cn/</p></li><li><p>通过状态控制：同步两个组件的信息</p></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [previous, setPrevious] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [current, setCurrent] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="1-1-左侧手机展示：">1.1 左侧手机展示：<a class="anchor" href="#1-1-左侧手机展示：">·</a></h4><ul><li><p>专门封装了组件：</p><ul><li>实现功能：拿到想要播放的视频的索引，播放它就ok</li><li>不仅需要知道当前切换的索引是什么，还需要知道切换前的索引，这样才能拿到视频暂停上一个视频的播放</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">PhonePlayer</span></span><br><span class="line">  background=&#123;<span class="string">&#x27;/img/play/cat/cat-background.png&#x27;</span>&#125;</span><br><span class="line">  demoList=&#123;demoList&#125;</span><br><span class="line">  current=&#123;current&#125; </span><br><span class="line">  previous=&#123;previous&#125;</span><br><span class="line">  size=<span class="string">&quot;medium&quot;</span></span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure></li><li><p>具体实现：</p><p>细节问题：切换时，初始时其实视频标签都渲染了，但opacity控制它只显示一个：而且通过定位，他们都在同一个位置</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.video-phone-case-inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.phone-video</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>);</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">25px</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">PhonePlayer</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  background,</span></span><br><span class="line"><span class="params">  demoList,</span></span><br><span class="line"><span class="params">  current,</span></span><br><span class="line"><span class="params">  previous,</span></span><br><span class="line"><span class="params">  size = <span class="string">&#x27;small&#x27;</span>,</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mode = &#123;</span><br><span class="line">    <span class="attr">small</span>: &#123; <span class="attr">width</span>: <span class="number">250</span>, <span class="attr">height</span>: <span class="number">520</span>, <span class="attr">case</span>: <span class="string">&#x27;/img/phone1.png&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">medium</span>: &#123; <span class="attr">width</span>: <span class="number">450</span>, <span class="attr">height</span>: <span class="number">540</span>, <span class="attr">case</span>: <span class="string">&#x27;/img/phone2.png&#x27;</span> &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> videoRefs = <span class="title function_">useRef</span>([]);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    videoRefs.<span class="property">current</span> = videoRefs.<span class="property">current</span>.<span class="title function_">slice</span>(<span class="number">0</span>, demoList.<span class="property">length</span>);</span><br><span class="line">  &#125;, [demoList]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      videoRefs.<span class="property">current</span>[<span class="number">0</span>] &amp;&amp; videoRefs.<span class="property">current</span>[<span class="number">0</span>].<span class="title function_">play</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (previous === current) <span class="keyword">return</span>;</span><br><span class="line">    videoRefs.<span class="property">current</span>[previous].<span class="title function_">pause</span>(); <span class="comment">//暂停上一个播放的视频 并把时间调回起始点</span></span><br><span class="line">    videoRefs.<span class="property">current</span>[previous].<span class="property">currentTime</span> = <span class="number">0</span>;</span><br><span class="line">    videoRefs.<span class="property">current</span>[current].<span class="title function_">play</span>(); <span class="comment">// 播放当前video</span></span><br><span class="line">  &#125;, [previous, current]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span>  <span class="attr">....</span>放背景图 /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;demoList.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            return (</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">video</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                // <span class="attr">...</span>只显示部分属性</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                // 控制元素显隐：如果这里用<span class="attr">display</span>性能不好  <span class="attr">opacity</span>会有丝滑效果</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">style</span>=<span class="string">&#123;&#123;opacity:</span> <span class="attr">index</span> === <span class="string">current</span> ? <span class="attr">1</span> <span class="attr">:</span> <span class="attr">0</span>,&#125;&#125; </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">ref</span>=<span class="string">&#123;(el)</span> =&gt;</span> (videoRefs.current[index] = el)&#125; // 控制视频播放过程</span></span><br><span class="line"><span class="language-xml">                preload=&quot;auto&quot;  // 预加载 提前加载，避免播放等待</span></span><br><span class="line"><span class="language-xml">              /&gt;</span></span><br><span class="line"><span class="language-xml">            );</span></span><br><span class="line"><span class="language-xml">          &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">src</span>=<span class="string">&#123;mode[size].case&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">height</span>=<span class="string">&#123;mode[size].height&#125;</span> <span class="attr">width</span>=<span class="string">&#123;mode[size].width&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          /&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-右侧切换展示：">1.2 右侧切换展示：<a class="anchor" href="#1-2-右侧切换展示：">·</a></h4><ul><li><p>引入antd中的tab，需要注意文档中说明：activeKey是string，注意转number</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Tabs</span></span><br><span class="line">  defaultActiveKey=<span class="string">&quot;0&quot;</span></span><br><span class="line">  onChange=&#123;<span class="function">(<span class="params">activeKey</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setPrevious</span>(current);   </span><br><span class="line">      <span class="title function_">setCurrent</span>(<span class="title class_">Number</span>(activeKey)); &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">  &#123;demoList.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TabPane</span> <span class="attr">tab</span>=<span class="string">&#123;item.title&#125;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span> //是string</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;item.subTitle&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;item.desc.map((text, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              ....icon显示</span></span><br><span class="line"><span class="language-xml">              ....文字显示</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">TabPane</span>&gt;</span></span></span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/<span class="title class_">Tabs</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、方式2：通过display">2、方式2：通过display<a class="anchor" href="#2、方式2：通过display">·</a></h3><blockquote><p>这是我原本写的方式，但并不推荐:</p><ul><li>因为会带来dom的重建与销毁，不利于性能；</li><li>此外，对于视频类的，会感觉播放卡顿</li></ul></blockquote><h4 id="2-1-封装的实现思路：">2.1 封装的实现思路：<a class="anchor" href="#2-1-封装的实现思路：">·</a></h4><ul><li>父组件包括切换组件、显示组件，并有<strong>curplay</strong>状态控制，将<strong>状态+改变状态的方法</strong>传递给子组件，</li><li>子：切换组件，通过匹配该信息，（1）显示切换的激活样式；（2）用户切换时，更新状态<strong>curplay</strong></li><li>子：显示组件，通过匹配curplay，显示对应的展示内容，不匹配的隐藏；</li></ul><h4 id="2-2-切换组件">2.2 切换组件<a class="anchor" href="#2-2-切换组件">·</a></h4><ul><li><p>注意，这个key那边接受不到，所以想传索引，用单独的props</p></li><li><p>然后CurShowTab中，激活样式下划线是伪元素实现</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="title class_">Data</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">CurShowTab</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">item</span>=<span class="string">&#123;item&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">activeIndex</span>=<span class="string">&#123;curPlay&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">itemIndex</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onTabChange</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;setCurPlay(index);&#125;&#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span></span><br><span class="line">))&#125;</span><br></pre></td></tr></table></figure></li><li><p>伪元素：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-显示组件">2.3 显示组件<a class="anchor" href="#2-3-显示组件">·</a></h4><ul><li><p>只是展示对应的内容</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="title class_">Data</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isCurPlay = index === curPlay;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">CurShowCard</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">item</span>=<span class="string">&#123;item&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">isCurPlay</span>=<span class="string">&#123;isCurPlay&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">itemIndex</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;)&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、方式3：通过props-children">3、方式3：通过props.children<a class="anchor" href="#3、方式3：通过props-children">·</a></h3><ul><li>实现目的：将显示部分的内容以插槽的形式传入组件；</li><li>子组件通过props.children拿到传入的组件，渲染出来；</li></ul><h3 id="4、方式4：高阶组件的方式">4、方式4：高阶组件的方式<a class="anchor" href="#4、方式4：高阶组件的方式">·</a></h3>]]></content>
      
      
      <categories>
          
          <category> 2.3-实现Tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 功能实现的tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS tricks-1</title>
      <link href="/posts/CSStricks-1.html"/>
      <url>/posts/CSStricks-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="center-开发中的CSS-tricks-1-center"><center>开发中的CSS tricks-1</center><a class="anchor" href="#center-开发中的CSS-tricks-1-center">·</a></h2><hr><h3 id="1、hover悬浮效果">1、hover悬浮效果<a class="anchor" href="#1、hover悬浮效果">·</a></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">      <span class="attribute">transition</span>: <span class="number">0.2s</span>;</span><br><span class="line">      <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">12px</span> <span class="number">12px</span> <span class="number">#00000010</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、混入实现原生CSS读取">2、混入实现原生CSS读取<a class="anchor" href="#2、混入实现原生CSS读取">·</a></h3><ul><li><p>背景色，采用混入的方式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">原本：<span class="attribute">Background-image</span>: <span class="built_in">url</span>()</span><br></pre></td></tr></table></figure></li><li><p>配置混入：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> appendHost($path) &#123;</span><br><span class="line">  <span class="keyword">@return</span> $host + $path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将url带上host</span><br><span class="line"><span class="keyword">@mixin</span> backgroundImg($path) &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">appendHost($path</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用混入：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@include</span> backgroundImg(<span class="string">&#x27;/componentStatic/danceCard.png&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>写行内样式的bg：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">style=&#123;&#123;<span class="attr">backgroundImage</span>: <span class="string">&#x27;url(&#x27;</span> + <span class="title function_">src</span>(item.<span class="property">backgroundImg</span>) + <span class="string">&#x27;)&#x27;</span>,&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、vertical-align">3、vertical-align<a class="anchor" href="#3、vertical-align">·</a></h3><ul><li><p>实现场景：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&amp;<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: sub;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vertical-align属性：</p><p>参数参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align</p><ul><li><p>使行内元素盒模型与其行内元素容器垂直对齐</p></li><li><p>垂直对齐表格单元内容:</p><p>注意 <code>vertical-align</code> 只对行内元素、行内块元素和表格单元格元素生效：不能用它垂直对齐<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements">块级元素</a>。</p></li><li><p>vertical-align：inherit在safari上有兼容问题；</p></li></ul></li></ul><h3 id="4、负定位的用法">4、负定位的用法<a class="anchor" href="#4、负定位的用法">·</a></h3><p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/image-20220402170005923.png" alt="image-20220402170005923"></p><ul><li><p>定位值为负数，且为自身宽度，将伪元素定位到组件外部：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>为什么这样做？</p><ul><li><p>这个场景在奇数偶数行反向显示时：页面设计时，将来它下一行是在左边大蓝条；</p></li><li><p>使用组件时，传入参数控制类名，进而在反向显示时。调整父元素位置后，自己left为-负值即可；</p></li></ul></blockquote><h3 id="5、遮罩效果">5、遮罩效果<a class="anchor" href="#5、遮罩效果">·</a></h3><ul><li><p>hover时，出现遮罩效果：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 注意chrome上默认了body标签的margin为8，所以遮罩定位出现时不是完全吻合着图片 */</span></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 写好遮罩层样式,并且让它先不显示 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.cover</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.cover</span><span class="selector-pseudo">:hover</span>  &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">opacity</span>: <span class="number">1</span>;  <span class="comment">/* hover显示遮罩 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 400px; height: 300px;&quot;</span>&gt;</span></span><br><span class="line">  // 多句嘴：img的alt对SEO有帮助</span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">object-fit</span> = <span class="string">&#x27;cover&#x27;</span> <span class="attr">width</span>=<span class="string">&quot;400px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300px&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://mynightwish.oss-cn-beijing.aliyuncs.com/img/a-icehill.avif&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 遮罩 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span>&gt;</span></span><br><span class="line">    遮罩来了</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6、滚动条">6、滚动条<a class="anchor" href="#6、滚动条">·</a></h3><blockquote><p>文章地址：https://mynightwish.top/posts/scroll.html</p><p>实践场景：在markdown-editor-lite中，中间的滚动条时有时无，非常的诡异（包括测试环境、线上环境、各种浏览器及chrome上的不同版本）；</p><ul><li>后来，干脆自己整个滚动条，并模拟预期显示的滚动条的样式；</li></ul><p>此外，关于这个编辑器在issue上还有很多其他的bug</p></blockquote><h3 id="7、cacl">7、cacl<a class="anchor" href="#7、cacl">·</a></h3><p>----待补充</p><h3 id="8、隐藏属性">8、隐藏属性<a class="anchor" href="#8、隐藏属性">·</a></h3><p>https://mynightwish.top/posts/hideElement.html</p><h3 id="9、gap属性">9、gap属性<a class="anchor" href="#9、gap属性">·</a></h3><p>https://mynightwish.top/posts/gap-property.html</p><h3 id="10、组件库样式生效">10、组件库样式生效<a class="anchor" href="#10、组件库样式生效">·</a></h3><ul><li><p>只有那种原生的span，div可以生效，其他的类粘贴到控制台修改生效；</p></li><li><p>需要加入:global进行包裹：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:global &#123;</span><br><span class="line"><span class="selector-class">.antd-btn-primary</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>此外，对于项目中需要全局的组件库样式，我们建议在公共文件中添加，在具体页面中引入，不同的再覆盖；</li></ul><h3 id="11、Antd的menu">11、Antd的menu<a class="anchor" href="#11、Antd的menu">·</a></h3><ul><li><p>多层级嵌套的时候，map的时候不要key都用index，这样会重复问题：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"> &lt;div className=&#123;articleStyles.<span class="property">navContext</span>&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Menu</span> <span class="attr">selectedKeys</span>=<span class="string">&#123;[currentKey]&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;ARTICLE_NAV.map((item, index) =&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">SubMenu</span> <span class="attr">key</span> = <span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           &#123;item.navContext.map((item, index2) =&gt; </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Menu.Item</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                   <span class="attr">key</span> = <span class="string">&#123;</span>`$&#123;<span class="attr">index</span>&#125;<span class="attr">-</span>$&#123;<span class="attr">index2</span>&#125;`&#125; //避免重复</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                   <span class="attr">onClick</span> = <span class="string">&#123;()</span> =&gt;</span> handleSubmenuClick(item, index2, index)&#125;</span></span><br><span class="line"><span class="language-xml">                 &gt;</span></span><br><span class="line"><span class="language-xml">                   &#123;item.title&#125;</span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               )&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">SubMenu</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.3-实现Tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antd-数据展示</title>
      <link href="/posts/antd-data-show.html"/>
      <url>/posts/antd-data-show.html</url>
      
        <content type="html"><![CDATA[<h2 id="antd之数据展示类">antd之数据展示类<a class="anchor" href="#antd之数据展示类">·</a></h2><blockquote><p>记录一下实际开发中用到的一些有意思的组件及遇到问题解决</p><p>文档：https://ant.design/docs/spec/data-display-cn#%E6%A0%91%E5%BD%A2%E6%8E%A7%E4%BB%B6%EF%BC%88Tree%EF%BC%89</p><p>分类总结下遇到的组件，遇到再更新</p></blockquote><h3 id="Tree">Tree<a class="anchor" href="#Tree">·</a></h3><blockquote><p>『树形控件』通过逐级大纲的形式来展现信息的层级关系，高效且具有极佳的视觉可视性</p><p>用户可同时浏览与处理多个树状层级的内容。适用于任何需要通过层级组织的信息场景，如文件夹、组织架构、生物分类、国家地区等等。</p><h4 id="基本使用：">基本使用：<a class="anchor" href="#基本使用：">·</a></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Tree</span></span><br><span class="line">   defaultExpandedKeys=&#123;[<span class="string">&#x27;0-0-0&#x27;</span>, <span class="string">&#x27;0-0-1&#x27;</span>]&#125;</span><br><span class="line">   defaultSelectedKeys=&#123;[<span class="string">&#x27;0-0-0&#x27;</span>, <span class="string">&#x27;0-0-1&#x27;</span>]&#125;</span><br><span class="line">   defaultCheckedKeys=&#123;[<span class="string">&#x27;0-0-0&#x27;</span>, <span class="string">&#x27;0-0-1&#x27;</span>]&#125;</span><br><span class="line">   onCheck=&#123;onCheck&#125;</span><br><span class="line">   treeData=&#123;treeData&#125; </span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>treeData是渲染的树形数据数据</p><ul><li><p>可以使用预先确定好的树形数据、或者外部请求、传值拿到的数据</p></li><li><p>也可以通过代码动态生成，比如</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">generateData</span> = (<span class="params">_level, _preKey, _tns</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> preKey = _preKey || <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 第一层级从0开始拼接，往后递归时会将前面拼接的带入</span></span><br><span class="line">  <span class="keyword">const</span> tns = _tns || gData;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> children = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`<span class="subst">$&#123;preKey&#125;</span>-<span class="subst">$&#123;i&#125;</span>`</span>;</span><br><span class="line">    tns.<span class="title function_">push</span>(&#123; <span class="attr">title</span>: key, key &#125;);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; y) &#123; children.<span class="title function_">push</span>(key);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_level &lt; <span class="number">0</span>) <span class="keyword">return</span> tns;</span><br><span class="line">  <span class="keyword">const</span> level = _level - <span class="number">1</span>;</span><br><span class="line">  children.<span class="title function_">forEach</span>(<span class="function">(<span class="params">key, index</span>) =&gt;</span> &#123;</span><br><span class="line">    tns[index].<span class="property">children</span> = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">generateData</span>(level, key, tns[index].<span class="property">children</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> gData = []; <span class="comment">// 生成的数据用来渲染Tree</span></span><br><span class="line"><span class="title function_">generateData</span>(z);  </span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="1-1-场景1：重命名">1.1 场景1：重命名<a class="anchor" href="#1-1-场景1：重命名">·</a></h4><ul><li><p>实现原理：自定义子节点：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renameRef = useRef&lt;any&gt;(<span class="literal">null</span>);  <span class="comment">// 这里的用法并不是绑定dom节点，只是记录一个值</span></span><br><span class="line"><span class="comment">// 点击重命名按钮时：其中 </span></span><br><span class="line">renameRef.<span class="property">current</span> = node.<span class="property">key</span>; <span class="comment">// renameRef记录了重命名时想要改变的节点</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Tree</span> </span><br><span class="line">  treeData=&#123;treeData&#125;</span><br><span class="line">titleRender=&#123;<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当渲染成input输入框时，状态控制变量是开的 且必须是当前点击的节点 （匹配节点key值）</span></span><br><span class="line">    <span class="keyword">const</span> isRenameNode = isInputVisible &amp;&amp; renameRef.<span class="property">current</span> === v.<span class="property">key</span>;</span><br><span class="line">    <span class="comment">// 选择性渲染或普通渲染</span></span><br><span class="line">    <span class="keyword">return</span> (isRenameNode ? </span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">RenameInput</span> <span class="attr">currName</span>=<span class="string">&#123;currName&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">handleChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setCurrName(e.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">        handleEnter=&#123;handleRename&#125; // 重命名框的回车或obBlur，重命名函数调用</span></span><br><span class="line"><span class="language-xml">        maxLen=&#123;menuIndex.length &gt; 2 ? 20 : 10&#125;</span></span><br><span class="line"><span class="language-xml">       /&gt;</span> : <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;v.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;&#125;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入框回车后调用函数</span></span><br><span class="line"><span class="keyword">const</span> handleRename = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!currName.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (menuIndex.<span class="property">length</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    treeData[menuIndex[<span class="number">1</span>]].<span class="property">children</span>[menuIndex[<span class="number">2</span>]].<span class="property">title</span> = currName;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    treeData[menuIndex[<span class="number">1</span>]].<span class="property">title</span> = currName; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setTreeData</span>([...treeData]); <span class="comment">// 更新treeData</span></span><br><span class="line">  <span class="title function_">setIsInputVisible</span>(<span class="literal">false</span>);  <span class="comment">// 控制弹窗显隐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-场景2：拖拽层级">1.2 场景2：拖拽层级<a class="anchor" href="#1-2-场景2：拖拽层级">·</a></h4><blockquote><p>官方文档中有自由拖拽的例子，需要了解几个关键属性：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node         代表当前被drop 的对象</span></span><br><span class="line"><span class="comment">// dragNode     代表当前需要drop 的对象</span></span><br><span class="line"><span class="comment">// dropPosition 代表drop后的节点位置；不准确</span></span><br><span class="line"><span class="comment">// dropToGap    代表移动到非最顶级组第一个位置</span></span><br></pre></td></tr></table></figure><p>关于dropPosition的issue：https://github.com/ant-design/ant-design/issues/14244</p><h5 id="自由拖拽">自由拖拽<a class="anchor" href="#自由拖拽">·</a></h5><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">loop</span> = (<span class="params">data, key, callback</span>) =&gt; &#123;</span><br><span class="line"><span class="comment">// 递归寻找树中的节点，通过传入的key，匹配到拖拽节点</span></span><br><span class="line"><span class="comment">// 匹配到后，将当前元素，极其子节点，传入回调函数</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (data[i].<span class="property">key</span> === key)  <span class="keyword">return</span> <span class="title function_">callback</span>(data[i], i, data);</span><br><span class="line">     <span class="keyword">if</span> (data[i].<span class="property">children</span>) &#123;</span><br><span class="line">       <span class="title function_">loop</span>(data[i].<span class="property">children</span>, key, callback);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleDrag = (info): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> dropKey = info.<span class="property">node</span>.<span class="property">key</span>;</span><br><span class="line"> <span class="keyword">const</span> dragKey = info.<span class="property">dragNode</span>.<span class="property">key</span>;</span><br><span class="line"> <span class="keyword">const</span> dropPos = info.<span class="property">node</span>.<span class="property">pos</span>.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"> <span class="comment">// info.dropPosition: 你希望拖到哪里，从1开始计数</span></span><br><span class="line"> <span class="comment">// dropPos[dropPos.length - 1]：目标节点的索引位置  </span></span><br><span class="line"> <span class="comment">// 所以正常情况下，这个地方info.dropPosition永远是1</span></span><br><span class="line"> <span class="comment">// dropPosition: ( -1 | 0 | 1 ) dropPosition计算前的值，可以查看rc-tree源码;</span></span><br><span class="line"> <span class="comment">// -1 代表移动到最顶级组的第一个位置</span></span><br><span class="line"> <span class="keyword">const</span> dropPosition = info.<span class="property">dropPosition</span> - <span class="title class_">Number</span>(dropPos[dropPos.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line"> <span class="keyword">const</span> loopData = [...treeData];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> dragObj; <span class="comment">// 用来保存删除的节点</span></span><br><span class="line"><span class="comment">// 找到拖拽的节点及索引，从渲染数组中删除该项 </span></span><br><span class="line"> <span class="title function_">loop</span>(loopData, dragKey, <span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">   arr.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">   dragObj = item;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果要：移动到非最顶级组第一个位置</span></span><br><span class="line"> <span class="comment">// 找到dropKey对应的节点数据，将拖拽节点数据添加至目标节点的children中</span></span><br><span class="line"> <span class="keyword">if</span> (!info.<span class="property">dropToGap</span>) &#123;</span><br><span class="line">   <span class="title function_">loop</span>(loopData, dropKey, <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">     item.<span class="property">children</span> = item.<span class="property">children</span> || [];</span><br><span class="line">     item.<span class="property">children</span>.<span class="title function_">unshift</span>(dragObj);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="comment">// 平级移动、交叉组移动、移动到其他组(非最顶级)非第一个位置</span></span><br><span class="line">   (info.<span class="property">node</span>.<span class="property">props</span>.<span class="property">children</span> || []).<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; info.<span class="property">node</span>.<span class="property">props</span>.<span class="property">expanded</span> &amp;&amp; dropPosition === <span class="number">1</span></span><br><span class="line"> ) &#123;</span><br><span class="line">   <span class="title function_">loop</span>(loopData, dropKey, <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">     item.<span class="property">children</span> = item.<span class="property">children</span> || [];</span><br><span class="line">     item.<span class="property">children</span>.<span class="title function_">unshift</span>(dragObj);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 移动到最顶级第一个位置</span></span><br><span class="line">   <span class="keyword">let</span> ar;</span><br><span class="line">   <span class="keyword">let</span> i;</span><br><span class="line">   <span class="title function_">loop</span>(loopData, dropKey, <span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">     ar = arr;</span><br><span class="line">     i = index;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">if</span> (dropPosition === -<span class="number">1</span>) &#123;</span><br><span class="line">     ar.<span class="title function_">splice</span>(i, <span class="number">0</span>, dragObj);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     ar.<span class="title function_">splice</span>(i + <span class="number">1</span>, <span class="number">0</span>, dragObj);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">setTreeData</span>(loopData);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="同层级拖拽">同层级拖拽<a class="anchor" href="#同层级拖拽">·</a></h5><ul><li>github的issue：https://github.com/ant-design/ant-design/issues/15926</li></ul><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isSameLevel</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> aLevel = a.<span class="property">props</span>.<span class="property">pos</span>.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> bLevel = b.<span class="property">props</span>.<span class="property">pos</span>.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">return</span> aLevel === bLevel;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isSameParent</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> aLevel = a.<span class="property">props</span>.<span class="property">pos</span>.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> bLevel = b.<span class="property">props</span>.<span class="property">pos</span>.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  aLevel.<span class="title function_">pop</span>();</span><br><span class="line">  bLevel.<span class="title function_">pop</span>();</span><br><span class="line">  <span class="keyword">return</span> aLevel.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) === bLevel.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleDrag = (info): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dragNode = info.<span class="property">node</span>;</span><br><span class="line">  <span class="keyword">const</span> dropNode = info.<span class="property">dragNode</span>;</span><br><span class="line">  <span class="keyword">const</span> canDrop = <span class="title function_">isSameParent</span>(dragNode, dropNode) &amp;&amp; <span class="title function_">isSameLevel</span>(dragNode, dropNode);</span><br><span class="line">  <span class="keyword">if</span> (!canDrop) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;不允许跨层级拖拽&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dropKey = info.<span class="property">node</span>.<span class="property">key</span>;..../省略</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="走马灯">走马灯<a class="anchor" href="#走马灯">·</a></h3><blockquote><p>作为一组平级内容的并列展示模式，常用于图片或卡片轮播，可由用户主动触发或者系统自动轮播。适合用于官网首页、产品介绍页等展示型区块。</p><blockquote><p>注：</p><ol><li>轮播的数量不宜过多以免造成用户厌烦，控制在 3~5 个之间为最佳</li><li>建议在设计上提供暗示，让用户对轮播的数量和方向保持清晰的认知</li></ol></blockquote></blockquote><h3 id="卡片">卡片<a class="anchor" href="#卡片">·</a></h3><blockquote><p>卡片是一种承载信息的容器，对可承载的内容类型无过多限制，它让一类信息集中化，增强区块感的同时更易于操作；卡片通常以网格或矩阵的方式排列，传达相互之间的层级关系。适合较为轻量级和个性化较强的信息区块展示。</p><blockquote><p>注：</p><ol><li>卡片通常根据栅格进行排列，建议一行最多不超过四个</li><li>在有限的卡片空间内需注意信息之间的间距，若信息过长可做截断处理。例如『Ant Design 适用于中台…』</li></ol></blockquote></blockquote><h3 id="时间轴">时间轴<a class="anchor" href="#时间轴">·</a></h3><blockquote><p>垂直展示的时间流信息，一般按照时间倒叙记录事件，追踪用户当下以及过去做了什么。每一条信息以时间为主轴，内容可涵盖主题、类型、相关的附加内容等等。</p><p>适用于包括事件、任务、日历标注以及其他相关的数据展示。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2.1-组件库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件库-antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端链路的性能优化</title>
      <link href="/posts/better_performance.html"/>
      <url>/posts/better_performance.html</url>
      
        <content type="html"><![CDATA[<h2 id="全链路的性能优化整合">全链路的性能优化整合<a class="anchor" href="#全链路的性能优化整合">·</a></h2><blockquote><p>前言：</p><p>前面的过程中，我们零零散散地提到了性能优化做的事情，恰巧内网最近一篇文章写的不错，仔细学习了下作者的微信公众号文章。但我不打算把他的文本简单copy一遍，因为自己最近刚刚做过相关的事，所以，更多的想结合自己的理解和其他资料学习总结一下</p></blockquote><blockquote><p>在介绍知识之前，我们需要交代一下背景。如果现在给你一个现成的项目要求做性能优化，你会怎么下手呢？这种感觉就好像，你要去体检，那么知道你哪里好，哪儿不好，不好需要吃什么药呢？开始之前，需要明确几点：</p><ul><li><p>如何评价页面的性能好坏呢？</p><p>当然不是直觉，必须有数据指标支撑，这就需要一些工具的帮助</p></li><li><p>随后，问题就来了，如何使用各种性能相关工具？</p><p>这个过程中，肯定会涉及到很多指标，我们需要读懂指标的含义，针对其对应的表现优化，要有针对性的理解指标，就要需要浏览器的基本知识了。</p></li><li><p>页面是从哪里来的？又是怎么在浏览器上渲染出来的？</p></li></ul></blockquote><blockquote><p>以上抛出的3个问题基本回答了：</p><ol><li>浏览器的网络请求环节发生了什么？</li><li>页面渲染环节发生了什么？</li><li>两个环节的我们如何下手优化？</li></ol></blockquote><blockquote><h3 id="完整过程"><strong>完整过程</strong><a class="anchor" href="#完整过程">·</a></h3></blockquote><p><img src="https://cdn.jsdeliver.net/gh/myNightwish/CDN_res/img/640" alt="图片"></p><h3 id="一、网络通信环节">一、网络通信环节<a class="anchor" href="#一、网络通信环节">·</a></h3><h4 id="阶段0：用户输入">阶段0：用户输入<a class="anchor" href="#阶段0：用户输入">·</a></h4><blockquote><p>我们在搜索栏目巴拉巴拉输入…一个url，并回车后。浏览器小伙会暗中判断输入的url是不是正确的：</p><ul><li><p>那什么是正确的url呢？</p><p>那肯定要看标准的呀，安排：https://mynightwish.top/posts/URL_URI.html</p></li><li><p>不标准是不是就搜不到了？</p><p>wrong，浏览器会用默认的搜索引擎将该关键字拼接成url</p></li></ul></blockquote><h4 id="阶段1：【Process-Unload-Event】、【Redirect】">阶段1：【Process Unload Event】、【Redirect】<a class="anchor" href="#阶段1：【Process-Unload-Event】、【Redirect】">·</a></h4><blockquote><p>浏览器会将现有页面卸载掉并重定向到用户新输入的url页面；</p><p>此时浏览器会准备一个<code>渲染进程</code>用于渲染即将到来的页面，和一个<code>网络进程</code>用于发送网络请求。</p></blockquote><h4 id="阶段2：Service-Worker">阶段2：Service Worker<a class="anchor" href="#阶段2：Service-Worker">·</a></h4><blockquote><p>即图中：【Service Worker Init】与【Service Worker Fecth Event 】步骤</p><p>如果当前页面注册了Service Worker那么它可以拦截当前网站所有的请求，进行判断是否需要向远程发送网络请求。</p><p>如果不需要发送网络请求，则取本地文件。如果需要则进行下一步。</p></blockquote><h4 id="阶段3：网络请求">阶段3：网络请求<a class="anchor" href="#阶段3：网络请求">·</a></h4><blockquote><p>包含了图中黄色的：【HTTP Cache】、【DNS】、【TCP】、【Request】、【Response】步骤</p><p>OSI网络七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p>在实际应用中物理层、数据链路层被统称为物理层，会话层、表示层、应用层被统称为应用层，所以实际使用时通常分为4个层级</p><p>【物理层】&gt;【网络层(IP)】&gt;【传输层(TCP/UDP)】&gt;【应用层(HTTP)】</p></blockquote><blockquote><p>刚刚阶段1：说浏览器会重定向到输入的url页面：</p><ul><li>它怎么知道这个url对应哪个页面呢？它又怎么拿到该页面对应的资源呢？</li></ul></blockquote><p>浏览器小伙会拿着url通过<code>网络进程</code>进行如下步骤：</p><p><img src="https://cdn.jsdeliver.net/gh/myNightwish/CDN_res/img/image-20220505225418696.png" alt="image-20220505225418696"></p><ol><li><p>根据url查询本地是否已经有强制缓存，如果有则判断缓存是否过期，如果没过期则直接返回缓存内容，也就是图1中【HTTP Cache】步骤</p><blockquote><p>这里涉及到了强缓存、协商缓存的概念，需要补课的小伙伴，猛戳：</p><p>https://mynightwish.top/posts/588825314.html</p></blockquote></li><li><p>如果没有强制缓存或缓存已过期，则将该请求加入队列，排队准备发送网络请求，也就是图2中【正在排队】，然后进入DNS解析阶段，也就是图1中【DNS】以及图2中的【DNS查找】，DNS根据域名解析出对应的IP地址。(DNS基于UDP)。</p><blockquote><p>关于DNS解析，猛戳：https://mynightwish.top/posts/2124882507.html</p><p>说的俗一点：就是浏览器不认识这个url了，或者这个url已经变心了，浏览器需要重新去寻找该url对应的真正地址：ip地址，才能找到这个真实的资源，建立连接，才能正常的再一次一起happy工作~</p></blockquote></li><li><p>然后使用IP寻址找到对方，然后根据IP地址+端口号创建一个TCP连接(三次握手)，也就是图1中【TCP】以及图2中的【初始连接】创建完成后利用TCP连接来传输数据。(TCP会将数据拆分为多个数据包，进行有序传输，如果丢包会重发，TCP的特点是可靠、有序)</p><blockquote><p>关于TCP的传输，猛戳：https://mynightwish.top/posts/2124882507.html</p><p>终于找到伙计了，咱们打个招呼，握个手吧~</p></blockquote></li><li><p>判断当前协议是否为https，如果为https，则进行SSL协商，将数据进行加密，如果为http协议则不进行加密(明文传输)，也就是图2中的【SSL】。</p><blockquote><p>关于为什么需要HTTPS、它为啥安全呢、怎么加密的呢？请再次戳我这儿：</p><p>https://mynightwish.top/posts/HTTPS.html</p><p>一会我要跟伙计说话，可不能被别人偷听了，我该咋让你安全知道我说了啥呢？</p></blockquote></li><li><p>开始发送http请求(请求行/请求头/请求体)，也就是图1中【Request】以及图2中的【已发送请求】。HTTP协议有多个版本，目前使用最多的版本为HTTP/1.1，HTTP/1.1发送完成后默认不会断开。keep-alive 默认打开，为了下次传输数据时复用上次创建的连接。每个域名最多同时建立6个TCP连接，所以同一时间最多发生6个请求。</p><blockquote><p>哎呀，废了半天劲，终于找到你了，手也握了，接下来我要跟你讨论一个惊天秘密，hhhh…</p><p>可供我们选择的通讯方式太多了：</p><ul><li>BB机、老年机、智能机</li></ul><p>关于HTTP的版本升级路线，如果你想了解，仍然戳我：</p><p>https://mynightwish.top/posts/2716721158.html</p></blockquote></li><li><p>服务器收到数据后解析HTTP请求(请求行/请求头/请求体)，处理完成后生成状态码和HTTP响应(响应行/响应头/响应体)后返回给客户端，也就是图2的【等待中】在做的事情。</p><blockquote><p>服务器端，收到你的请求后，要回应你啊。那么如何表示它的回应内容呢？都说男生很难读懂女朋友的心情，但服务器会很贴心的给你一个响应报文，他把自己关于回应的都写在这里啦，是不是更简单~</p><ul><li>关于请求报文、响应报文，安排：https://mynightwish.top/posts/2716721158.html</li><li>关于状态码，猛戳我：https://mynightwish.top/posts/2716721158.html</li></ul></blockquote><p>服务端可以响应并返回给客户端很多种类型的资源，这里主要介绍<code>html</code>类型</p><ul><li><p>目前前端处理服务端响应html请求主要分为SSR服务端渲染与CSR客户端渲染：</p><p>CSR就是返回一个空的HTML模版，然后浏览器加载js后通过js动态渲染页面。</p><p>SSR是服务端在接受到请求时事先在服务端渲染好html返回给客户端后，客户端再进行客户端激活。</p></li><li><p>在打开一个站点的首屏页的完整链路中，使用<strong>SSR服务端渲染时的速度要远大于CSR客户端渲染，并且SSR对SEO友好</strong>。所以对于首屏加载速度比较敏感或者需要优化SEO的站点来说，使用SSR是更好的选择。比如我们的Next.js</p></li></ul><blockquote><p>这里又出现了服务端渲染、客户端渲染的概念，手拉手跟我一起学习下吧：</p><p>https://mynightwish.top/posts/CSR_SSR.html</p></blockquote></li><li><p>客户端接收到HTTP响应后根据状态码进行对应的处理，如果状态码为304则直接代表协商缓存生效，直接取本地的缓存文件。如果不是则下载内容。也就是图1中【Response】以及图2中的【下载内容】步骤。</p><blockquote><p>这里又涉及到了协商缓存的概念，点俺：</p><p>https://mynightwish.top/posts/588825314.html</p></blockquote></li></ol><h3 id="二、页面渲染">二、页面渲染<a class="anchor" href="#二、页面渲染">·</a></h3><p>…待续</p>]]></content>
      
      
      <categories>
          
          <category> 3.2-浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL、URI</title>
      <link href="/posts/URL_URI.html"/>
      <url>/posts/URL_URI.html</url>
      
        <content type="html"><![CDATA[<h2 id="Url与URI都是啥？">Url与URI都是啥？<a class="anchor" href="#Url与URI都是啥？">·</a></h2><h4 id="1、URL与URI">1、URL与URI<a class="anchor" href="#1、URL与URI">·</a></h4><ul><li><p>URI：统一资源标识符</p><p>父类        表示请求服务器资源，定位这个资源</p></li><li><p>URL：统一资源定位符，常常被称为网址，是因特网上标准的资源地址</p><p>子类       而URL还要表示如何访问这个资源</p><p>通用的格式：scheme://host[:port]/path/…/?query#anchor</p></li></ul><h4 id="2、组成格式：">2、组成格式：<a class="anchor" href="#2、组成格式：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.aspxfans.com:8080/news/index.…</span><br></pre></td></tr></table></figure><ul><li><p>**协议：**访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等后面一定接上://</p></li><li><p>**域名：**该URL的域名部分为“www.aspxfans.com”</p></li><li><p>**port：**跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。</p><ul><li>端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li></ul></li><li><p>（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</p></li><li><p><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</p></li><li><p><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分</p><ul><li>如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分</li><li>如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。</li><li>本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li></ul></li><li><p><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例的锚部分是“name”。锚部分也不是一个URL必须的部分；</p></li><li><p><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。</p><p>本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ul><h4 id="3、URL-编码">3、URL 编码<a class="anchor" href="#3、URL-编码">·</a></h4><ul><li>URL 只能使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3school.com.cn%2Ftags%2Fhtml_ref_ascii.asp">ASCII 字符集</a>来通过因特网进行发送。</li><li>由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</li><li>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</li><li>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">天天`转换为有效的ASCII格式就是`%CC%EC%CC%EC</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> URL、URI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSR、SSR、ISR</title>
      <link href="/posts/CSR_SSR_ISR.html"/>
      <url>/posts/CSR_SSR_ISR.html</url>
      
        <content type="html"><![CDATA[<h2 id="SSR">SSR<a class="anchor" href="#SSR">·</a></h2><h3 id="SSR是什么？">SSR是什么？<a class="anchor" href="#SSR是什么？">·</a></h3><blockquote><p>SSR（Server Side Rendering），一种传统的渲染方式。与客户端渲染不同的是，SSR输出的是一个渲染完成的html，整个渲染过程是在服务器端进行的。例如传统的JSP，PHP都是服务端渲染</p><p>由于服务端把渲染的完整的页面吐给客户端。这样减少了一次客户端到服务端的一次http请求，加快相应速度，一般用于首屏的性能优化。</p></blockquote><h3 id="SSR如何工作的？">SSR如何工作的？<a class="anchor" href="#SSR如何工作的？">·</a></h3><blockquote><p>SSR将一个完整的HTML发送给客户端，客户端只负责HTML的解析。只不过它会被网速，在线活跃人数，服务器的物理位置等等客观因素所约束造成用户体验不佳的情况。</p><p>而且如果面临客户端和服务器多次交互的情况就显得非常吃亏，即使在页面只是有稍加改动的地方都需要重新请求到一个完整页面并且重新进行渲染，对服务器的压力更大</p><p>假设你需要访问的域名叫： example.testsite.com.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example Website<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Website<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example of my new website<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.testsite.com/other.html.&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击 ##Link## 这个链接，弹出来下面这个页面 other.html:</p><ul><li>两个页面的差异就只有一行，但是渲染过程时将整个页面重新渲染，而不仅仅只是发生更改的一行，在当今越加复杂的页面来看动辄几百行的代码来看，要是每次发生少量更改都需要重新渲染整个页面显然是不符合潮流的。</li><li><strong>页面特征来看，使用服务器端渲染的返回的页面是完整的HTML页面。</strong></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example Website<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Website<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example of my new website<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is some more content from the other.html<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="SSR优缺点">SSR优缺点<a class="anchor" href="#SSR优缺点">·</a></h3><h4 id="优点">优点<a class="anchor" href="#优点">·</a></h4><ol><li><p>有利于SEO，由于页面在服务器生成，搜索引擎直接抓取到最终页面结果。</p></li><li><p>有利于首屏渲染：</p><p>简单来讲它不需要来回多次往返于客户端和服务端。</p><p>html所需要的数据都在服务器处理好，直接生成html，首屏渲染时间变短。但是其性能等众多因素会影响用户体验，比如说：网速，在线活跃人数，服务器的物理位置等等。</p></li></ol><h4 id="缺点">缺点<a class="anchor" href="#缺点">·</a></h4><ol><li><strong>占用服务器资源</strong>，渲染工作都在服务端渲染</li><li>用户体验不好，每次跳转到新页面都需要在重新服务端渲染整个页面，<strong>不能只渲染可变区域</strong></li></ol><h2 id="CSR">CSR<a class="anchor" href="#CSR">·</a></h2><h3 id="什么是CSR？">什么是CSR？<a class="anchor" href="#什么是CSR？">·</a></h3><blockquote><p>CSR（Client Side Rendering）指的是：页面的渲染工作在客户端（浏览器）上进行的，并不是在服务端把页面渲染好，再把页面响应回来，直接用完整的页面去展示。</p><p>比如：Vue、React框架开发中，会先下载空的HTML模版（不是最终的完全的html），然后由浏览器通过加载js后，由js动态渲染页面结果。</p></blockquote><h3 id="CSR如何工作的？">CSR如何工作的？<a class="anchor" href="#CSR如何工作的？">·</a></h3><p>以react为例，客户端渲染初始化的html一般如下</p><ul><li><p>可以看出当前页面除了 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 元素，没有其他的元素，</p></li><li><p>然后通过加载 <code>bundle.js</code> , <code>main.chunk.js</code> 来执行渲染。如果需要成功展示出页面原有的样子就需要这2个文件下载到本地，如果通过直接访问的方式页面只会一片空白。</p></li><li><p>整个渲染过程包括，生成DOM节点，注入样式，交互事件绑定，数据获取等等。</p></li></ul><p>当补充上<code>bundle.js</code> , <code>main.chunk.js</code> ，从显示效果来看：</p><ul><li><p>能够展示和之前SSR一样的效果，不同的是，当点击Link链接的时候，页面不会和服务器之间又交互。此时只对Link那一行的代码做了修改，其余位置保持不变。而不是像SSR做了整个页面的重新渲染。</p></li><li><p>但控制页面的所有js文件如果没有完全加载的话，整个页面是渲染不出来的，这才是导致客户端渲染弱于首屏渲染的原因。</p></li><li><p><strong>客户端渲染的页面特征是包含有js链接的script标签</strong></p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">data-react-helmet</span>=<span class="string">&quot;true&quot;</span>&gt;</span>react app<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span> <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">   You need to enable JavaScript to run this app.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/bundle.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/main.chunk.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSR的优缺点">CSR的优缺点<a class="anchor" href="#CSR的优缺点">·</a></h3><h4 id="优点-2">优点<a class="anchor" href="#优点-2">·</a></h4><ol><li><p>符合前后端分离的开发模式：</p><p>前端专注于界面开发，后端专注于api开发，且前端有更多的选择性，可以使用vue，react框架开发，而不需要遵循后端特定的模板。</p></li><li><p>服务器压力变轻：渲染工作在客户端进行，服务器直接返回不加工的html</p></li><li><p>用户后续访问操作体验好：</p><p>为啥是后续，因为首屏加载的过程中渲染做的事情很多，并可能发生阻塞等问题。但是可以将网站做成SPA，可以增量渲染</p><p>因为多次和服务器的交互导致首屏加载速度慢。但一旦这些请求完成之后，用户和页面之间的交互时用户体验就会好很多。</p></li></ol><h4 id="缺点-2">缺点<a class="anchor" href="#缺点-2">·</a></h4><ol><li>不利于SEO，因为搜索引擎不执行JS相关操作，无法获取渲染后的最终html。</li><li>首屏渲染时间比较长，因为需要页面执行ajax获取数据来渲染页面，如果请求接口多，不利于首屏渲染</li></ol><h2 id="SSG">SSG<a class="anchor" href="#SSG">·</a></h2><h3 id="SSG是什么">SSG是什么<a class="anchor" href="#SSG是什么">·</a></h3><blockquote><p>SSG（Static Site Generation），代表的是静态站点生成。在构建的时候直接把结果页面输出html到磁盘，每次访问直接把html返回给客户端，相当于一个静态资源</p><p>Next.js支持该种渲染模式</p></blockquote><h3 id="SSG的优缺点">SSG的优缺点<a class="anchor" href="#SSG的优缺点">·</a></h3><h4 id="优点-3">优点<a class="anchor" href="#优点-3">·</a></h4><ol><li><p>减轻服务器压力，可以把生成的静态资源（html）放到CDN上，合理利用缓存</p><p>预先渲染的静态页面可以被推送到CDN，并在几秒钟内全球可用。静态内容速度快，对停机时间有弹性</p></li><li><p>有利于SEO，由于html已经提前生成好，不需要服务端和客户端去渲染，能立即被爬虫索引</p></li></ol><h4 id="缺点-3">缺点<a class="anchor" href="#缺点-3">·</a></h4><ol><li><p>只适用于静态数据，对于经常改动的数据，需要每次重新生成页面。</p><p>考虑到一个有100,000种产品的电子商务商店。产品价格经常变化。当一个内容编辑将耳机的价格从100美元改为75美元作为促销的一部分时，他们的CMS使用网络钩子来重建整个网站。等待几个小时来反映新的价格是不可行的。</p></li><li><p>用户体验不好，每次打开新页面都需要重新渲染整个页面，<strong>不能只渲染可变区域</strong></p><p>理想的情况是，你的应用程序足够聪明，能够理解哪些产品发生了变化，并_逐步_更新这些页面**，而不需要全面重建**。</p></li><li><p>不适合大规模静态网站：</p><p>即使每个页面都在不现实的1毫秒内静态生成，<strong>重建整个网站</strong>仍然需要<strong>几个小时</strong>。对于大型网络应用，选择完全的静态网站生成是不可行的</p></li></ol><h2 id="ISR">ISR<a class="anchor" href="#ISR">·</a></h2><h3 id="什么是ISR？">什么是ISR？<a class="anchor" href="#什么是ISR？">·</a></h3><blockquote><p>ISR（Incremental Site Rendering），增量式的网站渲染。使开发人员和内容编辑人员能够在每个页面的基础上使用静态生成，<strong>而不需要重建整个网站</strong>。</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fnextjs.org%2F">Next.js</a>允许你在建立网站后创建或更新静态页面。增量静态再生（ISR）通过ISR，你可以保留静态的好处，同时扩展到数百万个页面。</p><p>静态页面可以在运行时（按需）生成，而不是用ISR在构建时生成。使用分析、A/B测试或其他指标，你可以灵活地对构建时间做出自己的权衡。</p></blockquote><ol><li></li><li>。</li></ol><blockquote></blockquote><h3 id="ISR的优缺点">ISR的优缺点<a class="anchor" href="#ISR的优缺点">·</a></h3><h4 id="优点-4">优点<a class="anchor" href="#优点-4">·</a></h4><p>考虑一下有10万个产品的电子商务商店。在一个现实的50ms静态生成每个产品页面的情况下，<strong>如果没有ISR</strong>，这将需要<strong>将近2小时</strong>。有了ISR，</p><ol><li><p><strong>更快的构建</strong>在构建时生成<strong>最受欢迎</strong>的1,000种产品。对其他产品的请求将是一个缓存缺失，按需静态生成。1分钟的构建。</p><p>总结：</p><ul><li><strong>关键性页面</strong>（如网站首页、热点数据等）预渲染为静态页面，缓存至 CDN，保证最佳访问性能</li><li><strong>非关键性页面</strong>（如流量很少的老旧内容）先响应 fallback 内容，然后浏览器渲染（CSR）为实际数据；同时对页面进行异步预渲染，之后缓存至 CDN，提升后续用户访问的性能</li><li>页面的更新遵循 stale-while-revalidate 的逻辑，即始终返回 CDN 的缓存数据（无论是否过期）；如果数据已经过期，那么触发异步的预渲染，异步更新 CDN 的缓存。</li></ul></li><li><p><strong>更高的缓存命中率</strong>在构建时生成10,000个产品，确保更多的产品在用户的请求前被缓存</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30229b64d10f493b82adf820ac258ce3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom: 33%;" /></li></ol><h4 id="缺点-4">缺点<a class="anchor" href="#缺点-4">·</a></h4><ol><li>对于没有预渲染的页面，用户首次访问将会看到一个 fallback 页面，此时服务端才开始渲染页面，直到渲染完毕。这就导致用户体验上的不一致。</li><li>对于已经被预渲染的页面，用户直接从 CDN 加载，但这些页面可能是已经过期的，甚至过期很久的，只有在用户刷新一次，第二次访问之后，才能看到新的数据。对于电商这样的场景而言，是不可接受的（比如商品已经卖完了，但用户看到的过期数据上显示还有）。</li></ol><h3 id="ISR例子">ISR例子<a class="anchor" href="#ISR例子">·</a></h3><blockquote><p>比如：一个电子商务产品页面</p></blockquote><h4 id="1、抓取数据">1、抓取数据<a class="anchor" href="#1、抓取数据">·</a></h4><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11860107454b4ade8d627bf3958cfe02~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:33%;" /><ol><li>Next.js可以为每个页面定义一个重新验证的时间。让我们把它设置为60秒。</li><li>对产品页面的初始请求将显示带有原始价格的缓存页面。</li><li>产品的数据会在CMS中更新。</li><li>在初始请求之后和60秒之前，对该页面的任何请求都会被缓存并即时生效。</li><li>在60秒的窗口之后，下一次请求仍然会显示缓存的（陈旧的）页面。Next.js会在后台触发页面的再生。</li><li>一旦页面成功生成，Next.js将使缓存失效并显示更新的产品页面。如果后台再生失败，旧的页面就不会被改变。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/products/[id].js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params">&#123; params &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">product</span>: <span class="keyword">await</span> <span class="title function_">getProductFromDatabase</span>(params.<span class="property">id</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">revalidate</span>: <span class="number">60</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、生成路径">2、生成路径<a class="anchor" href="#2、生成路径">·</a></h4><p>Next.js定义了哪些产品要在构建时生成，哪些要按需生成。让我们<strong>在构建时只生成最受欢迎的1000种产</strong>品，向<code>getStaticPaths</code> ，提供前1000种产品ID的列表。</p><p>我们需要配置Next.js在初始构建后请求任何其他产品时的 &quot;回退 &quot;方式。有两个选项可以选择：<code>blocking</code> 和<code>true</code> 。</p><ul><li><p><code>fallback: blocking</code> （首选）</p><ul><li>当请求到一个尚未生成的页面时，Next.js将在第一次请求中对该页面进行服务器渲染。</li><li>以后的请求将从缓存中提供静态文件。</li></ul></li><li><p><code>fallback: true</code></p><ul><li><p>当向一个尚未生成的页面发出请求时，Next.js将在<strong>第一次请求时</strong>立即提供一个具有加载状态的静态页面。</p></li><li><p>当数据加载完毕后，页面将以<strong>新的数据重新渲染并被缓存</strong>。</p></li><li><p>未来的请求将从缓存中提供静态文件。</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/products/[id].js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> products = <span class="keyword">await</span> <span class="title function_">getTop1000Products</span>()</span><br><span class="line">  <span class="keyword">const</span> paths = products.<span class="title function_">map</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">id</span>: product.<span class="property">id</span> &#125;</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; paths, <span class="attr">fallback</span>: ‘blocking’ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ISR的局限性：">ISR的局限性：<a class="anchor" href="#ISR的局限性：">·</a></h3><blockquote><p>Next.js首先关注的是终端用户。最佳解决方案 &quot;是相对的，并因行业、受众和应用程序的性质而异。它允许开发者在不离开框架的情况下在不同的解决方案之间转换，让你为项目挑选合适的工具</p></blockquote><h4 id="1、缓存过期">1、缓存过期<a class="anchor" href="#1、缓存过期">·</a></h4><blockquote><p>ISR并不总是正确的解决方案。例如，Facebook的新闻源不能显示陈旧的内容。</p><p>在这种情况下，你会想使用SSR和可能是你自己的<code>cache-control</code> headers，用<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.fastly.com%2Fblog%2Fsurrogate-keys-part-1">代理键来</a>使内容失效。由于Next.js是一个混合框架，你能够自己做出这种权衡，并保持在框架内</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// You can cache SSR pages at the edge using Next.js</span></span><br><span class="line"><span class="comment">// inside both getServerSideProps and API Routes</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;s-maxage=60, stale-while-revalidate&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>SSR和边缘缓存与ISR类似（尤其是在使用<code>stale-while-revalidate</code> 缓存头的情况下），主要区别在于第一个请求：</p><ul><li>使用ISR，如果预先渲染，第一个请求可以保证是静态的。即使你的数据库发生故障，或者与API的通信出现问题，你的用户仍然会看到正确提供的静态页面。</li><li>然而，SSR将允许你根据传入的请求定制你的页面。</li><li><strong>注意</strong>在没有缓存的情况下使用SSR会导致性能下降。在阻止用户看到你的网站时，每一毫秒都很重要，这对你的<a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Ftime-to-first-byte%2F">TTFB</a>（第一个字节的时间）会有很大的影响。</li></ul></blockquote><h4 id="不适用小型网站">不适用小型网站<a class="anchor" href="#不适用小型网站">·</a></h4><blockquote><p>ISR对于小型网站来说并不总是有意义的。如果你的重新验证期大于重建整个网站所需的时间，你还不如使用传统的静态网站生成。</p></blockquote><h2 id="DPR">DPR<a class="anchor" href="#DPR">·</a></h2><h3 id="DPR是什么？">DPR是什么？<a class="anchor" href="#DPR是什么？">·</a></h3><blockquote><p>DPR（Distributed Persistent Rendering）：分布式的持续渲染。运行模式如下：</p><ol><li>去除了 fallback 行为，而是直接用 On-demand Builder（按需构建器）来响应未经过预渲染的页面，然后将结果缓存至 CDN；</li><li>数据页面过期时，不再响应过期的缓存页面，而是 CDN 回源到 Builder 上，渲染出最新的数据；</li><li>每次发布新版本时，自动清除 CDN 的缓存数据。</li></ol></blockquote><img src="https://cdn.jsdeliver.net/gh/myNightwish/CDN_res/img/006z7Mergy1gx1o8tslizj31400mmtcu.jpg" alt="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca10e209725443599b2bbeb1a13800d5~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:33%;" /><h3 id="缺点-5">缺点<a class="anchor" href="#缺点-5">·</a></h3><ol><li>新页面的访问可能会触发 On-demand Builder 同步渲染，导致当次请求的响应时间比较长；</li><li>比较难防御 DoS 攻击，因为攻击者可能会大量访问新页面，导致 Builder 被大量并行地运行，这里需要平台方实现 Builder 的归一化和串行运行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 2.2-基建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>overflow与滚动</title>
      <link href="/posts/scroll.html"/>
      <url>/posts/scroll.html</url>
      
        <content type="html"><![CDATA[<h3 id="overflow与scroll">overflow与scroll<a class="anchor" href="#overflow与scroll">·</a></h3><h4 id="overflow属性：">overflow属性：<a class="anchor" href="#overflow属性：">·</a></h4><blockquote><p>overflow文档：https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow</p></blockquote><p>定义当一个元素的内容太大而无法适应 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">块级格式化上下文</a> 时候该做什么，该属性有四个常用的值：</p><blockquote><p><code>visible</code>: 默认值。内容不会回修剪，可以呈现在元素框之外。</p><p><code>hidden</code>: 如果内容超出父级容器，超出部分将会被隐藏</p><p><code>scroll</code>: 无论是否超出容器，都会出现一个滚动条。</p><p><code>auto</code>: 如果没有超出容器的显示，将会正常显示，如果超出，将会出现一个滚动条。</p></blockquote><p><strong>值得注意的是</strong>：</p><ul><li>如果 <code>overflow-x</code> 与 <code>overflow-y</code> 的值相同，结果等同于 <code>overflow</code>；</li><li>如果  <code>overflow-x</code> 与 <code>overflow-y</code> 不同，且其中一个属性的值被赋予 <code>visible</code>，另外一个被赋予一个 非 <code>visible</code> 的值，第一个被赋予 <code>visible</code> 的值会自动变为 <code>auto</code>。</li></ul><h4 id="起作用的条件：">起作用的条件：<a class="anchor" href="#起作用的条件：">·</a></h4><blockquote><ul><li><p>父容器非 <code>display:inline</code> 水平</p></li><li><p>对应方位的尺寸限制，(<code>width</code> / <code>height</code> / <code>max-width</code> / <code>max-height</code> / <code>absolute</code>拉伸 )</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">垂直滚动设置 高度或者最小高度 如：&#123;overflow:scroll; height:500px&#125;</span><br><span class="line"></span><br><span class="line">水平滚动设置 宽度或者最小宽度 如：&#123;overflow:scroll; width:500px&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于单元格<code>td</code>元素等，还需要设置<code>table</code>为<code>table-layout:fixed</code>状态</p></li></ul></blockquote><h4 id="滚动条出现的条件：">滚动条出现的条件：<a class="anchor" href="#滚动条出现的条件：">·</a></h4><blockquote><ol><li><p>HTML 元素自带的，例如 <code>&lt;html&gt;</code> 和 <code>&lt;textarea&gt;</code> 属性。</p><p><strong>值得注意的是</strong>，默认滚动条是来自于 <code>&lt;html&gt;</code> 元素而不是 <code>&lt;body&gt;</code> 元素。滚动条也会占用用容器的可用宽度或者高度</p></li><li><p>使用 <code>overflow</code> 属性出现的滚动条：内容超出范围</p></li></ol></blockquote><blockquote><p>获取滚动条：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let st = document.documentElement.scrollTop || document.body.scrollTop;</span><br></pre></td></tr></table></figure></blockquote><h4 id="自定义滚动条scrollbar：">自定义滚动条scrollbar：<a class="anchor" href="#自定义滚动条scrollbar：">·</a></h4><blockquote><p>文档：https://developer.mozilla.org/zh-CN/docs/Web/CSS/::-webkit-scrollbar</p><p><code>webkit</code> 内核提供了以下适用于 <code>webkit</code> 内核的浏览器自定义滚动条的样式的属性，具体如下：</p><ul><li><code>::-webkit-scrollbar</code> — 整个滚动条.</li><li><code>::-webkit-scrollbar-button</code> — 滚动条上的按钮 (上下箭头).</li><li><code>::-webkit-scrollbar-thumb</code> — 滚动条上的滚动滑块.</li><li><code>::-webkit-scrollbar-track</code> — 滚动条轨道.</li><li><code>::-webkit-scrollbar-track-piece</code> — 滚动条没有滑块的轨道部分.</li></ul></blockquote><blockquote><h5 id="滚动条样式美化">滚动条样式美化<a class="anchor" href="#滚动条样式美化">·</a></h5><p>巧了，博客魔改中也使用了滚动条的相关属性：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.test1</span>::-webkit-scrollbar &#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">8px</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="selector-class">.test1</span>::-webkit-scrollbar-track &#123;  </span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#808080</span>;  </span><br><span class="line"> -webkit-<span class="attribute">border-radius</span>: <span class="number">2em</span>;  </span><br><span class="line"> -moz-<span class="attribute">border-radius</span>: <span class="number">2em</span>;  </span><br><span class="line"> <span class="attribute">border-radius</span>:<span class="number">2em</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="selector-class">.test1</span>::-webkit-scrollbar-thumb &#123;  </span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#ff4400</span>;  </span><br><span class="line"> -webkit-<span class="attribute">border-radius</span>: <span class="number">2em</span>;  </span><br><span class="line"> -moz-<span class="attribute">border-radius</span>: <span class="number">2em</span>;  </span><br><span class="line"> <span class="attribute">border-radius</span>:<span class="number">2em</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="依赖于-overflow-的-CSS-属性：">依赖于 overflow 的 CSS 属性：<a class="anchor" href="#依赖于-overflow-的-CSS-属性：">·</a></h4><blockquote><h5 id="resize-属性：">resize 属性：<a class="anchor" href="#resize-属性：">·</a></h5><ul><li>用于设定一个元素的是否可调整大小，该属性具有如下几个值：<ul><li><code>none</code>: 默认值，元素不能被用户缩放。</li><li><code>both</code>: 允许用户在水平和垂直方向上调整元素的大小。</li><li><code>horizontal</code>: 允许用户在水平方向上调整元素的大小。</li><li><code>vertical</code>: 允许用户在垂直方向上调整元素的大小。</li></ul></li></ul><h5 id="text-overflow-属性：">text-overflow 属性：<a class="anchor" href="#text-overflow-属性：">·</a></h5><ul><li>用于指定当文本溢出时的操作，该属性具有如下几个值：<ul><li><code>clip</code>: 默认值&quot;在内容区域的极限处截断文本</li><li><code>ellipsis</code>: 用 <code>...</code> 来表示被截断的文本</li><li><code>&lt;string&gt;</code>: 该字符串内容将会被添加在内容区域中，如果空间太小，该字符串也会被截断</li></ul></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> overflow、滚动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>帧动画-优化资源加载</title>
      <link href="/posts/animation.html"/>
      <url>/posts/animation.html</url>
      
        <content type="html"><![CDATA[<h2 id="center-逐帧动画替换MP4"><center>逐帧动画替换MP4<a class="anchor" href="#center-逐帧动画替换MP4">·</a></h2><blockquote><p>玩过捕鱼达人的小伙伴，可能见过金币旋转的效果。这种旋转的实现方式有很多种：</p><ul><li>使用MP4视频播放</li><li>使用帧动画播放长图，看起来形成动态效果</li><li>canvas逐帧画；</li></ul><p>今天，要分享的是如何将一个MP4视频，从节省资源大小的角度，将其抽成一个个图，形成一个雪碧图，再通过关键帧控制<strong>移动图片</strong>，使得连贯的显示成视频效果</p><ul><li>例如，点赞、取消赞的效果；</li><li>腾讯云的小图标播放</li></ul><p><strong>额外注意：</strong></p><ul><li>百分比的取值可以是基值的整数倍，不能是小数倍，否则又会看到切换过程</li></ul><p>demo地址：https://github.com/myNightwish/myCSS-demo-for-practice/tree/main/%E8%A7%86%E9%A2%91%E5%B8%A7%E5%8A%A8%E7%94%BB2</p></blockquote><hr><h3 id="实现点赞demo：">实现点赞demo：<a class="anchor" href="#实现点赞demo：">·</a></h3><h4 id="center-transition实现点赞demo："><center>transition实现点赞demo：<a class="anchor" href="#center-transition实现点赞demo：">·</a></h4><blockquote><h5 id="DOM">DOM:<a class="anchor" href="#DOM">·</a></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;heart&quot;</span> <span class="attr">class</span>=<span class="string">&quot;heart&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="JS">JS<a class="anchor" href="#JS">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> heart = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;heart&quot;</span>);</span><br><span class="line"></span><br><span class="line">heart.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;clicked&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="CSS">CSS<a class="anchor" href="#CSS">·</a></h5><p><strong>注意</strong>：如果position的值没把握好，会看到整个长图的切换过程，这肯定不是预期的</p><ul><li><h5 id="写法1：通过精准大小控制">写法1：通过精准大小控制<a class="anchor" href="#写法1：通过精准大小控制">·</a></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">web_heart_animation_edge.png</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="built_in">steps</span>(<span class="number">28</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clicked</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">2800px</span> <span class="number">0</span>; // <span class="number">28</span>份</span><br><span class="line">  <span class="attribute">transition-duration</span>: .<span class="number">8s</span>;  <span class="comment">/* 写在.heart中会使得取消的时候有反向的动画 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="写法2：通过属性控制">写法2：通过属性控制<a class="anchor" href="#写法2：通过属性控制">·</a></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">https://abs.twimg.com/a/1511233232/img/animations/web_heart_animation_edge.png</span>) <span class="number">0</span> <span class="number">0</span> no-repeat;</span><br><span class="line">      <span class="attribute">background-position</span>: left;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="built_in">steps</span>(<span class="number">28</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.clicked</span> &#123;</span><br><span class="line">      <span class="attribute">background-position</span>: right;</span><br><span class="line">      <span class="attribute">transition-duration</span>: <span class="number">0.8s</span>;  <span class="comment">/* 写在.heart中会使得取消的时候有反向的动画 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="center-Animation实现点赞demo："><center>Animation实现点赞demo：<a class="anchor" href="#center-Animation实现点赞demo：">·</a></h4><blockquote><h5 id="DOM-2">DOM<a class="anchor" href="#DOM-2">·</a></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;heart&quot;</span> <span class="attr">class</span>=<span class="string">&quot;heart stop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn-stop&quot;</span> <span class="attr">value</span>=<span class="string">&quot;play&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="JS-2">JS<a class="anchor" href="#JS-2">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> image = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;heart&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn-stop&quot;</span>);</span><br><span class="line">   </span><br><span class="line">button.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">value</span> == <span class="string">&#x27;pause&#x27;</span>) &#123;</span><br><span class="line">    image.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;stop&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="string">&#x27;paly&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    image.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;stop&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="string">&#x27;pause&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="CSS-2">CSS<a class="anchor" href="#CSS-2">·</a></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">web_heart_animation_edge.png</span>);</span><br><span class="line">  // 可以控制播放次数、暂停</span><br><span class="line">  <span class="attribute">animation</span>: heart-burst <span class="built_in">steps</span>(<span class="number">28</span>) <span class="number">0.8s</span> infinite both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.stop</span> &#123;<span class="attribute">animation-play-state</span>: paused; &#125;</span><br><span class="line"><span class="keyword">@keyframes</span> heart-burst &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background-position</span>: <span class="number">0%</span>;&#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background-position</span>: <span class="number">100%</span>;&#125;  </span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">@keyframes</span> heart-burst &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;<span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background-position</span>: -<span class="number">2800px</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="腾讯云播放demo">腾讯云播放demo<a class="anchor" href="#腾讯云播放demo">·</a></h3><blockquote><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  className=&#123;styles.<span class="property">baseIcon</span>&#125;</span><br><span class="line">  style=&#123;&#123;<span class="attr">background</span>: <span class="string">&#x27;./testPic.jpg&#x27;</span>&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h4 id="css">css<a class="anchor" href="#css">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.baseIcon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">animation</span>: enterAnimation <span class="number">2s</span> <span class="built_in">steps</span>(<span class="number">32</span>) forwards infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> enterAnimation &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background-position</span>: <span class="number">0</span> <span class="built_in">-</span>(动图的全部高度); &#125;// 高<span class="number">6400px</span></span><br><span class="line">  <span class="number">100%</span> &#123;<span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">  <span class="keyword">@keyframes</span> enterAnimation &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;<span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="number">100%</span> &#123;<span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">9600%</span>;&#125; //只要是<span class="number">32</span>*<span class="number">100</span>的整数倍都不会看到切换过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="视频如何抽帧">视频如何抽帧<a class="anchor" href="#视频如何抽帧">·</a></h2><p>？？？待解决的问题，这涉及到另一个很大的话题，视频抽帧问题，有时间探索一下；</p>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 帧动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基建(2)之webp转换&amp;资源引入</title>
      <link href="/posts/basic_construct_2.html"/>
      <url>/posts/basic_construct_2.html</url>
      
        <content type="html"><![CDATA[<h2 id="webpack插件实践踩坑及收获">webpack插件实践踩坑及收获<a class="anchor" href="#webpack插件实践踩坑及收获">·</a></h2><blockquote><h3 id="前言-2">前言<a class="anchor" href="#前言-2">·</a></h3><p>在开始今天的文章之前，依旧先交代下问题出现的背景（凑字数）：</p><ul><li>基于项目性能提升的需要，我们需要将网站中所有图片png、jpg格式图片全部换成webp格式的；</li><li>手动替换是不现实的，而npm包上并没有现成的符合我们需求的插件，基于此，决定自己写一个脚本，进而将脚本封装为webpack插件</li><li>在此过程中，需要了解webpack插件机制，从而在合适的时机去执行脚本；</li><li>完成插件后，我们还需要将本地项目中的.png后缀换成webp，否则项目跑不起来；手动替换显然有点Naive，于是需要写一个loader；</li><li>基于以上需求，我们需要做的事：<ol><li>完成图片转换webp脚本的编写；</li><li>完成脚本到plugin从插件的转换；</li><li>编写loader替换原有的png代码；</li><li>思考如何优化？<ul><li>你希望本地运行时时期就执行转换吗？</li><li>还是说打包时，才做这件事，那么本地项目怎么跑起来；</li></ul></li><li>之前的一个优化：关于线上、线下资源部署路径导入问题，如何借助webpack解决这个问题<ul><li>loader与plugin的区别，什么时候用loader，什么时候用plugin</li><li>如何用loader解决这个问题</li></ul></li></ol></li></ul></blockquote><h3 id="一、转换webp的脚本">一、转换webp的脚本<a class="anchor" href="#一、转换webp的脚本">·</a></h3><blockquote><h4 id="关于插件版本：">关于插件版本：<a class="anchor" href="#关于插件版本：">·</a></h4><ul><li><p>ESModule导入方式：两个插件的高版本所支持的，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imagemin <span class="keyword">from</span> <span class="string">&#x27;imagemin&#x27;</span>;  <span class="comment">//  8.版本</span></span><br><span class="line"><span class="keyword">import</span> imageminWebp <span class="keyword">from</span> <span class="string">&#x27;imagemin-webp&#x27;</span>; <span class="comment">//  7.版本</span></span><br></pre></td></tr></table></figure></li><li><p>此时为了脚本运行，在package.json中添加了，从而可以实现转换功能。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>但由于我需要将功能进一步封装为插件，于是，还需要配置webpack。然而Next中的webpack配置很多文件都是CJS导入，此时必须将这部分也换为CJS导入。但这种导入在高版本中不支持~需要两个不同低版本的搭配使用，而不能直接用最新版</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;imagemin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> imageminWebp = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webp&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>小教训：有问题多去issue，goole，少用中文，我的描述可能不准确</p></li></ul></blockquote><blockquote><h4 id="实现思路：">实现思路：<a class="anchor" href="#实现思路：">·</a></h4><ul><li>从输入命令中读取指定的要转换的目录、得到路径、转换质量；</li><li>递归读取文件目录下的jpg、png图片，借助插件，转换图片；</li><li>每层完成转换后，继续往深处目录递归读取，知道完成所有的转换</li></ul></blockquote><blockquote><p>脚本实现：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">recurConvert</span> (dir) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = fs.<span class="title function_">readdirSync</span>(dir, &#123;<span class="attr">withFileTypes</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">imageMin</span>([path.<span class="title function_">join</span>(dir, <span class="string">&#x27;*.&#123;jpg,png&#125;&#x27;</span>)], dir, &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [ <span class="title function_">imageMinWebp</span>(&#123; <span class="attr">quality</span>: quality&#125;) ]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 删除png、jpg图片</span></span><br><span class="line">  fs.<span class="title function_">readdirSync</span>(dir).<span class="title function_">filter</span>(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 踩坑：=== (&#x27;.png&#x27;|| &#x27;.jpg&#x27;)  运算优先级</span></span><br><span class="line">    <span class="keyword">const</span> excludeType = path.<span class="title function_">extname</span>(file).<span class="title function_">toLowerCase</span>() === (<span class="string">&#x27;.png&#x27;</span>|| <span class="string">&#x27;.jpg&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(excludeType)&#123;</span><br><span class="line">      <span class="keyword">const</span> deleteFile = path.<span class="title function_">join</span>(dir, file);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fs.<span class="title function_">unlink</span>(deleteFile);</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未成功删除png、jpg图片&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 串行、并行转换复习一下</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = res.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i].<span class="title function_">isDirectory</span>()) &#123;</span><br><span class="line">      <span class="comment">// 如果有文件夹，继续往深处读取转换</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">recurConvert</span>(path.<span class="title function_">join</span>(dir, res[i].<span class="property">name</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用脚本：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imageMin = <span class="built_in">require</span>(<span class="string">&#x27;imagemin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> imageMinWebp = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输入参数中读取：指定转换的目录、转换质量</span></span><br><span class="line"><span class="comment">// node ./convertScript.js  /public  75</span></span><br><span class="line"><span class="keyword">const</span> quality = process.<span class="property">argv</span>[<span class="number">3</span>] || <span class="number">75</span>;</span><br><span class="line"><span class="keyword">const</span> startDir = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./&#x27;</span>, process.<span class="property">argv</span>[<span class="number">2</span>]);</span><br><span class="line"><span class="title function_">recurConvert</span>(startDir); <span class="comment">// 从当前所在根目录开始读取</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><h4 id="写脚本：">写脚本：<a class="anchor" href="#写脚本：">·</a></h4><ul><li>第一次写脚本，是个蛮有意思的过程，简单学习了文件读写操作等</li><li>一点启示：<ul><li>期望尝试做点小工具之类的，用于博客工具、懒人工具；</li><li>之前博客魔改，在魔改插件的时候学习下插件的封装，非webpack；</li></ul></li></ul></blockquote><h3 id="二、转换webp的插件">二、转换webp的插件<a class="anchor" href="#二、转换webp的插件">·</a></h3><blockquote><p>由于项目的需要，此处指的是webpack插件；</p><p>之前的文章简单介绍过封装一个插件的过程，本环节主要是</p><ul><li>脚本是如何转换为插件；</li><li>梳理一下webpack运行机制，帮助我们了解webpack运行的过程      --webpack专题</li><li>封装插件时，如何选择合适的时机，这是我比较好奇的一点   --webpack专题</li></ul></blockquote><blockquote><h3 id="转换插件：">转换插件：<a class="anchor" href="#转换插件：">·</a></h3><ul><li>只需要将脚本要执行的事情，放在合适的时机钩子里去执行即可；</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  导入依赖包和模块...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">convertWebpWebpackPlugin</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">compile</span>.<span class="title function_">tap</span>(<span class="string">&#x27;convertWebpWebpackPlugin&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...省略recurConvert函数</span></span><br><span class="line">      <span class="keyword">const</span> &#123; quality, convertPath &#125; = <span class="variable language_">this</span>.<span class="property">options</span>;</span><br><span class="line">      <span class="keyword">const</span> startDir = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../&#x27;</span>, convertPath);</span><br><span class="line">      <span class="keyword">const</span> isDir = fs.<span class="title function_">statSync</span>(startDir).<span class="title function_">isDirectory</span>();</span><br><span class="line">      isDir &amp;&amp; <span class="title function_">recurConvert</span>(startDir);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = convertWebpWebpackPlugin;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">convertWebpWebpackPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">quality</span>: <span class="number">75</span>,</span><br><span class="line">  <span class="attr">convertPath</span>: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="插件优化：">插件优化：<a class="anchor" href="#插件优化：">·</a></h3><ul><li>补充打印日志的功能；</li><li>补充外部定义重写选项：</li><li>插件使用7.0版本写法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">convertWebpWebpackPlugin</span> &#123;</span><br><span class="line">  <span class="comment">// ....省略</span></span><br><span class="line">    <span class="comment">// 输出 asset 到 output 目录之前执行</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;convertWebpWebpackPlugin&#x27;</span>,</span><br><span class="line">       <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; type = <span class="string">&#x27;png&#x27;</span>, quality = <span class="number">75</span>, </span><br><span class="line">               convertPath = <span class="string">&#x27;public&#x27;</span>,override = <span class="literal">false</span>,</span><br><span class="line">          detailedLogs = <span class="literal">true</span>,&#125; = <span class="variable language_">this</span>.<span class="property">options</span>;</span><br><span class="line">      <span class="comment">// 这里其实是imageMin升级版7.0的写法，跟上面6版本写法是一样的目的</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">recurConvert</span>(<span class="params">dir</span>) &#123;</span><br><span class="line">          <span class="title function_">imageMin</span>([path.<span class="title function_">join</span>(dir, <span class="string">`*.&#123;<span class="subst">$&#123;type&#125;</span>&#125;`</span>)], &#123;</span><br><span class="line">            <span class="attr">destination</span>: dir,</span><br><span class="line">            <span class="attr">plugins</span>: [<span class="title function_">imageMinWebp</span>(&#123; quality &#125;)],</span><br><span class="line">          &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">files</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 官方文档：//=&gt; [&#123;data: &lt;Buffer 89 50 4e …&gt;, destinationPath: &#x27;build/images/foo.jpg&#x27;&#125;, …]</span></span><br><span class="line">                files.<span class="property">length</span> &amp;&amp; files.<span class="title function_">map</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">                   <span class="keyword">const</span> &#123; data, sourcePath, destinationPath &#125; = ele;</span><br><span class="line">                   detailedLogs &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">                      <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.floor(fs.statSync(sourcePath).size / <span class="number">1000</span></span></span></span><br><span class="line"><span class="subst"><span class="string">                      )&#125;</span>KB --&gt; <span class="subst">$&#123;<span class="built_in">Math</span>.floor(data.length/<span class="number">1000</span>)&#125;</span>KB`</span>,destinationPath</span><br><span class="line">                    );<span class="comment">// 打印转换日志：</span></span><br><span class="line">                  !!override &amp;&amp; fs.<span class="title function_">unlinkSync</span>(sourcePath); <span class="comment">// 是否删除原文件 </span></span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error during convert：&#x27;</span>, error);&#125;);</span><br><span class="line">          <span class="keyword">let</span> files = fs.<span class="title function_">readdirSync</span>(dir, &#123;<span class="attr">withFileTypes</span>: <span class="literal">true</span>,&#125;);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.<span class="title function_">isDirectory</span>()) &#123;</span><br><span class="line">              <span class="keyword">await</span> <span class="title function_">recurConvert</span>(path.<span class="title function_">join</span>(dir, file.<span class="property">name</span>));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//在assets output 的时候触发，用compilation的assets找到静态文件</span></span><br><span class="line">          <span class="keyword">const</span> isDir = fs.<span class="title function_">statSync</span>(convertPath).<span class="title function_">isDirectory</span>();</span><br><span class="line">          isDir &amp;&amp; <span class="title function_">recurConvert</span>(convertPath);</span><br><span class="line">          <span class="title function_">callback</span>(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          compilation.<span class="property">warnings</span>.<span class="title function_">push</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`convertWebpWebpackPlugin Error: <span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">convertWebpWebpackPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;png&#x27;</span>, <span class="comment">// 支持多种，用逗号隔开即可</span></span><br><span class="line">  <span class="attr">quality</span>: <span class="number">75</span>,</span><br><span class="line">  <span class="attr">assets</span>: <span class="string">&#x27;public/img/&#x27;</span>,</span><br><span class="line">  <span class="attr">override</span>: <span class="literal">true</span>, </span><br><span class="line">  <span class="attr">detailedLogs</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="疑问：">疑问：<a class="anchor" href="#疑问：">·</a></h4><p>我的疑问是：脚本有必要写成webpack插件吗？</p><p>目前来看，插件在npm run dev运行时（编译时）就完成了替换，此时项目已经可以正常运行了；</p><p>那么写成插件的意义是什么呢？</p></blockquote><h3 id="三、替换png的loader">三、替换png的loader<a class="anchor" href="#三、替换png的loader">·</a></h3><blockquote><p>由于项目是在next框架下开发的，尽管这些可以实现webpack中的配置，但在Next中仍然存在问题：</p><ol><li>项目中存在很多png图片，如果直接执行插件，所有png被换位webp，此时项目跑不起来，因为原本代码是找png代码；此时还需要替换；</li><li>脚本中，出于项目打包体积的考虑，将convert后的webp图片对应的png图片删除了，但如果convert过程中发生了错误，就会导致项目运行时找不到图片的错误；</li></ol></blockquote><blockquote><h4 id="string-replace-loader">string-replace-loader<a class="anchor" href="#string-replace-loader">·</a></h4><p>直接使用现有的：https://github.com/Va1/string-replace-loader</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(jsx|js|scss|tsx|ts)$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;string-replace-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">search</span>: <span class="regexp">/\.(jpe?g|png)/</span>,</span><br><span class="line">    <span class="attr">replace</span>: <span class="string">&#x27;.webp&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="自定义loader：">自定义loader：<a class="anchor" href="#自定义loader：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> source.<span class="title function_">replace</span>(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;.webp&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">config.<span class="property">module</span>.<span class="property">rules</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(jsx|js|scss|tsx|ts)$/</span>,</span><br><span class="line"><span class="attr">use</span>: [path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./loaders/replacePicExten.js&#x27;</span>)]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>问题：</p><p>只能支持将原声标签img引入时的图片，编译后，其后缀转换为webp；</p><p>不支持混入引入方式、src函数引入图片、url传入的3种方式，会找不到图片</p></li><li><p>为什么不生效呢？</p><p>因为这样写，它会找source中’.png’的字符串，可是source是单独的一个js文件作为一整个字符串，所以它即使包含了’.png’，它也并不是’.png’，所以无法完成替换</p><p>此外，还应该区分：哪个文件夹下的png字符串</p></li></ul></blockquote><h3 id="四、替换原生img路径-loader">四、替换原生img路径-loader<a class="anchor" href="#四、替换原生img路径-loader">·</a></h3><blockquote><h4 id="4-1-背景">4.1 背景<a class="anchor" href="#4-1-背景">·</a></h4><p>交代背景：我们需要区分测试环境develop和线上环境两个东西，所以代码中的请求资源路径是固定的，但是两个环境路径、甚至域名什么的都不一样，不可能说写死(测试环境代码请求路径时写一套，线上环境的再写一套)，所以需要配置环境变量env，分开配置它，检测我们的项目运行在哪个环境中：</p><ul><li>如果在测试环境，ok，把请求资源时，前面那一坨换成期望的测试环境的域名</li><li>如果在线上环境，就将其换成线上指定的域名配置</li></ul></blockquote><blockquote><h4 id="4-2-配置域名：">4.2 配置域名：<a class="anchor" href="#4-2-配置域名：">·</a></h4><p>比如说，我们开发产品叫小度xiaodu，依据Next的约定，会有3个环境的划分：</p><h5 id="测试环境、也叫staging-环境（test）：">测试环境、也叫staging 环境（test）：<a class="anchor" href="#测试环境、也叫staging-环境（test）：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//xiaodu.staging.com</span></span><br><span class="line">基于这样的一个域名下，会有很多的子路径：</span><br><span class="line">比如测试部署环境路径可能叫：/develop</span><br><span class="line">此时部署环境的完整路径：<span class="attr">https</span>:<span class="comment">//xiaodu.staging.com/develop</span></span><br><span class="line">那么我的项目跑在这个环境中时，所有的请求应该基于：项目部署根目录/develop的方式去划分</span><br><span class="line">- 比如使用api：项目部署根目录/develop/api的方式去请求</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">APP_DOMAIN</span>=<span class="attr">https</span>:<span class="comment">//xiaodu.staging.com</span></span><br><span class="line"><span class="variable constant_">NEXT_PUBLIC_PUBLIC_PATH</span>=/develop</span><br><span class="line"><span class="comment">// 指定url请求的base url</span></span><br><span class="line"><span class="variable constant_">NEXT_PUBLIC_API_BASE_URL</span>=$NEXT_PUBLIC_PUBLIC_PATH/api</span><br><span class="line"><span class="comment">// 指定获取静态资源的路径</span></span><br><span class="line"><span class="variable constant_">NEXT_PUBLIC_ASSETS_URL</span>=$APP_DOMAIN$NEXT_PUBLIC_PUBLIC_PATH</span><br></pre></td></tr></table></figure><h5 id="线上环境（production）">线上环境（production）<a class="anchor" href="#线上环境（production）">·</a></h5><p>同理，只是两个环境更换了域名而已；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">APP_DOMAIN</span>=<span class="attr">https</span>:<span class="comment">//www.xiaodu.com</span></span><br><span class="line"><span class="variable constant_">NEXT_PUBLIC_PUBLIC_PATH</span>=<span class="string">&#x27;&#x27;</span> <span class="comment">//它没有二级路径</span></span><br><span class="line"><span class="variable constant_">NEXT_PUBLIC_API_BASE_URL</span>=$NEXT_PUBLIC_PUBLIC_PATH/api</span><br><span class="line"><span class="variable constant_">NEXT_PUBLIC_ASSETS_URL</span>=$APP_DOMAIN</span><br></pre></td></tr></table></figure><h5 id="本地环境（development）：">本地环境（development）：<a class="anchor" href="#本地环境（development）：">·</a></h5><ul><li>就是本地跑的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">APP_DOMAIN</span>=<span class="attr">https</span>:<span class="comment">//localhost:4000  // 我指定了端口在哪里跑</span></span><br><span class="line"><span class="variable constant_">NEXT_PUBLIC_API_BASE_URL</span>=$NEXT_PUBLIC_PUBLIC_PATH/api</span><br><span class="line"><span class="variable constant_">NEXT_PUBLIC_ASSETS_URL</span>=$APP_DOMAIN</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="4-3-资源引入">4.3 资源引入<a class="anchor" href="#4-3-资源引入">·</a></h4><h5 id="1-发网络请求：">1 发网络请求：<a class="anchor" href="#1-发网络请求：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">比如通过axios请求时：</span><br><span class="line"><span class="attr">baseURL</span>: <span class="string">`<span class="subst">$&#123;process.env.NEXT_PUBLIC_API_BASE_URL&#125;</span>`</span>,</span><br></pre></td></tr></table></figure><h5 id="2-路由跳转">2 路由跳转<a class="anchor" href="#2-路由跳转">·</a></h5><ul><li><p>配置Next.config.js，但它只对link有效</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">basePath</span>: process.<span class="property">env</span>.<span class="property">NEXT_PUBLIC_PUBLIC_PATH</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3-Next的Image">3 Next的Image<a class="anchor" href="#3-Next的Image">·</a></h5><p><strong>Next.js对public的资源不起作用</strong>，Next中的public和dist不是子目录的关系</p><ul><li><p>配置Next.config.js，一个loader</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">images</span>: &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;imgix&#x27;</span>,  </span><br><span class="line">    <span class="attr">path</span>: process.<span class="property">env</span>.<span class="property">NEXT_PUBLIC_ASSETS_URL</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-请求静态资源之img">4 请求静态资源之img<a class="anchor" href="#4-请求静态资源之img">·</a></h5><ul><li>对于资源引入：img（src函数解决的）、混入（backgroundImage）、url、Image（Next自带）</li></ul><p>原生img标签：</p><ul><li><p>比如，某个代码用到了public下面的images下的图片testPic1.png</p></li><li><p>相对路径：images/testPic1.png</p><ul><li>项目部署在测试环境中时，资源在：https://www.xiaodu.com/public/images/testPic1.png</li><li>测试环境中时，资源在：https://xiaodu.staging.com/develop/public/images/testPic1.png</li></ul></li><li><p>所以只要将引入资源相对于public下的相对路径传入，拼接上所在环境的前缀就是它在对应环境里的正确资源路径：即</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$&#123;process.<span class="property">env</span>.<span class="property">NEXT_PUBLIC_ASSETSURL</span>&#125;$&#123;path&#125;</span><br></pre></td></tr></table></figure><p>所以可以写个拼接函数，在需要的地方传入这个相对路径调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> completeSrc = <span class="keyword">function</span> (<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;process.env.NEXT_PUBLIC_ASSETS_URL&#125;</span><span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>backgroundImage：</p><ul><li><p>背景色，采用混入的方式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">原本：<span class="attribute">Background-image</span>: <span class="built_in">url</span>()</span><br></pre></td></tr></table></figure></li><li><p>配置混入：在公共部分common.module.scss</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> appendHost($path) &#123;<span class="keyword">@return</span> $host + $path;&#125;</span><br><span class="line"></span><br><span class="line">// 将url带上host</span><br><span class="line"><span class="keyword">@mixin</span> backgroundImg($path) &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">appendHost($path</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>css使用：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@include</span> backgroundImg(<span class="string">&#x27;/componentStatic/cardhover.png&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>行内样式使用：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">style=&#123;&#123; <span class="attr">backgroundImage</span>: <span class="string">&#x27;url(&#x27;</span> + <span class="title function_">src</span>(bannerData.<span class="property">backgroundImg</span>) + <span class="string">&#x27;)&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-4-优化引入">4.4 优化引入<a class="anchor" href="#4-4-优化引入">·</a></h4><ul><li>拼接路径函数缺点：迭代中需要口口相传，而无法自动转换，能否使用一个webpack-loader进行转换，当传入相对路径时，将其替换；</li><li>需要实现的功能：路径替换，src形式，传入path，loader可自动拼接</li><li>实现问题：<ol><li>loader如何准确找到要转换的img标签的src；</li><li>loader如何替换src的值</li><li>loader何时去替换，因为你本地开发环境去替换了，是死的，不能说上线前再删掉，重新打包</li></ol></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我来了&#x27;</span>, <span class="keyword">typeof</span> source)  <span class="comment">// source是当前文件下的所有代码，string类型的</span></span><br><span class="line">  <span class="comment">// 问题0： 如何匹配jsx中的img标签   √</span></span><br><span class="line">  <span class="keyword">const</span> imgReg = <span class="regexp">/&lt;img.*?(?:&gt;|\/&gt;)/gi</span>;</span><br><span class="line">  <span class="keyword">const</span> resArr = source.<span class="title function_">match</span>(imgReg);  <span class="comment">// resArr 为包含所有img标签的数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!!resArr &amp;&amp; resArr.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; resArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> srcReg = <span class="regexp">/src=[\&#x27;\&quot;]?([^\&#x27;\&quot;]*)[\&#x27;\&quot;]?/i</span>;</span><br><span class="line">      <span class="comment">// 这里拿到的其实是字符串，item.picUrl,而非对应的真实地址</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resArr[i]&#x27;</span>, resArr[i], <span class="string">`<span class="subst">$&#123;resArr[i]&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> relativePath = resArr[i].<span class="title function_">match</span>(srcReg);</span><br><span class="line">      <span class="comment">// 问题1：如何拿到resArr[i]对应的真实相对地址path?  待解决~</span></span><br><span class="line">      <span class="keyword">const</span> joinPath = <span class="string">`<span class="subst">$&#123;process.env.NEXT_PUBLIC_ASSETS_ABS_URL&#125;</span><span class="subst">$&#123;relativePath&#125;</span>`</span>;</span><br><span class="line">      <span class="comment">// 问题2：如何将真实地址进行拼接</span></span><br><span class="line">      <span class="keyword">return</span> source.<span class="title function_">replace</span>(relativePath, joinPath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="五、疑问">五、疑问<a class="anchor" href="#五、疑问">·</a></h3><blockquote><p>需要带着问题去找资料学习总结一下，这部分内容在webpac专题里展开</p></blockquote><h4 id="loader的执行时机是什么？">loader的执行时机是什么？<a class="anchor" href="#loader的执行时机是什么？">·</a></h4><h4 id="loader与plugin有什么区别？">loader与plugin有什么区别？<a class="anchor" href="#loader与plugin有什么区别？">·</a></h4><h4 id="待解决的问题的原因是什么？">待解决的问题的原因是什么？<a class="anchor" href="#待解决的问题的原因是什么？">·</a></h4>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基建 </tag>
            
            <tag> webpack插件 </tag>
            
            <tag> webp图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站开发-前端模块化</title>
      <link href="/posts/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96.html"/>
      <url>/posts/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目开发-模块化">项目开发~模块化<a class="anchor" href="#项目开发-模块化">·</a></h2><blockquote><h4 id="本期文章背景：">本期文章背景：<a class="anchor" href="#本期文章背景：">·</a></h4><ul><li>基于项目中的需要封装webp转换的webpack插件，我在编写脚本时，需要使用两个插件，而他们的导入导出方式频繁报错；</li><li>这引起了我的注意力，于是借此契机，重新复习下前端模块化的导出方式，进而整理了模块化的发展；</li><li>在这个过程中，翻遍了github的issue和stackoverflow：<ul><li>通过github上的issue解决了两个插件的导入问题，顺利完成第一次插件的封装；</li><li>重新认识了之前背下来的知识点，之前只是记下了；</li><li>理解了一期博客魔改时的报错问题，以及当时的解决方式并不是最优的；</li></ul></li></ul></blockquote><blockquote><p>项目中的模块导出：</p><ul><li><p>需求：我需要将png格式的图片转化为webp格式的，于是我使用了两个插件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imagemin <span class="keyword">from</span> <span class="string">&#x27;imagemin&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> imageminWebp <span class="keyword">from</span> <span class="string">&#x27;imagemin-webp&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>然而，它们的最新版，都支持esModule导入方式，即import。此时为了脚本运行，在package.json中添加了，从而可以实现转换功能。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>但由于我需要将功能进一步封装为插件，于是，还需要配置webpack。然而webpack部分很多文件都是CJS导入，此时必须将这部分也换为CJS导入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;imagemin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> imageminWebp = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-webp&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>问题出现了，报错，原因：一个库支持esModule  一个库只支持CJS。</p><p>如果全部换为esModule，项目中很多东西需要全部更换，这不现实啊；</p><p>后来找到issue：</p><p>需要两个不同版本的搭配使用，而不能直接用最新版，大冤种啊~~这谁能知道</p></li><li><p>废话一句：goole上少用中文，都是泪~</p></li></ul></blockquote><h3 id="一、why模块化">一、why模块化<a class="anchor" href="#一、why模块化">·</a></h3><blockquote><h4 id="早期的JS发展：">早期的JS发展：<a class="anchor" href="#早期的JS发展：">·</a></h4><ul><li>JS作为一种脚本语言，做一些简单的表单验证或动画实现等，代码量少，只需将JS代码写到script标签中即可，并没必要放到多个文件中来编写；</li></ul></blockquote><blockquote><h4 id="问题出现：">问题出现：<a class="anchor" href="#问题出现：">·</a></h4><p>要实现的业务越来越复杂，传统开发模式不能再满足，于是出现了模块化的思想；</p><ul><li>前端技术发展飞速，ajax的出现，前后端开发分离；</li><li>进而SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要JS来实现；</li><li>Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；</li></ul><h4 id="什么叫模块">什么叫模块<a class="anchor" href="#什么叫模块">·</a></h4><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul></blockquote><blockquote><h4 id="模块化带来了什么好处：">模块化带来了什么好处：<a class="anchor" href="#模块化带来了什么好处：">·</a></h4><ul><li>避免命名冲突，减少命名空间污染</li><li>更好的分离, 按需加载</li><li>**高复用性：**公共模块可以促进代码复用，业务模块可以提升项目的可维护性；</li><li><strong>高维护性</strong>：为了满足高内聚低耦合，需要将不具备复用价值的代码抽离成相互独立的模块，有很多关于函数不要超过多少行的经验，所以要做有意义的代码拆分</li></ul></blockquote><h3 id="二、模块化演变">二、模块化演变<a class="anchor" href="#二、模块化演变">·</a></h3><blockquote><h4 id="阶段1：全局function模式">阶段1：全局function模式<a class="anchor" href="#阶段1：全局function模式">·</a></h4><p>将不同的功能封装成不同的全局函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>问题:<ul><li>污染全局作用域，容易引起<strong>命名冲突或数据不安全</strong>，<strong>变量可以在外部访问和修改</strong>；</li><li>无法管理模块间的依赖关系，模块成员之间看不出直接关系</li></ul></li></ul><blockquote><h4 id="阶段2：namespace模式">阶段2：namespace模式<a class="anchor" href="#阶段2：namespace模式">·</a></h4><p>简单对象封装：变成对象的属性或方法，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line"><span class="attr">data</span>: <span class="string">&#x27;www.baidu.com&#x27;</span>,</span><br><span class="line"><span class="title function_">foo</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>`</span>)&#125;,</span><br><span class="line"><span class="title function_">bar</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>`</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.<span class="property">data</span> = <span class="string">&#x27;other data&#x27;</span> <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.<span class="title function_">foo</span>() <span class="comment">// foo() other data</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure></blockquote><ul><li>优点： 减少了全局变量，解决命名冲突</li><li>缺点：这样的写法会暴露所有模块成员，内部状态可以被外部改写</li></ul><blockquote><h4 id="阶段3：IIFE模式">阶段3：IIFE模式<a class="anchor" href="#阶段3：IIFE模式">·</a></h4><p>匿名函数自调用(闭包)：将数据和行为封装到一个函数内, 通过给window添加属性向外暴露接口</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> myModule.<span class="title function_">foo</span>()</span></span><br><span class="line"><span class="language-javascript"> myModule.<span class="title function_">bar</span>()</span></span><br><span class="line"><span class="language-javascript"> <span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">data</span>) <span class="comment">//undefined 不能访问模块内部数据</span></span></span><br><span class="line"><span class="language-javascript"> myModule.<span class="property">data</span> = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span><br><span class="line"><span class="language-javascript"> myModule.<span class="title function_">foo</span>() <span class="comment">//没有改变</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span></span>) &#123;  <span class="comment">// module.js文件</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span>   <span class="comment">//操作数据的函数</span></span><br><span class="line"><span class="comment">//用于暴露私有函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)&#125;</span><br><span class="line"><span class="comment">//用于暴露私有函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line"> <span class="title function_">otherFun</span>() <span class="comment">//内部调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部私有的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">otherFun</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;otherFun()&#x27;</span>)&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="property">myModule</span> = &#123; foo, bar &#125; <span class="comment">//ES6写法 //暴露行为</span></span><br><span class="line">&#125;)(<span class="variable language_">window</span>)</span><br></pre></td></tr></table></figure></blockquote><ul><li>好处：数据是私有的，外部只能通过暴露的方法操作</li><li>问题：如果当前这个模块依赖另一个模块怎么办?</li></ul><blockquote><h4 id="阶段4：引入依赖">阶段4：引入依赖<a class="anchor" href="#阶段4：引入依赖">·</a></h4><p>是IIFE模式增强，现代模块实现的基石</p><p>例子：通过jquery方法将页面背景色改成红色，so必须先引入jQuery，把这个库当作参数传入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function(window, $) &#123;  // module.js文件</span><br><span class="line">let data = &#x27;www.baidu.com&#x27;   //操作数据的函数</span><br><span class="line">//用于暴露私有函数</span><br><span class="line">function foo() &#123; console.log(`foo() $&#123;data&#125;`)</span><br><span class="line"> $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)&#125;</span><br><span class="line">//用于暴露私有函数</span><br><span class="line">function bar() &#123;</span><br><span class="line"> console.log(`bar() $&#123;data&#125;`)</span><br><span class="line"> otherFun() //内部调用</span><br><span class="line">&#125;</span><br><span class="line">//内部私有的函数</span><br><span class="line">function otherFun() &#123; console.log(&#x27;otherFun()&#x27;)&#125; </span><br><span class="line">window.myModule = &#123; foo, bar &#125; //暴露行为</span><br><span class="line">&#125;)(window, jQuery)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入的js必须有一定顺序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>myModule.foo()<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>好处：<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</li></ul><blockquote><h4 id="阶段5：各种规范出现">阶段5：各种规范出现<a class="anchor" href="#阶段5：各种规范出现">·</a></h4><p><strong>引入多个<code>script</code>后出现问题：</strong></p><ul><li><p>请求过多：如果要依赖多个模块，那就会发送多个请求，导致请求过多</p></li><li><p>依赖模糊：不知道他们的具体依赖关系，很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p></li><li><p>难以维护：以上两点就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重问题</p></li><li><p>模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。</p></li></ul><p>而这些问题可以通过模块化规范来解决，目前主流的 <code>JavaScript</code> 模块化规范有 <strong>CommonJS</strong>，AMD，CMD，<strong>ES6 Module</strong> 四种规范</p></blockquote><h3 id="三、CJS">三、CJS<a class="anchor" href="#三、CJS">·</a></h3><h4 id="1、基本语法">1、基本语法<a class="anchor" href="#1、基本语法">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(xxx)；</span><br><span class="line"><span class="comment">// 如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径；</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = value  或<span class="built_in">exports</span>.<span class="property">xxx</span> = value</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="keyword">function</span> (<span class="params">value</span>) &#123;<span class="keyword">return</span> value + x;&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">x</span> = x;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">addX</span> = addX;</span><br><span class="line">-----</span><br><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="property">x</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="title function_">addX</span>(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="2、特点">2、特点<a class="anchor" href="#2、特点">·</a></h4><ul><li><p>所有代码都运行在模块作用域，不会污染全局作用域。</p></li><li><p>模块<strong>可多次加载</strong>，但<strong>只会在第一次加载时运行一次，然后运行结果就被缓存了</strong>，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</p></li><li><p>模块加载的顺序，按照其在代码中出现的顺序</p></li><li><p><strong>node提出</strong>的标准，在服务器端，模块的加载是<strong>运行时同步加载</strong>的；</p><p>Node中每个js文件都是个单独的模块，单独的作用域，在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见；</p></li><li><p>在<strong>浏览器端，模块需要提前编译打包处理</strong></p></li></ul><h4 id="3、模块的加载机制">3、模块的加载机制<a class="anchor" href="#3、模块的加载机制">·</a></h4><blockquote><h5 id="3-1-CJS暴露的模块到底是什么">3.1 CJS暴露的模块到底是什么?<a class="anchor" href="#3-1-CJS暴露的模块到底是什么">·</a></h5><ul><li><p>CJS规定，每个模块内部，module变量代表当前模块。</p></li><li><p>而这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。</p></li><li><p>所以，<strong>加载某个模块，其实是加载该模块暴露出的module.exports属性</strong></p></li></ul></blockquote><blockquote><h5 id="3-2-输入的是被输出的值的拷贝：">3.2 输入的是被输出的值的拷贝：<a class="anchor" href="#3-2-输入的是被输出的值的拷贝：">·</a></h5></blockquote><ul><li><p>一旦输出一个值，<strong>模块内部的变化就影响不到这个值</strong>。这点与ES6模块化有重大差异</p><ul><li>lib.js：输出内部变量counter和改写这个变量的内部方法incCounter</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;counter++;&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>counter输出以后，lib.js模块内部的变化就影响不到counter了。因为<strong>counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">incCounter</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="四、ESModule">四、ESModule<a class="anchor" href="#四、ESModule">·</a></h3><blockquote><p>设计思想：尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p><p>基本两种使用方式：import静态导入和import（）动态加载</p></blockquote><h4 id="1、基本语法-2">1、基本语法<a class="anchor" href="#1、基本语法-2">·</a></h4><blockquote><p>使用import命令时，需要知道所要加载的变量名或函数名，否则无法加载；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** export命令用于规定模块的对外接口 **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;   <span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** import命令用于输入其他模块提供的功能 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">ele</span>) &#123;  ele.<span class="property">textContent</span> = <span class="title function_">add</span>(<span class="number">99</span> + basicNum);&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>export default</strong>：</p><ul><li>为了让用户不阅读文档就能加载模块，就要用到<strong>export default</strong>命令，为模块指定默认输出</li><li>其他模块加载该模块时，import命令可以为该匿名函数自定义名字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);&#125;</span><br><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="2、动态加载">2、动态加载<a class="anchor" href="#2、动态加载">·</a></h4><ul><li><p>注意：import加载一个模块，是不可以在其放到逻辑代码中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123; <span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./xxx&#x27;</span>&#125; <span class="comment">// 报错：unexpected identifier（语法错误）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>解析阶段执行的放在运行阶段执行，导致报错</strong></p><ul><li>JS代码时交给JS引擎执行经过：Parse — AST — 字节码 — 二进制代码 — 执行</li><li>parse过程对语法进行了分析，此时就必须知道它的依赖关系，就已经确定了依赖关系，此阶段并没有执行，。</li><li>这时js代码没有任何的运行，所以无法在类似if判断中根据代码的执行情况；</li></ul></li></ul><h5 id="import-函数">import() 函数<a class="anchor" href="#import-函数">·</a></h5><blockquote><ul><li>脚手架中的import 基于webpack ，所以webpack会对import函数进行解析，将（）里面的内容单独打包到JS文件，到时候多个JS文件在首屏渲染的时候，就不需一次性加载一个非常大的文件，等到用这个文件时再加载即可</li><li>在webpack环境下，一般用require，它支持ES CJS。若在es module环境下用import函数</li></ul></blockquote><ul><li><p>import函数返回的是一个promise；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="title function_">import</span>(<span class="string">&#x27;./xxx.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">fun1</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err)&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="title function_">import</span>(<span class="string">&#x27;./xxx.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">fun2</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>export default {}的形式导出，此时promise 的res.default是一个对象，结果存放在这里</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">取得时候：res.<span class="property">default</span>.<span class="property">fun1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、模块加载机制">3、模块加载机制<a class="anchor" href="#3、模块加载机制">·</a></h4><h5 id="3-1-ESModule输出的是值的引用，而CJS输出的是一个值的拷贝">3.1 ESModule输出的是值的引用，而CJS输出的是一个值的拷贝<a class="anchor" href="#3-1-ESModule输出的是值的引用，而CJS输出的是一个值的拷贝">·</a></h5><blockquote><p><strong>ES Module</strong></p><ul><li>export在导出一个变量时，js引擎会解析这个语法，并创建<strong>模块环境记录</strong>；</li><li><strong>模块环境记录</strong>会和变量进行实时绑定；</li><li>在导入的地方，可以实时获取到绑定的最新值；所以，如果在导出的模块中修改了，那导入的地方可实时获取最新变量；</li><li>JS引擎在实时绑定时，一旦发现值发生改变，并不是直接赋值，而是将之前的值删除，用新的值绑定，再将新的值放入记录中，用的时候也是拿新值。</li><li>注意：在导入的地方不可以修改变量，因为它只是被绑定到了这个变量上（其实是一个常量）</li></ul></blockquote><blockquote><p><strong>CommonJS</strong></p><ul><li>module.exports导出的是一个对象，可以将这个对象的引用在其他模块中赋值给其他变量</li><li>但最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改</li></ul></blockquote><h5 id="3-2-ESModule编译时加载、异步加载，CJS运行时同步加载">3.2 ESModule编译时加载、异步加载，CJS运行时同步加载<a class="anchor" href="#3-2-ESModule编译时加载、异步加载，CJS运行时同步加载">·</a></h5><blockquote><p><strong>ES Module</strong></p><ul><li><p>编译时（解析）加载：import不能和运行时相关内容一起使用，so也称ES Module是静态解析的，而不是动态或者运行时解析的；</p><ul><li>比如from后面的路径需要动态获取；</li><li>比如不能将import放到if等语句的代码块中；</li></ul></li><li><p>异步加载：JS引擎遇到import时会去获取这个js文件，但<strong>这个获取过程是异步的，并不会阻塞主线程继续执行；</strong></p><ul><li><p>也就是说<strong>设置了 type=module 的代码，相当于在script标签上也加上了 async 属性</strong>；</p></li><li><p>如果后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；结果：② — ①</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;main.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// 这个js文件的代码不会被阻塞执行</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><blockquote><p><strong>CommonJS</strong></p><ul><li>运行时：CommonJS 加载的是一个对象（即module.exports属性），该对象<strong>只有在脚本运行完才会生成</strong>。</li><li>js引擎在<strong>执行js代码的过程</strong>中加载模块；</li><li>同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
            <tag> CommonJS </tag>
            
            <tag> ESModule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐藏元素</title>
      <link href="/posts/hideElement.html"/>
      <url>/posts/hideElement.html</url>
      
        <content type="html"><![CDATA[<h2 id="center-控制元素显示与隐藏-center"><center>控制元素显示与隐藏</center><a class="anchor" href="#center-控制元素显示与隐藏-center">·</a></h2><blockquote><p>文章的背景：</p><ul><li><p>同样是在官网的需求开发中，某些相似功能的实现，看到大佬的实现方式跟我的不太一样，所以这引起了我的好奇心：</p><ul><li><p>都有哪些隐藏方法及特点呢，这个问题面试中经常问，但自己实践的并不多；</p></li><li><p>最重要的是他们应用在实际开发中，自身特性会带来什么损失与收益？</p><p>比如我之前在react中很喜欢通过变量&amp;去控制元素的渲染，但我发现也有人特别青睐opacity去实现；</p><p>此外，对于视频类渲染资源，还会有明显的卡顿加载问题，display重复频繁的切换，不仅影响渲染中的资源频繁重建与消耗，还会带来播放卡顿这种不爽的体验；</p></li></ul></li></ul></blockquote><hr><p>Ok，在CSS中很多隐藏元素的方法，但这些方法的可访问性、布局、动画、性能和事件处理的方式有所不同。</p><blockquote><ul><li><strong>动画：</strong> 一些CSS隐藏元素的方法一般是全有或者全无，元素要么是完全可见，要么是完全不可见，并且没有中间状态。其他的，比如透明度，可以是一个范围的值，所以在这中间过程插入动画成为可能；</li><li><strong>可访问性：</strong> 下面的每一种方法都会在视觉上隐藏一个元素，但不一样会真正的去除DOM元素。有一些方式隐藏元素后，屏幕阅读器仍然能读取到元素内容；  欺骗眼睛~</li><li><strong>事件处理：</strong> 隐藏元素之后，有些方式元素上的事件仍然能被触发，而有些方式的会无效；</li><li><strong>表现：</strong><ul><li>浏览器加载并解析 HTML DOM 和 CSS 对象模型后，页面将分三个阶段呈现：布局（生成每个元素的几何位置）、绘制（绘制每个元素的像素）、组合（以适当的顺序放置元素层）。</li><li>仅导致构图变化的效果明显比影响布局的效果更好。在某些情况下，浏览器还可以使用硬件加速。</li></ul></li></ul></blockquote><hr><h3 id="1-1-opacity">1.1 opacity<a class="anchor" href="#1-1-opacity">·</a></h3><p>指的是opacity: N 和 filter: opacity(N) 属性这两种方式：数字代表了透明度：0-1之间</p><ul><li><p>opacity: N：该属性用来设置元素的透明度；</p></li><li><p>filter: opacity(N) ：filter属性用来<strong>设置元素的滤镜</strong>，opacity是滤镜中的透明度，用来设置元素的透明度</p></li><li><p>两者之间几乎没有实际的区别，但如果同时应用多种效果（模糊、对比度、灰度等）时，应该使用 filter 属性。</p></li><li><p>注意：opacity <strong>可以设置动画并提供出色的性能</strong>，但页面上<strong>保留完全透明的元素可能会触发事件</strong>。</p></li><li><p>为什么它会影响到渲染的第3层：组合呢？</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a2f0cb41f40420c9ffce6d682c88781~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom: 50%;" /></li></ul><hr><h3 id="1-2-color-alpha-透明度">1.2 color alpha 透明度<a class="anchor" href="#1-2-color-alpha-透明度">·</a></h3><ul><li><p>将元素的color、background-color 和 border-color 等属性设置为rgba(0,0,0,0)，这样元素会完全透明：</p></li><li><p>这三个属性都是支持设置动画效果</p></li><li><p>需要注意，透明度不能应用于<strong>带有背景图片的元素</strong>，除非它们是使用 linear-gradient 或类似方法生成的</p></li><li><p>Alpha 通道可以设置为：</p><ul><li>transparent：完全透明（中间不能插入动画）；</li><li>rgba(r, g, b, a)：红色、绿色、蓝色和 alpha；</li><li>hsla(h, s, l, a)：色相、饱和度、亮度和 alpha；</li><li>#RRGGBBAA 或 #RGBA。</li></ul></li><li><p>注意：会引起重绘~</p></li></ul><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/f607b886fa544a05af2a32cdbef41587~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" /><hr><h3 id="1-3-transform">1.3 transform<a class="anchor" href="#1-3-transform">·</a></h3><ul><li>transform用于元素的平移、缩放、旋转等。</li><li>通过 scale(0) 或者 translate(-9999px, 0px)  属性值将元素隐藏：</li><li><strong>transform 属性提供了出色的性能和硬件加速</strong>，因为<strong>元素被有效地移动到了单独的层</strong>中，并且可以在 2D 或 3D 中进行<strong>动画处理</strong>。</li><li>原始的布局空间会保持原样，并不会受影响。</li><li>使用这种方式隐藏的元素<strong>不会触发任何事件。</strong></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48f8701c71a74215b6bc64946b36e070~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><hr><h3 id="1-4-clip-path">1.4 clip-path<a class="anchor" href="#1-4-clip-path">·</a></h3><p>实例demo的githun地址：https://github.com/myNightwish/myCSS-demo-for-practice/tree/main/clip-path</p><blockquote><p>CSS 的 <a href="https://link.segmentfault.com/?enc=3AhC5uxscovJ3IW590c3AA%3D%3D.xJzvIJGM%2FNZl2dt8Ggv0WxUpiKJA8bFQ9lVvZtvdgv7GfH4BuqUv50Q5jc4o5z86BpGoJqbt%2FdE%2BL6NKg9BGig%3D%3D">clip-path</a> 属性是 <a href="https://link.segmentfault.com/?enc=P6Igi%2BfTG%2FS6s6RjYAdpCg%3D%3D.zyP8TfM8RV8W%2FKhKuTMzDkyuvql3LXUdwAvNctQhXuOLet8ZnD68cevyZAaxS%2BI%2Fq9oHdRlYKwjvqqI7Wepjlg%3D%3D">clip</a> 属性的升级版，它们的作用都是对元素进行 “剪裁”，不同的是 <code>clip</code> 只能作用于 <code>position</code> 为 <code>absolute</code> 和 <code>fixed</code> 的元素且剪裁区域只能是正方形，而 <code>clip-path</code> 更加强大，可以以任意形状去裁剪元素，且对元素的定位方式没有要求。基于这样的特性，<code>clip-path</code> 常用于实现一些炫酷的动画效果。</p></blockquote><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/1460000023301224-20220404211948735.gif" style="zoom:33%;" /><img src="https://segmentfault.com/img/remote/1460000023301225" alt="menus" style="zoom:33%;" /><ul><li><code>clip-path</code> 重要属性值，分别为：<ul><li><code>basic-shape</code>: 基本图形，包括 <code>inset()</code>、<code>circle()</code>、<code>ellipse()</code>、<code>polygon()</code></li><li><code>clip-source</code>: 通过 <code>url()</code> 方法引用一段 SVG 的 <code>&lt;clipPath&gt;</code> 来作为剪裁路径</li><li><code>geometry-box</code>: 单独使用时会将指定框的边缘作为剪裁路径，或者配合 <code>basic-shape</code> 使用，用于定义剪裁的<strong>参考框（Reference Box）</strong></li></ul></li></ul><h4 id="basic-shape-Inset"><code>basic-shape</code>: Inset()<a class="anchor" href="#basic-shape-Inset">·</a></h4><ul><li><p>Inset()：定义被剪裁元素内部的一块矩形区域。</p><blockquote><p>参数类型：<code>inset( &lt;shape-arg&gt;&#123;1,4&#125; [round &lt;border-radius&gt;]? )</code></p></blockquote><p>其中 <code>shape-arg</code> 分别为矩形的上右下左顶点到被剪裁元素边缘的距离（和<code>margin</code>、<code>padding</code>参数类似），<code>border-radius</code> 为可选参数，用于定义 border 的圆角。</p></li><li><p>demo展示：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inset</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">2s</span>; <span class="comment">/*加入动画  裁剪过程更加丝滑*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inset</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">100px</span> <span class="number">200px</span> <span class="number">10%</span> <span class="number">20%</span> round <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">img</span> class=&quot;inset&quot; <span class="attribute">src</span>=&quot;http://source.unsplash.com/random/<span class="number">500</span>x500<span class="string">&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="basic-shape-circle"><code>basic-shape</code>: circle()<a class="anchor" href="#basic-shape-circle">·</a></h4><p><strong>用 <code>clip-path: circle(0)</code> 可以将元素隐藏</strong></p><ul><li>定义一个圆，椭圆用Ellipse</li></ul><blockquote><p>参数类型：<code>circle( [&lt;shape-radius&gt;]? [at &lt;position&gt;]? )</code></p><p>其中 <code>shape-radius</code> 为圆形的半径，<code>position</code> 为圆心的位置</p></blockquote><p>如果 <code>shape-radius</code> 为百分比，则 100% 相当于：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(width^<span class="number">2</span>+height^<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">2</span>) width、height分别为被剪裁元素的宽高</span><br></pre></td></tr></table></figure><ul><li><p>demo例子：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inset</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">100px</span> at center);</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">2s</span>; <span class="comment">/*加入动画  裁剪过程更加丝滑*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inset</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">50%</span> at center);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">img</span> class=&quot;inset&quot; <span class="attribute">src</span>=&quot;http://source.unsplash.com/random/<span class="number">500</span>x500<span class="string">&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="basic-shape-Polygon"><code>basic-shape</code>: Polygon<a class="anchor" href="#basic-shape-Polygon">·</a></h4><ul><li><p><code>polygon()</code> 用于定义一个多边形。</p><blockquote><p>参数类型：<code>polygon( [&lt;fill-rule&gt;,]? [&lt;shape-arg&gt; &lt;shape-arg&gt;]# )</code></p></blockquote><p>其中 <code>fill-rule</code> 为填充规则，即通过一系列点去定义多边形的边界。</p></li><li><p>demo例子：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inset</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0%</span> <span class="number">50%</span>, <span class="number">50%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">50%</span>, <span class="number">50%</span> <span class="number">100%</span>);</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inset</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">0%</span> <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">img</span> class=&quot;inset&quot;  <span class="attribute">src</span>=&quot;http://source.unsplash.com/random/<span class="number">500</span>x500<span class="string">&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Clip-Source">Clip Source<a class="anchor" href="#Clip-Source">·</a></h4><p>即通过引用一个svg的 <a href="https://link.segmentfault.com/?enc=NJmk5BJIx8tB93fGAeBw%2Fg%3D%3D.Q%2FGM%2F0qUczCzn%2FDP0CpBg7BQTBP7a%2BjunWrE8md2RAbxJuM89lngQLk3fEwhNRnTAw1HF5M0C59cvqu%2BAS0wTX0sKGdrVAYsEsv75GWnoVI%3D">clipPath</a> 元素来作为剪裁路径。</p><ul><li><p>demo：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clipPath</span> <span class="attr">id</span>=<span class="string">&quot;svgCircle&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;500&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;500&quot;</span> <span class="attr">r</span>=<span class="string">&quot;400&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">clipPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;img svg-circle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://source.unsplash.com/random/500x500&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Clippy">Clippy<a class="anchor" href="#Clippy">·</a></h4><p>如果觉得计算和绘制图形太麻烦，可以使用 <a href="https://link.segmentfault.com/?enc=hMA%2B8jb%2FKjhN6lDI8wT0Cg%3D%3D.CLDBfoaVPdYvKKvog%2FaWURwanXyJe0yRMZR0lItjBM0IWEM%2BqLVkkPFemRpVVvI0">clippy</a> 这个在线 <code>clip-path</code> 绘制工具，里面包含了大部分常用的图形，也支持可视化绘制自定义图形。</p><h4 id="隐藏元素：⭐️⭐️">隐藏元素：⭐️⭐️<a class="anchor" href="#隐藏元素：⭐️⭐️">·</a></h4><p>用 <code>clip-path: circle(0)</code> 可以将元素隐藏</p><ul><li><p>clip-path为添加动画效果提供了空间，不过它只能在现代浏览器中使用</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/984bc03238dc491eb5654413b8a308bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom: 50%;" /></li></ul><hr><h3 id="1-5-visibility-hidden">1.5 visibility: hidden<a class="anchor" href="#1-5-visibility-hidden">·</a></h3><ul><li><p>visibility 属性可以设置为 visible 或 hidden 来显示和隐藏元素。</p></li><li><p>除非使用collapse值，否则元素使用的空间保持不变。<strong>存在于渲染树</strong>中，被渲染出来了，<strong>会占据空间</strong>，只是内容不可见</p></li><li><p><strong>不会响应用户交互，点击的话回调函数没有反应</strong></p></li><li><p>会引起重绘</p></li></ul><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/6c3342fe96314ad5b86fbb282b07a566~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" /><hr><h3 id="1-6-display-none">1.6 display: none<a class="anchor" href="#1-6-display-none">·</a></h3><p>可能是最常用的元素隐藏方法</p><ul><li><p>值为 none 时元素就隐藏，此时元素<strong>仍存在于DOM</strong>结构中。但<strong>不存在于render tree</strong> 中，<strong>不会被渲染</strong>，就<strong>不会占据空间</strong>，后面的元素会顶上来</p></li><li><p>其值改变会引起回流</p></li><li><p>不能点击</p></li><li><p>display 可能是最糟糕的 CSS 属性：<strong>除非使用 position:absolute 将元素移出文档流</strong>，或者采用contain属性，否则它的隐藏过程无法设置动画，<strong>并将触发页面重新布局</strong>。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a296bc53b043ddbdab194edbf49c58~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" /></li></ul><hr><h3 id="1-7-z-index">1.7 z-index<a class="anchor" href="#1-7-z-index">·</a></h3><ul><li><p>将元素的 z-index 属性设置为负值，以实现元素的隐藏。</p></li><li><p>这实际上就是将元素放在了看不到的层，被其他元素遮住也算是隐藏</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position:relative</span><br><span class="line">z-index:-999</span><br></pre></td></tr></table></figure><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/8addf56486ac44bbb48649a3c8168eac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" /></li></ul><hr><h3 id="1-8-position">1.8 position<a class="anchor" href="#1-8-position">·</a></h3><ul><li><p>position属性允许使用top、bottom、left、right 从页面中的默认位置移动元素。</p></li><li><p>因此，绝对定位的元素可以通过left：-9999px 等值移出可视界面</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>:relative</span><br><span class="line">left:-<span class="number">99999px</span></span><br></pre></td></tr></table></figure></li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7301efebb57a40808f35995bd640e48f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" /><hr><h3 id="1-9-伪元素">1.9 伪元素<a class="anchor" href="#1-9-伪元素">·</a></h3><ul><li><p>通过在元素的上面放置与背景颜色相同的元素，可以在视觉上隐藏一个元素</p></li><li><p>虽然这从技术上讲是可以实现的，但是这样做需要更多的代码。</p></li><li><p>比如使用::after伪元素来实现：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6211f95aef37447087d229c2d0a9a935~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" /></li></ul><hr><h3 id="1-10-缩小尺寸">1.10 缩小尺寸<a class="anchor" href="#1-10-缩小尺寸">·</a></h3><ul><li><p>通过使用width、height、padding、border-width 或 font-size 来缩小元素的尺寸以实现元素的隐藏。</p></li><li><p>可能还需要应用 overflow: hidden; 来确保内容不会溢出。</p></li><li><p>这种形式可以在隐藏过程中使用动画效果，并且他的性能会比 transform 好很多。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/2fa94a4e5a2d4b67acbf245a827e376c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" /><hr><h2 id="实际开发的小总结">实际开发的小总结<a class="anchor" href="#实际开发的小总结">·</a></h2><h3 id="1、控制视频播放">1、控制视频播放<a class="anchor" href="#1、控制视频播放">·</a></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleIconStop</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> video = e.<span class="property">target</span>;</span><br><span class="line">  <span class="keyword">if</span> (video &amp;&amp; !video.<span class="property">paused</span>) &#123;<span class="comment">// 移到且不是暂停中</span></span><br><span class="line">    video.<span class="title function_">pause</span>();  </span><br><span class="line">    video.<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;0.3&#x27;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      video.<span class="property">currentTime</span> = <span class="number">0</span>;</span><br><span class="line">      video.<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、hover时，clip-path扫描效果">2、hover时，clip-path扫描效果<a class="anchor" href="#2、hover时，clip-path扫描效果">·</a></h3><ul><li><p>html结构：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#123;styles.<span class="property">wrapper</span>&#125;&gt; <span class="comment">// 展示内容的包裹</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.background&#125;</span> /&gt;</span></span> <span class="comment">/* 背景特效，一个空div*/</span></span><br><span class="line">  ...div包裹的想展示的内容省略....</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>扫描动画：设置关键帧在某个百分比时，裁剪的点</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> sweepin &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">100%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">33%</span> &#123;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">100%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">66%</span> &#123;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">25%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">25%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CSS显示：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">transition</span>: all ease <span class="number">0.5s</span>;</span><br><span class="line">  ....省略</span><br><span class="line">  <span class="selector-class">.background</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="keyword">@include</span> backgroundImg(<span class="string">&#x27;/img/scan.png&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: center/cover;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">100%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.desc</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute; <span class="attribute">top</span>、<span class="attribute">left</span></span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;   <span class="comment">/*1.1 首先，将图片通过z-index，用显示内容将背景图隐藏起来 */</span></span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">70%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.myButton</span> &#123;</span><br><span class="line">    <span class="comment">/*1.4 但按钮的位置不能变动，否则来回hover时，会有明显位置移动；opacity占据位置，visibility禁止交互 */</span></span><br><span class="line">    <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;  <span class="comment">/*1.3 但按钮只在hover时显示，所以要先隐藏，hover时，改变透明度 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute; <span class="attribute">top</span>、<span class="attribute">left</span></span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;  <span class="comment">/*1.2 按钮跟desc同属显示内容这一层，只是hover时才显示 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/*2.1 hover时，动画作用在背景上， */</span></span><br><span class="line">  <span class="selector-class">.background</span> &#123;</span><br><span class="line">    <span class="attribute">animation-name</span>: sweepin;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">0.5s</span>;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">0%</span> <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">overflow</span>: inherit;</span><br><span class="line">  <span class="selector-class">.desc</span> &#123;    <span class="comment">/*2.2 颜色有改变 */</span></span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">70%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.myButton</span> &#123;   <span class="comment">/*2.3 按钮显示出来 可点击 */</span></span><br><span class="line">    <span class="attribute">visibility</span>: visible;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、Tab切换显示">3、Tab切换显示<a class="anchor" href="#3、Tab切换显示">·</a></h3><ul><li>切换不同的子Tab，展示对象的内容；</li><li>这里就不要用display的做法，来回重建成本大，而且媒体资源不流畅，体验也不好；</li><li>更合适的做法opacity：<ul><li>第一次就将元素全部渲染出来，让index控制哪个元素可见；</li><li>切换时传递index，动态添加类，opacity控制显示出来；</li><li>还有一个问题：占位，使用定位的做法更好，全部relative定在同一位置</li></ul></li></ul><h2 id="小结">小结<a class="anchor" href="#小结">·</a></h2><p>简单举出了几种隐藏元素的方式，也算是基于实践开发中的小总结吧~以后有新的东西再回来补充，就酱</p>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐藏元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hook系列(2)-why</title>
      <link href="/posts/why%20Hook.html"/>
      <url>/posts/why%20Hook.html</url>
      
        <content type="html"><![CDATA[<h1 id="center-Hook系列（2）之why-center"><center>Hook系列（2）之why</center><a class="anchor" href="#center-Hook系列（2）之why-center">·</a></h1><blockquote><p>Hook 解决了长期以来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题。本系列第2期将分享使用Hook的动机</p></blockquote><ul><li>自定义Hook的封装</li><li>使用Hook的动机、好处是什么？</li></ul><h2 id="二、自定义Hooks">二、自定义Hooks<a class="anchor" href="#二、自定义Hooks">·</a></h2><blockquote><ul><li>自定义<code>Hook</code>非常简单，只需要定义一个函数，并把<strong>相应需要的状态和<code>effect</code>封装进去</strong>，同时，<code>Hook</code>之间也是可以相互引用的。</li><li>使用<code>use</code>开头命名自定义<code>Hook</code>，这样可以方便<code>eslint</code>进行检查。</li></ul></blockquote><h3 id="1、实现监听缩放的Hook-demo">1、实现监听缩放的Hook-demo<a class="anchor" href="#1、实现监听缩放的Hook-demo">·</a></h3><ul><li><p>目标功能：<strong>放大、缩小浏览器窗口</strong>时，页面上的结果都会跟着进行变化</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example9</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> size = <span class="title function_">useWinSize</span>(); <span class="comment">// 也就是useWinSize()的结果是页面最新的size数据</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>页面Size:&#123;size.width&#125;x&#123;size.height&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Example9</span> </span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-实现过程">1.1 实现过程<a class="anchor" href="#1-1-实现过程">·</a></h4><ol><li><p>用useState设置<code>size</code>状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [ size , setSize] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">width</span>:<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>, <span class="comment">// 获取页面的size信息</span></span><br><span class="line">        <span class="attr">height</span>:<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>然后编写一个更新状态的方法<code>onResize</code>：</p><ul><li>本质还是依赖setSize更新函数，将最新的尺寸信息赋值给size；</li><li>用<code>useCallback</code>，目的是为了缓存方法(useMemo是为了缓存变量)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> onResize = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">setSize</span>(&#123;</span><br><span class="line">           <span class="attr">width</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>,</span><br><span class="line">           <span class="attr">height</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;,[])</span><br></pre></td></tr></table></figure></li><li><p>为了防止一直监听，所以在卸载时，方法移除</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        &#123;<span class="comment">/*  resize  浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件*/</span>&#125;</span><br><span class="line">  <span class="comment">// 监听浏览器的resize事件，保存最先的size信息</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, onResize)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,onResize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br></pre></td></tr></table></figure></li><li><p>最后<strong>返回size变量</strong>就可以了，最后返回的是<strong>一个变量；</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> size;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>完整代码：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useWinSize</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ size , setSize] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">width</span>:<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>,</span><br><span class="line">        <span class="attr">height</span>:<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onResize = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">setSize</span>(&#123;</span><br><span class="line">            <span class="attr">width</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,[]) </span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,onResize)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,onResize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、修改title">2、修改title<a class="anchor" href="#2、修改title">·</a></h3><ul><li><p>根据不同的页面名称修改页面<code>title</code>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useTitle</span>(<span class="params">title</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = title;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> (<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;主页&quot;</span>);</span><br><span class="line">    &#125;, [title]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Page1</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="title function_">useTitle</span>(<span class="string">&#x27;Page1&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>12343-test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、实现监听页面滚动的Hook">3、实现监听页面滚动的Hook<a class="anchor" href="#3、实现监听页面滚动的Hook">·</a></h3><blockquote><p>监听页面滚动，记录滚动位置，返回滚动过程中的位置信息</p></blockquote><ul><li><p>一个新的小收获：如何保存状态为对象的数据？</p><p>可以使用useRef钩子，每次更新时，既可以指定更新某一属性，也可以更新这个数值~</p></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isClient &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useWindowScroll = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> frame = <span class="title function_">useRef</span>(<span class="number">0</span>); <span class="comment">// 它的current属性保存的是requestAnimationFrame的id</span></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: isClient ? <span class="variable language_">window</span>.<span class="property">scrollX</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: isClient ? <span class="variable language_">window</span>.<span class="property">scrollY</span> : <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// q1:第一次scroll时，取消id是0呀？</span></span><br><span class="line">      <span class="title function_">cancelAnimationFrame</span>(frame.<span class="property">current</span>);</span><br><span class="line">      <span class="comment">// q2: 为啥每次回调里先取消再设置下一帧的？直接赋值不可以吗？</span></span><br><span class="line">      <span class="comment">// 最后直接在卸载时取消~是出于内存的考虑吗？</span></span><br><span class="line">      <span class="comment">// q3:测试了一下，取消不影响页面滚动；但没有第1个id；这是为啥呢？</span></span><br><span class="line">      frame.<span class="property">current</span> = <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">x</span>: <span class="variable language_">window</span>.<span class="property">scrollX</span>,</span><br><span class="line">          <span class="attr">y</span>: <span class="variable language_">window</span>.<span class="property">scrollY</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 页面挂载完毕后，监听滚动，执行handler：</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handler, &#123;<span class="attr">capture</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">passive</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="comment">//卸载时取消监听、</span></span><br><span class="line">      <span class="title function_">cancelAnimationFrame</span>(frame.<span class="property">current</span>);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>一些奇怪问题：</p><p>current的id从初始的0 直接蹦到了2。这是为啥呢？？？？？</p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/image-20220403162430758.png" alt="image-20220403162430758" style="zoom:50%;" /></li></ul><h3 id="4、日志打点">4、日志打点<a class="anchor" href="#4、日志打点">·</a></h3><ul><li><p>注意区分：首次挂载与更新；</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useLogger</span> = (<span class="params">componentName, ...params</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 首次挂载</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;componentName&#125;</span>初始化`</span>, ...params);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;componentName&#125;</span>卸载`</span>, ...params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="comment">// 针对更新的钩子</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;componentName&#125;</span>更新`</span>, ...params);</span><br><span class="line">  &#125;, [componentName])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Page1</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="title function_">useLogger</span>(<span class="string">&#x27;Page1&#x27;</span>, props);</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、双向绑定">5、双向绑定<a class="anchor" href="#5、双向绑定">·</a></h3><ul><li><p>将表单<code>onChange</code>的逻辑抽出来封成一个<code>Hook</code>，这样所有需要双向绑定的表单组件都可以复用：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useBind</span>(<span class="params">init</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [value, setValue] = <span class="title function_">useState</span>(init);</span><br><span class="line">  <span class="keyword">let</span> onChange = <span class="title function_">useCallback</span>(<span class="function"><span class="params">event</span> =&gt;</span> <span class="title function_">setValue</span>(event.<span class="property">currentTarget</span>.<span class="property">value</span>), []);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Page1</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="title function_">useBind</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...value</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以利用<code>HOC</code>，结合<code>context</code>和<code>form</code>来封装一个更通用的双向绑定</p></li></ul><h2 id="二、为什么Hook升级了工作模式？">二、为什么Hook升级了工作模式？<a class="anchor" href="#二、为什么Hook升级了工作模式？">·</a></h2><blockquote><p>这一部分主要参考了官方文档的介绍，语言比较总结概括，但要真的能很好地实践与理解还需要不断的在实际中应用~</p><p>暂时我还没有特别深的能理解这些话，随着实际开发经验的增加，希望能有更多的理解与运用</p></blockquote><h3 id="1、使状态逻辑复用更简单可行">1、使状态逻辑复用更简单可行<a class="anchor" href="#1、使状态逻辑复用更简单可行">·</a></h3><ul><li>过去复用状态逻辑，靠的是HOC、render Props这些组件设计模式，但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是**“嵌套地狱”**的现象。</li><li>而Hooks可以看做是React解决状态逻辑复用的原生途径，达到既不破坏组件结构，又能够实现扁平式的状态逻辑复用，而避免了大量的组件嵌套</li><li><code>Hook</code>和<code>Mixin</code>在用法上有一定的相似之处，但是<code>Mixin</code>引入的逻辑和状态是可以相互覆盖的，而多个<code>Hook</code>之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。</li></ul><h3 id="2、解决业务逻辑难以拆分的问题-2">2、解决业务逻辑难以拆分的问题<a class="anchor" href="#2、解决业务逻辑难以拆分的问题-2">·</a></h3><ol><li><p>类组件：</p><p>过去组织业务逻辑时，先想清楚业务需要，将对应的业务逻辑拆到对应的生命周期中，逻辑与生命周期强耦合。比如：DidMout去获取数据，在DidUpdate里获取数据的变化，但是大型项目中，一个生命周期做的事情很多。这些事情看起来毫无关联，而有关联的被分散在不同的生命周期里。</p></li><li><p>但是Hooks有专门管理状态的、有引入副作用的等等，<strong>它能帮我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。</strong></p><p>可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于<strong>生命周期方法</strong>进行分割。</p></li></ol><h3 id="3、告别难以理解的class">3、告别难以理解的class<a class="anchor" href="#3、告别难以理解的class">·</a></h3><p>class的两大痛点：this、生命周期</p><ul><li><p>**this：**比如推出了箭头函数、bind来解决this问题，但本质上是在用实践层面解决设计层面的问题。而函数组件就没有这个问题了。</p></li><li><p>**生命周期：**学习成本、不合理的逻辑划分方式</p></li></ul><p>相比函数，编写一个<code>class</code>可能需要掌握更多的知识，需要注意的点也越多，比如<code>this</code>指向、绑定事件等等。另外，计算机理解一个<code>class</code>比理解一个函数更快。<code>Hooks</code>让你可以在<code>classes</code>之外使用更多<code>React</code>的新特性。</p><h5 id="4、从设计思想上更加契合React的理念-2">4、从设计思想上更加契合React的理念<a class="anchor" href="#4、从设计思想上更加契合React的理念-2">·</a></h5><p>前面的函数组件、类组件已经做了对比分析。</p><h3 id="4、Hooks的局限性-2">4、Hooks的局限性<a class="anchor" href="#4、Hooks的局限性-2">·</a></h3><p>Hooks并非万能，在认识到Hooks利好的同时，也需要认识到他的局限性。</p><ol><li><p>Hooks暂时还不嫩而过完全为函数组件补全类组件的能力：比如，某些钩子还是没有；</p></li><li><p>函数组件仍然是“轻量”，这可能使得它并不能很好地消化“复杂”</p></li><li><p>在使用层面严格的约束</p><p>耦合和内聚的边界很难把握，函数式组件给了更多自由，却对开发者代码能力提了更高的要求。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAF是什么？</title>
      <link href="/posts/requestAnimationFrame_1.html"/>
      <url>/posts/requestAnimationFrame_1.html</url>
      
        <content type="html"><![CDATA[<h2 id="center-requestAnimationFrame-center"><center>requestAnimationFrame</center><a class="anchor" href="#center-requestAnimationFrame-center">·</a></h2><ul><li><p>本篇文章的背景：</p><blockquote><ol><li>实际开发中，滚动过程中吸顶效果实现中借助了requestAnimationFrame API；</li><li>在下一个迭代双周中，我们的目标是对官网页面整体优化，其中包括了动画部分：原本是采用放一个mp4视频文件进行播放，但MP4耗费资源，对首屏加载也不友好~基于此，采用动画优化，对于具体涉及实现的技术将在下一专题进行总结；</li><li>在周会分享中，前端页面渲染部分，探讨了一些前端动画中的实现方式，requestAnimationFrame就是其中之一；</li></ol></blockquote></li><li><p>官方文档：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</p><ul><li><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p></li><li><p><strong>说人话：</strong></p><p>该API能以浏览器的显示频率来作为其动画动作的频率，比如浏览器每10ms刷新一次，动画回调也每10ms调用一次，这样就不会存在过度绘制的问题，动画不会掉帧，自然流畅。</p></li></ul></li></ul><h3 id="1、前置知识-动画的形成">1、前置知识-动画的形成<a class="anchor" href="#1、前置知识-动画的形成">·</a></h3><h4 id="1-1-计算机屏幕刷新率与浏览器重绘次数">1.1 <strong>计算机屏幕刷新率与浏览器重绘次数</strong><a class="anchor" href="#1-1-计算机屏幕刷新率与浏览器重绘次数">·</a></h4><ul><li><p>常见显示器有两种，即 CRT和 LCD；</p><ul><li><p>CRT 是一种使用阴极射线管的显示器，屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。<strong>电子束每秒击打荧光粉的次数就是屏幕绘制频率</strong>。</p></li><li><p>LCD 就是常见的液晶显示器。 不存在绘制频率的问题，因为 LCD 中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以 LCD 不会有电子束击打荧光粉而引起的闪烁现象。</p></li></ul></li><li><p>屏幕刷新率：</p><ul><li>指<code>1s</code>内屏幕刷新的次数，一般电脑为<code>1s 60次</code>(<code>1000ms / 60 ≈ 16.7ms</code> | <code>60FPS</code>)，也就是<strong>每<code>16.7ms</code>会刷新一下屏幕</strong>。此数值受到分辨率、显卡、屏幕尺寸等其他因素的影响</li><li>当你只看着电脑时，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。但我们感觉不到这个变化，因为人眼的视觉停留效应</li></ul></li><li><p>视觉停留效应：</p><ul><li>即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。</li><li>试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</li></ul></li><li><p>由于刷新频率是<code>60FPS</code>，所以大多数浏览器会<strong>限制其重绘次数</strong>，一般不会超过计算机的刷新频率，因为即使超过了其频率，用户的体验也不会得到提升。</p></li></ul><h4 id="1-2-动画的形成及实现方式">1.2 动画的形成及实现方式<a class="anchor" href="#1-2-动画的形成及实现方式">·</a></h4><ul><li><p>动画的本质是在快速不断的切换图片，让人眼看到图像被绘制而引起变化的视觉效果。</p></li><li><p>这个变化要以连贯的、平滑的方式进行过渡。而动画是由浏览器按照一定的频率一帧一帧的绘制的：想要流畅，就需要尽可能在一秒中绘制更多的图片，但绘制太多需要消耗大量的性能，</p></li><li><p>通常来说<strong>因为人眼的残影现象，所以只要两帧画面切换时间高于1/24秒，即可形成流畅的动画</strong>。所以通常将渲染频率控制在每秒30~60次，人的视觉效果都很正常，也可以兼顾渲染性能</p></li><li><p>web实现动画的方式</p><ul><li><code>css</code>：<code>animation</code>、<code>transition</code></li><li><code>js</code>: <code>setTimeout</code>、<code>setInteval</code></li><li><code>html</code>: <code>canvas</code>、<code>svg</code></li><li><code>requestAnimationFrame</code>等…</li></ul></li></ul><h4 id="1-3-requestAnimationFrame的优势">1.3 requestAnimationFrame的优势<a class="anchor" href="#1-3-requestAnimationFrame的优势">·</a></h4><ul><li>动画更加流畅，防止动画失帧<ul><li><strong>浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新UI</strong>，给用户一种流畅的体验</li><li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li><li>而setInterval或setTimeout实现的JavaScript动画就没有这么可靠了，因为浏览器压根就无法保证每一帧渲染的时间间隔，</li></ul></li><li>资源节能(CPU、内存等)<ol><li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量</li><li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销</li></ol></li></ul><h3 id="2、requestAnimationFrame的应用">2、<code>requestAnimationFrame</code>的应用<a class="anchor" href="#2、requestAnimationFrame的应用">·</a></h3><h4 id="2-1-实现动画demo">2.1 实现动画demo<a class="anchor" href="#2-1-实现动画demo">·</a></h4><ul><li><p>宽度改变</p><p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/1618f7bc6acd9f5c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0-20220403135057109.awebp" alt="示例"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animationWidth</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">width</span> = <span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">width</span>) + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">width</span>) &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(animationWidth)  <span class="comment">// 函数继续传入</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(animationWidth);</span><br></pre></td></tr></table></figure><ul><li>可以看到，requestAnimationFrame接受一个动画执行函数作为参数，这个函数的作用是仅执行一帧动画的渲染，并根据条件判断是否结束，<strong>如果动画没有结束，则继续调用requestAnimationFrame并将自身作为参数传入</strong>。</li><li>从示例来看，得到了效果平滑流畅的动画，这样就巧妙地避开了每一帧动画渲染的时间间隔问题。</li></ul></li><li><p>位移</p><p>由于人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，这样你所看到的效果就是，图像在流畅的移动。这就是视觉效果上形成的动画。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;background-color: orange;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 调用的是系统的时间间隔</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> start;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">timestamp</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (start === <span class="literal">undefined</span>)</span></span><br><span class="line"><span class="language-javascript">      start = timestamp;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> elapsed = timestamp - start;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//这里使用`Math.min()`确保元素刚好停在200px的位置。</span></span></span><br><span class="line"><span class="language-javascript">    element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateX(&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">0.1</span> * elapsed, <span class="number">200</span>) + <span class="string">&#x27;px)&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (elapsed &lt; <span class="number">5000</span>) &#123; <span class="comment">// 5秒后停止动画</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> timer1 = <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//取消回调函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// cancelAnimationFrame(timer1);</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-注意点">2.2 注意点<a class="anchor" href="#2-2-注意点">·</a></h4><ul><li>对于<strong>window.requestAnimationFrame()</strong>：<ul><li>当你准备更新动画时你应调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。</li><li>回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。</li><li>为了提高性能和电池寿命，在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页时，requestAnimationFrame() 会被暂停调用。</li><li>回调函数会被传入<strong>DOMHighResTimeStamp参数</strong>，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。<strong>在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳</strong>，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。</li></ul></li></ul><h2 id="3、requestAnimationFrame-与-Event-Loop">3、requestAnimationFrame 与 Event Loop<a class="anchor" href="#3、requestAnimationFrame-与-Event-Loop">·</a></h2><p>Event Loop（事件循环）是用来协调事件、用户交互、脚本、渲染、网络的一种浏览器内部机制。</p><ul><li>Event Loop 在浏览器内也分几种：window event loop、worker event loop、worklet event loop。这里主要讨论的是 window event loop。也就是浏览器一个<strong>渲染进程内主线程所控制</strong>的 Event Loop。</li></ul><h4 id="3-1-Event-Loop的整体过程">3.1 Event Loop的整体过程<a class="anchor" href="#3-1-Event-Loop的整体过程">·</a></h4><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/ca5ec835c88b4f89b06e0302bfe98a7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0-20220403141256079.awebp" alt="img" style="zoom: 50%;" /><ul><li>大体上来说，event loop 就是不停地找 task queues 里是否有可执行的 task ，如果存在即将其推入到 call stack （执行栈）里执行，并且在合适的时机更新渲染<ol><li>在所选 task queue (taskQueue)中约定必须包含一个可运行任务。如果没有此类 task queue，则跳转至下面 microtasks 步骤。</li><li>让 taskQueue 中最老的 task (oldestTask) 变成第一个可执行任务，然后从 taskQueue 中删掉它。</li><li>将上面 oldestTask 设置为 event loop 中正在运行的 task。</li><li>执行 oldestTask。</li><li>将 event loop 中正在运行的 task 设置为 null。</li><li>执行 microtasks 检查点（也就是执行 microtasks 队列中的任务）。</li><li>设置 hasARenderingOpportunity 为 false。</li><li>更新渲染。（哈哈哈，有点锁上门渲染的意思~）</li><li>如果当前是 window event loop 且 task queues 里没有 task 且 microtask queue 是空的，同时渲染时机变量 hasARenderingOpportunity 为 false ，去执行 idle period（requestIdleCallback）。</li><li>返回到第一步。</li></ol></li></ul><h4 id="3-2-Event-Loop的更新渲染过程">3.2 Event Loop的更新渲染过程<a class="anchor" href="#3-2-Event-Loop的更新渲染过程">·</a></h4><p>流程基本如下图所示 ：</p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/bee8d1d1e9b1437ebd0fa2ce5e5b795e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0-20220403141628158.awebp" alt="img" style="zoom: 67%;" /><p>浏览器渲染有个<strong>渲染时机</strong>（Rendering opportunity）的问题，也就是浏览器会根据当前的浏览上下文判断是否进行渲染，它会尽量高效，<strong>只有必要的时候才进行渲染</strong>；</p><p>如果没有界面的改变，就不会渲染。按照规范里说的一样，因为考虑到硬件的刷新频率限制、页面性能以及页面是否存在后台等等因素，有可能执行完 setTimeout 这个 task 之后，发现还没到渲染时机，所以 setTimeout 回调了几次之后才进行渲染</p><ul><li><p>电脑屏幕的刷新和render是两个概念对吗？</p><p>电脑是由其配置决定刷新频率、并且一直在刷新；</p><p>但页面渲染会基于判断是否有必要重新渲染，</p></li></ul><ol><li>遍历当前浏览上下文中所有的 document ，必须按在列表中找到的顺序处理每个 document 。</li><li>渲染时机（Rendering opportunities）<strong>：如果当前浏览上下文中没有到渲染时机</strong>，则将所有 docs 删除，取消渲染（此处是 否存在渲染时机由浏览器自行判断，根据硬件刷新率限制、页面性能或页面是否在后台等因素）。</li><li>如果当前document 不为空，设置 hasARenderingOpportunity 为 true 。</li><li>不必要的渲染（Unnecessary rendering）：如果浏览器<strong>认为更新文档的浏览上下文的呈现不会产生可见效果</strong>且文档的 animation frame callbacks 是空的，则取消渲染。</li><li>从 docs 中删除浏览器认为出于其他原因最好跳过更新渲染的文档。</li><li>如果文档的浏览上下文是顶级浏览上下文，则刷新该文档的自动对焦候选对象。</li><li>处理 resize 事件，传入一个 performance.now() 时间戳。</li><li>处理 scroll 事件，传入一个 performance.now() 时间戳。</li><li>处理媒体查询，传入一个 performance.now() 时间戳。</li><li>运行 CSS 动画，传入一个 performance.now() 时间戳。</li><li>处理全屏事件，传入一个 performance.now() 时间戳。</li><li>执行 requestAnimationFrame 回调，传入一个 performance.now() 时间戳。</li><li>执行 intersectionObserver 回调，传入一个 performance.now() 时间戳。</li><li>对每个 document 进行绘制。</li><li>更新 ui 并呈现。</li></ol><p>至此，requestAnimationFrame 的回调时机就清楚了，它会在 style/layout/paint 之前调用。</p><h2 id="4、应用场景">4、应用场景<a class="anchor" href="#4、应用场景">·</a></h2><h4 id="4-1-大量数据渲染">4.1 大量数据渲染<a class="anchor" href="#4-1-大量数据渲染">·</a></h4><p>在大数据渲染过程中，比如表格的渲染，如果不进行一些性能策略处理，就会出现 UI 冻结现象，用户体验极差。</p><ul><li>有个场景，将后台返回的<strong>十万条记录</strong>插入到表格中，如果一次性在循环中生成 DOM 元素，会导致页面卡顿5s左右。</li><li>此时，就可以用 <strong>requestAnimationFrame</strong> 来分步渲染，确定最好的时间间隔，页面加载更流畅</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">var</span> size = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> count = total / size;</span><br><span class="line"><span class="keyword">var</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addItems</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> fg = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        li.<span class="property">innerText</span> = <span class="string">&#x27;item &#x27;</span> + (done * size + i);</span><br><span class="line">        fg.<span class="title function_">appendChild</span>(li);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ul.<span class="title function_">appendChild</span>(fg);</span><br><span class="line">    done++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done &lt; count) &#123; <span class="title function_">requestAnimationFrame</span>(addItems);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(addItems);</span><br></pre></td></tr></table></figure><h4 id="4-2-实现动画">4.2 实现动画<a class="anchor" href="#4-2-实现动画">·</a></h4><ul><li><p>css3实现使得性能和流畅度都得到了很大的提升，但同时局限性也挺大。</p><p>比如<strong>不是所有的属性都能参与动画，动画过程不能完全控制，动画缓动效果太小</strong>等等。</p></li><li><p>刚好相反的是setTimeout和setInterval能达成更多的可控性质的自有帧动画，但是由于刷新时间和定时器时间不同会出现掉帧现象，定时器时间设的越短掉帧时间越严重，而且性能牺牲很严重</p></li><li><p>然而 <strong>requestAnimationFrame</strong> 的出现让我们有了除了这两种我们常用的方案之外的另一种更优的选择</p></li><li><p>具体如2节示例。</p></li></ul><h3 id="5、兼容性">5、兼容性<a class="anchor" href="#5、兼容性">·</a></h3><ul><li><p>针对低版本浏览器，则需要使用setTimeout来模拟requestAnimationFrame，且针对不同浏览器对requestAnimationFrame的实现，这个api的名字也略有差异，张鑫旭大佬的模拟requestAnimationFrame的写法如下：</p></li><li><p>如果遇到低版本浏览器的动画需求，你只需要把这段代码丢进去定义一个低配版requestAnimationFrame方法即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> vendors = [<span class="string">&#x27;webkit&#x27;</span>, <span class="string">&#x27;moz&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; vendors.<span class="property">length</span> &amp;&amp; !<span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span>; ++x) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> = <span class="variable language_">window</span>[vendors[x] + <span class="string">&#x27;RequestAnimationFrame&#x27;</span>];</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">cancelAnimationFrame</span> = <span class="variable language_">window</span>[vendors[x] + <span class="string">&#x27;CancelAnimationFrame&#x27;</span>] ||    </span><br><span class="line">          <span class="comment">// Webkit中此取消方法的名字变了</span></span><br><span class="line">        <span class="variable language_">window</span>[vendors[x] + <span class="string">&#x27;CancelRequestAnimationFrame&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> = <span class="keyword">function</span>(<span class="params">callback, element</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">            <span class="keyword">var</span> timeToCall = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="number">16.7</span> - (currTime - lastTime));</span><br><span class="line">            <span class="keyword">var</span> id = <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="title function_">callback</span>(currTime + timeToCall);</span><br><span class="line">            &#125;, timeToCall);</span><br><span class="line">            lastTime = currTime + timeToCall;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">cancelAnimationFrame</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">cancelAnimationFrame</span> = <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(id);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="小结-2">小结<a class="anchor" href="#小结-2">·</a></h3><blockquote><p>下一次，我们将在项目中分享，reequestAnimationFrame是如何解决页面滚动吸顶效果的，以及另一期实践中，类似金币转圈圈的效果实现、腾讯云中某一图标的动态旋转实现~</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> requestAnimationFrame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基建(1)之CDN</title>
      <link href="/posts/basic_construct_1.html"/>
      <url>/posts/basic_construct_1.html</url>
      
        <content type="html"><![CDATA[<h2 id="center-开发中的基建配置-CDN-center"><center>开发中的基建配置 - CDN</center><a class="anchor" href="#center-开发中的基建配置-CDN-center">·</a></h2><blockquote><p>总结一下，开发中的基建配置相关，纯小白在开发过程中收获到了很多~</p></blockquote><h3 id="1-1-网站使用场景-为啥会有CDN">1.1 网站使用场景-为啥会有CDN<a class="anchor" href="#1-1-网站使用场景-为啥会有CDN">·</a></h3><ul><li><p>网站吸引力好的关键特征：</p><ol><li>内容有吸引力</li><li>访问速度快</li><li>支持频繁的用户互动</li><li>可以在各处浏览无障碍</li><li>能在复杂的网络环境下运行，全球的用户访问体验</li></ol></li><li><p>网站面临的问题：</p><p>随着使用越来越多的对象（如图片、帧、CSS及APIs）和形形色色的动作（分享、跟踪）而系统逐渐庞大，从而变慢带来用户的流失。如果网站是你的盈利渠道或是品牌窗口，那么网站速度慢将是一个致命的打击，因为用户对网站访问速度的忍受能力越来越差；</p><p>噔噔噔噔~，CDN出现了，而它能够加速网站的访问；</p></li></ul><h3 id="1-2-CDN是什么、工作流程">1.2 CDN是什么、工作流程<a class="anchor" href="#1-2-CDN是什么、工作流程">·</a></h3><blockquote><p>也叫内容分发网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p><p>说人话：</p><ul><li><p>无论你在天涯海角，只要连了网，CDN服务就如同把源站搬到你面前一样，世界触手可及！</p></li><li><p>CDN就是护航者和加速者的角色，更快准狠的触发信息和触达每一个用户，带来极致体验</p></li></ul><p>比如我的博客网站就用到了，目的只是为了提升页面图片加载速度</p><p>如今的CDN可谓是大文件、小文件、点播、直播、动静皆宜！</p></blockquote><ul><li><p>目的：</p><ol><li><p>通过在<strong>网络各处放置节点服务器</strong>所构成的在现有的互联网基础之上的一层智能虚拟网络，尽可能地避开影响数据<strong>传输速度和稳定性</strong>的瓶颈和环节，使内容传输的更快、更稳定</p></li><li><p>解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。</p></li></ol></li></ul><h4 id="1-2-1-不同CDN工作流程：">1.2-1 不同CDN工作流程：<a class="anchor" href="#1-2-1-不同CDN工作流程：">·</a></h4><p>用户在通过浏览器访问数据时：</p><ul><li>用户在浏览器中输入要访问的域名。</li><li>浏览器向DNS服务器请求对该域名的解析，DNS服务器返回该域名的IP地址给浏览器。</li><li>浏览器使用该IP地址向服务器请求内容，服务器将用户请求的内容返回给浏览器。</li></ul><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTY4NDg2,size_16,color_FFFFFF,t_70-20220402203054278.png" alt="在这里插入图片描述" style="zoom: 50%;" /><h4 id="1-2-2-使用CDN加速：">1.2-2 使用CDN加速：<a class="anchor" href="#1-2-2-使用CDN加速：">·</a></h4><ul><li><p>用户在浏览器中输入要访问的域名</p></li><li><p>浏览器向DNS服务器请求对域名解析。而D<strong>NS服务器将域名的解析权交给 CDN专用DNS服务器</strong></p></li><li><p>CDN专用DNS服务器将CDN负载均衡设备的IP地址返回给用户</p></li><li><p>用户向 <strong>CDN负载均衡设备</strong> 发起内容URL访问请求：CDN负载均衡设备会为用户选择一台合适的 CDN缓存服务器 提供服务，选择的依据包括：</p><ul><li>根据用户IP地址，判断哪一台服务器距离用户最近；</li><li>根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；</li><li>查询各个服务器的负载情况，判断哪一台服务器的负载较小。</li><li>基于以上这些依据的综合分析之后，<strong>负载均衡设置会把缓存服务器的IP地址返回给用户</strong>。</li></ul></li><li><p>用户向缓存服务器发出请求，缓存服务器响应用户请求，将用户所需内容传送到用户</p></li><li><p><strong>如果这台缓存服务器上并没有用户想要的内容</strong>，而负载均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉取到本地</p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTY4NDg2,size_16,color_FFFFFF,t_70-20220402203020588-20220402203545041.png" alt="在这里插入图片描述" style="zoom: 50%;" /></li></ul><h3 id="1-3-项目中怎么用的？">1.3 项目中怎么用的？<a class="anchor" href="#1-3-项目中怎么用的？">·</a></h3><blockquote><p>ok，言归正传，回到需求开发中：将所有的cdn静态资源中心化到一个cdnPathMap</p></blockquote><h4 id="1-写一个CDN映射文件">1. 写一个CDN映射文件<a class="anchor" href="#1-写一个CDN映射文件">·</a></h4><blockquote><p>这里为甚要单独配置这个映射，每个资源直接记住绝对路径不就好了吗？</p><ol><li>将来cdn地址如果迁移，需要手动更改所有的地址，噩梦，这个是目的</li><li>假如线上请求地址，与线下请求cdn地址不一样，可以支持配置；</li></ol></blockquote><ul><li>将cdn host 配置在环境变量里，在每次打包的时候可以更换此环境变量，不用再侵入式的改变单个资源的host，只需要保存静态资源的Path。</li><li>提升了语义化，方便开发者了解该资源的意义，也不用开发者关心静态资源的host</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Host</span> = process.<span class="property">env</span>.<span class="property">NEXT_PUBLIC_CDN_HOST</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以键值对的形式设置cdn上对应资源的文件名：相对路径</span></span><br><span class="line"><span class="comment">// key代表一个语义化的静态资源名称，value代表静态资源的cdn Path</span></span><br><span class="line"><span class="keyword">const</span> cdnPathMap = &#123; </span><br><span class="line">  <span class="string">&#x27;dance-video&#x27;</span>: <span class="comment">// 自定义的映射名</span></span><br><span class="line">    <span class="string">&#x27;cdn-network/projectA/static/dance-video/myGirl.MP4&#x27;</span>,  <span class="comment">// cdn的资源远端链接</span></span><br><span class="line">  .....省略其他</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">staticFile</span> = (<span class="params">path</span>) =&gt; &#123; <span class="comment">// 拼接完整的url：设置成绝对路径，得到真实路径</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Url</span> = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title class_">Host</span>);</span><br><span class="line">  <span class="title class_">Url</span>.<span class="property">pathname</span> = path;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Url</span>.<span class="property">href</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cdnMap</span> = (<span class="params">sourceMap</span>) =&gt; &#123;</span><br><span class="line"><span class="comment">// 遍历所有资源，得到所有的完整绝对路径  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(sourceMap).<span class="title function_">reduce</span>(<span class="function">(<span class="params">_map, currentKey</span>) =&gt;</span> &#123;</span><br><span class="line">    _map[currentKey] = <span class="title function_">staticFile</span>(sourceMap[<span class="string">`<span class="subst">$&#123;currentKey&#125;</span>`</span>]);</span><br><span class="line">    <span class="keyword">return</span> _map;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> staticFileMap = <span class="title function_">cdnMap</span>(cdnPathMap); </span><br></pre></td></tr></table></figure><h4 id="2-使用该文件">2. 使用该文件<a class="anchor" href="#2-使用该文件">·</a></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; staticFileMap &#125; <span class="keyword">from</span> <span class="string">&#x27;/utils/staticFile&#x27;</span>;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&#123;staticFileMap[</span>&#x27;<span class="attr">dance-video</span>&#x27;]&#125;  &gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3-补充URL">3. 补充URL<a class="anchor" href="#3-补充URL">·</a></h4><p><strong><code>URL()</code></strong> 构造函数返回一个新创建的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL"><code>URL</code></a> 对象，表示由一组参数定义的 URL。</p><p>如果给定的基本 URL 或生成的 URL 不是有效的 URL 链接，则会抛出一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(url [, base])</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>url</code>：是一个表示绝对或相对 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString"><code>DOMString</code></a>。如果<code>url</code> 是相对 URL，则会将 <code>base</code> 用作基准 URL。如果 <code>url</code> 是绝对URL，则无论参数<code>base</code>是否存在，都将被忽略。</li><li><code>base</code> 可选：是一个表示基准 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString"><code>DOMString</code></a>，在 <em>url</em> 是相对 URL 时，它才会起效。如果未指定，则默认为 <code>''</code>。</li></ul><h3 id="1-4-CDN的关键技术">1.4 CDN的关键技术<a class="anchor" href="#1-4-CDN的关键技术">·</a></h3><img src="https://pic1.zhimg.com/80/v2-eaf80abf6a52913375d2ade0dde79ed0_1440w.jpg" alt="img" style="zoom: 67%;" /><ul><li>内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术</li><li>内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应；</li><li>内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；</li><li>性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。</li></ul><h3 id="1-5-一些QA">1.5 一些QA<a class="anchor" href="#1-5-一些QA">·</a></h3><ul><li><p><strong>1.CDN加速是对网站所在服务器加速，还是对其域名加速？</strong></p><p>CDN是只对网站的<strong>某一个具体的域名加速</strong>。如果同一个网站有多个域名，则访客访问加入CDN的域名获得加速效果，访问未加入CDN的域名，或者直接访问IP地址，则无法获得CDN效果。</p></li><li><p><strong>2.CDN和镜像站点比较有何优势？</strong></p><ul><li>CDN对网站访客完全透明，不需要访客手动选择要访问的镜像站点，保证了网站对访客的友好性</li><li>CDN对每个节点都有可用性检查，不合格的节点会第一时间剔出，从而保证了极高的可用率，而镜像站点无法实现这一点。</li><li>CDN部署简单，对原站基本不做任何改动即可生效。</li></ul></li><li><p><strong>3. 为什么我的网站更新后，通过CDN后看到网页还是旧网页，如何解决？</strong></p><ul><li>由于CDN采用各节点缓存的机制，网站的静态网页和图片修改后，如果CDN缓存没有做相应更新，则看到的还是旧的网页。为了解决这个问题，CDN管理面板中提供了URL推送服务，来通知CDN各节点刷新自己的缓存。　　在URL推送地址栏中，输入具体的网址或者图片地址，则各节点中的缓存内容即被统一删除，并且当即生效。</li></ul></li><li><p><strong>4. 能不能让CDN不缓存某些即时性要求很高的网页和图片？</strong></p><ul><li><p>只需要使用动态页面，asp，php，jsp等动态技术做成的页面不被CDN缓存，无需每次都要刷新。</p></li><li><p>或者采用一个网站两个域名，一个启用CDN，另外一个域名不用CDN，对即时性要求高的页面和图片放在不用CDN的域名下</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基建 </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中的gap属性</title>
      <link href="/posts/gap-property.html"/>
      <url>/posts/gap-property.html</url>
      
        <content type="html"><![CDATA[<h2 id="gap属性">gap属性<a class="anchor" href="#gap属性">·</a></h2><blockquote><p>阅读指南：</p><ol><li>首先介绍了gap属性的进化史，有必要阅读下，了解gap为何而出现</li><li>然后是开发中常见的Flex布局（important，个人最喜欢的）、Grid布局中的用法；</li><li>最后推荐csstricks的一篇文章，文中有很多的动效demo，可供尝试；</li></ol></blockquote><h3 id="1、CSS-gap属性进化史">1、CSS gap属性进化史<a class="anchor" href="#1、CSS-gap属性进化史">·</a></h3><blockquote><p>可参考张鑫旭大佬的这篇文章：https://www.zhangxinxu.com/wordpress/2020/06/css-gap-history/</p><p>文章的总结：</p><ol><li>Multi-column布局首先支持了<code>column-gap</code>属性。</li><li>Grid布局规范模块独立发展，出现了grid布局独有的间隙属性<code>grid-gap</code>，<code>grid-row-gap</code>和<code>grid-column-gap</code>。</li><li>站在CSS世界整体视角，CSS间隙属性出现了内耗。于是，规范调整，保留列间隙和行间隙的概念，但是CSS属性向已经存在的<code>column-gap</code>属性靠拢。于是，<code>gap</code>，<code>row-gap</code>和<code>column-gap</code>属性诞生，成为CSS世界中统一的间隙属性。</li><li>Multi-column布局也额外支持了<code>gap</code>和<code>row-gap</code>属性，只是多栏布局没有行间隙概念，因此<code>row-gap</code>属性并无渲染效果。</li><li>Flex布局也采用间隙的概念，支持了统一的<code>gap</code>属性，只是刚支持不久</li></ol></blockquote><h3 id="2、grid布局的gap">2、grid布局的gap<a class="anchor" href="#2、grid布局的gap">·</a></h3><blockquote><p>参考mdn文档：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout</p></blockquote><p><code>gap</code> 并非是新的属性，它一直存在于多栏布局 <code>multi-column</code> 与 grid 布局中，其中：</p><ul><li><code>column-gap</code> 属性用来设置多栏布局 <code>multi-column</code> 中元素列之间的间隔大小</li><li>grid 布局中 <code>gap</code> 属性是用来设置网格行与列之间的间隙，该属性是 <code>row-gap</code> 和 <code>column-gap</code> 的简写形式，并且起初是叫 <code>grid-gap</code></li></ul><h4 id="2-1-布局demo：">2.1 布局demo：<a class="anchor" href="#2-1-布局demo：">·</a></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid-container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: deeppink;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/1460000039855201.png" alt="grid 布局" style="zoom:67%;" /><ul><li>通过给 <code>grid-container</code> 添<strong>加 <code>gap</code> 属性</strong>，可以设置网格行与列之间的间隙：</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid-container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">+   <span class="attribute">gap</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://segmentfault.com/img/remote/1460000039855202" alt="img" style="zoom:67%;" /><h3 id="3、flex中的gap">3、flex中的gap<a class="anchor" href="#3、flex中的gap">·</a></h3><blockquote><p>从 <strong>Chromium 84</strong> 开始，可以在 <code>flex</code> 布局中使用 <code>gap</code> 属性。作用与在 grid 布局中的类似，可以控制水平和竖直方向上 flex item 之间的间距：</p></blockquote><ul><li><code>gap</code> 属性的优势在于，它避免了传统的使用 <code>margin</code> 时，要考虑<strong>第一个或者最后一个元素的左边距或者右边距的烦恼</strong>。正常而言，4 个水平的 <code>flex item</code>，它们就应该只有 3 个间隙。</li><li><code>gap</code> 只生效于两个 <code>flex item</code> 之间。</li></ul><h4 id="布局demo1：">布局demo1：<a class="anchor" href="#布局demo1：">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">gap</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: deeppink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/1460000039855203.png" alt="img"></p><h4 id="布局demo2：">布局demo2：<a class="anchor" href="#布局demo2：">·</a></h4><ul><li><p>HTML：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;flexbox&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CSS:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrapper</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#777</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="selector-id">#flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">20px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#flexbox</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;  // 以指定宽度作为basis，可拉伸，可收缩</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果：</p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/image-20220331202347208.png" alt="image-20220331202347208" style="zoom:25%;" /><p><strong>flex换行显示：flex-wrap：wrap</strong></p><ul><li>会在满足gap间距的情况下，计算一行最大能凑够几个，显示的每项实际宽度可能会拉伸；</li><li>比如：一行宽300 每个盒子定死 100 gap要求 10 此时，只能显示2个，一行两列，间隔10 每个盒子实际 145；</li></ul><p><strong>flex是不换行：默认属性</strong></p><ul><li><p>在满足间距下，计算一行最大能凑够几个，如果不够，会压缩显示。</p></li><li><p>如果这里的gap能够满足盒子，就</p></li></ul></li></ul><h3 id="4、小结">4、小结<a class="anchor" href="#4、小结">·</a></h3><p>本文简单介绍了gap属性，主要用于解决开发中的margin左右第一个和第4个问题；</p><p>更多关于它的用法，可参考MDN文档等资料：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout</p><p>更多关于它的demo，推荐阅读：https://css-tricks.com/almanac/properties/g/gap/</p>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hook系列(1)之what</title>
      <link href="/posts/what&#39;s%20Hook.html"/>
      <url>/posts/what&#39;s%20Hook.html</url>
      
        <content type="html"><![CDATA[<h2 id="center-Hook系列（1）之what-center"><center>Hook系列（1）之what</center><a class="anchor" href="#center-Hook系列（1）之what-center">·</a></h2><blockquote><p>前言：</p><p>书接上回，我们简单读完了React文档中的核心概念部分：</p><p>此外，基于Hook的讨论展开之前，铺垫了一篇函数组件VS类组件的特性分析，以及为什么函数组件跟契合react的理念：</p><p>从本期开始，关于HOOK的讨论正式展开：</p><p>我们将从what、how、why的角度去研究Hook，对于how更关注：how to work ，而API的使用层面不过于关注</p><ul><li>目的：学习HOOK的特性，以及开发实践时有什么启发（写法、优化、排查bug等）</li></ul></blockquote><blockquote><p>官方文档：<strong>Hook</strong>是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p></blockquote><p>总的来说，Hooks是React团队在实践中逐渐认知的一个改进点，解决了团队长期编写和维护成千上万的组件时，遇到的各种各样看起来不相关的问题。背后涉及到<strong>类组件、函数组件</strong>两种组件形式的思考和侧重；</p><h2 id="what">what<a class="anchor" href="#what">·</a></h2><blockquote><p>由于Hooks背后涉及到<strong>类组件、函数组件</strong>两种组件形式的思考和侧重，因此在说明之前，我们将对比下两大组件：</p></blockquote><ul><li><p>是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数</p></li><li><p>是一套使函数组件更强大、更灵活的钩子。函数组件相比于类组件少了很多东西，而Hooks的出现就是帮助函数式组件补齐这种缺陷。函数式组件可以自由的使用Hooks提供的丰富工具</p></li></ul><h3 id="1、useState基础">1、useState基础<a class="anchor" href="#1、useState基础">·</a></h3><h4 id="1-1-基础用法">1.1 基础用法<a class="anchor" href="#1-1-基础用法">·</a></h4><ul><li>早期函数组件相比于类组件，劣势之一：缺乏维护和定义state的能力，而这个API<strong>为函数组件引入状态</strong></li><li>它与 class 里面的 <code>this.state</code> 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，但 state 中的变量会被 React 保留。</li><li>React 会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。</li></ul><ul><li><p>与类组件的不同：</p><ul><li>同样逻辑的函数组件比类组件复杂度更低，代码量更少</li><li>它类似 class 组件的 <code>this.setState</code>，但它不会把<strong>新state 和旧state 合并</strong>，而是<strong>替换</strong></li><li>值得注意的是，不同于 <code>this.state</code>，这里的 state <strong>不一定要是一个对象</strong> —— 如果你有需要，它也可以是。</li><li>这个初始 state 参数只有在第一次渲染时会被用到，在后续的重新渲染中，<code>useState</code> 返回的第一个值将始终是更新后最新的 state</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">const</span> [xxx, setXxx] = <span class="title class_">React</span>.<span class="title function_">useState</span>(initValue)<span class="comment">// 初始值，允许任意类型的值</span></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>React 会确保 <code>setState</code> 函数的标识是稳定的，并不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>setState</code>。</p></blockquote></li></ul><h4 id="1-2-函数式setState更新">1.2 函数式setState更新<a class="anchor" href="#1-2-函数式setState更新">·</a></h4><ul><li><p>如果新state 需要通过用先前state 计算得出，可以将函数传递给 <code>setState</code>。</p></li><li><p>该函数将接收先前state，并返回一个更新后的值。</p></li><li><p>如果你的更新函数返回值与当前 state 完全相同，则随后的<strong>重渲染会被完全跳过。</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setXxx</span>(<span class="function"><span class="params">value</span> =&gt;</span> newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      Count: &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意</p><p>与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code> 结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 也可使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123;...prevState, ...updatedValues&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p></blockquote><h4 id="1-3-惰性initialState">1.3 惰性initialState<a class="anchor" href="#1-3-惰性initialState">·</a></h4><ul><li><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。</p></li><li><p>如果初始 state 需通过复杂计算获得，则可传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = <span class="title function_">someExpensiveComputation</span>(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-跳过-state-更新">1.4 跳过 state 更新<a class="anchor" href="#1-4-跳过-state-更新">·</a></h4><ul><li>调用 State Hook 的更新函数并传入当前的 state 时，也就是函数式更新，state返回值没有发生变化时，React 将跳过子组件的渲染及 effect 的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）</li></ul><blockquote><p>需要注意的是：</p><ul><li><p>React 可能仍需<strong>在跳过渲染前渲染该组件</strong>。不过由于 React <strong>不会对组件树的“深层”节点进行不必要的渲染</strong>，所以大可不必担心。</p></li><li><p>如果你在渲染期间执行了高开销的计算，则可用 <code>useMemo</code> 来进行优化。</p></li></ul></blockquote><h4 id="1-5-注意：">1.5 注意：<a class="anchor" href="#1-5-注意：">·</a></h4><ul><li><p>多个状态声明时，<strong>必须分开写</strong></p></li><li><p>多次调用 <code>useState</code> 时，必须保证每次渲染时它们的调用顺序是不变的。后面解释why</p></li><li><p>因此，不能出现在<strong>条件判断语句</strong>中，因为它<strong>必须有一样的渲染顺序</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [ age , setAge ] = <span class="title function_">useState</span>(<span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> [ sex , setSex ] = <span class="title function_">useState</span>(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> [ work , setWork] = <span class="title function_">useState</span>(<span class="string">&#x27;前端程序员&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [ age , setAge ] = <span class="title function_">useState</span>(<span class="number">18</span>)   <span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span>(showSex)&#123;</span><br><span class="line">  <span class="keyword">const</span> [ sex , setSex ] = <span class="title function_">useState</span>(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">  showSex=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [ work , setWork ] = <span class="title function_">useState</span>(<span class="string">&#x27;前端程序员&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="why-顺序为什么重要？">why 顺序为什么重要？<a class="anchor" href="#why-顺序为什么重要？">·</a></h4><p>已经填坑——请查看Hook的使用规则小节部分或者源码调用流程部分；</p></li></ul><h3 id="2、-useEffect基">2、 useEffect基<a class="anchor" href="#2、-useEffect基">·</a></h3><blockquote><p>之前在React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为**“副作用”**</p><ul><li><code>useEffect</code> 就是一个 Effect Hook，给函数组件增加了操作副作用的能力</li><li>它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API</li><li>调用 <code>useEffect</code> 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以可以访问到组件的 props 和 state</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(callback, [](可选));</span><br></pre></td></tr></table></figure><h4 id="2-1-引入副作用">2.1 引入副作用<a class="anchor" href="#2-1-引入副作用">·</a></h4><blockquote><p>生命周期到useEffect的转换关系都不是最重要的，最重要的是构建组件有副作用，useEffect为函数组件引入副作用的钩子</p></blockquote><ul><li><p>通过 Hook，可以把<strong>组件内相关的副作用组织在一起</strong>（例如创建订阅及取消订阅），<strong>而不要把它们拆分到不同的生命周期函数里</strong></p></li><li><p>过去在DidMount 、DidUpdate、willUnmount中做的事，可放在该钩子做。比如：操作DOM、获取外部API</p></li><li><p>【注意】：<strong>useEffect中返回的函数叫“清除函数”：</strong></p><p>当React识别到该函数，会在卸载阶段执行其清除逻辑。</p><p>这个函数不会收第2个参数、或其他参数因素的影响。</p><p>只要你在useEffect回调中返回了一个函数，它就会被当做清除函数来处理。</p></li></ul><h4 id="2-2-无需清除的-effect-⭐️面试">2.2 无需清除的 effect ⭐️面试~<a class="anchor" href="#2-2-无需清除的-effect-⭐️面试">·</a></h4><blockquote><p>有时候，我们只想**在 React 更新 DOM 之后运行一些额外的代码。**比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。</p><p>因为在执行完这些操作之后，就可以忽略他们了。</p></blockquote><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次渲染都执行：相当于 componentDidMount 和 componentDidUpdate:</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只在挂载阶段执行一次的副作用，且该函数的返回值不是一个函数</span></span><br><span class="line">    &#125;,[]);</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>useEffect</code> 做了什么？</strong> React 会保存你传递的函数（effect），并在执行 DOM 更新之后调用它</p></li><li><p><strong>为什么在组件内部调用 <code>useEffect</code>？</strong></p><p>可以在 effect 中直接访问 <code>count</code> state 变量（或其他 props），而不需要特殊的 API 来读取它，它已经保存在函数作用域中（Hook 使用了<strong>JS的闭包机制</strong>）</p></li><li><p><strong><code>useEffect</code> 会在每次渲染后都执行吗？</strong></p><p>是的，默认情况下，它在<strong>第一次渲染之后<em>和</em>每次更新之后</strong>都会执行。</p><p>你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。</p><p>React <strong>保证了每次运行 effect 的同时，DOM 都已经更新完毕。</strong></p></li><li><h5 id="函数在渲染过程中的不同：⭐️⭐️⭐️">函数在渲染过程中的不同：⭐️⭐️⭐️<a class="anchor" href="#函数在渲染过程中的不同：⭐️⭐️⭐️">·</a></h5><ul><li>注意到，传递给 <code>useEffect</code> 的函数在每次渲染中<strong>都会有所不同，这是刻意为之的。</strong></li><li>事实上这正是我们可以在 effect 中<strong>获取最新的 <code>count</code> 的值</strong>，而不用担心其过期的原因。</li><li>每次我们重新渲染，都会生成<em>新的</em> effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。</li><li>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 effect <strong>不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快</strong>。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a> Hook 供你使用，其 API 与 <code>useEffect</code> 相同。</li><li>后续章节挖坑：⭐️</li></ul></li></ul><h4 id="2-3-需清除的effect">2.3 需清除的effect<a class="anchor" href="#2-3-需清除的effect">·</a></h4><p>此外，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作可以防止引起内存泄露！</p><ul><li><p><strong>为什么要在 effect 中返回一个函数？</strong></p><p>这是 effect 可选的<strong>清除机制</strong>。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.<span class="property">source</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清除订阅</span></span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>React 何时清除 effect？</strong></p><ul><li><p>为防止内存泄漏，清除函数会在组件卸载前执行。如果组件多次渲染（通常如此），则<strong>在执行下一个 effect 之前，上一个 effect 就已被清除</strong>。在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都触发 effect 的执行</p></li><li><p>正如之前学到的，<strong>effect 在每次渲染时都会执行</strong>。这就是为什么 React <em>会</em>在执行当前 effect 之前清除上一个 effect</p></li></ul><p><strong>为什么要这样，以及如何在遇到性能问题时跳过此行为</strong>在2.5 2.6会展开</p></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只在挂载、卸载阶段执行的副作用，且该函数的返回值是一个函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 业务逻辑A: 它会在挂载阶段执行</span></span><br><span class="line">  ....<span class="property">A</span></span><br><span class="line">      <span class="comment">// 业务逻辑B: 它会在卸载时执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    &#125;,[]);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 每一次渲染、且卸载阶段执行的副作用，且该函数的返回值是一个函数，不传第2个参数</span></span><br><span class="line">  <span class="comment">// 业务逻辑A: 它会在每次渲染时执行</span></span><br><span class="line">  ....<span class="property">A</span></span><br><span class="line">      <span class="comment">// 业务逻辑B:它会在卸载时执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 根据一定的依赖条件出发的副作用</span></span><br><span class="line">      <span class="comment">// 业务逻辑：</span></span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">// 若xxx是一个函数，则xxx会在组件卸载时被触发</span></span><br><span class="line">  <span class="keyword">return</span> xxx;</span><br><span class="line">    &#125;,[count1, count2, count3]);</span><br></pre></td></tr></table></figure><h4 id="2-4-Effect的执行时机">2.4 Effect的执行时机<a class="anchor" href="#2-4-Effect的执行时机">·</a></h4><ul><li><p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，传给 <code>useEffect</code> 的函数会在浏览器完成布局与绘制<strong>之后</strong>，在一个延迟事件中被调用。</p></li><li><p>这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为<strong>绝大多数操作不应阻塞浏览器对屏幕的更新。</strong></p></li><li><p>然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。</p></li><li><p>React 为此提供了一个额外的 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a> Hook 来处理这类 effect。它和 <code>useEffect</code> 的结构相同，区别只是调用时机不同。</p></li><li><p>虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。在开始新的更新前，React 总会先清除上一轮渲染的 effect。</p></li></ul><h4 id="使用多个Effect实现关注点分离">使用多个Effect实现关注点分离<a class="anchor" href="#使用多个Effect实现关注点分离">·</a></h4><ul><li>使用 Hook 其中一个<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#complex-components-become-hard-to-understand">目的</a>就是要解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。so，它可以<strong>使用多个 effect</strong>。这会将不相关逻辑分离到不同的 effect 中：</li><li><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的<em>每一个</em> effect。</li></ul><h4 id="2-5-为何每次更新时都运行-Effect">2.5 为何每次更新时都运行 Effect<a class="anchor" href="#2-5-为何每次更新时都运行-Effect">·</a></h4><p>为什么 effect 的清除阶段在<strong>每次重新渲染时都会执行</strong>，<strong>而不是只在卸载组件的时候执行一次</strong>。</p><ul><li><p><strong>因为这样的设计可以帮助创建组件bug更少：</strong></p><p>一个用于显示好友是否在线的 <code>FriendStatus</code> 组件。从 class 中 props 读取 <code>friend.id</code>，然后在组件挂载后订阅好友的状态，并在卸载组件的时候取消订阅：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">friend</span>.<span class="property">id</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleStatusChange</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">friend</span>.<span class="property">id</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleStatusChange</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但当组件已显示在屏幕时，<code>friend</code> prop 发生变化时会发生什么？</strong></p><p>我们的组件将继续展示原来的好友状态。<strong>这是一个 bug</strong>。</p><p>而且我们还会因为<strong>取消订阅时使用错误的好友 ID</strong> 导致内存泄露或崩溃的问题。class 组件中要添加 <code>componentDidUpdate</code> 来解决这个问题：</p><p>忘记正确地处理 <code>componentDidUpdate</code> 是 React 应用中常见的 bug 来源，其实确实存在</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;    </span><br><span class="line">  <span class="comment">// 取消订阅之前的 friend.id    </span></span><br><span class="line"> <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(prevProps.<span class="property">friend</span>.<span class="property">id</span>, <span class="variable language_">this</span>.<span class="property">handleStatusChange</span>);     <span class="comment">// 订阅新的 friend.id    </span></span><br><span class="line"> <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">friend</span>.<span class="property">id</span>,<span class="variable language_">this</span>.<span class="property">handleStatusChange</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>但hook的写法：并不会受到此 bug 影响</strong></p><p><strong>并不需特定的代码来处理更新逻辑，因为 <code>useEffect</code> <em>默认</em>就会处理</strong>。它会在调用一个新的 effect 之前对前一个 effect 进行清理。下面按时间列出一个可能会产生的订阅和取消订阅操作调用序列来说明：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mount with &#123; friend: &#123; id: 100 &#125; &#125; props</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">100</span>, handleStatusChange);     <span class="comment">// 运行第一个 effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with &#123; friend: &#123; id: 200 &#125; &#125; props</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">100</span>, handleStatusChange); <span class="comment">// 清除上一个 effect</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">200</span>, handleStatusChange);     <span class="comment">// 运行下一个 effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with &#123; friend: &#123; id: 300 &#125; &#125; props</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">200</span>, handleStatusChange); <span class="comment">// 清除上一个 effect</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">300</span>, handleStatusChange);     <span class="comment">// 运行下一个 effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmount</span></span><br><span class="line"><span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">300</span>, handleStatusChange); <span class="comment">// 清除最后一个 effect</span></span><br></pre></td></tr></table></figure><p>此默认行为保证了一致性，<strong>避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug。</strong></p></li></ul><h4 id="2-6-通过跳过-Effect来性能优化">2.6 通过跳过 Effect来性能优化<a class="anchor" href="#2-6-通过跳过-Effect来性能优化">·</a></h4><p>在某些情况下，每次渲染后都执行清理或执行 effect 可能会导致性能问题。</p><h5 id="渲染：">渲染：<a class="anchor" href="#渲染：">·</a></h5><ul><li><p><strong>在 class 组件中</strong>，通过在 <code>componentDidUpdate</code> 中添加对 <code>prevProps</code> 或 <code>prevState</code> 的<strong>比较逻辑</strong>解决：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevState.<span class="property">count</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;<span class="variable language_">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这是很常见的需求，所以<strong>它被内置到了 <code>useEffect</code> 的 Hook API 中</strong>。如果<strong>某些特定值在两次重渲染之间没有发生变化</strong>，你可以通知 React <strong>跳过</strong>对 effect 的调用，只要传递数组作为 <code>useEffect</code> 的第二个可选参数即可：</p><p>如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="清除时：">清除时：<a class="anchor" href="#清除时：">·</a></h5><ul><li><p>对于有清除操作的 effect 同样适用：未来版本，可能会在构建时自动添加第二个参数。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStatusChange</span>(<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="title function_">setIsOnline</span>(status.<span class="property">isOnline</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.<span class="property">friend</span>.<span class="property">id</span>]); <span class="comment">// 仅在 props.friend.id 发生变化时，重新订阅</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="注意：-2">注意：<a class="anchor" href="#注意：-2">·</a></h5><ul><li><p>如果你要使用此优化方式，请确保数组中包含了<strong>所有外部作用域中会随时间变化并且在 effect 中使用的变量</strong>，否则你的代码会引用到先前渲染中的旧变量。参阅文档，了解更多关于<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">如何处理函数</a>以及<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">数组频繁变化时的措施</a>内容。</p></li><li><p>如果想<strong>执行只运行一次的 effect</strong>（仅在组件挂载和卸载时执行），可以传递一个空数组（<code>[]</code>）作为第二个参数。</p><ul><li><p>这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它<strong>永远都不需要重复执行</strong>。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。</p></li><li><p>如果传入了一个空数组（<code>[]</code>），effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入 <code>[]</code> 作为第二个参数更接近大家更熟悉的 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 思维模式，但我们有<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">更好的</a><a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">方式</a>来避免过于频繁的重复调用 effect。</p></li><li><p>除此之外，请记得 <strong>React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code></strong>，因此会使得额外操作很方便。</p></li><li><p>推荐启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</p></li></ul></li></ul><h3 id="3、useContext基">3、useContext基<a class="anchor" href="#3、useContext基">·</a></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>); <span class="comment">//参数必须是 context 对象本身</span></span><br></pre></td></tr></table></figure><ul><li>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值</li><li>当前的 context 值由上层组件中<strong>距离当前组件最近</strong>的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定</li></ul><h4 id="3-1-特性：">3.1 特性：<a class="anchor" href="#3-1-特性：">·</a></h4><ul><li>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。</li><li>调用了 <code>useContext</code> 的组件<strong>总会在 context 值变化时重渲染</strong>，即使祖先使用 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>。</li><li>如果重渲染组件的开销较大，可以 <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693">通过使用 memoization 来优化</a>。</li></ul><h4 id="3-2-完整用法：">3.2 完整用法：<a class="anchor" href="#3-2-完整用法：">·</a></h4><ol><li><p>创建Context容器对象：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">XxxContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>()  </span><br></pre></td></tr></table></figure></li><li><p>传值子组件时，外面包裹<code>xxxContext.Provider</code>, 通过<strong>value</strong>属性（定死的）给后代组件传数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;xxxContext.<span class="property">Provider</span> value=&#123;数据&#125;&gt;</span><br><span class="line">子组件</span><br><span class="line">&lt;/xxxContext.<span class="property">Provider</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>数据其实是字符串，如果你想传对象，或多个值，可以再包一个{}</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;xxxContext.<span class="property">Provider</span> value=&#123;&#123;username, age, height&#125;&#125;&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">xxxContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;username:</span> &#x27;<span class="attr">superawesome</span>&#x27;&#125;&#125;&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>后代组件接收：<code>useContext()</code>钩子函数用来引入 Context 对象</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Messages</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; username &#125; = <span class="title function_">useContext</span>(xxxContext)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;messages&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>1 message for &#123;username&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;message&quot;</span>&gt;</span>useContext is awesome!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-关于Context-API">3.3 关于Context API<a class="anchor" href="#3-3-关于Context-API">·</a></h4><ul><li><p><code>useContext(MyContext)</code> 相当于 class 组件中的 <code>static contextType = MyContext</code> 或者 <code>&lt;MyContext.Consumer&gt;</code>。</p></li><li><p><code>useContext(MyContext)</code> 只是让你能<strong><em>读取</em> context 的值及订阅 context 的变化</strong>。你<strong>仍需在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件<em>提供</em> context</strong>。</p></li><li><p>高级指引部分有展开讲： <a href="https://zh-hans.reactjs.org/docs/context.html">Context 高级指南</a></p></li></ul><h4 id="3-4-memoization优化">3.4 memoization优化<a class="anchor" href="#3-4-memoization优化">·</a></h4><p>待续~挖坑</p><h3 id="4、useReducer">4、useReducer<a class="anchor" href="#4、useReducer">·</a></h3><h4 id="4-1">4.1<a class="anchor" href="#4-1">·</a></h4><blockquote><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发<strong>深更新的组件做性能优化</strong>，因为<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down">你可以向子组件传递 <code>dispatch</code> 而不是回调函数</a> 。</p></blockquote><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate"><code>useState</code></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。</p></li><li><p><strong>注意</strong></p><p>React 会确保 <code>dispatch</code> 函数的标识是稳定的，并不会在组件重新渲染时改变。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code>。</p></li></ul><h4 id="4-2-用法demo">4.2 用法demo<a class="anchor" href="#4-2-用法demo">·</a></h4><ul><li><p>用 reducer 重写 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate"><code>useState</code></a> 一节的计数器示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;     <span class="comment">// 1.1 初始化state</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;    <span class="comment">// 1.2 定义reducer</span></span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>: <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>: <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState); <span class="comment">// 1.3 初始化</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="language-xml">// 1.4 想要更改store数据的组件，只需要有dispatch钩子就可以</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-指定初始-state">4.3 指定初始 state<a class="anchor" href="#4-3-指定初始-state">·</a></h4><p>有两种不同初始化 <code>useReducer</code> state 的方式：</p><h5 id="最简单的：">最简单的：<a class="anchor" href="#最简单的：">·</a></h5><ul><li><p>将初始 state 作为第二个参数传入 <code>useReducer</code> 是最简单的方法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  &#123;<span class="attr">count</span>: initialCount&#125;  );</span><br></pre></td></tr></table></figure><ul><li>React 不使用 <code>state = initialState</code> 这一由 Redux 推广开来的参数约定。有时候初始值依赖于 props，因此需要在调用 Hook 时指定。</li><li>如果你特别喜欢上述的参数约定，可以通过调用 <code>useReducer(reducer, undefined, reducer)</code> 来模拟 Redux 的行为，但不鼓励你这么做。</li></ul></li></ul><h5 id="惰性初始化">惰性初始化:<a class="anchor" href="#惰性初始化">·</a></h5><ul><li><p>需将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 state 将被置为 <code>init(initialArg)</code></p></li><li><p>这么做可将用于计算 state 的逻辑提到reducer外部，这也为将来对<strong>重置 state 的 action</strong> 做处理提供了便利：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params">initialCount</span>) &#123;  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:  <span class="keyword">return</span> <span class="title function_">init</span>(action.<span class="property">payload</span>);     <span class="comment">// 重置action</span></span><br><span class="line">    <span class="attr">default</span>:    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialCount, init);  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;       Reset</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-4-跳过-dispatch">4.4 跳过 dispatch<a class="anchor" href="#4-4-跳过-dispatch">·</a></h4><ul><li>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）</li><li>需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。不是很理解~？？？</li></ul><h3 id="5、useRef">5、useRef<a class="anchor" href="#5、useRef">·</a></h3><h4 id="特性">特性<a class="anchor" href="#特性">·</a></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = <span class="title function_">useRef</span>(initialValue);</span><br></pre></td></tr></table></figure><ul><li><code>useRef</code> 返回一个可变的 <strong>ref 对象</strong>，其 <code>.current</code> <strong>属性被初始化为传入的参数</strong>（<code>initialValue</code>）。返回的 ref 对象在<strong>组件的整个生命周期内持续存在</strong>。</li><li>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。</li><li><code>useRef()</code> 比 <code>ref</code> 属性更有用：<ul><li>ref：是一种<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">访问 DOM</a> 的主要方式，如果将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 <strong>ref 对象的 <code>.current</code> 属性设置为相应的 DOM 节点</strong></li><li><code>useRef()</code> ：可以<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables">很方便地保存任何可变值</a>，因为它创建的是一个普通JS对象。而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<strong><code>useRef</code> 会在每次渲染时返回同一个 ref 对象。</strong></li><li>注意：当 ref 对象内容变化时，<code>useRef</code> 并<em>不会</em>通知你。<strong>变更 <code>.current</code> 属性不会引发组件重新渲染</strong>。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node">回调 ref</a> 来实现。</li></ul></li></ul><h4 id="使用demo：">使用demo：<a class="anchor" href="#使用demo：">·</a></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TextInputWithFocusButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onButtonClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    inputEl.<span class="property">current</span>.<span class="title function_">focus</span>(); <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、useMemo">6、useMemo<a class="anchor" href="#6、useMemo">·</a></h3><p>这部分不太理解，以后在实际使用时要多注意一下~</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">computeExpensiveValue</span>(a, b), [a, b]);</span><br></pre></td></tr></table></figure><ul><li>把“创建”函数和<strong>依赖项数组</strong>作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化<strong>有助于避免在每次渲染时都进行高开销的计算</strong>。</li><li>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 值</li><li>传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code></li></ul><h4 id="特性：">特性：<a class="anchor" href="#特性：">·</a></h4><ul><li><p>**目的：**用来解决用React hooks产生的无用渲染的性能问题</p></li><li><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值</p></li><li><p>先编写在没有 <code>useMemo</code> 的情况下也可执行的代码 —— 之后再添加 <code>useMemo</code>，以达到优化性能的目的</p></li></ul><blockquote><p>**你可以把 <code>useMemo</code> 作为性能优化的手段，但不要把它当成语义上的保证。**将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。</p><ul><li>这里不是很理解？？？</li></ul></blockquote><h4 id="demo举例：">demo举例：<a class="anchor" href="#demo举例：">·</a></h4><ul><li><p>作用：</p><ul><li>函数组件失去了<code>shouldCompnentUpdate</code>，所以无法在组件更新前，根据某些条件来组件是否更新</li><li>函数组件不再区分<code>mount</code>和<code>update</code>两个状态，所以<strong>函数组件每次调用都会执行内部的所有逻辑</strong>，性能损耗</li></ul></li><li><h5 id="父组件：">父组件：<a class="anchor" href="#父组件：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [name , setname] = <span class="title function_">useState</span>(<span class="string">&#x27;小红&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [count , setcount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>名字：&#123;name&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setcount(count++)&#125;&#125;&gt;数字：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="子组件：">子组件：<a class="anchor" href="#子组件：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123;name,children&#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我要更改父组件传过来的名字name啦&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&#x27;,新的&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newName = <span class="title function_">changeName</span>(name)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;newName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>点击数字，计时器会更新，但是名字相关的展示组件，与count毫无关系，但是也在执行，这是在做无用的渲染。</li><li>我们希望，只有与它相关的更新了，才执行对应的方法</li></ul></li><li><h4 id="优化：">优化：<a class="anchor" href="#优化：">·</a></h4><p>useMemo包裹，并传递第二个参数，参数匹配成功，才会执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newName = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span><span class="title function_">changeName</span>(name),[name]) </span><br></pre></td></tr></table></figure></li></ul><h4 id="注意：-3">注意：<a class="anchor" href="#注意：-3">·</a></h4><blockquote><p>依赖项数组不会作为参数传“创建”函数。</p><p>虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p><p>推荐启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 规则。此规则会在<strong>添加错误依赖时</strong>发出警告并给出修复建议。</p></blockquote><h3 id="7、useCallback">7、useCallback<a class="anchor" href="#7、useCallback">·</a></h3><h4 id="特性：-2">特性：<a class="anchor" href="#特性：-2">·</a></h4><ul><li><p>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数</p></li><li><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数<strong>仅在某个依赖项改变时才会更新。</strong></p></li><li><p>当你把回调函数传递给经过优化的并<strong>使用引用相等性</strong>去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p>怎么理解？？？挖坑~</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = <span class="title function_">useCallback</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doSomething</span>(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="注意：-4">注意：<a class="anchor" href="#注意：-4">·</a></h4><ul><li><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</li></ul><blockquote><p>依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p></blockquote><ul><li>推荐启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议</li></ul><h3 id="8、useLayoutEffect">8、useLayoutEffect<a class="anchor" href="#8、useLayoutEffect">·</a></h3><ul><li>与 <code>useEffect</code> 不同的是，它会在所有的 DOM 变更之后同步调用 effect，可以使用它来读取 DOM 布局并同步触发重渲染。</li><li>在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</li></ul><p>尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p><blockquote><p>提示</p><p>如果你正在将代码从 class 组件迁移到Hook，则注意 <code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的。但推荐你<strong>一开始先用 <code>useEffect</code></strong>，只有当它出问题的时候再尝试用 <code>useLayoutEffect</code>。</p><p>如果你使用服务端渲染，请记住，<strong><em>无论</em> <code>useLayoutEffect</code> <em>还是</em> <code>useEffect</code> 都无法在 JS代码加载完成之前执行</strong>。这就是为什么<strong>在服务端渲染组件中引入 <code>useLayoutEffect</code> 代码时会触发 React 告警</strong>。</p><ul><li>解决这个问题，需要将代码逻辑移至 <code>useEffect</code> 中（如果首次渲染不需要这段逻辑的情况下）</li><li>或是将该组件延迟到客户端渲染完成后再显示（如果直到 <code>useLayoutEffect</code> 执行之前 HTML 都显示错乱的情况下）。</li></ul><p>若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 <code>showChild &amp;&amp; &lt;Child /&gt;</code> 进行条件渲染，并使用 <code>useEffect(() =&gt; &#123; setShowChild(true); &#125;, [])</code> 延迟展示组件。这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。</p></blockquote><h3 id="9、useContext-useReducer">9、useContext + useReducer<a class="anchor" href="#9、useContext-useReducer">·</a></h3><h4 id="9-1、redux开发痛点">9.1、redux开发痛点<a class="anchor" href="#9-1、redux开发痛点">·</a></h4><p>比如当你正在开发一个很复杂的功能，中途需要不断添加全局状态，每次添加都不得不重复如下步骤：</p><ol><li>去到管理 redux 的文件夹，思考把这个状态放到状态树的哪个位置，然后新建一个文件夹并命名 <code>myFeature</code>。</li><li>创建三个文件 <code>my-feature/actions.js</code> 、<code>my-feature/reducer.js</code>、<code>my-feature/type.js</code></li><li>combineReducer 和并 reduce</li><li>将 action 引入到组件中</li><li>通过 connect HOC 与你的组件相连</li><li>增加两个方法 mapStateToProps 和 mapDispatchToProps</li></ol><p>以上只是加个状态而已，写很多模板代码还是其次，最要命的是会打断你写代码的思路。</p><p>而且随着项目越来越大， redux 的状态树也会变大，维护也会变困难。</p><h4 id="做法：">做法：<a class="anchor" href="#做法：">·</a></h4><p>对包裹组件使用useContext 和useReducer：</p><ul><li><p>一方面：后代的组件都能够获取到这个值store里面某个值，用来渲染</p></li><li><p>另一方面，还要把dispatch这个函数传下去，到时候，某种交互想改变store的数据，可以直接dispatch，派发action</p></li><li><p><strong>APP组件：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Color</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./color&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Color</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ShowArea</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Color</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**Color组件：**包裹、传递</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.  创建 context</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ColorContext</span> = <span class="title function_">createContext</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2  reducer方法 声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">UPDATE_COLOR</span>: <span class="keyword">return</span> action.<span class="property">color</span></span><br><span class="line">    <span class="attr">default</span>:  <span class="keyword">return</span> state  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Color</span> = props =&gt; &#123;</span><br><span class="line"><span class="comment">//2.1 使用useReducer</span></span><br><span class="line">  <span class="keyword">const</span> [color, dispatch] = <span class="title function_">useReducer</span>(reducer, <span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="comment">// 3. Provider通过value 将自己的组件中的某一state+更新该state的方法也传给了子组件</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ColorContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;color,</span> <span class="attr">dispatch</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ColorContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>**ShowArea：**使用的组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ColorContext</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./color&quot;</span>; <span class="comment">// 1. 导入context</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ShowArea</span> = props =&gt; &#123;</span><br><span class="line">  <span class="comment">// 2. 通过context接收到satate</span></span><br><span class="line">  <span class="keyword">const</span> &#123; color, dispatch&#125; = <span class="title function_">useContext</span>(<span class="title class_">ColorContext</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    // 3.1 使用store中的数据渲染</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">color</span> &#125;&#125;&gt;</span>字体颜色展示为&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">//3.2 用户交互改变store</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span>  <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          dispatch(&#123; type: UPDATE_COLOR, color: &quot;red&quot; &#125;);&#125;&#125;</span></span><br><span class="line"><span class="language-xml">         &gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  )</span></span><br><span class="line"><span class="language-xml">  return </span></span><br><span class="line"><span class="language-xml">&#125;;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="小结-3">小结<a class="anchor" href="#小结-3">·</a></h2><blockquote><p>至此，我们介绍完了Hook中大部分钩子及其使用特性；</p><p>关于接下来的Hook系列旅程中，我们将结合特性说明Hook的调用工作流程：How to work，以及最后分析why hooks的出现，以及为React的实际开发带来了怎样的好处；</p><p>最后总结一些Hook的实际开发心得~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类组件vs函数组件</title>
      <link href="/posts/React&#39;s%20Component.html"/>
      <url>/posts/React&#39;s%20Component.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数组件VS类组件">函数组件VS类组件<a class="anchor" href="#函数组件VS类组件">·</a></h2><h3 id="1、类组件-2">1、类组件<a class="anchor" href="#1、类组件-2">·</a></h3><p>基于ES6的写法，通过继承React.component的组件</p><h4 id="1-1-类组件的优势">1.1 类组件的优势<a class="anchor" href="#1-1-类组件的优势">·</a></h4><p>类组件是一个<strong>面向对象编程思想</strong>的一种表现。</p><blockquote><p>而面向对象的特性之一：</p><ul><li>封装：将一类属性和方法聚合到一个class中</li><li>继承：新的class可以通过继承现有class，实现对某一类属性和方法的复用；</li></ul></blockquote><p>so，类组件内部只通过继承React.component，就轻易获得了内部丰富的配备。</p><h4 id="1-2-类组件的的劣势：">1.2 类组件的的劣势：<a class="anchor" href="#1-2-类组件的的劣势：">·</a></h4><ul><li>React.component提供了很多东西，学习成本更高，比如生命周期，用的不好也会让代码一团糟。大而全但心累。</li><li>开发者编写的逻辑在封装后，是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。这就需要学习更高的设计模式，用更高的学习成本来交换一点编码的灵活度</li></ul><h3 id="2、函数组件-2">2、函数组件<a class="anchor" href="#2、函数组件-2">·</a></h3><p>以函数的形态存在的组件，在<strong>早期没有Hooks加持</strong>时，函数组件内部无法定义、维护state，因此也叫**“无状态组件”**</p><h4 id="2-1-使用层面特性PK：">2.1 使用层面特性PK：<a class="anchor" href="#2-1-使用层面特性PK：">·</a></h4><ul><li>类组件继承自class，函数组件不需要；</li><li>类组件可以访问生命周期钩子，函数组件不可；</li><li>类组件可以获取实例化后的this，并基于该this做事情，但函数组件不可；</li><li>类组件可以定义并维护state状态，但函数组件不可；</li></ul><h4 id="2-2-函数组件的优势">2.2 函数组件的优势<a class="anchor" href="#2-2-函数组件的优势">·</a></h4><p>不仅能承担数据渲染（简单的任务），同样可以承担复杂的交互逻辑；</p><ul><li>粗浅的认知：轻量、灵活、较低的学习成本</li><li><strong>Dam（React开发者）：函数组件会捕获render内部的状态，这是两类组件最大的不同。</strong>（如何理解这句话？）</li><li>类组件、函数组件之间的千差万别，但最不能被我们忽视的是，<strong>心智模式层面的差异，<strong>是</strong>面向对象和函数式编程</strong>这两种不同设计思想的差异</li></ul><ul><li><p><strong>而函数式组件更加契合React的理念：</strong></p><p>UI = f(data)，react组件本身的定位就是函数，吃进去数据，吐出来UI。开发者编写的是声明式的代码，而React就是把声明式的代码转换为命令式的DOM操作，把数据层面的描述映射到用户可见的UI变化中去。</p><p>这就意味着react中数据和渲染是紧密绑在一起的，但类组件是做不到这一点。<strong>为什么呢？</strong></p><p>因为<strong>函数组件会捕获render内部的状态，这是两类组件最大的不同。</strong></p></li></ul><h3 id="3、如何理解那句话？">3、如何理解那句话？<a class="anchor" href="#3、如何理解那句话？">·</a></h3><p><strong>函数组件会捕获render内部的状态，这是两类组件最大不同</strong></p><h4 id="3-1-类组件">3.1 类组件<a class="anchor" href="#3-1-类组件">·</a></h4><ul><li><p><strong>类组件中，虽然props不可变，但this是可变的，this上的数据是可以修改的</strong></p><ul><li>this.props每次都可以获取最新的props，而这正是react获取数据实时性的重要手段。</li><li>多数情况下，this.props与预期的渲染动作的连贯</li><li>假如通过setTimeout将预期的渲染推迟了3s，打破了this.props和渲染动作之间的这种时机上的联动。也就是渲染时捕获到的是一个错误的props，这就出现了问题</li></ul></li><li><p><strong>而函数组件会捕获render内部的状态</strong></p><ul><li>在函数执行的一瞬间就被捕获，而props本身又是一个不可变值，因此在任何时机读取到的props都是最新的props。</li><li>当父组件传递新的props时，其实内部产生了一次新的函数调用，并不会影响上一个props。</li><li>函数组件是真正将数据与渲染绑定在了一起</li></ul></li><li><p>总的来说，函数组件是一个<strong>更加匹配其设计理念</strong>、也<strong>更有利于逻辑拆分和重用</strong>的组件表达形式。</p></li></ul><h3 id="4、小结-2">4、小结<a class="anchor" href="#4、小结-2">·</a></h3><p>通过本文对比，可以看出，在Hooks出现之前，类组件的<strong>能力边界</strong>明显强于函数组件（啥活都能干）。</p><p>但一味鼓吹轻量、易上手、取代类组件也不是应该讨论谁优谁劣的依据。更多的关注点，应该是二者的不同之处，把对应的场景与不同的特性结合起来。</p>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数组件 </tag>
            
            <tag> 类组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React核心概念系列（2）</title>
      <link href="/posts/React&#39;s%20key%20Concept-2.html"/>
      <url>/posts/React&#39;s%20key%20Concept-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="center-React文档系列之核心概念（2）-center"><center>React文档系列之核心概念（2）</center><a class="anchor" href="#center-React文档系列之核心概念（2）-center">·</a></h2><p>书接上回，由于条件渲染（7）+列表的使用（8）在实际开发中，写过很多遍；这里不再讨论他们的使用。但是其中关注到：key为什么建议不要用index，这里周会做过一次讨论。</p><ul><li>官方推荐的阅读文档：https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</li><li>周会讨论的文档：主要是源码部分</li><li>这个点，出于文章的结构性考虑，会作为单独的篇幅探讨</li></ul><h3 id="6、表单">6、表单<a class="anchor" href="#6、表单">·</a></h3><p>这个地方是我最近做官网streamLake需求中，遇到过的实际问题；可以结合表单提交那篇博文讨论。ok，进入正题！</p><h4 id="6-1-React中的表单">6.1 React中的表单<a class="anchor" href="#6-1-React中的表单">·</a></h4><ul><li><p>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>名字:</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ul><li>此表单具有默认的 HTML 表单行为，即在用户提交表单后跳到新页面。 React 中同样有效</li></ul></li><li><p>但大多数情况下，使用 <strong>JS 函数可以很方便的处理表单的提交</strong>， 同时还可以<strong>访问用户填写的表单数据</strong>。实现这种效果的标准方式是使用“受控组件”。</p></li></ul><h4 id="6-2-受控组件">6.2 受控组件<a class="anchor" href="#6-2-受控组件">·</a></h4><h5 id="定义：">定义：<a class="anchor" href="#定义：">·</a></h5><ul><li><p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）之类的表单元素<strong>通常自己维护 state，并根据用户输入进行更新</strong>。</p></li><li><p>而 React 中，可变状态（mutable state）通常存在组件的 state 属性中，且只能通过 <a href="https://react.docschina.org/docs/react-component.html#setstate"><code>setState()</code></a>更新。</p></li><li><p>so，可以把两者结合起来，使 React 的 state 成为“唯一数据源”：渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。</p></li><li><p>被 React <strong>以这种方式控制取值的表单输入元素</strong>就叫做**“受控组件”。**</p></li></ul><h5 id="使用：">使用：<a class="anchor" href="#使用：">·</a></h5><ul><li><p>例如，如果想让表单在提交时打印出名称，可以将表单写为受控组件：</p><ul><li>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。</li><li>由于 <code>handlechange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</li><li>对于受控组件来说，<strong>输入值始终由 React 的 state 驱动</strong>。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">event</span>) =&gt; &#123;<span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleSubmit</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;提交的名字: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>);</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>名字:</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在百度的有一期需求是这样的，所以当时也不用操心数据维护的问题。但是后来需求中，因为考虑组件的封装问题，这样就不好处理了：</p><ul><li>如果这里的input组件是自定义封装的组件，怎么办，这样就没有这么方便去用satte维护了。这就涉及到跨组件写，成本就更高了</li></ul></li></ul><h4 id="6-3-常见受控组件">6.3 常见受控组件<a class="anchor" href="#6-3-常见受控组件">·</a></h4><h5 id="textarea标签：">textarea标签：<a class="anchor" href="#textarea标签：">·</a></h5><ul><li>与单行 input 的表单非常类似：略</li></ul><h5 id="select标签：">select标签：<a class="anchor" href="#select标签：">·</a></h5><ul><li><p><code>&lt;select&gt;</code> 创建下拉列表标签</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">value</span>: <span class="string">&#x27;lime&#x27;</span>&#125;; <span class="comment">//默认选中项</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;form onSubmit=&#123;<span class="variable language_">this</span>.<span class="property">handleSubmit</span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>选择你喜欢的风味:</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;grapefruit&quot;</span>&gt;</span>葡萄柚<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;lime&quot;</span>&gt;</span>酸橙<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>select</code> 标签中选择多个选项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select multiple=&#123;true&#125; value=&#123;[&#x27;B&#x27;, &#x27;C&#x27;]&#125;&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="文件-input-标签：《非受控》">文件 input 标签：《非受控》<a class="anchor" href="#文件-input-标签：《非受控》">·</a></h5><ul><li><p>在 HTML 中，<code>&lt;input type=&quot;file&quot;&gt;</code> 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications">File API</a> 进行控制。</p></li><li><p>因为它的 value 只读，所以它是 React 中的一个<strong>非受控</strong>组件。将与其他非受控组件<a href="https://react.docschina.org/docs/uncontrolled-components.html#the-file-input-tag">在后续文档中</a>一起讨论。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="多个输入控件：">多个输入控件：<a class="anchor" href="#多个输入控件：">·</a></h5><ul><li><p>可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">  <span class="attr">isGoing</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">numberOfGuests</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleInputChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> target = event.<span class="property">target</span>;</span><br><span class="line">  <span class="keyword">const</span> value = target.<span class="property">name</span> === <span class="string">&#x27;isGoing&#x27;</span> ? target.<span class="property">checked</span> : target.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">const</span> name = target.<span class="property">name</span>;</span><br><span class="line">  <span class="comment">// 使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[name]: value&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;input</span><br><span class="line">  name=<span class="string">&quot;isGoing&quot;</span></span><br><span class="line">  type=<span class="string">&quot;checkbox&quot;</span></span><br><span class="line">  checked=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isGoing</span>&#125;</span><br><span class="line">  onChange=&#123;<span class="variable language_">this</span>.<span class="property">handleInputChange</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="ES6-计算属性名称">ES6 计算属性名称<a class="anchor" href="#ES6-计算属性名称">·</a></h5><ul><li><p>以下代码等同：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[name]: value&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> partialState = &#123;&#125;;</span><br><span class="line">partialState[name] = value;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(partialState);</span><br></pre></td></tr></table></figure></li></ul><h5 id="受控输入空值">受控输入空值<a class="anchor" href="#受控输入空值">·</a></h5><ul><li><p>在<a href="https://react.docschina.org/docs/forms.html#controlled-components">受控组件</a>上指定 value 的 prop 会阻止用户更改输入。如果你指定了 <code>value</code>，但输入仍可编辑，则可能是你意外地将<code>value</code> 设置为 <code>undefined</code> 或 <code>null</code>。</p></li><li><p>效果：输入最初被锁定，但在短时间延迟后变为可编辑</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;hi&quot;</span> /&gt;</span></span>, mountNode); <span class="comment">//咋输都输不进去</span></span><br><span class="line">或：<span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;</span>&quot;<span class="attr">hi</span>&quot;&#125; /&gt;</span></span>, mountNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;null&#125;</span> /&gt;</span></span>, mountNode);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-4-受控组件的替代方案">6.4 受控组件的替代方案<a class="anchor" href="#6-4-受控组件的替代方案">·</a></h4><ul><li><p>有时使用受控组件会很麻烦，因为需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。</p></li><li><p>当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用<a href="https://react.docschina.org/docs/uncontrolled-components.html">非受控组件</a>, 这是实现输入表单的另一种方式。</p></li><li><p>想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 <a href="https://jaredpalmer.com/formik">Formik</a> 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上</p></li></ul><h3 id="7、状态提升">7、状态提升<a class="anchor" href="#7、状态提升">·</a></h3><p>这个demo非常有趣，请多多研究一下</p><h4 id="7-1-状态提升的做法">7.1 状态提升的做法<a class="anchor" href="#7-1-状态提升的做法">·</a></h4><p>在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”。</p><ul><li><p>此时，共享组件之间便有了同一数据源，</p></li><li><p>但新问题出现了：</p><p>props是只读的，共享组件失去了对它的控制权</p></li><li><p>在 React 中，这个问题通常是通过使用“受控组件”来解决的</p><p>与 DOM 中的 <code>&lt;input&gt;</code> 接受 <code>value</code> 和 <code>onChange</code> 一样，父组件把<strong>值和更新值的函数都作为props传下去</strong>，子组件将来更新时，调用更新函数</p><ul><li>它通过修改父组件自身的内部 state 来处理数据的变化，进而使用新的数值重新渲染那些要用这些数据的共享组件。</li></ul></li></ul><h4 id="7-2-demo分析">7.2 demo分析<a class="anchor" href="#7-2-demo分析">·</a></h4><h5 id="自己的理解总结：">自己的理解总结：<a class="anchor" href="#自己的理解总结：">·</a></h5><ul><li>原本两个组件，内部自己维护自己的state 。但因为要求二者同步更新，所以提出了状态提升。将父组件中的state来掌控这个个数据源，子组件做为props下流，拿到温度，各自按自己的逻辑显示；</li><li>但受控组件还要用户输入控制，so，为了解决这个问题，父组件下流props时，不仅传显示数据温度，还要将改变温度的函数也传下去，将来受控组件才能更新；</li><li>更新时，调用传过来的函数及新输入值，从而更新父组件内的state。state下流至props，UI更新：</li></ul><h5 id="demo代码：">demo代码：<a class="anchor" href="#demo代码：">·</a></h5><ul><li><p>子组件：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;<span class="variable language_">super</span>(props);&#125;</span><br><span class="line"><span class="title function_">handleChange</span>(<span class="params">e</span>) &#123;<span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">onTemperatureChange</span>(e.<span class="property">target</span>.<span class="property">value</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> temperature = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">temperature</span>;</span><br><span class="line">  <span class="keyword">const</span> scale = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">scale</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;temperature&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure></li><li><p>父组件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;<span class="comment">// 省略</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">temperature</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">scale</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleCelsiusChange</span>(<span class="params">temperature</span>) &#123;<span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">scale</span>: <span class="string">&#x27;c&#x27;</span>, temperature&#125;);&#125;</span><br><span class="line"><span class="title function_">handleFahrenheitChange</span>(<span class="params">temperature</span>) &#123;<span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">scale</span>: <span class="string">&#x27;f&#x27;</span>, temperature&#125;);&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> scale = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">scale</span>;</span><br><span class="line">  <span class="keyword">const</span> temperature = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">temperature</span>;</span><br><span class="line">  <span class="keyword">const</span> celsius = scale === <span class="string">&#x27;f&#x27;</span> ? <span class="title function_">tryConvert</span>(temperature, toCelsius) : temperature;</span><br><span class="line">  <span class="keyword">const</span> fahrenheit = scale === <span class="string">&#x27;c&#x27;</span> ? <span class="title function_">tryConvert</span>(temperature, toFahrenheit) : temperature;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TemperatureInput</span> <span class="attr">scale</span>=<span class="string">&quot;c&quot;</span> <span class="attr">temperature</span>=<span class="string">&#123;celsius&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onTemperatureChange</span>=<span class="string">&#123;this.handleCelsiusChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TemperatureInput</span> <span class="attr">scale</span>=<span class="string">&quot;f&quot;</span> <span class="attr">temperature</span>=<span class="string">&#123;fahrenheit&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onTemperatureChange</span>=<span class="string">&#123;this.handleFahrenheitChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">BoilingVerdict</span>  <span class="attr">celsius</span>=<span class="string">&#123;parseFloat(celsius)&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> );</span><br></pre></td></tr></table></figure></li></ul><h5 id="过程梳理：">过程梳理：<a class="anchor" href="#过程梳理：">·</a></h5><p>当你对输入框内容进行编辑时会发生些什么：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入框输值 ---&gt; 调用 DOM 中 &lt;input&gt; 的 onChange 方法:handleChange</span><br><span class="line">---&gt; 调用 this.props.onTemperatureChange()，并传入新输入的值作为参数 </span><br><span class="line">---&gt; 通过使用新的输入值与当前输入框对应的温度计量单位来调用 this.setState() </span><br><span class="line">---&gt;进而请求 React 重新渲染自己本身</span><br><span class="line">----&gt;  render 方法得到组件的 UI 呈现 ---&gt; 子组件的 render 方法来获取子组件的 UI 呈现。BoilingVerdict组件根据输入值匹配水是否沸腾，并将结果更新至 DOM。</span><br></pre></td></tr></table></figure><p>得益于每次的更新都经历相同的步骤，两个输入框的内容才能<strong>始终保持同步。</strong></p><h4 id="7-3-总结">7.3 总结<a class="anchor" href="#7-3-总结">·</a></h4><ul><li><p>在 React 应用中，任何可变数据<strong>应当只有一个相对应的唯一“数据源”。</strong></p><p>通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠<a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down">自上而下的数据流</a>，<strong>而不是尝试在不同组件间同步 state</strong>。</p></li><li><p>带来的好处是，排查和隔离 bug 所需的工作量将会变少。</p><p>由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。</p></li><li><p>当你在 UI 中发现错误时，可以使用 <a href="https://github.com/facebook/react/tree/main/packages/react-devtools">React 开发者工具</a> 来检查问题组件的 props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的那个组件。这使得你能够追踪到产生 bug 的源头：</p></li></ul><p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/react-devtools-state.gif" alt="Monitoring State in React DevTools"></p><h3 id="8、组合-vs-继承">8、组合 vs 继承<a class="anchor" href="#8、组合-vs-继承">·</a></h3><p>React 有十分强大的组合模式。并<strong>推荐使用组合而非继承</strong>来实现组件间的代码重用。</p><h4 id="8-1-包含关系：children-prop">8.1  包含关系：<code>children</code> prop<a class="anchor" href="#8-1-包含关系：children-prop">·</a></h4><h5 id="定义：-2">定义：<a class="anchor" href="#定义：-2">·</a></h5><ul><li><p>有些组件无法提前知晓它们子组件的具体内容。</p><p>这些组件使用一个特殊的 <code>children</code> prop 来将他们的子组件传递到渲染结果中：</p></li><li><p>我的通俗理解：</p><p>反正不知道将来我的女朋友什么样子，先提前给她起个名字“翠花”，将来谁是女朋友，谁的结婚证是翠花这个名字</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FancyBorder</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">FancyBorder</span> <span class="attr">FancyBorder-</span>&#x27; + <span class="attr">props.color</span>&#125;&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用：-2">使用：<a class="anchor" href="#使用：-2">·</a></h5><ul><li><p>这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们</p></li><li><p><code>&lt;FancyBorder&gt;</code> JSX 标签中的所有内容都会作为一个 <code>children</code> prop 传递给 <code>FancyBorder</code> 组件。因为 <code>FancyBorder</code> 将 <code>&#123;props.children&#125;</code> 渲染在一个 <code>&lt;div&gt;</code> 中，被传递的这些子组件最终都会出现在输出结果中。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WelcomeDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span> // props下流的colo值  内部是下流的组件</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span> Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>      </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span>Thank you for visiting our spacecraft!<span class="tag">&lt;/<span class="name">p</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="预留出几个“洞”：">预留出几个“洞”：<a class="anchor" href="#预留出几个“洞”：">·</a></h5><ul><li><p>少数情况下，可能需要在一个组件中预留出几个“洞”。这种情况下，可以不用 <code>children</code>，而是自行约定：将所需内容传入 props，并使用相应的 prop。</p></li><li><p><code>&lt;Contacts /&gt;</code> 和 <code>&lt;Chat /&gt;</code> 之类的 React 元素本质就是对象（object），所以可以把它们当作 props，像其他数据一样传递。</p></li><li><p>这种方法可能使你想起别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SplitPane</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-left&quot;</span>&gt;</span>&#123;props.left&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-right&quot;</span>&gt;</span>&#123;props.right&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">SplitPane</span> <span class="attr">left</span>=<span class="string">&#123;</span>&lt;<span class="attr">Contacts</span> /&gt;</span>&#125; right=&#123;<span class="tag">&lt;<span class="name">Chat</span> /&gt;</span>&#125; /&gt;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-特例关系">8.2 特例关系<a class="anchor" href="#8-2-特例关系">·</a></h4><ul><li><p>有时，会把一些组件看作是其他组件的特殊实例，比如 <code>WelcomeDialog</code> 可以说是 <code>Dialog</code> 的特殊实例。</p></li><li><p>在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dialog</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WelcomeDialog</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Dialog</span> <span class="attr">title</span>=<span class="string">&quot;Welcome&quot;</span> <span class="attr">message</span>=<span class="string">&quot;visiting!&quot;</span> /&gt;</span></span>;&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-3-继承">8.3 继承<a class="anchor" href="#8-3-继承">·</a></h4><ul><li>而继承，大意是FB成百上千的组件用react都没有用继承来构建组件层次的情况，他不推荐你用继承。而相比之下：props+组合模式更好<ul><li>Props 和组合提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</li><li>如果你想在组件间复用非 UI 的功能，建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件直接引入（import）而无需通过 extend 继承它们。</li></ul></li></ul><h3 id="9、React哲学">9、React哲学<a class="anchor" href="#9、React哲学">·</a></h3><h4 id="9-1-官方定位：">9.1 官方定位：<a class="anchor" href="#9-1-官方定位：">·</a></h4><ul><li>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</li></ul><h4 id="9-2-组件层级划分">9.2 组件层级划分<a class="anchor" href="#9-2-组件层级划分">·</a></h4><ul><li><p>如何将设计好的 UI 划分为组件层级？</p><ul><li><p>可以将组件当作一种函数或者是对象来考虑，根据<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">单一功能原则</a>来判定组件的范围。</p></li><li><p>一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。</p></li><li><p>实例图：</p><ul><li><code>FilterableProductTable</code><ul><li><code>SearchBar</code></li><li><code>ProductTable</code><ul><li><code>ProductCategoryRow</code></li><li><code>ProductRow</code></li></ul></li></ul></li></ul><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/thinking-in-react-components.png" alt="组件嵌套图示" style="zoom:50%;" /></li></ul></li></ul><h4 id="9-3-构建应用">9.3 构建应用<a class="anchor" href="#9-3-构建应用">·</a></h4><ul><li><p>你可以自上而下或者自下而上构建应用：</p><p>自上而下意味着：先编写层级较高的组件（比如 <code>FilterableProductTable</code>）</p><p>自下而上意味着：从最基本的组件开始编写（比如 <code>ProductRow</code>）。</p><p>当你的应用较简单时，自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。</p></li></ul><h4 id="9-4-确定state">9.4 确定state<a class="anchor" href="#9-4-确定state">·</a></h4><p>确定是state还是props的判断：</p><ol><li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li><li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li><li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li></ol><h4 id="9-5-确定组件传值问题">9.5 确定组件传值问题<a class="anchor" href="#9-5-确定组件传值问题">·</a></h4><p>这里主要讨论的是内层子组件与外层组件的传递，例子中使用的受控组件，查看状态提升小节，这里不再赘述；</p><h3 id="10、撒花">10、撒花<a class="anchor" href="#10、撒花">·</a></h3><p>ok，到这里，核心概念部分就已经结束了，我们相当于简单过了一下文档的基础部分，对react的认知又多了一点：</p><ul><li>关于state与Props的认知与区别。以及**props的特性。结合组件复用，**其实可以延伸至高阶组件HOC，这跟最近需求开发中的一个困惑：组件复用时样式太零散，但我不想通过零零散散的参数控制乱七八糟的属性，怎么办？</li><li>关于JSX中的转换过程，其实这里展开的不太深入，看完高级部分，会再反过来更新补充博文；</li><li>关于表单提交，解决了开发中的困惑，借此机会学习了别的处理方式；</li><li>关于事件处理、生命周期、Hooks、数据管理这些非常重要的东西，并没有大篇幅地展开介绍，期待一下高级部分；</li><li>interesting的一点是，今天下午开发需求刚好用上了昨晚看的状态提升，哈哈哈哈，开心~</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React核心概念系列（1)</title>
      <link href="/posts/React&#39;s%20key%20Concept-1.html"/>
      <url>/posts/React&#39;s%20key%20Concept-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="center-React文档系列之核心概念（1）-center"><center>React文档系列之核心概念（1）</center><a class="anchor" href="#center-React文档系列之核心概念（1）-center">·</a></h1><p>今天终于开启了react官方文档学习系列的第一步，简单日程如下：</p><ul><li>先看完基础的核心概念部分；</li><li>然后是高级指引部分，希望能追上早会技术分享的脚步；</li><li>之后，会将以前的阅读与项目中遇到的问题，整合进行总结出来。这个目的所在</li></ul><h3 id="1、JSX">1、JSX<a class="anchor" href="#1、JSX">·</a></h3><h4 id="1-1-什么是JSX">1.1 什么是JSX?<a class="anchor" href="#1-1-什么是JSX">·</a></h4><h5 id="官网定义：">官网定义：<a class="anchor" href="#官网定义：">·</a></h5><ul><li><p>是一个 JavaScript 的<strong>语法扩展</strong>， 可以很好地描述 UI 应该呈现出它应有<strong>交互的本质形式</strong>。</p></li><li><p><strong>JSX <strong>可能会使人联想到模版语言</strong>，但它具有 JavaScript 的全部功能</strong></p></li><li><p>这种标签语法既不是字符串也不是 HTML</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="总结后续内容：">总结后续内容：<a class="anchor" href="#总结后续内容：">·</a></h5><ul><li>文档定义：<strong>JSX是拓展</strong>而不是某个版本，说明<strong>浏览器不像天然支持JS那样支持JSX</strong>，即使它看起来很像HTML，所以JSX其实是React.creatElement()的语法糖</li><li>而<strong>帮手Babel</strong>是一个工具链，主要用于将ECMAScript2015+版本代码转换为向后兼容的JS语法，以便能够运行在当前、旧版本的浏览器和其他环境中。</li><li>JSX会被<strong>Babel</strong>编译为**react.creatElement()**的调用，这个函数会返回React元素。</li><li>JSX语法糖让我们用最熟悉的类HTML标签语法来创建虚拟DOM，降低学习成本，提升开发效率</li></ul><h4 id="1-2-为什么要用-JSX？">1.2 为什么要用 JSX？<a class="anchor" href="#1-2-为什么要用-JSX？">·</a></h4><ul><li><p>React 认为<strong>渲染逻辑</strong>本质上与<strong>其他 UI 逻辑</strong>内在耦合：</p><p>比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</p></li><li><p>React 并没有人为地分离<strong>标记与逻辑</strong>，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现分离</p></li><li><p>React <a href="https://react.docschina.org/docs/react-without-jsx.html">不强制要求</a>使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。</p></li></ul><h4 id="1-3-JSX的使用">1.3 JSX的使用<a class="anchor" href="#1-3-JSX的使用">·</a></h4><h5 id="大括号">大括号<a class="anchor" href="#大括号">·</a></h5><ul><li><p>声明了一个名为 <code>name</code> 的变量，然后在 JSX 中使用它：</p></li><li><p>在 JSX 语法中，你可以在大括号内放置任何有效的 JS表达式</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Josh Perez&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  element,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h5 id="函数调用">函数调用<a class="anchor" href="#函数调用">·</a></h5><ul><li><p>调用 JavaScript 函数 <code>formatName(user)</code> 的结果，并将结果嵌入到 <code>&lt;h1&gt;</code> 元素中</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatName</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> user.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + user.<span class="property">lastName</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Harper&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Perez&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  element,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h5 id="条件语句">条件语句<a class="anchor" href="#条件语句">·</a></h5><ul><li><p>可以在 <code>if</code> 语句和 <code>for</code> 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：</p></li><li><p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getGreeting</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="JSX-的属性">JSX 的属性<a class="anchor" href="#JSX-的属性">·</a></h5><p>注意：因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p><ul><li><p>用引号，来将属性值指定为字符串字面量：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>用大括号，来在属性值中插入一个 JavaScript 表达式：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。</p></li></ul><h5 id="JSX-防止注入攻击">JSX 防止注入攻击<a class="anchor" href="#JSX-防止注入攻击">·</a></h5><p>https://mynightwish.top/posts/2062301197.html?_sw-precache=e8cf09069586c0ee9ef7f817de532a71</p><ul><li><p>React DOM 在渲染所有输入内容之前，默认会进行<a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html">转义</a>。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。</p></li><li><p>所有的内容<strong>在渲染之前都被转换成了字符串</strong>。这样可以有效地防止 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS（cross-site-scripting, 跨站脚本）</a>攻击。</p></li><li><p>可以安全地在 JSX 当中插入用户输入内容：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.<span class="property">potentiallyMaliciousInput</span>;</span><br><span class="line"><span class="comment">// 直接使用是安全的：</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-JSX-React元素">1.4 JSX --&gt; React元素<a class="anchor" href="#1-4-JSX-React元素">·</a></h4><ul><li><p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用;</p></li><li><p>这个函数会返回一个叫做**“React  Element”**的JS对象</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello, world!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 二者等效</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>这个函数会返回一个叫做**“React  Element”**的JS对象，也就是 <strong>“React 元素”</strong>。它们描述了预期在屏幕上看到的内容。</p></li><li><p>React 通过读取这些对象，然后使用它们来<strong>构建 DOM</strong> 以及保持随时更新。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：这是简化过的结构</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、-React-元素">2、 React 元素<a class="anchor" href="#2、-React-元素">·</a></h3><p>说人话：<strong>如何将 React 元素渲染为 DOM的？</strong></p><h4 id="2-1-将一个元素渲染为-DOM">2.1 将一个元素渲染为 DOM<a class="anchor" href="#2-1-将一个元素渲染为-DOM">·</a></h4><ul><li><p>注意：</p><ul><li>假设 HTML 文件某处有一个 <code>&lt;div&gt;</code>：<strong>“根” DOM 节点</strong>，因为该节点内的所有内容都将由 React DOM 管理。</li><li>仅使用 React 构建的应用通常只有单一的根 DOM 节点。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将想要渲染的React 元素传入 <a href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-已渲染的元素的更新">2.2 已渲染的元素的更新<a class="anchor" href="#2-2-已渲染的元素的更新">·</a></h4><ul><li><p>React 元素是<a href="https://en.wikipedia.org/wiki/Immutable_object">不可变对象</a>。一旦被创建，你就<strong>无法更改它的子元素或者属性</strong>。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p></li><li><p><strong>更新 UI</strong> 唯一的方式是<strong>创建一个全新的元素</strong>，并将其传入 <a href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>。</p></li><li><p>考虑一个计时器的例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ul><li>这个例子会在 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval"><code>setInterval()</code></a> 回调函数，<strong>每秒都调用 <a href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>。</strong></li></ul></li><li><p><strong>注意：</strong></p><p>在实践中，大多数 React 应用<strong>只会调用一次</strong> <a href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>。怎么做到的呢？？？？？</p></li></ul><h4 id="2-3-React只更新需更新部分">2.3 React只更新需更新部分<a class="anchor" href="#2-3-React只更新需更新部分">·</a></h4><ul><li><p>React DOM 会将元素和它的子元素与它们之前的状态<strong>比较</strong>，并只会进行<strong>必要的更新</strong>来使 DOM 达到预期的状态。</p></li><li><p>尽管每一秒都会<strong>新建一个描述整个 UI 树的元素</strong>，React DOM <strong>只会更新实际改变了的内容，也就是例子中的文本节点。</strong></p><p><img src="https://cdn.jsdeliver.net/gh/myNightwish/CDN_res/react/granular-dom-updates.gif" alt="img"></p></li><li><p>根据我们的经验，考虑 UI 在任意给定时刻的状态，而不是随时间变化的过程，能够消灭一整类的 bug。 啥意思呢？？？？</p></li></ul><h3 id="3、组件">3、组件<a class="anchor" href="#3、组件">·</a></h3><h4 id="3-1-定义">3.1 定义<a class="anchor" href="#3-1-定义">·</a></h4><ul><li><p>组件，从概念上类似于 JS函数。它<strong>接受任意的入参</strong>（即 “props”），并<strong>返回</strong>用于描述页面展示内容的 <strong>React 元素</strong>。</p></li><li><p>React 元素可以是DOM 标签、或用户自定义的组件：</p><p>为自定义组件时，它会将 JSX 所接收的<strong>属性</strong>以及<strong>子组件</strong>（children）<strong>转换为单个对象</strong>传递给组件，这个对象被称之为 “props”。</p></li><li><p>转换过程：</p><ol><li>调用 <code>ReactDOM.render()</code> 函数，并传入 <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 作为参数。</li><li>React 调用 <code>Welcome</code> 组件，并将 <code>&#123;name: 'Sara'&#125;</code> 作为 props 传入。</li><li><code>Welcome</code> 组件将 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 元素作为返回值。</li><li>React DOM 将 DOM 高效地更新为 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;Sara&quot;</span> /&gt;</span></span>;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><ol><li>我们调用 <code>ReactDOM.render()</code> 函数，并传入 <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 作为参数。</li><li>React 调用 <code>Welcome</code> 组件，并将 <code>&#123;name: 'Sara'&#125;</code> 作为 props 传入。</li><li><code>Welcome</code> 组件将 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 元素作为返回值。</li><li>React DOM 将 DOM 高效地更新为 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li></ol></li><li><p>组件复用</p><p>提取组件可能是一件繁重的工作，但在大型应用中，构建可复用组件库是完全值得的。</p><p>根据经验来看，如果 UI 中有一部分<strong>被多次使用</strong>（<code>Button</code>，<code>Panel</code>，<code>Avatar</code>），或<strong>组件本身就足够复杂</strong>（<code>App</code>，<code>FeedStory</code>，<code>Comment</code>），那它就是一个可复用组件的候选项。</p></li></ul><h4 id="3-2-Props-的只读性">3.2 Props 的只读性<a class="anchor" href="#3-2-Props-的只读性">·</a></h4><p><strong>React的严格规则：<strong>所有 React 组件都必须像</strong>纯函数</strong>一样保护它们的 props 不被更改。</p><ul><li><p>纯函数：多次调用下相同的入参始终返回相同的结果。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123; <span class="comment">//纯函数</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withdraw</span>(<span class="params">account, amount</span>) &#123; <span class="comment">//非纯函数，因为它更改了自己的入参：</span></span><br><span class="line">  account.<span class="property">total</span> -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>任何组件（函数组件、类组件）都决不能修改自身的 props。但应用的 UI 是动态的，并会伴随着时间的推移而变化，怎么办？</p><p>“state”出场啦~~，在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p></li></ul><h3 id="4、state">4、state<a class="anchor" href="#4、state">·</a></h3><h4 id="4-1-ReactDOM-render-更新渲染元素">4.1  <code>ReactDOM.render()</code>更新渲染元素<a class="anchor" href="#4-1-ReactDOM-render-更新渲染元素">·</a></h4><ul><li><p>前面章节2介绍了一种更新 UI 界面的方法：调用 <code>ReactDOM.render()</code> 来更新想渲染的元素：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>( element,    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)  );&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>如何封装真正可复用的 <code>Clock</code> 组件，并设置自己的计时器并每秒更新一次：</p><ul><li>关键的技术细节：<code>Clock</code> 组件需要设置一个计时器，并且需要每秒更新 UI。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Clock</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>           </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Clock</span> <span class="attr">date</span>=<span class="string">&#123;new</span> <span class="attr">Date</span>()&#125; /&gt;</span></span>,    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>); </span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-state更新渲染元素">4.2 state更新渲染元素<a class="anchor" href="#4-2-state更新渲染元素">·</a></h4><ul><li>以上的实现并不符合预期，其实<strong>每秒都在重新创建，重新调用</strong>。而我们希望只编写一次代码，便可让 <code>Clock</code> 组件自我更新：</li><li>此时，需要在 <code>Clock</code> 组件中添加 “state” 来实现这个功能。State 与 props 类似，但 state 是私有的，并完全受控于当前组件。</li></ul><h5 id="1-转成类组件">1. 转成类组件<a class="anchor" href="#1-转成类组件">·</a></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);  <span class="comment">//通过以下方式将 props 传递到父类的构造函数中：</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="2-设置-Clock-的计时器并每秒更新它">2. 设置 <code>Clock</code> 的计时器并每秒更新它<a class="anchor" href="#2-设置-Clock-的计时器并每秒更新它">·</a></h5><ul><li><p>在具有许多组件的应用中，当组件被销毁时释放所占用的资源是非常重要的。</p></li><li><p>“挂载&quot;：当 <code>Clock</code> 组件第一次被渲染到 DOM 中时，就为其<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval">设置一个计时器</a></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 把计时器的 ID 保存在 this 之中（this.timerID）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">timerID</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">tick</span>(),<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>“卸载&quot;：当 DOM 中 <code>Clock</code> 组件被删除的时候，应该<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval">清除计时器</a>。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerID</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 <code>tick()</code> 方法，<code>Clock</code> 组件每秒都会调用它。现在时钟每秒都会刷新。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-总结☆☆☆">3. 总结☆☆☆<a class="anchor" href="#3-总结☆☆☆">·</a></h5><ol><li><p>当 <code>&lt;Clock /&gt;</code> 被传给 <code>ReactDOM.render()</code>时，React 会调用 <code>Clock</code> 组件的构造函数。因为 <code>Clock</code> 需要显示当前的时间，所以它会用一个包含当前时间的对象来初始化 <code>this.state</code>。我们会在之后更新 state。</p></li><li><p>之后 React 会调用组件的 <code>render()</code> 方法。这就是 React 确定该在页面上展示什么的方式。然后 React 更新 DOM 来匹配 <code>Clock</code> 渲染的输出。</p></li><li><p>当 <code>Clock</code> 的输出被插入到 DOM 中后，React 就会调用 <code>ComponentDidMount()</code> 生命周期方法。在这个方法中，<code>Clock</code> 组件向浏览器请求设置一个计时器来每秒调用一次组件的 <code>tick()</code> 方法。</p></li><li><p>浏览器每秒都会调用一次 <code>tick()</code> 方法。 在这方法之中，<code>Clock</code> 组件会通过调用 <code>setState()</code> 来计划进行一次 UI 更新。</p><p><strong>得益于 <code>setState()</code> 的调用，React 能够知道 state 已经改变了</strong>，然后会重新调用 <code>render()</code> 方法来确定页面上该显示什么。这一次，<code>render()</code> 方法中的 <code>this.state.date</code> 就不一样了，如此以来就会渲染输出更新过的时间。React 也会相应的更新 DOM。</p><ul><li><code>setState()</code> 是视图更新的驱动方式</li></ul></li><li><p>一旦 <code>Clock</code> 组件从 DOM 中被移除，React 就会调用 <code>componentWillUnmount()</code> 生命周期方法，这样计时器就停止了。</p></li></ol><h4 id="4-3-State的3个使用原则">4.3 State的3个使用原则<a class="anchor" href="#4-3-State的3个使用原则">·</a></h4><h5 id="1-不要直接修改-State">1. 不要直接修改 State<a class="anchor" href="#1-不要直接修改-State">·</a></h5><ul><li><p>否则不会重新渲染组件。而是应该使用 <code>setState()</code>:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">comment</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">comment</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-State-的更新可能是异步的">2. State 的更新可能是异步的<a class="anchor" href="#2-State-的更新可能是异步的">·</a></h5><ul><li><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用</p></li><li><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以<strong>不要依赖他们的值来更新下一个状态</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">increment</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-State的更新会被合并">3. State的更新会被合并<a class="anchor" href="#3-State的更新会被合并">·</a></h5><ul><li><p>当你调用 <code>setState()</code> 时，React 会把<strong>你提供的对象合并到当前的 state</strong></p></li><li><p>例如，你的 state 包含几个独立的变量：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">posts</span>: [],      </span><br><span class="line">    <span class="attr">comments</span>: []    </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以分别调用 <code>setState()</code> 来单独地更新它们：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">fetchPosts</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">posts</span>: res.<span class="property">posts</span> &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchComments</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;  <span class="attr">comments</span>: res.<span class="property">comments</span> &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的合并是浅合并，所以 <code>this.setState(&#123;comments&#125;)</code> 完整保留了 <code>this.state.posts</code>， 但是完全替换了 <code>this.state.comments</code>。</p></li></ul><h4 id="4-4-数据是下流动的">4.4 数据是下流动的<a class="anchor" href="#4-4-数据是下流动的">·</a></h4><h5 id="1-state-是局部封装的">1. state 是局部封装的<a class="anchor" href="#1-state-是局部封装的">·</a></h5><ul><li><p>不管是父组件或是子组件都无法知道<strong>某个组件是有状态的还是无状态的</strong>，且它们<strong>也不关心它是函数组件还是 class 组件</strong>。这就是为什么称 state 为局部的或是封装的的原因：</p><p>除了拥有并设置了它的组件，其他组件都无法访问。</p></li><li><p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中：</p><p><code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>；</p><p>但组件本身不知道它是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">FormattedDate</span> date=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">date</span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FormattedDate</span>(<span class="params">props</span>) &#123; <span class="comment">//傻子，不知道是prop、state、还是自定义传过来的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-总结">2. 总结<a class="anchor" href="#2-总结">·</a></h5><p>这通常会被叫做“自上而下”或是“单向”的数据流。</p><ul><li><p>任何的 state 总是所属于特定的组件，且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p></li><li><p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但它只能向下流动。</p></li><li><p>在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。这咋理解？？？</p></li></ul><h3 id="5、事件处理">5、事件处理<a class="anchor" href="#5、事件处理">·</a></h3><h4 id="5-1-与DOM元素的差异">5.1 与DOM元素的差异<a class="anchor" href="#5-1-与DOM元素的差异">·</a></h4><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p><ol><li><p>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;activateLasers()&quot;</span>&gt;</span><br><span class="line">  <span class="title class_">Activate</span> <span class="title class_">Lasers</span></span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  Activate Lasers</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code></p><p>例如，传统的 HTML 中阻止链接默认打开一个新页面</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#&quot;</span> onclick=<span class="string">&quot;console.log(&#x27;clicked.&#x27;); return false&quot;</span>&gt;<span class="title class_">Click</span> me&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ActionLink</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这里，<code>e</code> 是一个合成事件。React 根据 <a href="https://www.w3.org/TR/DOM-Level-3-Events/">W3C 规范</a>来定义这些合成事件，所以你<strong>不需要担心跨浏览器的兼容性问题</strong>。查看 <a href="https://react.docschina.org/docs/events.html"><code>SyntheticEvent</code></a> 参考指南</li><li>用 React 时，你一般不需要使用 <code>addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可</li></ul></li></ol><h4 id="5-2-回调函数中的-this">5.2  回调函数中的 <code>this</code><a class="anchor" href="#5-2-回调函数中的-this">·</a></h4><h5 id="绑定this">绑定this<a class="anchor" href="#绑定this">·</a></h5><ul><li>在 JS 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code>this</code>。当你调用函数时 <code>this</code> 的值为 <code>undefined</code>。</li><li>这并不是 React 特有的行为；这其实与 <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/">JavaScript 函数工作原理</a>有关</li><li>通常情况下，如果你没有在方法后面添加 <code>()</code>，例如 <code>onClick=&#123;this.handleClick&#125;</code>，你应该为这个方法绑定 <code>this</code>。</li></ul><h5 id="解决绑定麻烦2种：">解决绑定麻烦2种：<a class="anchor" href="#解决绑定麻烦2种：">·</a></h5><ol><li><p>实验性的 <a href="https://babeljs.io/docs/plugins/transform-class-properties/">public class fields 语法</a>，<a href="https://github.com/facebookincubator/create-react-app">Create React App</a> 默认启用此语法。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 此语法确保 `handleClick` 内的 `this` 已被绑定。  // 注意: 这是 *实验性* 语法。   handleClick = () =&gt; &#123;    console.log(&#x27;this is:&#x27;, this);  &#125;</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>箭头函数</p><p>问题：每次渲染 <code>LoggingButton</code> 时都会创建不同的回调函数；</p><ul><li>在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会额外的重新渲染</li><li>so，建议在构造器中绑定或使用 class fields 语法来避免这类性能问题</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is:&#x27;</span>, <span class="variable language_">this</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 此语法确保 `handleClick` 内的 `this` 已被绑定。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick()&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="5-3-事件传参">5.3 事件传参<a class="anchor" href="#5-3-事件传参">·</a></h4><p>2种方式：</p><ul><li>在这2种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递</li><li>如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">deleteRow</span>(id, e)&#125;&gt;<span class="title class_">Delete</span> <span class="title class_">Row</span>&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.deleteRow.bind(this,</span> <span class="attr">id</span>)&#125;&gt;</span>Delete Row<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表单提交&amp;文件上传&lt;1&gt;</title>
      <link href="/posts/50508479.html"/>
      <url>/posts/50508479.html</url>
      
        <content type="html"><![CDATA[<h2 id="表单提交的几种">表单提交的几种<a class="anchor" href="#表单提交的几种">·</a></h2><h3 id="官网项目开发遇到的问题">官网项目开发遇到的问题<a class="anchor" href="#官网项目开发遇到的问题">·</a></h3><ul><li><p>官网开发时，有客户反馈的工单提交功能：</p></li><li><p>我的做法：</p><p>考虑多个页面、每个页面元素很多，且结构相似，于是采用了组件复用，在每个组件填写信息，然后提交组件处收集信息给server端</p><ul><li>但问题是，我一开始没有用Form表单的方式去做，当提交时就会涉及到<strong>收集数据的问题</strong>；</li><li>很多组件，层级传下去非常麻烦，于是我想起了Contex的数据管理方式去做：但这样每个控件都需要去处理，很麻烦。我又很快意识到这不是一个好的处理方式；</li></ul></li><li><p>其实，跟同事简单交流了两句，突然意识到原来最基本的Form表单就可以做…而且</p><ul><li>根本就不用操心这个数据收集问题</li><li>页面跳转，更符合需求要求</li><li>Antd中刚好就有那些现成控件，处理起来较简单；</li></ul></li><li><p>所以说，动手之前一定要确定好可行性、实践最佳的几种方式，这也是需求开发中的教训：</p><ul><li>一来，可以极大减少开发中的无效劳动，节省时间精力；</li><li>二来，与别人的交流中极有可能会收获到新的东西</li><li>可能是受到之前文件上传的影响，我就一开始脑子里没想起这个做法；</li></ul></li></ul><h3 id="1-type-submit提交（refresh）">1. type=submit提交（refresh）<a class="anchor" href="#1-type-submit提交（refresh）">·</a></h3><ul><li><p>关于具体内容，可以参考mdn文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">form基础知识文档</a>，重点几个重点属性：</p><ul><li>提交行为是通过type=submit触发的；</li><li>method 属性默认缺省为get请求方式：参数会有&amp;拼接；</li><li>表单的提交后会有默认行为，会<strong>跳转刷新</strong>到action 的页面，so，后续的ajax就不会有这个问题；</li><li>表单的提交方式，请求头默认的<strong>content-type 为 x-www-form-urlencoded</strong>；</li><li>当一个form 表单内部，所有的input 中只有一个 type=‘text’ 时，回车会有默认的提交行为（注意前提条件）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- form 表单post提交，默认会刷新到 action 页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3008/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">name</span>=<span class="string">&quot;post提交&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- form 表单get 提交, 默认刷新action 页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3008/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span> <span class="attr">name</span>=<span class="string">&quot;get提交&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-隐藏iframe方式（norefresh）">2. 隐藏iframe方式（norefresh）<a class="anchor" href="#2-隐藏iframe方式（norefresh）">·</a></h3><ul><li><p>form 表单的缺点是：提交后会跳转到action中指定的url；但我不想刷新页面，怎么办呢？</p></li><li><p>实现：设置一个隐藏的iframe 页面，并将form 的target 属性指向这个iframe，当前页面iframe则不会刷新页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无刷新页面提交 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3008/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">name</span>=<span class="string">&quot;post提交&quot;</span> <span class="attr">target</span>=<span class="string">&quot;targetIfr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;targetIfr&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-JS事件触发（refresh）">3. JS事件触发（refresh）<a class="anchor" href="#3-JS事件触发（refresh）">·</a></h3><ul><li><p>通过button、链接等触发事件，调用submit()方法提交数据，jquery通过submit()方法</p></li><li><p>调用submit()方法：拿到表单id</p></li><li><p>注意：</p><ul><li>通过脚本提交行为<strong>依然存在跳转 新页面刷新</strong>的问题</li><li>脚本中可以通过阻止默认行为来禁止页面跳转</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过js 进行表单的提交 存在问题，页面会跳转刷新--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3008/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">name</span>=<span class="string">&quot;jsForm&quot;</span> <span class="attr">target</span>=<span class="string">&quot;targetIfr&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jsForm&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过jquery 进行表单的提交 存在问题，并阻止页面跳转刷新--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3008/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">name</span>=<span class="string">&quot;jqueryForm&quot;</span> <span class="attr">target</span>=<span class="string">&quot;targetIfr&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jqueryForm&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;jqbtn&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js会刷新</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> jsForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;jsForm&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    jsForm.<span class="title function_">submit</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jquery</span></span><br><span class="line">$(<span class="string">&#x27;#jqbtn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  $(<span class="string">&#x27;#jqueryForm&#x27;</span>).<span class="title function_">submit</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;submit success&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-ajax-提交（norefresh）">4. ajax 提交（norefresh）<a class="anchor" href="#4-ajax-提交（norefresh）">·</a></h3><h4 id="使用：-3">使用：<a class="anchor" href="#使用：-3">·</a></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ajax 请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;jqbtn&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#jqbtn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3008/user&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params),</span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&quot;application/json&quot;</span>, <span class="comment">// 默认以formdata形式发送给后台</span></span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="注意事项：">注意事项：<a class="anchor" href="#注意事项：">·</a></h4><ul><li><p>form 表单内 <strong>不允许 <code>&lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;</code>的存在</strong>，否则会和ajax 自身请求冲突</p></li><li><p>ajax 请求中，默认的content-type 为’formdata’，可根据自己的需要修改;</p></li><li><p>后台对不同的content-type 请求头的处理如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理请求 的content-type 为application/json</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理请求的content-type 为application/x-www-form-urlencoded</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">urlencoded</span>(&#123;</span><br><span class="line">  <span class="attr">extended</span>: <span class="literal">false</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li></ul><h4 id="跨域问题：">跨域问题：<a class="anchor" href="#跨域问题：">·</a></h4><ul><li><p>ajax 请求需要处理跨域问题，而form 表单的默认提交不需要：</p><p>因为：原页面用form 提交到另一个域名之后，原脚本无法获取响应的内容，所以浏览器认为这是安全的，而ajax 需要处理响应的内容，浏览器则认为这是一种跨域的行为</p></li><li><p>如何解决ajax 的跨域问题？</p><p>在后台的代码中加入跨域的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&quot;cors&quot;</span>)</span><br><span class="line"><span class="comment">// 解决跨域</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件上传">文件上传<a class="anchor" href="#文件上传">·</a></h2><h3 id="基本流程：">基本流程：<a class="anchor" href="#基本流程：">·</a></h3><ul><li>浏览器端提供了表单form，用户提交请求后，将文件数据和其他表单信息 编码并上传至服务端，服务端将上传的内容解码，提取出表单中的信息，将文件数据存入磁盘或数据库。</li><li>注意：上传≠提交</li></ul><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/1696aa6d479cdaa5~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 25%;" /><h3 id="方式1：纯form表单上传">方式1：纯form表单上传<a class="anchor" href="#方式1：纯form表单上传">·</a></h3><h4 id="基本使用：-2">基本使用：<a class="anchor" href="#基本使用：-2">·</a></h4><ul><li><p>传统的form表单上传，用form表单的input[type=”file”]控件，选择文件并上传</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:7787/files&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请选择文件&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用的关键点：">使用的关键点：<a class="anchor" href="#使用的关键点：">·</a></h4><ul><li><p><code>enctype=&quot;multipart/form-data&quot;</code>：不能少，用<strong>multipart格式</strong>上传文件，此时request头：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Content-Type:multipart/form-data; boundary=-—WebKitFormBoundaryzr34cwJKQC9</span><br></pre></td></tr></table></figure></li><li><p><code>method=&quot;post&quot;</code>： 用post方式提交数据，<strong>只有 method=“post” 时才使用 enctype 属性</strong></p></li><li><p><code>action</code>：标明上传的服务端处理地址，上传完后会刷新并跳转到该页面</p></li><li><p><code>type=&quot;file&quot;</code>：使用input的file控件上传，如果是多文件批量上传，可以将input[type=”file”]的name属性设置为如：name=”file[]”</p></li><li><p><code>accept</code>属性是H5新属性，规定了可通过文件上传提交的文件类型</p></li><li><p>上传的触发事件：</p><ul><li>可以是：input[type=”file”]的<code>onChange</code>触发</li><li>也可以由事件触发：比如<code>onClick</code>表单提交</li></ul></li></ul><h4 id="form的enctype属性">form的enctype属性<a class="anchor" href="#form的enctype属性">·</a></h4><ul><li>form的<strong>enctype属性</strong>用于指定编码方式，<strong>只有 method=“post” 时才使用 enctype 属性</strong>，取值：<ol><li><strong>application/x-www-form-urlencoded（默认）</strong>：在发送前对所有字符编码（将空格转换为 “+” 符号，特殊字符转换为 ASCII HEX 值）。<code>application/x-www-form-urlencoded</code>无法进行文件上传。</li><li><strong>multipart/form-data</strong>：不对字符编码。当使用有文件上传控件的表单时，该值是必需的</li><li>text/plain：将空格转换为 “+” 符号，但不编码特殊字符。 用得非常少</li></ol></li></ul><h3 id="方式2：FormData">方式2：FormData<a class="anchor" href="#方式2：FormData">·</a></h3><h4 id="前端实现步骤：">前端实现步骤：<a class="anchor" href="#前端实现步骤：">·</a></h4><ol><li>监听 Input 控件[type=‘file’]的 onchange ，通过 files 属性即可获得当前用户选择的文件（是二进制的）。其实当用户选完文件后，<code>File</code>对象实例就已创建了，存到了对应<code>input DOM</code>中<code>files</code>中</li><li>前端将文件相关的 type 和 size 组织到一个 <strong>FormData</strong> 对象中，利用XMLHttpRequest实例做出文件的上传，此时前端发出的就是，multipart/form-data的编码类型</li></ol><ul><li><strong>总结</strong>：Form表单和FormData对象是可以相互转化的，Form 表单里每一个 Input 控件的 name，其实就是 FormData 里的 key</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;文件上传&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;uploadFile()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> file = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;file&#x27;</span>).<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> fd = <span class="keyword">new</span> <span class="title class_">FormData</span>();     <span class="comment">// 实例化一个文件</span></span></span><br><span class="line"><span class="language-javascript">  fd.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, file);      <span class="comment">// 将文件内容插入进去</span></span></span><br><span class="line"><span class="language-javascript">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/upload&#x27;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  xhr.<span class="title function_">send</span>(fd);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="后端：">后端：<a class="anchor" href="#后端：">·</a></h4><ol><li>在真正文件内容外多了几行文件信息，所以解析器目的是去掉这几行内容。以便写文件摘出有效的文件内容然后写进新文件里，从而达到文件上传的目的</li><li>打印fd，获取到整个表单的内容：然而<code>formData</code>打印出来的则是一个空对象：<ul><li>并不代表整个对象就是空的，只是<strong>浏览器对该对象进行了处理，无法对文件操作，只能通过<code>append</code>添加一些字段。</strong></li></ul></li></ol><h3 id="Blob-文件上传方式：">Blob 文件上传方式：<a class="anchor" href="#Blob-文件上传方式：">·</a></h3><ul><li><code>Blob</code> 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 来用于数据操作。</li><li>Blob 表示的不一定是JS原生格式的数据。<code>blob</code>对象本质上是<code>js</code>中的一个对象，里面可以储存大量的二进制编码格式的数据。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a> 接口基于<code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件</li><li>要从其他非blob对象和数据构造一个 <code>Blob</code>，请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob"><code>Blob()</code></a> 构造函数。要创建一个 blob 数据的子集 blob，请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice"><code>slice()</code></a> 方法。要获取用户文件系统上的文件对应的 <code>Blob</code> 对象，参考file API</li></ul><h4 id="1-1-直接使用-blob-上传：">1.1 直接使用 blob 上传：<a class="anchor" href="#1-1-直接使用-blob-上传：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> json = &#123; <span class="attr">hello</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json, <span class="literal">null</span>, <span class="number">2</span>)], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, blob, <span class="string">&#x27;1.json&#x27;</span>);</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:7787/files&#x27;</span>, formData);</span><br></pre></td></tr></table></figure><h4 id="1-2-用-File-对象，再一次包装">1.2 用 File 对象，再一次包装<a class="anchor" href="#1-2-用-File-对象，再一次包装">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> json = &#123; <span class="attr">hello</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json, <span class="literal">null</span>, <span class="number">2</span>)], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = <span class="keyword">new</span> <span class="title class_">File</span>([blob], <span class="string">&#x27;1.json&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, file);</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:7787/files&#x27;</span>, formData)</span><br></pre></td></tr></table></figure><h2 id="POST-提交数据方案">POST 提交数据方案<a class="anchor" href="#POST-提交数据方案">·</a></h2><h3 id="1-1-关于HTTP协议的规定">1.1 关于HTTP协议的规定<a class="anchor" href="#1-1-关于HTTP协议的规定">·</a></h3><ul><li><p>HTTP 协议是以 <strong>ASCII 码</strong>传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：<strong>状态行、请求头、消息主体</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;  // 消息主体</span><br></pre></td></tr></table></figure></li><li><p>协议规定 POST 提交的数据必须放在消息主体中，但协议并没规定数据必须用什么编码方式：</p><ul><li>so，<strong>开发者可决定消息主体的格式</strong>，只要<strong>最后发送的 HTTP 请求满足上面的格式</strong>就可以。</li><li>但是，数据发送出去，还要服务端解析成功才有意义：<ul><li>服务端通常根据请求头（headers）中的 <strong>Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体解析</strong>。</li></ul></li></ul></li><li><p>所以说到 POST 提交数据方案，包含了 <strong>Content-Type</strong> 和<strong>消息主体编码方式</strong>两部分</p></li></ul><h3 id="1-2-application-x-www-form-urlencoded：-原生form">1.2 application/x-www-form-urlencoded： 原生form<a class="anchor" href="#1-2-application-x-www-form-urlencoded：-原生form">·</a></h3><ul><li><p>当action为post时，浏览器把form数据按照 <strong>key1=val1&amp;key2=val2 的方式编码</strong>，key 和 val 都进行了 URL 转码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;form_action.asp&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;text/plain&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lname&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Request Header中的</strong>关键信息：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded;charset=utf-8 title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</span><br></pre></td></tr></table></figure></li><li><p><strong>注意！！！！</strong></p><ul><li><p>此类型不适合用于传输<strong>大型二进制</strong>数据或包含<strong>非ASCII字符</strong>的数据，<strong>它不能用于文件的上传</strong>，<strong>文件流会被彻底忽略，它实际传输的是对应文件的名称</strong></p></li><li><p>平常使用这个类型都是把表单数据<strong>用url编码后传给后端</strong>，二进制文件没办法一起编码进去。所以<code>multipart/form-data</code>就诞生了</p></li></ul></li></ul><h3 id="1-3-multipart-form-data：-原生form">1.3 multipart/form-data：   原生form<a class="anchor" href="#1-3-multipart-form-data：-原生form">·</a></h3><ul><li><p>如果有<strong>type=file的话，就要用到multipart/form-data</strong>了</p></li><li><p>请求体：</p><p>浏览器把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或file)，Content-Type，name(控件name)，并加上分割符(boundary)：</p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/4c36074fly1fzixzg5fsdj20rv0dv75u.jpg" alt="encrypt为multipart/form-data时的请求报文" style="zoom: 80%;" /><ul><li><p><strong>Content-Type</strong> 字段：在请求头中，声明当前的内容类型为 <strong>multipart/form-data</strong>。并指定一个名为 boundary 的随机字符串：用来分隔参数，帮服务器正确识别文件起始位置</p></li><li><p><strong>Content-Disposition</strong>：每个字段都有的头部字段，其取值为 form-data，后追加若干个字段，譬如 name、filename 以及用以指定文件类型的 Content-Type(假如这个“字段”是一个文件的话)。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">------WebKitFormBoundary7YGEQ1Wf4VuKd0cE</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;file&quot;; filename=&quot;index.html&quot;</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br></pre></td></tr></table></figure></li><li><p>**filename：**如果是文件的话，除了内容形式、字段名还有文件类型、文件名</p></li></ul></li></ul><h3 id="1-4-JSON格式：-Ajax数据交互">1.4 JSON格式：      Ajax数据交互<a class="anchor" href="#1-4-JSON格式：-Ajax数据交互">·</a></h3><ul><li><p>参数contentType为: <code>application/json</code>，告诉服务端消息主体是序列化后的 JSON 字符串</p></li><li><p>特点：</p><ul><li><p>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。</p></li><li><p>各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，友好。</p></li></ul></li><li><p>在使用ajax传输json数据时，需要使用 JSON.stringify函数，将参数转化为json数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;PUT&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/student&quot;</span>,          </span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    <span class="attr">contentType</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">request</span>) &#123; <span class="title function_">alert</span>(<span class="string">&#x27;修改学生信息失败&#x27;</span>); &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>) &#123; <span class="title function_">alert</span>(<span class="string">&#x27;修改学生信息成功&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-text-xml-略">1.5 text/xml    略<a class="anchor" href="#1-5-text-xml-略">·</a></h3><p>它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。</p><ul><li><p>XML的特点：</p><p>必须要有一个根      标签名自定义     对大小写敏感   有开始就要有结束  同一级别下只能有一个标签名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;nation&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">n1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span>n001<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">n1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">n2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span>n002<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">n2</span>&gt;</span></span></span><br><span class="line">&lt;/nation&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表单提交 </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>script &amp; 懒加载 &amp; 预加载</title>
      <link href="/posts/2169143571.html"/>
      <url>/posts/2169143571.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言<a class="anchor" href="#前言">·</a></h2><ul><li><h4 id="这篇博文的契机与背景：">这篇博文的契机与背景：<a class="anchor" href="#这篇博文的契机与背景：">·</a></h4><ul><li>在博客迁移魔改时，整合外链时，发现一些没必要加载；</li><li>谷歌lighthouse跑分时，建议有些资源推迟加载，采用defer、async</li></ul></li><li><h4 id="内容安排：">内容安排：<a class="anchor" href="#内容安排：">·</a></h4><ul><li>首先介绍常见的css、JS文件引入方式；</li><li>针对这几种方式，现有优化措施的区别及适用场景</li></ul></li></ul><h2 id="资源引入">资源引入<a class="anchor" href="#资源引入">·</a></h2><h3 id="1-CSS的-Link-标签">1. CSS的<code>&lt;Link&gt;</code>标签<a class="anchor" href="#1-CSS的-Link-标签">·</a></h3><ul><li>标签作用：<code>&lt;link&gt;</code><strong>没有结束标签</strong>。<strong>rel属性</strong>用于定义当前文档与被链接文档之间的关系；</li></ul><h4 id="1-1-dns-prefetch">1.1 dns-prefetch<a class="anchor" href="#1-1-dns-prefetch">·</a></h4><ul><li><p>一种 DNS 预解析技术：当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的链接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> <span class="comment">&lt;!-- off为关闭,ON为开启 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-Prefetch">1.2 Prefetch<a class="anchor" href="#1-2-Prefetch">·</a></h4><ul><li><p>一种浏览器机制，利用浏览器空闲时间来下载后续可能需要使用的资源。</p></li><li><p><strong><code>在浏览器完成当前页面的加载后，开始偷偷地拉取指定的文档并将其存储在缓存中。</code></strong></p></li><li><p>但具体什么时候请求这个资源由浏览器决定。</p></li><li><p>页面跳转时prefetch发起的请求不会中断。该方法的加载优先级很低，一般用来提高下一个页面的加载速度。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;XXX&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试用例：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;coffee.jpg&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;coffee.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Chrome Network面板分析：</p><p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/73b07ee0d57a4d4e9b3268d01fdc25b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><ul><li><strong>可看到<code>link prefetch</code>出现了coffee.jpg的加载请求。后续通过<code>img src</code>再次请求coffee.jpg时，直接就通过<code>prefetch cache</code>获取了</strong>。so，验证了浏览器在空闲时间预先加载资源，真正使用时直接从浏览器缓存中快速获取。</li></ul></li></ul><h4 id="1-3-Preload">1.3 Preload<a class="anchor" href="#1-3-Preload">·</a></h4><ul><li><p>目的：一项新的web标准，旨在提高性能和为开发人员提供更细粒度的加载控制，可以让开发者自定义资源的加载逻辑，且无需忍受基于脚本的资源加载器带来的性能损失</p></li><li><p>说人话：希望浏览器尽早的请求资源，且不阻塞正常的onload</p></li><li><p>preload是声明式的fetch，可以强制浏览器请求资源，同时<strong>不阻塞文档onload事件</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">as</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试用例：</p><p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/03c62177ff59429685f62d696e6123c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><p>Chrome Network面板分析：</p><p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/d9e7dd7b75474fd09526af1487ba5671~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><ul><li><strong>可以发现脚本的加载时机提前了，在浏览器开始解析html后很快就进行了加载。</strong></li></ul></li><li><p>注意：<strong>preload</strong> link必须设置<strong>as属性</strong>来声明资源的类型（font/image/style/script等)，否则浏览器可能无法正确加载资源。<code>对于字体文件或者可以加载的跨域资源需要加上crossorigin属性。</code></p></li></ul><h5 id="as属性：">as属性：<a class="anchor" href="#as属性：">·</a></h5><ul><li><p>常用的as属性值有：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script, style, image, media, document, font</span><br></pre></td></tr></table></figure></li><li><p>目的：告诉浏览器加载的是什么资源。通过设置<code>as</code>属性可实现：</p><ul><li>浏览器可设置正确的资源加载优先级</li><li>浏览器可以确保请求是符合<strong>内容安全策略</strong>的</li><li>浏览器根据<code>as</code>的值发送正确的accept头部信息</li><li>浏览器根据<code>as</code>的值得知资源类型。因此当获取的资源相同时，浏览器能够判断前面获取的资源能否重用。</li></ul><p><strong>忽略<code>as</code>或者设置错误的值</strong>会使preload等同于XHR异步请求。但浏览器不知道加载的是什么，会赋予此类资源非常低的加载优先级。</p></li></ul><h4 id="1-4-总结">1.4 总结<a class="anchor" href="#1-4-总结">·</a></h4><ul><li>对当前页面有必要的资源使用<code>preload</code></li><li>对可能在将来的页面中使用的资源使用<code>prefetch</code></li><li><code>preload</code>和<code>prefetch</code>请求的资源都缓存在HTTP缓存中</li></ul><h3 id="2-JS的-script-标签">2. JS的 <code>&lt;script&gt;</code> 标签<a class="anchor" href="#2-JS的-script-标签">·</a></h3><ul><li>标签的作用：通过直接在页面嵌入 JS 代码或者通过加载外部脚本文件，这里只讨论加载脚本；</li><li>但另一方面，由于前端工程化的建设（脚手架和打包工具的普及），我们可能很少再亲手去写这种引入了方式</li><li>工作特点：<ul><li>script 标签可以放置在 html 任意位置，head、body，甚至是 div 里；</li><li>无论是内联还是外置——的执行顺序基本上（async 和 defer 除外）秉承由上至下串行执行的原则</li><li>so，浏览器首次解析文档时遇到<code>script</code>，会依次等代码下载、执行完以后才会继续解析。</li><li>这期间，经历网络传输、解析和执行，有时候会导致<strong>浏览器白屏</strong>。所以谈到首屏渲染的时候，我们往往会建议将 <strong>script 标签放到 <code>&lt;body&gt;</code> 元素的最后面——先呈现页面再执行 JS。</strong></li></ul></li><li>so，在<code>HTML规范</code>中为解决引入顺序问题，在<code>script</code>标签上提供了**<code>async</code>和<code>defer</code>**这两个属性，使得文档解析到<code>script</code>时不会发生阻塞。</li></ul><h3 id="3-音视频的加载播放处理">3. 音视频的加载播放处理<a class="anchor" href="#3-音视频的加载播放处理">·</a></h3><ul><li>由于业务需求的原因，会遇到音视频的播放加载prefetch问题；</li><li>由于会有一些专业知识，这个放在下一期调研~</li></ul><h2 id="资源加载">资源加载<a class="anchor" href="#资源加载">·</a></h2><h3 id="1-1-defer-延迟加载">1.1 defer 延迟加载<a class="anchor" href="#1-1-defer-延迟加载">·</a></h3><ul><li><p>加入defer属性后，脚本会延迟到整个DOM解析完后在去执行，即使把<code>&lt;script&gt;</code>标签放入<code>&lt;head&gt;</code>也不会阻塞后面DOM的解析</p></li><li><p>该属性会告诉<code>浏览器立即下载脚本，但是延迟执行脚本</code>。</p></li><li><p>先看测试用例：<img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/f76fcdfeb2db42ed92677f6c7eb55758~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><ul><li>Chrome加载面板分析：<img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/0b6237d947f142f59a2593d6a37ed11c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></li></ul></li><li><p>可以看到：</p><p><strong>1、主进程的<code>Parse HTML</code>并不会受<code>&lt;script&gt;</code>标签影响，网络进程还是会立即去加载脚本资源。2、多个设置了<code>defer属性</code>的script标签，会按照script放置顺序执行内容（<code>即使前置的script加载耗时更长</code>）。3、脚本内容会在HTML解析完毕后，<code>DOMContentLoaded</code>事件调用前执行。</strong></p></li><li><p>最终打印测试验证：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc02b8edf20f44a3a5179c16f9188058~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image.png"></p></li></ul><h3 id="1-2-async-异步加载">1.2 async 异步加载<a class="anchor" href="#1-2-async-异步加载">·</a></h3><ul><li><p>async属性会告诉浏览器立即下载脚本，哪个脚本先加载完就先执行，而且是加载完就立马执行。</p></li><li><p>如果有DOM正在解析，会阻塞解析。</p></li><li><p>测试用例：<img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/aa00cb4640c1449db0b7fa7190340dbf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><ul><li>Chrome加载面板分析：<img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/02e185c88ee444fbacd73012fd0bb9ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></li></ul></li><li><p><strong>总结</strong>：</p><p><strong>1、DOMContentLoaded事件的触发并不受<code>async</code>脚本加载的影响，<code>async</code>脚本会在load事件调用前执行。</strong></p><p><strong>2、这里文档解析太快没体现出来，其实<code>DOMContentLoaded</code>事件调用跟<code>async</code>脚本执行顺序是不定的。</strong></p></li><li><p>打印测试验证：</p><p><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/img/9af05ad7151a439aa1508c4d5ab7366f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p></li></ul><h3 id="1-3-懒加载">1.3 懒加载<a class="anchor" href="#1-3-懒加载">·</a></h3><ul><li>目的：延迟加载，指的是在长网页中延迟加载图像，一种优化网页性能的手段；<ul><li><strong>能提升用户的体验</strong>，不妨设想下，用户打开像手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。</li><li><strong>减少无效资源的加载</strong>，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。</li><li><strong>防止并发加载的资源过多会阻塞js的加载</strong>，影响网站的正常使用。</li></ul></li><li>效果：<ul><li>用户滚动到它们之前，可视区域外的图像不会加载</li><li>这与图像预加载相反，在长网页上用懒加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载</li></ul></li><li>适用场景：图片很多，页面很长的电商网站场景中</li></ul><h4 id="原理">原理<a class="anchor" href="#原理">·</a></h4><ul><li><p>首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则存在data-original属性中；</p></li><li><p>监听页面滚动事件scroll，回调中判断（我们预期想懒加载的图片）是否进入可视区域。如果是，将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.image-item</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;//一定记得设置图片高度</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/1.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/2.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/3.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/4.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/5.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/6.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/7.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/8.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-item&quot;</span> <span class="attr">lazyload</span>=<span class="string">&quot;true&quot;</span>  <span class="attr">data-original</span>=<span class="string">&quot;images/9.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> viewHeight =<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span><span class="comment">//获取可视区高度</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> eles=<span class="variable language_">document</span>.<span class="property">querySelectorAll</span>（<span class="string">&#x27;img[data-original][lazyload]&#x27;</span>）</span></span><br><span class="line"><span class="language-javascript">  [].<span class="property">forEach</span>.<span class="title function_">call</span>(eles,<span class="keyword">function</span>(<span class="params">item,index</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> rect</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(item.<span class="property">dataset</span>.<span class="property">original</span>===<span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">    rect=item.<span class="title function_">getBoundingClientRect</span>()<span class="comment">// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(rect.<span class="property">bottom</span>&gt;=<span class="number">0</span> &amp;&amp; rect.<span class="property">top</span> &lt; viewHeight)&#123;</span></span><br><span class="line"><span class="language-javascript">      !<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> img=<span class="keyword">new</span> <span class="title class_">Image</span>()</span></span><br><span class="line"><span class="language-javascript">        img.<span class="property">src</span>=item.<span class="property">dataset</span>.<span class="property">original</span></span></span><br><span class="line"><span class="language-javascript">        img.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          item.<span class="property">src</span>=img.<span class="property">src</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        item.<span class="property">removeAttribute</span>（<span class="string">&quot;data-original&quot;</span>）<span class="comment">//移除属性，下次不再遍历</span></span></span><br><span class="line"><span class="language-javascript">        item.<span class="property">removeAttribute</span>（<span class="string">&quot;lazyload&quot;</span>）</span></span><br><span class="line"><span class="language-javascript">      &#125;()</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">lazyload</span>()<span class="comment">//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">addEventListener</span>（<span class="string">&quot;scroll&quot;</span>，lazyload)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-预加载">1.4 预加载<a class="anchor" href="#1-4-预加载">·</a></h3><ul><li><p>性能优化技术：预先告知浏览器某些资源可能在将来会被使用到。<strong>预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源</strong>。</p></li><li><p><strong>为啥要用</strong>：在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。</p></li><li><p><strong>懒加载与预加载两者主要区别</strong>：</p><p><strong>一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力</strong>。</p></li></ul><h4 id="预加载的实现方法：">预加载的实现方法：<a class="anchor" href="#预加载的实现方法：">·</a></h4><ul><li><p>使用img标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用Image对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./myPreload.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//myPreload.js文件</span></span><br><span class="line"><span class="keyword">var</span> image= <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">image.<span class="property">src</span>=<span class="string">&quot;XXX.jpg&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用XMLHttpRequest对象,虽然存在跨域问题，但会精细控制预加载过程</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttprequest=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xmlhttprequest.<span class="property">onreadystatechange</span>=callback;</span><br><span class="line">xmlhttprequest.<span class="property">onprogress</span>=progressCallback;</span><br><span class="line">xmlhttprequest.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http:/xxxx.jpg&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttprequest.<span class="title function_">send</span>();</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlhttprequest.<span class="property">readyState</span>==<span class="number">4</span> &amp;&amp; xmlhttprequest.<span class="property">status</span>==<span class="number">200</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> responseText=xmlhttprequest.<span class="property">responseText</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Request was unsuccessful:&quot;</span>+xmlhttprequest.<span class="property">status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">progressCallback</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    e=e || event;</span><br><span class="line">    <span class="keyword">if</span>(e.<span class="property">lengthComputable</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Received&quot;</span>+e.<span class="property">loaded</span>+<span class="string">&quot;of&quot;</span>+e.<span class="property">total</span>+<span class="string">&quot;bytes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fcreatejs.com%2Fpreloadjs">PreloadJS库</a></p><p>提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。</p><p>预加载可以使用HTML标签以及XHR来完成。</p><p>默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用preload.js</span></span><br><span class="line"><span class="keyword">var</span> queue=<span class="keyword">new</span> createjs.<span class="title class_">LoadQueue</span>();</span><br><span class="line"><span class="comment">//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域</span></span><br><span class="line">queue.<span class="title function_">on</span>(<span class="string">&quot;complete&quot;</span>,handleComplete,<span class="variable language_">this</span>);</span><br><span class="line">queue.<span class="title function_">loadManifest</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&quot;myImage&quot;</span>,<span class="attr">src</span>:<span class="string">&quot;http://xxx1.jpg&quot;</span>&#125;,</span><br><span class="line">  &#123;id：<span class="string">&quot;myImage2&quot;</span>，<span class="attr">src</span>:<span class="string">&quot;http://xxxxx2.jpg&quot;</span>&#125;</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleComplete</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> image=queue.<span class="title function_">getResuLt</span>(<span class="string">&quot;myImage&quot;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3.2-浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async </tag>
            
            <tag> defer </tag>
            
            <tag> 懒加载 </tag>
            
            <tag> 预加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来pick眼花缭乱的图片格式</title>
      <link href="/posts/3906205819.html"/>
      <url>/posts/3906205819.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、前言碎碎">1、前言碎碎<a class="anchor" href="#1、前言碎碎">·</a></h2><h3 id="1-1-契机：">1.1 契机：<a class="anchor" href="#1-1-契机：">·</a></h3><ol><li><p>需求的设计稿提供了好多类型图片，瞎选择</p></li><li><p>博客网站，lightHouse跑分提示图片优化问题</p></li><li><p>Jsd优化图片加载问题时，我需要提前存储图片。保存成什么格式呢？我犯了难</p><p>基于此，我决定调研下图片都有哪些格式，以及适用什么场景</p></li></ol><h4 id="1-2-内容概要">1.2 内容概要<a class="anchor" href="#1-2-内容概要">·</a></h4><ul><li>图片的基本常识</li><li>了解常见图片格式的优缺点、使用场景</li><li>下期关注点：新型牛逼哄哄的<strong>AVIF、WebGL、WebAssembly 、canvas</strong></li></ul><h2 id="2、基本常识">2、基本常识<a class="anchor" href="#2、基本常识">·</a></h2><h3 id="2-1-彩色深度标准">2.1 彩色深度标准<a class="anchor" href="#2-1-彩色深度标准">·</a></h3><ul><li>8位，每个像素能显示的色数为2的8次方，即256种颜色。</li><li>16位增强色</li><li>24位<a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E7%9C%9F%E5%BD%A9%E8%89%B2">真彩色</a>，即2的24次方，约1680万种颜色。</li><li>32位真彩色<ul><li>在24位真彩色图像的基础上再增加一个表示图像透明度信息的Alpha通道</li><li><strong>也就是它增加了256阶颜色的灰度,为方便称呼，就规定它为32位色</strong></li></ul></li></ul><h3 id="2-2-图的分类">2.2 图的分类<a class="anchor" href="#2-2-图的分类">·</a></h3><h4 id="光栅图和矢量图">光栅图和矢量图<a class="anchor" href="#光栅图和矢量图">·</a></h4><p>对于图片，一般分光栅图和矢量图。</p><ul><li>**光栅图：**由二维的像素网格组成，每个像素存储了颜色和透明度的值<ul><li>缺点：不能很好的支持缩放，放大图片的锐度和清晰度会下降</li><li>主流：JPEG(jpg)、PNG、webp、GIF</li></ul></li><li>**矢量图：**由一些线条、形状和路径点组成，图的各种信息并不是保存在像素点中，而是保存在精确的绘图代码中，而这些指令完全独立于像素。如SVG<ul><li>优点：矢量图放大聚焦后，呈现效果仍然清晰，尤其适合 Retina 屏；</li></ul></li></ul><h4 id="无压缩、-无损压、有损压">无压缩、 无损压、有损压<a class="anchor" href="#无压缩、-无损压、有损压">·</a></h4><ul><li>**无压缩：**不对图片数据压缩处理，能准确地呈现原图片。如BMP</li><li>**无损压缩：**能在保证图片质量的同时降低图片的尺寸，如png、 GIF</li><li>**有损压缩：**会丢失掉部分数据，导致解压缩时不能100%还原成压缩前的样子，始终有部分原有像素、声音片段或视频帧永久丢失。<ul><li>需要在更小的文件体积和文件质量之间做一个合理的取舍，如jpg</li></ul></li></ul><h2 id="3、图片格式">3、图片格式<a class="anchor" href="#3、图片格式">·</a></h2><p>各种图片诞生时间轴：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF ---&gt; Base64---&gt;JPEG---&gt; PNG---&gt;SVG---&gt;JPEG2000  --&gt; WebP </span><br></pre></td></tr></table></figure><h3 id="1、GIF">1、GIF<a class="anchor" href="#1、GIF">·</a></h3><ul><li>**特点：**全称Graphics Interchange Format，每帧图最多支持256种颜色的8位无损图片格式。因此对颜色丰富图片（摄影）支持不好，也因此文件体积通常都很小</li></ul><h4 id="优点：">优点：<a class="anchor" href="#优点：">·</a></h4><ul><li>支持动画，这让 GIF 非常适合去展示一些无限循环的动画，比如图标、表情、广告栏等。</li><li>体积小、支持透明</li><li><strong>适合简单色彩的图片，但不适用照片</strong></li><li>支持部分接收到的文件可以以较低的质量显示。这在网络连接缓慢时特别有用。</li></ul><h4 id="缺点：">缺点：<a class="anchor" href="#缺点：">·</a></h4><ul><li>最多支持 8 位 256 色，色阶过渡糟糕，图片具有颗粒感</li><li>支持透明，但不支持半透明，边缘有杂边</li></ul><h3 id="2-、JPEG">2 、JPEG<a class="anchor" href="#2-、JPEG">·</a></h3><h4 id="2-1-特点">2.1.特点<a class="anchor" href="#2-1-特点">·</a></h4><ul><li><p>有损图片，几乎有3%的互联网资源文件是 JPEG 格式的图片，受欢迎：</p></li><li><p>有较好的色彩表现，但压缩时有所失真，因此图片格式体积的轻量</p></li></ul><h4 id="2-2-优点">2.2 优点<a class="anchor" href="#2-2-优点">·</a></h4><ul><li>**压缩率高：**JPEG 图片提供多种级别的压缩选择：网上图片用60%较合适，大于75%的压缩等级会使图片质量明显下降。</li><li>**兼容性好：**所有可上网设备都支持显示 JPEG 图，所以开发者不用担心兼容性问题</li><li>**色彩丰富：**展示摄影作品的最佳选择</li></ul><h4 id="2-3-缺点">2.3 缺点<a class="anchor" href="#2-3-缺点">·</a></h4><ul><li>JPEG不适合用来存储企业Logo、线框类的这种<strong>高清图</strong></li><li>背景透明：页面上用透明的效果来美化背景，JPEG 图片不是一个明智的选择</li><li>不支持动画</li></ul><h4 id="2-4-jpg和jpeg有啥区别">2.4 jpg和jpeg有啥区别<a class="anchor" href="#2-4-jpg和jpeg有啥区别">·</a></h4><h3 id="3、PNG">3、PNG<a class="anchor" href="#3、PNG">·</a></h3><h4 id="3-1-特点">3.1 特点<a class="anchor" href="#3-1-特点">·</a></h4><ul><li>与 GIF 相同，采用了一种无损的压缩算法</li><li>有三种版本：PNG-8，PNG-24，PNG-32，都不支持动画</li><li>PNG-8跟GIF属性相似，都是索引色模式，且都支持背景透明，颜色表现更优秀。如没动画需求，推荐<strong>用png-8替代gif</strong></li><li>PNG-24其实就是无损压缩的JPEG，透明度支持使用RGB</li><li>PNG-32就是在PNG-24的基础上，增加了透明度的支持。PNG图片的每个像素提供了高达256层级的透明度。<ul><li>具有多层级透明度的网络图片</li><li>支持复杂的照片和图形</li><li>经常要导出的图片：PNG的无损压缩保障了压缩后没有质量退化</li></ul></li></ul><h4 id="3-2-优点">3.2 优点<a class="anchor" href="#3-2-优点">·</a></h4><ul><li>不失真的情况下尽可能压缩图像文件的大小</li><li>像素丰富</li><li>支持透明（alpha通道）</li></ul><h4 id="3-3-缺点">3.3 缺点<a class="anchor" href="#3-3-缺点">·</a></h4><ul><li>所有版本都不支持动画</li><li>文件大</li><li>gif和jpg有渐进，png有交错，都是在没有完全下载图片时，能看到图片全貌。在线demo体验：https://xiangwenhu.github.io/TakeItEasy/bgWhithe/progress.html</li></ul><h3 id="4、SVG">4、SVG<a class="anchor" href="#4、SVG">·</a></h3><h4 id="4-1-特点">4.1 特点<a class="anchor" href="#4-1-特点">·</a></h4><ul><li>一种基于XML的矢量文件类型；</li><li>在 2001 年就已出现，但由于浏览器的支持不太友好，近年才流行起来</li><li>它将图像的内容指定为一组绘图命令，这些命令创建形状、线条、应用颜色、过滤器等等，可以准确地绘制在任何大小。</li><li>是现代 Web 设计中用户界面元素的流行选择，对于网站，特别适合展示一些小图片logo、地图、图标等。</li></ul><h4 id="4-2-优点">4.2 优点<a class="anchor" href="#4-2-优点">·</a></h4><ul><li>**可伸缩性：**随意缩放，在各种分辨率的屏幕上展示清晰，不牺牲质量；</li><li><strong>体积小：</strong> 平均比 GIF、 JPEG、 PNG （光栅格式）小得多，甚至在极高的分辨率下也是如此。尤其当图片被优化，并启用 gzip 压缩</li><li>**可优化减少http请求：**把 SVG 的代码丢到 HTML 中以减少请求数量</li><li><strong>与DOM无缝衔接：</strong><ul><li>可直接用 HTML、 CSS 和 JS (例如动画)来操作</li><li>可用 JS或者 CSS 让 SVG 变成动画</li></ul></li></ul><h4 id="4-3-缺点">4.3 缺点<a class="anchor" href="#4-3-缺点">·</a></h4><ul><li>当SVG复杂时：<ul><li>这会导致文件的体积变大很多</li><li>渲染速度减慢，不适合游戏类等高互动动画</li></ul></li><li>对于类似于摄影作品之类的图片，SVG并不是一个好的选择</li></ul><h3 id="5、WebP">5、WebP<a class="anchor" href="#5、WebP">·</a></h3><h4 id="5-1-特点">5.1 特点<a class="anchor" href="#5-1-特点">·</a></h4><ul><li>由 Google 开发的一种开源图片格式，专门为网站而诞生，性能出色的压缩水平，它以更小的体积糅合了 JPEG 和 PNG 的优点<ul><li>WebP 无损压缩比 PNG 的体积小 26%，支持透明度，但却只有 22% 的字节增加</li><li>webP 有损压缩比同质量的 JPEG 格式体积小 25-34%。</li></ul></li><li>WebP 还支持动画: 在有损的 WebP 文件中，图像数据由 VP8位流表示，该位流可能包含多个帧。</li><li>谷歌亲儿子，浏览器支持不错，兼容解决方案多。</li></ul><h4 id="5-2-优点">5.2 优点<a class="anchor" href="#5-2-优点">·</a></h4><ul><li>同等质量更小</li><li>压缩之后质量无明显变化</li><li>支持无损图像</li><li>支持动画</li></ul><h4 id="5-3-缺点">5.3 缺点<a class="anchor" href="#5-3-缺点">·</a></h4><ul><li>相对jpg，png，gif来说，兼容性稍弱</li></ul><h3 id="6、Base64">6、Base64<a class="anchor" href="#6、Base64">·</a></h3><h4 id="6-1-特点">6.1 特点<a class="anchor" href="#6-1-特点">·</a></h4><ul><li>base64 编码是将一副图片数据编码成一串字符串，使用该字符串代替图像地址</li><li>图片随着 HTML 的下载同时下载到本地，不再单独消耗一个http来请求图片。</li></ul><h4 id="6-2-优点">6.2 优点<a class="anchor" href="#6-2-优点">·</a></h4><ul><li>无额外请求：适合极小或者极简单图片</li><li>可像单独图片一样使用，比如背景图片重复使用等</li><li>没有跨域问题，无需考虑缓存、文件头或者cookies问题</li></ul><h4 id="6-3-缺点">6.3 缺点<a class="anchor" href="#6-3-缺点">·</a></h4><ul><li>相比其他格式，体积会至少大1/3</li><li>编码解码有额外消耗</li></ul><h3 id="7、AVIF">7、AVIF<a class="anchor" href="#7、AVIF">·</a></h3><p>备注：关于新型的画面渲染技术，由于内容太多，调研后，单独再写一节</p><ul><li><p>起源点：</p><ul><li>源于我在lightHouse跑分时，谷歌建议中有提高使用AVIF、webp来减少图片体积问题；于是产生了好奇心</li><li>做图床时，mac chrome中保存一图片，直接回车不指定格式，存下来的也是该格式</li></ul></li><li><p>关于介绍文档：</p><ol><li>官方Netflix：https://netflixtechblog.com/avif-for-next-generation-image-coding-b1d75675fe4?gi=158ccdded63d</li></ol><ul><li>官方还提供了很多其他对比图，还有对比图标和数据</li><li>总之，AVIF图片格式压缩很棒，件大小比JPEG小10倍，具有相同的图像质量</li></ul><ol start="2"><li><p>转该格式的工具：https://avif.io/</p></li><li><p>avif polyfill项目：https://github.com/Kagami/avif.js</p></li></ol></li><li><p>AVIF一点也不Naive：</p><ul><li><p>基于AV1的新图像格式，是符合HEIF标准的格式，使用HEIF作为容器（和Apple的HEVC一样）和AV1帧，压缩质量非常好；</p></li><li><p>另外，AVIF不仅支持标准动态范围（SDR）图像，还支持高动态范围（HDR）和宽色域（WCG）。它可以存储单个图像和图像序列。</p></li></ul></li><li><p>优点：</p><ul><li>AVIF由开源组织AOMedia开发，Netflix、Google与Apple均是该组织的成员。因此是一统天下的图片格式。</li><li>压缩很强，但质量仍然很好！</li></ul></li></ul><h3 id="8、-小结一下">8、 小结一下<a class="anchor" href="#8、-小结一下">·</a></h3><table><thead><tr><th>格式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>gif</td><td>文件小，支持动画、透明，无兼容性问题</td><td>只支持256种颜色</td><td>色彩简单的logo、icon、动图</td></tr><tr><td>jpg</td><td>色彩丰富，文件小</td><td>有损压缩，反复保存图片质量下降明显</td><td>色彩丰富的图片/渐变图像</td></tr><tr><td>png</td><td>无损压缩，支持透明，简单图片尺寸小</td><td>不支持动画，色彩丰富的图片尺寸大</td><td>logo/icon/透明图</td></tr><tr><td>webp</td><td>文件小，支持有损和无损压缩，支持动画、透明</td><td>浏览器兼容性相对而言不好</td><td>支持webp格式的app和webview</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeReview之CSS规范</title>
      <link href="/posts/867212230.html"/>
      <url>/posts/867212230.html</url>
      
        <content type="html"><![CDATA[<h2 id="codeReview之css书写顺序">codeReview之css书写顺序<a class="anchor" href="#codeReview之css书写顺序">·</a></h2><h3 id="1、为啥要讲究css书写顺序">1、为啥要讲究css书写顺序<a class="anchor" href="#1、为啥要讲究css书写顺序">·</a></h3><ul><li><p>减少浏览器reflow（回流），提升浏览器渲染dom的性能；</p></li><li><p>css样式解析到显示至浏览器屏幕上，发生的阶段：</p><ul><li><p><code>①:</code>解析html构建dom树，解析css构建css树：将html解析成树形的数据结构，将css解析成树形的数据结构</p></li><li><p><code>②:</code>构建render树：DOM树和CSS树合并之后形成的render树。</p></li><li><p><code>③:</code>布局render树：有了render树，浏览器已经知道那些网页中有哪些节点，各个节点的css定义和以及它们的从属关系，从而计算出每个节点在屏幕中的位置。</p></li><li><p><code>④:</code>绘制render树：按照计算出来的规则，通过显卡把内容画在屏幕上。</p></li></ul></li><li><p>总结一下：浏览器并不是一拿到css样式就立马开始解析，而是：</p><p>拿到css样式的书写顺序 ----&gt; 构建render tree ②  ——&gt;然后，才开始遍历树形结构的节点进行解析，而此时的遍历顺序是由之前的书写顺序决定的，所以这个书写顺序才要讲究起来</p></li></ul><h3 id="2、具体怎么讲究的呢？-优先级">2、具体怎么讲究的呢？-优先级<a class="anchor" href="#2、具体怎么讲究的呢？-优先级">·</a></h3><h4 id="1、定位属性：">1、定位属性：<a class="anchor" href="#1、定位属性：">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">     <span class="attribute">display</span>         规定元素应该生成的框的类型。</span><br><span class="line">     <span class="attribute">position</span>        定位规定元素的定位类型。</span><br><span class="line">     <span class="attribute">float</span>           规定框是否应该浮动。</span><br><span class="line">     <span class="attribute">left</span>  <span class="attribute">top</span>  <span class="attribute">right</span>  <span class="attribute">bottom</span>   </span><br><span class="line">     <span class="attribute">overflow</span>        规定当内容溢出元素框时发生的事情。</span><br><span class="line">     <span class="attribute">clear</span>           清除</span><br><span class="line">     <span class="attribute">z-index</span>         设置元素的堆叠顺序。</span><br><span class="line">     <span class="attribute">content</span>         内容</span><br><span class="line">         <span class="attribute">list-style</span>  </span><br><span class="line">         <span class="attribute">visibility</span>  可见性/显示</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="2、自身属性：">2、自身属性：<a class="anchor" href="#2、自身属性：">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attribute">width</span>、<span class="attribute">height</span>、<span class="attribute">border</span>、<span class="attribute">padding</span>、<span class="attribute">margin</span>、 、 <span class="attribute">background</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="3、文字样式：">3、文字样式：<a class="anchor" href="#3、文字样式：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  font-family  、 font-size   、font-style     规定文本的字体样式。</span><br><span class="line">   font-weight  、font-varient   规定是否以小型大写字母的字体显示文本</span><br><span class="line">   color   </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><h4 id="4、文本属性：">4、文本属性：<a class="anchor" href="#4、文本属性：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        text-align、 vertical-align、  </span><br><span class="line">        text-wrap          规定文本的换行规则。</span><br><span class="line">        text-transform     控制文本的大小写。</span><br><span class="line">        text-indent 、text-decoration 、letter-spacing 、word-spacing </span><br><span class="line">        white-space        规定如何处理元素中的空白。</span><br><span class="line">        text-overflow      规定当文本溢出包含元素时发生的事情。</span><br><span class="line">   &#125;   </span><br></pre></td></tr></table></figure><h4 id="5、C3新增属性：">5、C3新增属性：<a class="anchor" href="#5、C3新增属性：">·</a></h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">box</span>-shadow、 cursor、 <span class="built_in">border</span>-<span class="built_in">radius</span>、<span class="built_in">background</span>:<span class="built_in">linear</span>-gradient、   </span><br><span class="line">    <span class="built_in">transform</span>……       向元素应用 2D 或 3D 转换。     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3、CSS命名规范">3、CSS命名规范<a class="anchor" href="#3、CSS命名规范">·</a></h3><ul><li>必须以字母开头命名选择器，这样可保证在所有浏览器下都能兼容；</li><li>不允许单个字母的类选择器出现；</li><li><strong>不允许命名带有广告等英文的单词</strong>，例如ad,adv,adver,advertising，已防止该模块被浏览器当成垃圾广告过滤掉。任何文件的命名均如此；</li><li>下划线 ’ _ ’ 禁止出现在class命名中，全小写,统一使用’-‘连字符；</li><li>禁止驼峰命名 className，一般中横线的比较常见；</li><li>见名知意</li></ul><h3 id="CSS注意事项">CSS注意事项<a class="anchor" href="#CSS注意事项">·</a></h3><ol><li>不要以无语义的标签作为选择器,这会造成大面积污染</li><li>简写CSS颜色属性值</li><li>删除CSS属性值为0的单位</li><li>删除无用CSS样式</li><li>为单个CSS选择器或新申明开启新行</li><li>避免过度简写 , .ico足够表示这是一个图标 , 而.i不代表任何意思</li><li>使用有意义的名称，使用结构化或者作用目标相关的，而不是抽象的名称</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> codeReview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改记录-3月</title>
      <link href="/posts/blogChange2.html"/>
      <url>/posts/blogChange2.html</url>
      
        <content type="html"><![CDATA[<h2 id="2022-3月魔改记录">2022-3月魔改记录<a class="anchor" href="#2022-3月魔改记录">·</a></h2><h3 id="1、填坑功能：">1、填坑功能：<a class="anchor" href="#1、填坑功能：">·</a></h3><h4 id="访问足迹页面：">访问足迹页面：<a class="anchor" href="#访问足迹页面：">·</a></h4><ul><li>背景色更换；</li><li>更新token，百度站点上过期了；</li></ul><h4 id="日历：">日历：<a class="anchor" href="#日历：">·</a></h4><ul><li>已实现放在时间轴页面</li><li>找到了插件魔改的方法啦，请看readme文件，回忆一下</li></ul><h4 id="分类页面：">分类页面：<a class="anchor" href="#分类页面：">·</a></h4><ul><li>已填坑，同上</li><li>希望扩展功能：新增子分类</li><li>就在刚刚发现<strong>新bug</strong>：<ul><li>从导航其他页面回来，分类就丢失了…</li></ul></li></ul><h3 id="2、优化功能：">2、优化功能：<a class="anchor" href="#2、优化功能：">·</a></h3><h4 id="JSD-PicGo加速图片：">JSD+PicGo加速图片：<a class="anchor" href="#JSD-PicGo加速图片：">·</a></h4><ul><li>本期改版了页面图片的风格，偏清新一点</li><li>图片以前是图片网站的链接，此次换成了Github图床、Jsd加速搭配使用的方式。也算是缓解了一下一直以来，<strong>图片存储的痛点</strong>。首屏太慢了，我很嫌弃。</li><li><strong>待研究：</strong><ul><li>前期几张照片，用的png形式，用webp、avrif形式更好。下次风格改版时，再做；</li><li>图片版本更新问题：</li></ul></li></ul><h4 id="站点收录：">站点收录：<a class="anchor" href="#站点收录：">·</a></h4><ul><li>谷歌、百度站点收录：提交sitemap文件</li><li>增加蜘蛛，配置爬虫的文件：robost.txt</li><li><strong>新坑：</strong><ul><li>为啥站点地图提交成功，但谷歌显示未收录…</li><li>百度抓取失败…</li></ul></li></ul><h4 id="针对LighHouse跑分优化：">针对LighHouse跑分优化：<a class="anchor" href="#针对LighHouse跑分优化：">·</a></h4><ul><li>首先，表演一下，SEO表现很好</li><li>调整了没有用到的引入标签；</li><li>对于阻塞渲染的标签，不着急出现的，更改属性为defer或async</li><li>对于图片：换成了Jsd加速。</li></ul><h3 id="3、本期新增：">3、本期新增：<a class="anchor" href="#3、本期新增：">·</a></h3><h4 id="twikoo评论-美化：">twikoo评论+美化：<a class="anchor" href="#twikoo评论-美化：">·</a></h4><ul><li>通过vercel部署的，支持不用登录，即可评论啦。</li><li>但不支持插入图片，因为支持的图床没有picGo，sad。</li><li>待研究：<ul><li>后期在考虑vercel的免费部署</li></ul></li></ul><h4 id="音乐music页面：">音乐music页面：<a class="anchor" href="#音乐music页面：">·</a></h4><ul><li>新增加了喜欢的歌单页面，可以随便点</li><li>**待研究：**但页面太长了，所以有什么办法，这页像首页那样，只展示目录；</li><li>后续会改动，暂时内容待定；</li></ul><h4 id="视频movie页面：">视频movie页面：<a class="anchor" href="#视频movie页面：">·</a></h4><p>新增了一些觉得有意思的视频：</p><ul><li>借助外挂：tag-plugin-pro，我没有用原始的，这个外挂，因为可以自己参与魔改，更自由</li><li>**待研究：**同音频</li></ul><h4 id="books页面：">books页面：<a class="anchor" href="#books页面：">·</a></h4><ul><li>新增豆瓣外挂：但书和电影还没看完。。</li></ul><h4 id="字体：">字体：<a class="anchor" href="#字体：">·</a></h4><ul><li>新增了字体文件；</li><li>中文、英文不同：因为中文字体Candy英文不好看；</li><li>文章页面：字体不是Candy，考虑到正文看不舒服，所以这个字体是最简单的样式</li></ul><h4 id="其他：">其他：<a class="anchor" href="#其他：">·</a></h4><ul><li><p>砍掉了右侧aside的模块，如标签；</p></li><li><p>魔改了右侧aside中的时钟显示：<strong>但有问题:</strong></p><p>这个是通过ip查询地址对应的天气数据，当开vpn，某些地区获取的信息不对；所以显示的很奇怪；</p></li><li><p>下期魔改下加密文章，哈哈</p></li></ul><h3 id="4、遇到的问题：">4、遇到的问题：<a class="anchor" href="#4、遇到的问题：">·</a></h3><h4 id="压缩问题：-很头疼">压缩问题：  很头疼<a class="anchor" href="#压缩问题：-很头疼">·</a></h4><ul><li>**目的：**预期希望对编译后的文件：压缩CSS、JS、img。希望首屏更快</li><li>**做法：**用了一个gulp的js压缩文件，借助webpack插件压缩。在编译后生成public的文件 -----&gt; 压缩 ----&gt;deploy后。。这样很完美对吧。。<strong>部署后，就样式丢失了.sad</strong></li></ul><h4 id="部署后，样式丢失：">部署后，样式丢失：<a class="anchor" href="#部署后，样式丢失：">·</a></h4><ul><li><p>前提：由于之前手动配的workflow总是部署错误，so暂时取消了自己的workflow。直接hexo deploy后，由博客显示仓库对应的github pages走自己的workflow</p></li><li><p>问题：</p><ol><li>如果部署前，gulp了，线上一定gg；</li><li>如果部署前没有gulp，有gg的可能；</li></ol></li><li><h5 id="原来出现的类似状况：原因有以下几种：">原来出现的类似状况：原因有以下几种：<a class="anchor" href="#原来出现的类似状况：原因有以下几种：">·</a></h5><ul><li><h5 id="状况1：">状况1：<a class="anchor" href="#状况1：">·</a></h5><p>因为域名CAME的问题，需要每次收到更新rename；</p><p>解决：在source文件下，加CAME文件，填写你的域名喔~</p></li><li><h5 id="状况2：">状况2：<a class="anchor" href="#状况2：">·</a></h5><ul><li>gulp了部署失败。不gulp又好了，有时又失败；</li><li>有时明明部署好了，强刷新后也是好的&amp;刚更新的内容，过个2分钟，样式挂了~</li></ul></li><li><h5 id="状况3：">状况3：<a class="anchor" href="#状况3：">·</a></h5><p>原本在windows电脑上，我的主题更改文件直接去hexo-theme-butterfly下去做的，这样在打包部署上线时，会分析相关文件，然后最终生成静态资源，部署到仓库：myNightwish.github.io，这没问题。</p><p>问题分析：</p><ul><li>但当我用另一台Macpull下来代码，就会发现效果没有魔改文件生效的样子，为什么呢？</li><li>因为之前的魔改文件在nodeModelues文件里，部署时，这个文件是gitignore的，当然我们不能在ignore取消这个文件的上传，因为根本没有必要上传嘛~远端服务器会自己去npm库里安装的。</li><li>所以这个文件在我的private仓库：fererStorage里根本就没有魔改文件，so当我用另一台电脑拉下来的时候，<strong>当然不可能有原来的魔改效果呀</strong></li><li><strong>这样其实非常危险~</strong>：如果我windows电脑本地代码丢失，所有为魔改的折腾全部完蛋！！！</li></ul><p>问题解决：于是我痛下决心，将所有的魔改效果迁移了一下</p><ul><li>在根目录下新建butterfly，将相关文件夹迁移即可；</li><li>同时整理了之前的魔改文件，删除&amp;简化了部分代码；</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.1-记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo、cdn.jsdelivr、githubPages、Hexos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础-插件编写</title>
      <link href="/posts/684607466.html"/>
      <url>/posts/684607466.html</url>
      
        <content type="html"><![CDATA[<h3 id="Loader编写">Loader编写<a class="anchor" href="#Loader编写">·</a></h3><h4 id="1、初始化项目：">1、初始化项目：<a class="anchor" href="#1、初始化项目：">·</a></h4><ul><li><p>初始化：npm init -y</p><p>安装：npm i webpack@4.29.0 -d    npm i webpack-cli@3.2.1 -d</p></li><li><p>添加src目录下index.js文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello feier&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>添加配置文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改package.json:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br></pre></td></tr></table></figure><p>打包：打包生成产物：</p><ul><li>上面一坨是运行时需要的代码，而我们的代码被编译后，放在eval里。</li></ul></li></ul><h4 id="2、需求1：">2、需求1：<a class="anchor" href="#2、需求1：">·</a></h4><ul><li><h5 id="希望打包过程中，如果看到feier的字眼，就改成feizai。而loader就可以帮我们做到：">希望打包过程中，如果看到feier的字眼，就改成feizai。而loader就可以帮我们做到：<a class="anchor" href="#希望打包过程中，如果看到feier的字眼，就改成feizai。而loader就可以帮我们做到：">·</a></h5><ul><li>写loader：新建loaders文件夹：新建replaceLoaders文件：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loader就是一个函数：但不能写成箭头函数，因为要用this指向</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> source.<span class="title function_">replace</span>(<span class="string">&#x27;feier&#x27;</span>, <span class="string">&#x27;feizai&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用loader：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">            path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./loaders/replaceLoaders.js&#x27;</span>) <span class="comment">// 引入loader </span></span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>打包生成后，就变成了feizai</li></ul></li></ul><h4 id="3、loader传参1">3、loader传参1<a class="anchor" href="#3、loader传参1">·</a></h4><ul><li><p>配置文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">use</span>: [</span><br><span class="line">  <span class="comment">// path.resolve(__dirname, &#x27;./loaders/replaceLoaders.js&#x27;)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这里除了字符串，还可以配置一个对象</span></span><br><span class="line">    <span class="attr">loader</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./loaders/replaceLoaders.js&#x27;</span>),</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;myNightwish&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>loader插件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source</span>)&#123;</span><br><span class="line">    <span class="comment">// 拿到传递的loader：但是它不是通过参数接收的，而是this</span></span><br><span class="line">    <span class="comment">// this中的query有很多参数</span></span><br><span class="line">    <span class="keyword">return</span> source.<span class="title function_">replace</span>(<span class="string">&#x27;feier&#x27;</span>, <span class="variable language_">this</span>.<span class="property">query</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、loader传参2">4、loader传参2<a class="anchor" href="#4、loader传参2">·</a></h4><ul><li>官方文档：https://webpack.docschina.org/api/loaders/</li></ul><ul><li><p>Callback:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = source.<span class="title function_">replace</span>(<span class="string">&#x27;feier&#x27;</span>, <span class="variable language_">this</span>.<span class="property">query</span>.<span class="property">name</span>);</span><br><span class="line"><span class="comment">// 假如我处理source之后，还想把source-map带出去，可以通过回调函数的形式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">callback</span>(</span><br><span class="line">  <span class="attr">err</span>: <span class="title class_">Error</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">content</span>: string | <span class="title class_">Buffer</span>,</span><br><span class="line">  sourceMap?: <span class="title class_">SourceMap</span>,</span><br><span class="line">  meta?: any</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="plugin编写">plugin编写<a class="anchor" href="#plugin编写">·</a></h3><p>设计模式：发布订阅</p><h4 id="1、需求">1、需求<a class="anchor" href="#1、需求">·</a></h4><p>打包结束后，希望生成版权文件：</p><ul><li><p>初始化项目+安装+src</p></li><li><p>新建文件夹：plugins   新建文件：copyright-webpack-plugin</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件是一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyrightWebpackPlugin</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插件被使用了&#x27;</span>, options.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当调用插件时，会调用apply方法：该方法参数compiler，可理解为webpack的实例</span></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">compiler</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">CopyrightWebpackPlugin</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [ <span class="keyword">new</span> <span class="title class_">CopyrightWebpackPlugin</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;myNightwish&#x27;</span>&#125;)]</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、版权插件功能">2、版权插件功能<a class="anchor" href="#2、版权插件功能">·</a></h4><ul><li><p>这里简单举例了同步钩子、异步钩子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件是一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyrightWebpackPlugin</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插件被使用了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当调用插件时，会调用apply方法：该方法参数compiler，可理解为webpack的实例</span></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">compiler</span>)&#123;</span><br><span class="line">        <span class="comment">//1.  compiler是webpack实例，存储了各种打包相关的实例</span></span><br><span class="line">        <span class="comment">// 里面有hooks，生命周期钩子函数</span></span><br><span class="line">         <span class="comment">// emit：将打包之后的代码放入dist目录之前的操作  它是异步的</span></span><br><span class="line">      compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;CopyrightWebpackPlugin&#x27;</span>, <span class="function">(<span class="params">compilation, cb</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//2.  compilation存放的是与本次打包相关的内容</span></span><br><span class="line">             <span class="comment">// 本次打包生成的文件都生成在compilation.assets下面，so只需要在下卖弄加点东西就可</span></span><br><span class="line">            compilation.<span class="property">assets</span>[<span class="string">&#x27;CopyrightWebpackPlugin.txt&#x27;</span>] = &#123;</span><br><span class="line">                <span class="attr">source</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;copyRight by myNightwish&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">size</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;emit钩子执行了&#x27;</span>, compilation.<span class="property">assets</span>);</span><br><span class="line">            <span class="title function_">cb</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">      compiler.<span class="property">hooks</span>.<span class="property">compile</span>.<span class="title function_">tap</span>(<span class="string">&#x27;CopyrightWebpackPlugin&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;compiler&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、生命周期钩子">3、生命周期钩子<a class="anchor" href="#3、生命周期钩子">·</a></h4><ul><li><p>关于complation：https://webpack.docschina.org/api/compilation-hooks/</p><ul><li>compilation 对象包含了当前的模块资源、编译生成资源、文件的变化等。</li><li>当webpack在开发模式下运行时，每当检测到一个文件发生改变的时候，那么一次新的 Compilation将会被创建。从而生成一组新的编译资源。</li></ul></li><li><p>关于钩子类型的描述，请查看 <a href="https://github.com/webpack/tapable#tapable">Tapable 文档</a>.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">beforeCompile</span>.<span class="title function_">tap</span>(<span class="string">&quot;RemoveLogs&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The compiler before compile...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">compile</span>.<span class="title function_">tap</span>(<span class="string">&quot;RemoveLogs&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The compiler is starting compile...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">make</span>.<span class="title function_">tap</span>(<span class="string">&quot;RemoveLogs&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before done&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">&quot;RemoveLogs&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4、需求插件2：">4、需求插件2：<a class="anchor" href="#4、需求插件2：">·</a></h4><ul><li><p>功能：罗列出打包后的文件资源，并存储在readme.md文件中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RemoveLogs</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">filename</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个为什么这样写呢？？？？？</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&quot;FileListPlugin&quot;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// compilation 创建之后执行</span></span><br><span class="line">      compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tap</span>(<span class="string">&quot;FileListPlugin&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 输出 asset 到 output 目录之前执行</span></span><br><span class="line">        <span class="keyword">let</span> content = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;资源列表及其size：&quot;</span>);</span><br><span class="line">        <span class="comment">// compilation.assets 存放当前所有即将输出的资源</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">entries</span>(compilation.<span class="property">assets</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">[pathname, source]</span>) =&gt;</span> &#123;</span><br><span class="line">          content += <span class="string">`— <span class="subst">$&#123;pathname&#125;</span>: <span class="subst">$&#123;source.size()&#125;</span> bytes\r\n`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(content);</span><br><span class="line">        compilation.<span class="property">assets</span>[<span class="string">&quot;README.md&quot;</span>] = &#123;</span><br><span class="line">          <span class="title function_">source</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> content.<span class="property">length</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、需求插件3：">5、需求插件3：<a class="anchor" href="#5、需求插件3：">·</a></h4><ul><li><p>不太累计</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">class</span> <span class="title class_">RemoveLogs</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">filename</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">      compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;GetFileNamePlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        compilation.<span class="property">hooks</span>.<span class="property">chunkIds</span>.<span class="title function_">tap</span>(<span class="string">&#x27;GetFileNamePlugin&#x27;</span>, <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">filename</span> = <span class="title class_">Array</span>.<span class="title function_">from</span>(c)[<span class="number">0</span>].<span class="property">name</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    </span><br><span class="line">      compiler.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">&quot;RemoveLogs&quot;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; path, filename &#125; = compilation.<span class="property">options</span>.<span class="property">output</span>;</span><br><span class="line">        <span class="keyword">let</span> filePath = (path + <span class="string">&quot;/&quot;</span> + filename).<span class="title function_">replace</span>(<span class="regexp">/\\[name\\]/g</span>, <span class="variable language_">this</span>.<span class="property">filename</span>); </span><br><span class="line">        fs.<span class="title function_">readFile</span>(filePath, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> rgx = <span class="regexp">/console.log\\([&#x27;|&quot;](.*?)[&#x27;|&quot;]\\)/</span>;</span><br><span class="line">            <span class="keyword">const</span> newData = data.<span class="title function_">replace</span>(rgx, <span class="string">&quot;&quot;</span>);</span><br><span class="line">          </span><br><span class="line">            fs.<span class="title function_">writeFile</span>(filePath, newData, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(filePath, <span class="string">&quot;Logs Removed&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="bundler编写">bundler编写<a class="anchor" href="#bundler编写">·</a></h3><h4 id="1、初始化">1、初始化<a class="anchor" href="#1、初始化">·</a></h4><ul><li><p>src下新建index.js   message.js   word.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// word.js</span></span><br><span class="line"><span class="keyword">const</span> word = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;word&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;word&#125; <span class="keyword">from</span> <span class="string">&#x27;./word.js&#x27;</span></span><br><span class="line"><span class="comment">// 注意我们现在没用webpack so要写后缀 </span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`say <span class="subst">$&#123;word&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;message&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;message&#125; <span class="keyword">from</span> <span class="string">&#x27;./message.js&#x27;</span></span><br><span class="line"><span class="comment">// 这里涉及到几个模块下的相互调用：</span></span><br><span class="line"><span class="comment">// 此时浏览器根本不认识这种，此时需要一个类似webpack帮我们去实行项目的打包</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;index.js中的：&#x27;</span>, message);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、分析入口文件">2、分析入口文件<a class="anchor" href="#2、分析入口文件">·</a></h4><ul><li><p>新建bundler.js    模块分析文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包工具在这里写  它依赖于node  so记得提前安装喔</span></span><br><span class="line"><span class="comment">// 1. 定义一个函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">muduleAnalyser</span> = (<span class="params">filename</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.最开始对入口文件做分析</span></span><br><span class="line"><span class="title function_">muduleAnalyser</span>(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>实现1：读取入口文件，分析入口文件的代码</p><ul><li><p>ast.program.body：</p><p>第一个节点：ImportDeclaration  引入的声明    so它能帮我们找到声明的语句 我们可以根据对象找到依赖关系</p><p>第2个节点：ExpressionStatement  表达式语句</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">muduleAnalyser</span> = (<span class="params">filename</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 1.1 读取文件出来,content就是文件本身内容</span></span><br><span class="line">    <span class="keyword">const</span> content = fs.<span class="title function_">readFileSync</span>(filename, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;content&#x27;</span>, content)</span><br><span class="line">    <span class="comment">// 1.2 提取引入文件：message.js  字符串截取不灵活</span></span><br><span class="line">    <span class="comment">// 引入一个第三发模块：npm i @babel/parser -d  可以帮助我们分析源代码</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.<span class="title function_">parse</span>(content, &#123;</span><br><span class="line">        <span class="comment">// 如果入口文件时es6 的引入方式，需要传入sourceType为module</span></span><br><span class="line">        <span class="comment">// 此时打印出来的就是抽象语法树</span></span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ast.<span class="property">program</span>.<span class="property">body</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ImportDeclaration  自己写遍历麻烦，babel提供了npm i @babel/traverse --save</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.3 分析语法树,参数2 遍历时需要找到什么类型的元素</span></span><br><span class="line">    <span class="keyword">const</span> dependencies = []; <span class="comment">// 存遍历中遇到的依赖，但内部的value属性就可以得到引入的啥文件</span></span><br><span class="line">    <span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">        <span class="comment">// 要写成函数，这个节点的内容里包含node</span></span><br><span class="line">        <span class="title class_">ImportDeclaration</span>(&#123; node &#125;)&#123;</span><br><span class="line">            dependencies.<span class="title function_">push</span>(node.<span class="property">source</span>.<span class="property">value</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>但我们打包时，dependcies存入的不应该是相对路径：[ ‘./message.js’, ‘./word’ ]，而是绝对路径，怎么办</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 1.3 分析语法树,参数2 遍历时需要找到什么类型的元素</span></span><br><span class="line"><span class="keyword">const</span> dependencies = []; <span class="comment">// 存遍历中遇到的依赖，但内部的value属性就可以得到引入的啥文件</span></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="comment">// 要写成函数，这个节点的内容里包含node</span></span><br><span class="line">  <span class="title class_">ImportDeclaration</span>(&#123; node &#125;)&#123;</span><br><span class="line">    <span class="comment">// 拿到filename对应的文件夹路径</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(filename);</span><br><span class="line">    <span class="keyword">const</span> newPath = <span class="string">&#x27;./&#x27;</span>+path.<span class="title function_">join</span>(dirname, node.<span class="property">source</span>.<span class="property">value</span>);</span><br><span class="line">    dependencies.<span class="title function_">push</span>(newPath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>修改dependencies  既可以存相对路径，又能存绝对路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dependencies = &#123;&#125;;</span><br><span class="line">dependencies[node.<span class="property">source</span>.<span class="property">value</span>] = newPath;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>因为打包后需要安装成可以在浏览器上运行的，so安装babel核心模块</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @babel/core -d</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.4 babel的transformFromAst可以将ast语法树转化成浏览器可以识别的语法</span></span><br><span class="line">    <span class="comment">// 里面有code字段，它就是浏览器编译运行的可以在浏览器上生成运行的代码</span></span><br><span class="line">    <span class="keyword">const</span> &#123;code&#125; = babel.<span class="title function_">transformFromAst</span>(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">        <span class="comment">// 转换过程中，可以用的东西 npm i @babel/preset-env -d</span></span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        filename,</span><br><span class="line">        dependencies,</span><br><span class="line">        code</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、总结：-2">3、总结：<a class="anchor" href="#3、总结：-2">·</a></h4><ul><li><p>当我们做一个项目的打包时，w会对模块做分析。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).<span class="property">default</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">moduleAnalyser</span> = (<span class="params">filename</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> content = fs.<span class="title function_">readFileSync</span>(filename, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> ast = parser.<span class="title function_">parse</span>(content, &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> dependencies = &#123;&#125;; </span><br><span class="line">    <span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">        <span class="title class_">ImportDeclaration</span>(&#123; node &#125;)&#123;</span><br><span class="line">            <span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(filename);</span><br><span class="line">            <span class="keyword">const</span> newPath = <span class="string">&#x27;./&#x27;</span>+path.<span class="title function_">join</span>(dirname, node.<span class="property">source</span>.<span class="property">value</span>);</span><br><span class="line">            dependencies[node.<span class="property">source</span>.<span class="property">value</span>] = newPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123;code&#125; = babel.<span class="title function_">transformFromAst</span>(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>];</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        filename,</span><br><span class="line">        dependencies,</span><br><span class="line">        code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">moduleAnalyser</span>(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、依赖图">4、依赖图<a class="anchor" href="#4、依赖图">·</a></h4><ul><li><p>对整个项目的文件进行依赖分析：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 依赖图谱：存储所有模块的模块信息</span></span><br><span class="line"><span class="keyword">const</span> makeDependenciesGraph = <span class="keyword">function</span>(<span class="params">entry</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">graphInfo= <span class="title function_">makeDependenciesGraph</span>(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 依赖图谱：存储所有模块的模块信息</span></span><br><span class="line"><span class="keyword">const</span> makeDependenciesGraph = <span class="keyword">function</span>(<span class="params">entry</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> entryModule = <span class="title function_">moduleAnalyser</span>(entry);</span><br><span class="line">    <span class="comment">// 1.1 对所有的依赖分析:队列遍历</span></span><br><span class="line">    <span class="keyword">const</span> graphArr = [entryModule];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;graphArr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//1.2 拿出这个模块</span></span><br><span class="line">        <span class="keyword">const</span> item = graphArr[i];</span><br><span class="line">        <span class="comment">// 1.3 拿出这个依赖</span></span><br><span class="line">        <span class="keyword">const</span> &#123; dependencies &#125; = item;</span><br><span class="line">        <span class="comment">// 1.4 对对象里的文件进一步做分析</span></span><br><span class="line">        <span class="keyword">if</span>(dependencies)&#123;</span><br><span class="line">            <span class="comment">// 存储时，存的是对象，递归分析</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j <span class="keyword">in</span> dependencies)&#123;</span><br><span class="line">                graphArr.<span class="title function_">push</span>(<span class="title function_">moduleAnalyser</span>(dependencies[j]))</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 此时就拿到了这个图谱数组：但打包后为了方便处理，还要格式转换 </span></span><br><span class="line">    <span class="keyword">const</span> graph = &#123;&#125;;</span><br><span class="line">    graphArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        graph[item.<span class="property">filename</span>] = &#123;</span><br><span class="line">            <span class="attr">dependencies</span>: item.<span class="property">dependencies</span>,</span><br><span class="line">            <span class="attr">code</span>: item.<span class="property">code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graphInfo= <span class="title function_">makeDependenciesGraph</span>(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、生成代码">5、生成代码<a class="anchor" href="#5、生成代码">·</a></h4><ul><li><p>现在已经拿到所有模块的代码生成结果。目标：借助dependiencies生成真正可以在浏览器上运行的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">generateCode</span> = entry =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> graph = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">makeDependenciesGraph</span>(entry));</span><br><span class="line">    <span class="comment">// 1.1 最终生成的代码，实际上是字符串</span></span><br><span class="line">    <span class="comment">// 1.2 网页中的所有代码应该放在一个闭包里执行，避免污染全局环境</span></span><br><span class="line">    <span class="comment">// 1.6 现在graph中的代码中有require、exports对象，但是浏览器不识别，所以还需要转换：构造require、exports</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(function(graph)&#123;</span></span><br><span class="line"><span class="string">        function require(module)&#123;</span></span><br><span class="line"><span class="string">            function localRequire(relativePath)&#123;</span></span><br><span class="line"><span class="string">                return require(graph[module].dependencies[relativePath])</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">            (function(require, exports, code)&#123;</span></span><br><span class="line"><span class="string">                eval(code)</span></span><br><span class="line"><span class="string">            &#125;)(localRequire, exports, graph[module].code)</span></span><br><span class="line"><span class="string">            return exports;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        require(&#x27;<span class="subst">$&#123;entry&#125;</span>&#x27;)</span></span><br><span class="line"><span class="string">    &#125;)(<span class="subst">$&#123;graph&#125;</span>)`</span></span><br><span class="line">    <span class="comment">// 1.3 注意这里不能直接$&#123;graph&#125;  不然打印出来就是[object object] 对象会被toString方法</span></span><br><span class="line">    <span class="comment">// 1.4 so 传入之前要stringfy</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> code = <span class="title function_">generateCode</span>(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(code)</span><br></pre></td></tr></table></figure></li><li><p>将code粘贴到控制台，即可执行</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.2-基建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础-使用</title>
      <link href="/posts/2131155013.html"/>
      <url>/posts/2131155013.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景知识">一、背景知识<a class="anchor" href="#一、背景知识">·</a></h2><h3 id="1、为什么有webpack">1、为什么有webpack<a class="anchor" href="#1、为什么有webpack">·</a></h3><p>与前端发展密切联系</p><ol><li>web 10.时代  主要是编写静态页面 表达验证与动效</li><li>Web2.0时代   ajax的出现 不仅仅展示页面，还可以交互   管理数据</li><li>大前端开发时代：pc、移动，小程序，公众号。流程更复杂，要做的事越来越多   面临的问题：<ul><li>模块化支持：当下模块开发方式，但不同浏览器支持不同，且不同的模块化方式不一样</li><li>新特性支持：使用新特性提高效率：像es6、less及sass、模板语法、vue指令及jsx在浏览器中是无法直接执行的，必须经过构建这一个操作才能保证项目运行，所以<strong>前端构建打包</strong>很重要</li><li>开发中实时监听：能直接在浏览器上看到更改后的内容</li><li>项目优化：编码完成后，部署之前，打包压缩等工作</li></ul></li></ol><p>所以，总结来说：<strong>前端构建工程化</strong>发展的需要</p><h3 id="2、webpack能做什么">2、webpack能做什么<a class="anchor" href="#2、webpack能做什么">·</a></h3><h4 id="1、官方文档：">1、官方文档：<a class="anchor" href="#1、官方文档：">·</a></h4><ul><li>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<strong>静态模块打包器(module bundler)</strong></li><li>当 webpack 处理应用程序时，它会递归地构建一个<strong>依赖关系图(dependency graph)</strong>，其中包含应用程序需要的每个模块，然后将所有这些模块<strong>打包</strong>成一个或多个 <em><strong>bundle</strong></em></li></ul><h4 id="2、解释：">2、解释：<a class="anchor" href="#2、解释：">·</a></h4><ul><li><p>静态：打包后，最终<strong>产出静态资源</strong></p></li><li><p>模块：</p><ul><li><p>webpack默认支持各种<strong>模块化开发</strong>，前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理</p></li><li><p>在<a href="https://en.wikipedia.org/wiki/Modular_programming">模块化编程</a>中，开发者将程序分解为功能离散的 chunk，并称之为 <strong>模块</strong>。</p></li><li><p>每个模块都拥有小于完整程序的体积，使得验证、调试及测试变得轻而易举</p></li><li><p>Node.js 从一开始就支持模块化编程。 然而，web 的 <em>模块化</em> 正在缓慢支持中</p><ul><li>webpack天然支持的模块：ECMAScript 模块、CommonJS 模块、AMD 模块、WebAssembly 模块</li><li></li></ul></li></ul></li><li><p>打包：将不同类型的资源按模块处理进行<strong>打包</strong></p></li></ul><h3 id="3、安装与运行">3、安装与运行<a class="anchor" href="#3、安装与运行">·</a></h3><h4 id="1、初始化项目">1、初始化项目<a class="anchor" href="#1、初始化项目">·</a></h4><ul><li><p>初始化：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init -y 一路回车   会生成package.json 文件</span><br></pre></td></tr></table></figure></li><li><p>修改配置package.json：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">+ “private<span class="string">&quot;:&quot;</span><span class="keyword">true</span><span class="string">&quot;  意思是这是一个私有项目，它不会被发布到npm线上仓库</span></span><br><span class="line"><span class="string">-“main”:&quot;</span>index.js<span class="string">&quot; 配置项</span></span><br><span class="line"><span class="string">-&quot;</span>script<span class="string">&quot;:&#123;//可以先去掉里边的内容&#125;</span></span><br><span class="line"><span class="string">&quot;</span>author<span class="string">&quot;:&quot;</span>可以写成自己的名字<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>license<span class="string">&quot;:&quot;</span>INIT<span class="string">&quot;如果想开源的话，依然使用&quot;</span>ISC<span class="string">&quot;也可以</span></span><br><span class="line"><span class="string">&quot;</span>private<span class="string">&quot;: true, // 禁止发布到npm上     </span></span><br><span class="line"><span class="string">&quot;</span>main<span class="string">&quot;: &quot;</span>index.js<span class="string">&quot; // 向外暴露文件</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、安装webpack">2、安装webpack<a class="anchor" href="#2、安装webpack">·</a></h4><ul><li><p>全局安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i webpack webpack-cli -g  </span><br><span class="line">npm info webpack 查看都有哪些版本号</span><br></pre></td></tr></table></figure></li><li><p>局部安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i webpack-cli --save-dev</span><br><span class="line">npm i weboack --save-dev</span><br><span class="line">npm i webpack@版本号 -webpack-cli -D</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、打包项目">3、打包项目<a class="anchor" href="#3、打包项目">·</a></h4><ul><li><h4 id="全局打包方式：">全局打包方式：<a class="anchor" href="#全局打包方式：">·</a></h4><p>问题：假如当前项目在5上的，分享给别人就会有问题。因为别人的跟我的不匹配，我们应该用局部打包方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack index.js    // 全局版本</span><br><span class="line">webpack ./src/index.js -o ./build/built.js --mode=development</span><br><span class="line">// webpack就会以`./src/index.js`为入口文件开始打包,打包后输出到`./build/built.js`整体打包环境,是开发环境</span><br></pre></td></tr></table></figure><ul><li><p>此时直接执行webpack ，打包时，会自动去src目录下的index.js文件下去查找,进行依赖分析；</p></li><li><p>完成编译自动生成了dist文件夹。里面有main.js。他就是打包生成的产物。</p></li><li><p>index.html中引入dist下的main.js文件，就可以在浏览器中看到运行结果</p></li></ul></li><li><h4 id="局部打包方式1：命令行，麻烦">局部打包方式1：命令行，麻烦<a class="anchor" href="#局部打包方式1：命令行，麻烦">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx webpack index.js   </span><br><span class="line">// 打包时优先用当前项目的webpack版本， npx会在项目中的node_modules中找webpack包运行</span><br></pre></td></tr></table></figure></li><li><h4 id="局部打包方式2：脚本script">局部打包方式2：脚本script<a class="anchor" href="#局部打包方式2：脚本script">·</a></h4><p>假如在index.js做了修改：想自定义入口文件名字，希望产出文件放在指定目录下：ouputPath</p><ul><li><p>导出配置文件webpack.config.js中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">modulex.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;build.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>) <span class="comment">//必须为绝对路径，so要path模块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.son中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>  <span class="comment">// 打包默认优先使用本项目webpack版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果想修改打包配置文件命名：lg.webpack.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">则在package.<span class="property">json</span>中：scripts：&#123;</span><br><span class="line"><span class="attr">bulid</span>: webpack --config lg.<span class="property">webpack</span>.<span class="property">js</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、依赖图：">4、依赖图：<a class="anchor" href="#4、依赖图：">·</a></h4><p>webpack在打包时会有个依赖关系：基于入口文件：index.js，在里面使用语法导入别的模块，可以通过不同的loader转换。</p><ul><li>当你没有被某个模块引入时，webpack打包时不会去找他，在构建依赖图不会去做打包</li><li>进一步的，可能模块文件进入了，但是实际没有使用。会有tree  shaking做优化</li></ul><h3 id="4、实验分析：">4、实验分析：<a class="anchor" href="#4、实验分析：">·</a></h3><ul><li><p>在public目录下新建index.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>新建JS目录下 util.js文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">m, n</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> m+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  <span class="title function_">square</span> = (<span class="params">m</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> m*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;sum, square&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建JS目录下  api.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getInfo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zcs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = getInfo;</span><br></pre></td></tr></table></figure></li><li><p>在入口文件index.js中导入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;sum, square&#125; <span class="keyword">from</span> <span class="string">&#x27;./js/utils.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">3</span>));  <span class="comment">//这种esmodule的支持需要配置script 中的type为module</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">square</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//但即使配置了type  commonJS谷歌仍然不支持，此时webpack登场帮我们姐姐</span></span><br><span class="line"><span class="keyword">const</span> getInfo = <span class="built_in">require</span>(<span class="string">&#x27;./js/api&#x27;</span>)  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getInfo</span>())</span><br></pre></td></tr></table></figure></li><li><p>安装好webpack及cli：</p><p>此时直接执行webpack ，打包时，会自动去src目录下的index.js文件下去查找,进行依赖分析；</p><p>完成编译自动生成了dist文件夹。里面有main.js。他就是打包生成的产物。</p><p>index.html中引入dist下的main.js文件，就可以在浏览器中看到运行结果</p></li></ul><h2 id="二、核心概念及模块">二、核心概念及模块<a class="anchor" href="#二、核心概念及模块">·</a></h2><h3 id="0、4个核心概念">0、4个核心概念<a class="anchor" href="#0、4个核心概念">·</a></h3><p>入口、出口、loader、plugins</p><ul><li><p>**loader：**让Webpack 能够去处理那些非JavaScript文件(JavaScrpit)</p><ul><li><p>为什么webpack需要loader？</p><p>默认webpack自身只理解JS，而不能处理非JS文件，so需要有一个人对这种文件转换，之后让webapck去执行转换后的内容</p></li><li><p>loader是什么？</p><p>是一个模块，能够将转成webpack能够识别的模块，导出一个函数</p></li></ul></li><li><p>**插件(plugins)：**用于执行范围更广的任务：打包优化和压缩、重新定义环境中的变量等</p><ul><li>比如说，我们更改了配置项，就需要删除dist目录，重新打包生成编译产物，再运行；</li><li>再比如我们每次打包完成后，每次都要手动修改，也比较麻烦。</li><li>插件就能帮我们做这些</li></ul></li><li><p><strong>当有插件时，为什么还会有loader呢？</strong></p><p>核心功能不同</p><ul><li><p>对loader而言，它主要是对特定类型的（非JS）模块转换。而loader就承担了这些识别转换的功能。工作的时机就是<strong>读取某个特定类型的资源时</strong></p></li><li><p>而插件，可以做的更多。它同样存在自己的生命周期，我们可以认为打包的过程就是一个完整的流水线，那么当前的插件可以在流水线上的任一时机被插进来。比如说，我们希望在打包开始时做一些事情，或在打包进行到某一时机点做些事情，再比如希望写。而loader并不满足这种需求</p></li></ul></li></ul><h3 id="1、entry模块">1、entry模块<a class="anchor" href="#1、entry模块">·</a></h3><p>功能：指示 Webpack以哪个文件为<strong>入口</strong>开始打包，分析构建内部依赖图</p><p>4种写法：</p><ol><li><p>单入口：打包形成一个chunk(模块)，输出一个bundle(包)文件。此时默认的chunk名称是main</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry: &#x27;./src/index.js&#x27; </span><br></pre></td></tr></table></figure></li><li><p>多入口：所有入口文件最终只会形成一个chunk，输出出去只有一个bundle文件(类似将add.js打包进index.js中)</p><p>通常只有在<code>HMR功能中使用</code>, 让html热更新生效使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry: [&#x27;./src/index.js&#x27;, &#x27;./src/add.js&#x27;]</span><br></pre></td></tr></table></figure></li><li><p>多入口：有几个入口文件就形成几个chunk，输出几个bundle文件。此时chunk名称是 key</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">  <span class="attr">index</span>:<span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">add</span>:<span class="string">&#x27;./src/add.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊用法(混合使用)  ：通常在<code>dll</code>优化功能中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">      <span class="comment">// 所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。</span></span><br><span class="line">    <span class="attr">index</span>: [<span class="string">&#x27;./src/index.js&#x27;</span>, <span class="string">&#x27;./src/count.js&#x27;</span>], </span><br><span class="line">       <span class="comment">// 形成一个chunk，输出一个bundle文件。</span></span><br><span class="line">    <span class="attr">add</span>: <span class="string">&#x27;./src/add.js&#x27;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2、output模块">2、output模块<a class="anchor" href="#2、output模块">·</a></h3><p>功能：指示 Webpack打包后的资源输出到哪里去、如何命名</p><h4 id="1、filename：">1、<code>filename</code>：<a class="anchor" href="#1、filename：">·</a></h4><p>文件名称（指定名称+目录）</p><ul><li><p>如果这里写死bundle.js，<strong>多入口打包</strong>的时候，会报错，因为你指定了多个打包输出不能都用同一个文件，解决：占位符的写法filename: ‘[name].js’,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename: &#x27;js/[name].js&#x27;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、path：">2、<code>path</code>：<a class="anchor" href="#2、path：">·</a></h4><ul><li><p>输出文件目录(将来所有资源输出的公共目录)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path: resolve(__dirname, &#x27;build&#x27;),</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、publicPath：">3、<code>publicPath</code>：<a class="anchor" href="#3、publicPath：">·</a></h4><p>所有资源引入公共路径的前缀</p><ul><li><p>在本地打包后，告知本地打包的index.html，将来去哪个地方寻找加载的资源   浏览器补的</p></li><li><p>为空字符串’ '时，将当前域名+publicPath+filename形式访问资源。</p><ul><li><p>当以打开index.html的形式，也就是file协议打开时，index.html的js引用的是main.js，实际是./ 以相对路径形式访问</p></li><li><p>当开启der-server访问时，也可以找到加载的资源。怎么做的呢？</p><p>首先是前面域名：http://localhost:8080+‘/’(这个是浏览器自动帮我们加的)+filename（我们设置的）</p></li></ul></li><li><p>也可以写成/的形式：此时是以绝对路径的形式访问   自己补</p><ul><li><p>本地打包：<script defer src="/js/build.js"></script></p><p>报错加载不到资源  此时需要写成./。这样相当于将绝对路径改成相对路径，本地就ok了</p><p>但此时./如果还想dev-server形式，又无法预览。相对路径，它不知道怎么去找。找不到js下面的build.js</p></li></ul></li></ul><h4 id="4、chunkFilename">4、<code>chunkFilename</code>:<a class="anchor" href="#4、chunkFilename">·</a></h4><ul><li><p>非入口chunk的名称，如未指定这项,在入口文件中导入的js打包也会用上<code>filename</code>的文件名称进行命名，但是名字与入口文件冲突,就会使用0~∞数字命名,不容易区分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunkFilename: &#x27;js/[name]_chunk.js&#x27;, // 非入口chunk的名称</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、library">5、library<a class="anchor" href="#5、library">·</a></h4><ul><li><p><code>library:'[name]'</code>  //整个库向外暴露的变量名 实际上使用<code>var声明</code></p></li><li><p><code>libraryTarget</code>:将变量名添加到哪个对象上</p><p>​a) libraryTarget: ‘window’ 适合浏览器端</p><p>​b) libraryTarget: ‘global’ 适合node</p><p>​c) libraryTarget: ‘commonjs’ 使用commonjs方式进行模块导出</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/[name].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&#x27;js/[name]_chunk.js&#x27;</span>, <span class="comment">// 非入口chunk的名称</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3、module模块">3、module模块<a class="anchor" href="#3、module模块">·</a></h3><ul><li><p><code>test</code>:文件名匹配规则,后面参数是一个正则</p></li><li><p><code>exclude</code>:排除匹配某个目录下的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exclude: /node_modules/ -&gt;排除node_modules下的文件</span><br></pre></td></tr></table></figure></li><li><p><code>include</code>:只检查 某个目录下的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include: resolve(__dirname, &#x27;src&#x27;) -&gt;只检查 src 下的js文件</span><br></pre></td></tr></table></figure></li><li><p><code>loader</code>与<code>use</code>:单个loader使用<code>loader</code>,多个loader用<code>use</code></p></li><li><p><code>enforce</code>:指定该配置的执行顺序:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enforce:&#x27;`pre`&#x27;(优先执行) &gt; 默认 &gt; enforce:&#x27;`post`&#x27;(延后执行)</span><br></pre></td></tr></table></figure></li><li><p><code>options</code>:指定这个loader的配置选项</p></li><li><p><code> oneOf: []</code>:          <strong>性能优化</strong></p><ul><li>里面的配置只会生效一次,即里面有100个配置,当我一个文件进入这里检测,可能第10个配置匹配到了就生效,然后该文件就不会进行下面90次匹配</li><li>如果是不放<code> oneOf</code>里面的配置,就会完全执行100次匹配</li><li>当你使用eslint与babel两种配置进行对于js文件的匹配的情景下会使用</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,     <span class="comment">// 排除node_modules下的js文件</span></span><br><span class="line">        <span class="attr">include</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>),    <span class="comment">// 只检查 src 下的js文件</span></span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,   <span class="comment">// 单个loader用loader</span></span><br><span class="line">        <span class="comment">//use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] // 多个loader用use     </span></span><br><span class="line">        <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,<span class="comment">// 优先执行 // 延后执行enforce: &#x27;post&#x27;,</span></span><br><span class="line">        <span class="attr">options</span>: &#123;&#125;      <span class="comment">//指定这个loader的配置选项</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>: []  <span class="comment">// 以下配置只会生效一个</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4、resolve模块">4、resolve模块<a class="anchor" href="#4、resolve模块">·</a></h3><ul><li>功能：解析模块的规则</li></ul><ol><li><p><code>alias</code>： 配置解析模块路径别名: 优点<strong>简写路径</strong>    缺点路径<strong>没有提示</strong></p></li><li><p><code>extensions</code>：如果在这里配置了，引入时可以不用写后缀</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;$css/index&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>modules</code>：告诉webpack<strong>解析模块</strong>时去哪个目录</p><ul><li>不指定，webpack会一层一层往外找，不必要的性能浪费</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>()],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;       <span class="comment">// 解析模块的规则</span></span><br><span class="line">    <span class="attr">alias</span>: &#123;       <span class="comment">// 配置解析模块路径别名</span></span><br><span class="line">      <span class="attr">$css</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/css&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>],   <span class="comment">// 配置省略文件路径的后缀名</span></span><br><span class="line">    <span class="comment">// 告诉 webpack 解析模块是去找哪个目录</span></span><br><span class="line">    <span class="attr">modules</span>: [<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../../node_modules&#x27;</span>), <span class="string">&#x27;node_modules&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5、devServer模块">5、devServer模块<a class="anchor" href="#5、devServer模块">·</a></h3><p>这部分配置很多,只抽出我觉得比较重要的</p><blockquote><p>1、<code>proxy</code>:服务器代理 --&gt;解决开发环境跨域问题</p><p>​① target: 一旦devserver服务器接收到<code>/接口名/xxx</code>,就会把请求转发到<code>target</code>后面的参数url服务器上</p><p>​② pathRewrite:发送请求时,请求路径重写 --&gt; 如:将/api/xxx -&gt;/xxx(去掉前面的/api)</p><p>2、<code>contentBase</code>:指定运行代码的目录</p><p>3、<code>hot</code>:开启<code>HMR模块热替换</code>,这是优化部分功能</p><p>4、<code>overlay</code>:当设置为<code>false</code>时,如果代码错误,不要进行全屏提示</p><p>5、<code>watchContentBase</code>:当设置为<code>true</code>时,监听contentBase目录下的所有文件 一旦文件变化就会reload</p><p>6、<code>watchOptions</code>:内部设置监听的忽略文件,通常与<code>5</code>搭配使用</p><p>7、<code>compress</code>:是否开启<code>gzip</code>压缩</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),   <span class="comment">// 运行代码的目录</span></span><br><span class="line">    <span class="comment">// 监视 contentBase 目录下的所有文件，一旦文件变化就会 reload</span></span><br><span class="line">    <span class="attr">watchContentBase</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">      <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span>       <span class="comment">// 忽略文件</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">5000</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,      <span class="comment">// 开启HMR功能</span></span><br><span class="line">    <span class="attr">clientLogLevel</span>: <span class="string">&#x27;none&#x27;</span>,   <span class="comment">// 不要显示启动服务器日志信息</span></span><br><span class="line">    <span class="attr">quiet</span>: <span class="literal">true</span>,    <span class="comment">// 除了一些基本启动信息以外，其他内容都不要显示</span></span><br><span class="line">    <span class="attr">overlay</span>: <span class="literal">false</span>,       <span class="comment">// 如果出错了，不要全屏提示~</span></span><br><span class="line">    <span class="comment">// 服务器代理 --&gt; 解决开发环境跨域问题</span></span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="comment">// 一旦devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器(3000)</span></span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">        <span class="comment">// 发送请求时，请求路径重写：将 /api/xxx --&gt; /xxx （去掉/api）</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6、Mode：">6、Mode：<a class="anchor" href="#6、Mode：">·</a></h3><ul><li><p>指示Webpack使用相应模式的配置</p><table><thead><tr><th>选项</th><th>描述</th><th>特点</th></tr></thead><tbody><tr><td>development</td><td>会将process.env.NODE_ENV的值设置为development.<br />启用NamedChunksPlugin和NamedModulesPlugin</td><td>能让代码本地调试运行的环境</td></tr><tr><td>production</td><td>启动好多东西…</td><td>能让代码优化上线运行的环境</td></tr></tbody></table></li></ul><h3 id="7、optimization">7、optimization<a class="anchor" href="#7、optimization">·</a></h3><h2 id="三、loader">三、loader<a class="anchor" href="#三、loader">·</a></h2><h3 id="1、CSS-loader">1、CSS-loader<a class="anchor" href="#1、CSS-loader">·</a></h3><h4 id="1、CSS-loader-style-loader">1、CSS-loader   style-loader<a class="anchor" href="#1、CSS-loader-style-loader">·</a></h4><ul><li><p>css-loader css文件的识别、style-loader  css样式的绑定生效、sass-loader  scss 文件使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 匹配哪些文件</span></span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">     <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">     <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">       <span class="comment">// use数组中loader执行顺序：从右到左，从下到上 依次执行</span></span><br><span class="line">       <span class="comment">// style-loader创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line">       <span class="comment">// css-loader将css文件变成commonjs模块加载js中，里面内容是样式字符串      </span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">     <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">       <span class="comment">// less-loader:将less文件编译成css文件</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、browserslitrc">2、browserslitrc<a class="anchor" href="#2、browserslitrc">·</a></h4><ul><li><p>要求：需要考虑兼容性的支持：JS比如ES6  CSS 比如某些选择器</p></li><li><p>方式1：配置package.json</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;browserslist&quot;: [</span><br><span class="line">  &quot;&gt;1%&quot;,</span><br><span class="line">  &quot;last 2 version&quot;,</span><br><span class="line">  &quot;not dead&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>方式2：专门有.browserslistrc</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在里面写所有的要求</span><br></pre></td></tr></table></figure></li><li><p>查看兼容的浏览器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx browserslist</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、postcss">3、postcss<a class="anchor" href="#3、postcss">·</a></h4><ul><li><p>为什么会有？     工程化开发css，存在配置项筛选出要兼容的平台。利用这个工具可以</p></li><li><p>是什么？</p><p>可以将css文件处理完成，交给css-loader处理即可。在webpack中，通过javascript转换样式的工具</p></li></ul><h5 id="命令行的方式使用：">命令行的方式使用：<a class="anchor" href="#命令行的方式使用：">·</a></h5><ul><li><p>不支持命令行的方式，除非安装cli</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i postcss-cli -d</span><br></pre></td></tr></table></figure></li><li><p>假如我们指定兼容哪些平台，前缀不一样，会自动加前缀，做兼容性处理：autoprefix</p><p>在test.css中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">    transition: all 0.5s;</span><br><span class="line">    user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在login.js中引入文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#x27;../css/test.css&#x27;</span><br></pre></td></tr></table></figure></li><li><p>重新打包，可以发现控制台中style标签已经添加了样式内容，但是<strong>并没有为我们自动补齐前缀：</strong></p></li><li><p>处理test.css文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx postcss -o ret.css ./src/css/test.css</span><br><span class="line">此时下面就生成了ret.css</span><br></pre></td></tr></table></figure><p>它的生成产物，好像只是复制了一遍，并没做什么。<strong>因为postcss它本身只是一个工具，希望它做啥还需要插件拿进来</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i autoprefixer -d  <span class="comment">//安装插件：具体的功能，实现前缀添加</span></span><br></pre></td></tr></table></figure></li><li><p>重新处理test.cs文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx postcss --use autoprefixer -o ret.css ./src/css/test.css </span><br></pre></td></tr></table></figure></li><li><p>此时产物ret.css就添加了前缀</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#12345678</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.5s</span>; </span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">       -moz-user-select: none;</span><br><span class="line">        -ms-user-select: none;</span><br><span class="line">            user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="以配置的方式使用">以配置的方式使用<a class="anchor" href="#以配置的方式使用">·</a></h5><ul><li><p>安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm 安装post-loader</span><br><span class="line">配置：use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;]</span><br></pre></td></tr></table></figure><ul><li>但是postcss-loader什么也做不了，所以也不会自动添加。</li></ul></li><li><p>配置lg.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [</span><br><span class="line">    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;      <span class="comment">// 设置参数:希望将来加载的插件:</span></span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)      <span class="comment">// 插件的功能可以对其夹前缀</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、postcss-preset-env">4、postcss-preset-env<a class="anchor" href="#4、postcss-preset-env">·</a></h4><ul><li><p>是什么？</p><ul><li><p>这是一个预设，是插件的集合，用来对新的语法做处理；</p></li><li><p>比如我们在上面定义样式时，写了color: #12345678，这是不同于常见的rgb写法。而autoprefix时不能帮我们做这种新语法。还需要去配置里修改，但这很麻烦。so   postcss-preset-env</p></li></ul></li></ul><ul><li><p>它里面默认集合了常见的css转换，因此安装+配置即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">添加插件引入：</span><br><span class="line"><span class="attr">plugins</span>: [<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>),<span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)]</span><br></pre></td></tr></table></figure></li><li><p>可以简写为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="comment">// 插件的功能可以对其夹前缀</span></span><br><span class="line">  <span class="string">&#x27;autoprefixer&#x27;</span>,<span class="string">&#x27;postcss-preset-env&#x27;</span>  <span class="comment">//它有了，不用写autoprefixer</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">//最终简写</span></span><br><span class="line"><span class="attr">plugins</span>: [<span class="string">&#x27;postcss-preset-env&#x27;</span>]   <span class="comment">//它有了，不用写autoprefixer</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="单独配置文件postcss-config-css">单独配置文件postcss.config.css<a class="anchor" href="#单独配置文件postcss-config-css">·</a></h5><ul><li><p>针对CSS文件如此，Less文件也是如此，webpack支持专门搞个文件，设置这些，就不用再copy配一遍，很方便管理配置：新建postcss.config.css（不能随便命名）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">     <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)  <span class="comment">//可以简写</span></span><br><span class="line">        <span class="comment">// require(&#x27;autoprefixer&#x27;)</span></span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lg.config.js中只需要写对应loader：比如匹配css</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [</span><br><span class="line">    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;postcss-loader&#x27;</span>  <span class="comment">// 当它读到这里时会自动去找它的配置</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">      <span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">      <span class="string">&#x27;css-loader&#x27;</span>, </span><br><span class="line">      <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、importLoader属性">5、importLoader属性<a class="anchor" href="#5、importLoader属性">·</a></h4><ul><li><p>在test.css文件中：拆解部分login.css文件 给test.css</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.5s</span>;</span><br><span class="line">    user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在login.css文件中导入拆解走的样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./test.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#12345678</span>;   </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">155</span>, <span class="number">118</span>, <span class="number">70</span>, <span class="number">0.714</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新打包，成功。但控制台中发现兼容性的样式并没有，autoprefix配置没问题。so，@import导入的样式无法生效，为什么？</p><ul><li><p>按照loader解析顺序：</p><ul><li><p>postcss-loader经过分析配置后，会对生成的css文件生效。</p></li><li><p>然后，login.css文件@import导入了test.css文件。 postcss-loader拿到了login.css的代码后，分析基于筛选条件并不需要做额外处理，so会把代码直接交给了css-loader。</p></li><li><p>css-loader可以处理@import  media url这类问题。此时拿到了test.css文件。此时内部有需要兼容性处理的loader，但此时loader不会再回头找postcss-loader。它直接交给了style-loader处理。</p></li><li><p>所以我们在页面没有看到那块处理</p></li></ul></li></ul></li><li><p>解决：import loader属性，此时就可以看到import的模块进行了兼容性处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">importLoaders</span>: <span class="number">1</span> <span class="comment">//让它遇到import 往前找一个loader</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、file-url-loader">2、file/url-loader<a class="anchor" href="#2、file-url-loader">·</a></h3><h4 id="1、file-loader">1、file-loader<a class="anchor" href="#1、file-loader">·</a></h4><ul><li>打包图片：比如img的src   background的url引入图片资源</li><li>file-loader功能：<ul><li>能帮我们返回一个js能识别的东西</li><li>可以把要处理的 二进制文件拷贝到指定目录。如果我们没有指定，会拷贝到dist目录里</li></ul></li></ul><h5 id="img标签实验：">img标签实验：<a class="anchor" href="#img标签实验：">·</a></h5><ul><li><p>定义image.js文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">packImg</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//  比如页面上有标签：设置src属性</span></span><br><span class="line">    <span class="comment">// 容器元素</span></span><br><span class="line">    <span class="keyword">const</span> oEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> oEle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="title function_">packImg</span>());</span><br></pre></td></tr></table></figure></li><li><p>在入口文件index.js引入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./js/Image&#x27;</span>   <span class="comment">// 引入依赖</span></span><br></pre></td></tr></table></figure></li></ul><p>​重新打包生成，可在控制台中看到标签</p><ul><li><p>添加图片，本地img文件夹放了a b两张图，修改img.js，引入图片并打包。此时报错提示loader</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">packImg</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//  比如页面上有标签：设置src属性</span></span><br><span class="line">    <span class="comment">// 容器元素</span></span><br><span class="line">    <span class="keyword">const</span> oEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> oImg = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    oImg.<span class="property">src</span> = <span class="built_in">require</span>(<span class="string">&#x27;../img/aa.jpeg&#x27;</span>);</span><br><span class="line">    oEle.<span class="title function_">appendChild</span>(oImg); </span><br><span class="line">    <span class="keyword">return</span> oEle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="title function_">packImg</span>());</span><br></pre></td></tr></table></figure></li><li><p>安装该loader 并配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpeg)$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [<span class="string">&#x27;file-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>此时我的页面显示不正常，控制台报错：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Automatic</span> publicPath is not supported <span class="keyword">in</span> <span class="variable language_">this</span> browser。</span><br></pre></td></tr></table></figure><p>修改lg.config.js配置文件的outpath的publicPath</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;/dist/&#x27;</span>,  </span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;build.js&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>) <span class="comment">//必须为绝对路径，so要path模块</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>此时不报错，控制台会有img，但图片不显示，且src变成了 Object module。在webpack5中，file-loader默认返回的是一个对象，东西放在default中，就必须访问dedault。修改img.js，就ok啦</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oImg.<span class="property">src</span> = <span class="built_in">require</span>(<span class="string">&#x27;../img/aa.jpeg&#x27;</span>).<span class="property">default</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="img-js中不想通过default的方式">img.js中不想通过default的方式<a class="anchor" href="#img-js中不想通过default的方式">·</a></h5><ul><li>方式1：配置file-loader：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpeg)$/</span>,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>  <span class="comment">// false不换为esModule</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式2：通过esModule的导入方式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> oImgSrc  <span class="keyword">from</span> <span class="string">&#x27;../img/aa.jpeg&#x27;</span>;</span><br><span class="line">oImg.<span class="property">src</span> = oImgSrc;</span><br></pre></td></tr></table></figure><h5 id="background的引入实验">background的引入实验<a class="anchor" href="#background的引入实验">·</a></h5><ul><li><p>修改img.js，重新打包生成可看到dom结构已经生效</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obgImg = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">obgImg.<span class="property">className</span> = <span class="string">&#x27;bgbox&#x27;</span>;</span><br><span class="line"></span><br><span class="line">oEle.<span class="title function_">appendChild</span>(obgImg); </span><br><span class="line"><span class="keyword">return</span> oEle;</span><br></pre></td></tr></table></figure></li><li><p>新建css文件夹下的img.css</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgbox</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;../img/bb.jpeg&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改img.js：执行打包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#x27;../css/img.css&#x27;</span><br></pre></td></tr></table></figure><p>此时dist下有2个图片：有个是二进制图片，但页面并没有正确显示图片</p></li><li><p>在打包时，在处理img.js时</p><ul><li><p>依赖img.css，so postcsss-loader会去处理，并没有太多变化，又交给css-loader。该loader可以处理bg-img。</p></li><li><p>而css-loader会将bg-img替换为require语法。返回的是<strong>esModule</strong>，导出加了default。但是我们理想的，是不要你返回esModule，直接返回资源即可：</p></li></ul><ul><li><p>此时，css-loader配置中更改esModule：此时图片便可正常显示，且dist下不会有中间产物</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line">  <span class="attr">importLoaders</span>: <span class="number">1</span>, <span class="comment">//让它遇到import 往前找一个loader</span></span><br><span class="line">  <span class="attr">esModule</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改打包的文件以想要的方式生成：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;[name].[hash:6].[ext]&#x27;</span>,</span><br><span class="line">  <span class="attr">outputPath</span>: <span class="string">&#x27;img&#x27;</span> <span class="comment">// 打包到img下面，但一般不这样写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;img/[name].[hash:6].[ext]&#x27;</span>  <span class="comment">//这样也可以，会自动生成img，图片在这下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="打包其他资源">打包其他资源<a class="anchor" href="#打包其他资源">·</a></h5><blockquote><p><code>exclude</code>:指定除此之外的资源</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 打包其他资源(除了html/js/css资源以外的资源)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 排除css/js/html资源</span></span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/\.(css|js|html|less)$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="2、url-loader">2、url-loader<a class="anchor" href="#2、url-loader">·</a></h4><ul><li><p>安装  配置：此时图片正常显示，但dist下图片不会生成img。也没图片</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpeg)$/</span>,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;img/[name].[hash:6].[ext]&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>File-loader与url-loader</p><ul><li><p>File-loader：将当前图片的名称返回，路径返回，并将要打包的图片资源拷贝到dist目录下。</p><ul><li>缺点：在访问静态资源的时候，需要额外发请求</li></ul></li><li><p>但url-loader：将当前要打包的图片资源以base64的格式加载到代码中，所以不会看到dist目录下，控制台也可以看到。</p><ul><li><p>优点：不需要额外请求，减少请求次数。</p></li><li><p>缺点：图片过大时，请求慢，对首屏不好。</p></li></ul></li></ul><p>limit属性可以做拆分：大于该值，做拷贝，避免等待时间过长。小于该值，转64，减少额外请求</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;img/[name].[hash:6].[ext]&#x27;</span>,</span><br><span class="line">  <span class="attr">limit</span>: <span class="number">25</span>*<span class="number">1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、asset">3、asset<a class="anchor" href="#3、asset">·</a></h4><ul><li><p>在webpack5中，可以通过asset直接配置这两个loader，不需要单独分开配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Asset/reesouse: 可以将目标支援拷贝到指定目录  file-loader</span><br><span class="line">- asset/inline:   url-loader</span><br><span class="line">- Asset/source: raw-loader  不常用</span><br><span class="line">- asset/  设置类似limit等限制</span><br></pre></td></tr></table></figure></li><li><p>修改配置：lg.config.js，打包后，图片正常显示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpeg)$/</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再修改lg.config.js：</p><ul><li><p>全局方式：全局统一设置：需要找到output配置，打包完成，仍然正常使用，img也生成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/dist/&#x27;</span>,</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;build.js&#x27;</span>,</span><br><span class="line">        + <span class="attr">assetModuleFilename</span>: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>, <span class="comment">// 不用加. ext会自动加</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>) <span class="comment">//必须为绝对路径，so要path模块</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>但这种配置方式是全局的，将来还有可能处理其他静态资源，比如字体，也会被打包进入这该文件夹</p></li><li><p>局部的方式：lg.config.js，打包编译即可成功</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpeg)$/</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,  </span><br><span class="line">    <span class="attr">generator</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>asset/inline的方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpeg)$/</span>,</span><br><span class="line">   <span class="attr">type</span>: <span class="string">&#x27;asset/inline&#x27;</span>    <span class="comment">//不会产出图片，且没有generator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望做限制，还需要配置parser、generator</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpeg)$/</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line">      <span class="attr">generator</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">3</span>*<span class="number">1024</span>  <span class="comment">//此时超过3k的会生成在img，以静态资源的形式引入</span></span><br><span class="line">    <span class="comment">// 没有3k的会以 data uri的形式引入        </span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="asset还可以处理字体：略">asset还可以处理字体：略<a class="anchor" href="#asset还可以处理字体：略">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">    <span class="attr">generator</span>: &#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;font/[name].[hash:3][ext]&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4、配置：">4、配置：<a class="anchor" href="#4、配置：">·</a></h4><ul><li><p>问题一:只设置一个<code>test&#123;/\.(jpg|png|gif)$/&#125; ,loader:'url-loader'</code>,默认处理不了html中img图片,html中仍然是<code>./src/img.jpg</code></p><p>解: 需要再引入<code>test:&#123;/\.html$/&#125;</code>,才可以,但是这时候解析时会出问题：html的图片路径编程<code>[object Module]</code></p></li><li><p>问题二:html的图片路径变成<code>[object Module]</code></p><p>分析: 因为url-loader默认使用<code>es6模块化解析</code>，而html-loader引入图片是<code>commonjs</code>,所以解析时用的es6模块化解析,出现问题</p><p>解决:关闭<code>options</code>中的url-loader的es6模块化,使用commonjs解析 <code>options:&#123;esModule: false&#125;</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 问题：默认处理不了html中img图片</span></span><br><span class="line">        <span class="comment">// 处理图片资源        下载 url-loader file-loader</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 图片大小小于8kb，就会被base64处理</span></span><br><span class="line">          <span class="comment">// 优点: 减少请求数量（减轻服务器压力）</span></span><br><span class="line">          <span class="comment">// 缺点：图片体积会更大（文件请求速度更慢）</span></span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="comment">// 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs</span></span><br><span class="line">          <span class="comment">// 解析时会出问题：[object Module]</span></span><br><span class="line">          <span class="comment">// 解决：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 给图片进行重命名</span></span><br><span class="line">          <span class="comment">// [hash:10]取图片的hash的前10位</span></span><br><span class="line">          <span class="comment">// [ext]取文件原来扩展名</span></span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;images/&#x27;</span>,   <span class="comment">// 图片大于2048时， 将图片打包在images文件下</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        <span class="comment">// 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）</span></span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><h3 id="3、babel">3、babel<a class="anchor" href="#3、babel">·</a></h3><h4 id="1、babel简介">1、babel简介<a class="anchor" href="#1、babel简介">·</a></h4><ul><li><p>为什么需要babel？</p><p>虽然目前的脚手架帮助完兼容性处理。但是react会有jsx  ts es6这些对于浏览器默认不能识别。so希望产出为浏览器能够直接使用的，但是这些特性并不是所有浏览器都能识别的。而babel可做到</p></li><li><p>babel是什么？</p><p>它就是工具，本身不具备任何功能</p></li></ul><h5 id="实验1："><strong>实验1：</strong><a class="anchor" href="#实验1：">·</a></h5><ul><li>index.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="string">&#x27;front_end&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">alert</span>(title)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><ul><li>修改配置导出工具</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">   <span class="attr">filename</span>: <span class="string">&#x27;js/build.js&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时打包产物build.js，一大堆代码。但是可以看出，只是对JS代码做了拷贝 输出一份，没有做处理就，交给浏览器使用。因此<strong>我们希望有人能够帮我们做这件事，就是babel</strong></p><h5 id="实验2-命令行的方式">实验2-命令行的方式<a class="anchor" href="#实验2-命令行的方式">·</a></h5><ul><li><p>babel是一个微内核结构**，核心操作都放在core里**，你只需要针对不同语法安装不同的包即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @babel/core -d</span><br></pre></td></tr></table></figure></li><li><p>但默认情况下，我们不能在命令行中安装使用的babel。怎么办呢？还需要安装@babel/cli。这样就可直接npx babel</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i @babel/cli -d</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx babel src --out-dir build</span><br><span class="line">src:指定src下的所有文件   build 新建build文件夹，处理后的结果放在这里</span><br></pre></td></tr></table></figure></li><li><p>打开build的文件夹的main.js文件。与原文件index.js一模一样。为什么babel为什么啥也没做呢？</p><p>因为它只是工具。它只是能完成转换，但是具体啥转换，需要插件支持才可以。比如箭头函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @babel/plugin-transform-arrow-functions -d  <span class="comment">// 处理箭头函数</span></span><br><span class="line">npm i @babel/plugin-transform-block-scoping -d  <span class="comment">//处理const</span></span><br></pre></td></tr></table></figure></li><li><p>此时执行：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx babel src --out-dir build --plugins=@babel/plugin-transform-arrow-functions</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时完成箭头+const转换</span></span><br><span class="line">npx babel src --out-dir build --plugins=@babel/plugin-transform-arrow-functions,@babel/plugin-transform-block-scoping</span><br></pre></td></tr></table></figure></li><li><p>生成的main.js中箭头函数就转换成了普通函数</p></li></ul><h4 id="2、预设preset：">2、预设preset：<a class="anchor" href="#2、预设preset：">·</a></h4><p>当前每次转换一类，都需要转换，因此提供了<strong>预设。这样就不能每次配置了，它涵盖了大部分ES6的语法</strong></p><ul><li><p>安装preset</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i @babel/preset-env -D</span><br></pre></td></tr></table></figure></li><li><p>执行：此时就完成了转换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx babel src --out-dir build --presets=@babel/preset-env </span><br></pre></td></tr></table></figure></li></ul><h4 id="3、babel-loader">3、babel-loader<a class="anchor" href="#3、babel-loader">·</a></h4><h5 id="功能：">功能：<a class="anchor" href="#功能：">·</a></h5><ul><li>babel-loader：解析es6的桥梁，需要通过插件翻译es5，如babel-perset<ul><li><p>chrome浏览器对于ES6中的很多用法都做了底层实现，所以打包后的文件在chrome中打开ok，但如果在低版本的IE中打开就会出问题，因为他们根本就不认识这些ES6的代码，报错</p></li><li><p>如果能把ES6转成ES5，就能让浏览器都能识别了，babe-laoder就做了这样的工作：ES6 — ast ----ES5 —低版本的补充</p></li></ul></li><li>babel-core: babel的核心库，识别js代码，把js代码部分解析成ast，有些新语法在低版本js中不存在的，如箭头函数，rest参数，通过ast语法转换器分析其语法后转换低版本js。</li><li>babel-preset：代表一些类转码插件，提供预设，为es5转码。只能翻译一部分，所以还要babel-poly-fill</li><li>babel-poly-fill: 转换babel preset没有的es6新特性，打包js会变大。</li><li>transform-runtime:  babel-poly-fill 会污染全局变量，transform-runtime 转换es6时不会污染全局</li></ul><h5 id="实验1-文件配置方式">实验1:-文件配置方式<a class="anchor" href="#实验1-文件配置方式">·</a></h5><ul><li><p>安装：npm i babel-loader -D</p></li><li><p>配置导出文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新打包的dist：<strong>什么都没做，如果想做。必须指明插件，指明参数</strong>。so 导出文件需要重新配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [&#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">          <span class="string">&#x27;@babel/plugin-transform-arrow-functions&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;@babel/plugin-transform-block-scoping&#x27;</span> </span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样，不想要全家桶式的不用每次专门配置，也可以使用预设，就可以放心大胆用：此时配置方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [&#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]   <span class="comment">//需要提前安装</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这里打包出来的文件，会与browserlist支持的兼容想关联的，比如当你配置的希望只兼容支持的浏览器是很高很新版本，此时babel-loader转出来的语法可能就是ES6最新的。</p></li><li><p>还可以通过presets的参数的形式指定目标兼容：</p><p>此时bebel-loader最终结果会 {targets: 'chrome 91’为主，但只对当前loader有用。建议在browserlist方便管理，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">presets</span>: [[</span><br><span class="line">    <span class="string">&#x27;@babel/preset-env&#x27;</span>, </span><br><span class="line">    &#123;<span class="attr">targets</span>: <span class="string">&#x27;chrome 91&#x27;</span>&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="babel专门配置文件">babel专门配置文件<a class="anchor" href="#babel专门配置文件">·</a></h5><ul><li><p>方式1：<strong>babel.config.js</strong>（json、cjc、mjs）  现在babel是多包管理的方式，babelcore只是一个微内核，一个仓库下面有很多功能，每个功能一个包。这样的配置方式更适合一些    <strong>推荐</strong></p></li><li><p>方式2：babelrc.json （js） 在babel7之前用的较多，那时每个babel下边对应一个仓库，这样更符合</p></li><li><p>实验：</p><ul><li><p>lg.config.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>,]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>babel.config.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4、polyfill">4、polyfill<a class="anchor" href="#4、polyfill">·</a></h4><h5 id="是什么？">是什么？<a class="anchor" href="#是什么？">·</a></h5><p>填充预设不能做的事。</p><ul><li>假如在index.js中写了promise语法，我希望最终打包产出物中，<strong>应该要考虑到</strong>浏览器内部实现了promise，否则不能使用。所以，**polyfill就是能够实现这个功能的函数，能够对功能进行填充。**preset预设能帮我们做很多事情，但遇到Promise  generator 等更加新的语法时，可能不会做转换。而polyfill就会做这件事。</li></ul><ul><li><p>如果你不喜欢打包出来的文件是eval格式，可以在导出文件配置添加devtoo</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">+<span class="attr">devtool</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure></li></ul><ul><li>在4时，默认不做这些处理，已经加进去了。但这样打包后臃肿。5基于打包优化速度的考虑被移除，需要进行自己安装。</li></ul><h5 id="实验：">实验：<a class="anchor" href="#实验：">·</a></h5><ul><li><p>安装：npm i @babel/ployfill --s</p><ul><li><p>安装后提示：如果要使用，不建议直接安装了，而是引用core下面的stable   regenerator-runtime</p><p>tc39参与对ecma语法的制定，用core下面的stable是将已经制定的标准的加载进来。只要引进来，babel-loader就可以把功能填充过来。</p><p>当我们需要promise等，其实是基于generator实现等，而 regenerator-runtime引进来也可以进行填充</p></li></ul></li><li><p>卸载，polfill，安装这两个包：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i core-js regenerator-runtime</span><br></pre></td></tr></table></figure></li><li><p>配置babel单独配置文件：</p><ul><li><p>useBuiltIns：</p><ul><li><p>打包的过程中，useBuiltIns帮助我们可以根据业务需求来注入polifill里面的内容。</p></li><li><p>但你在开发一个内库、一个第三方模块的时候，组件库的时候，用这种注入是有问题的，它会通过全局变量的方式进行注入，会污染全局环境，</p></li><li><p>所以如果你在打包一个UI组件库的时候，你需要换一种配置</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 为什么要给preset-env设置参数呢？</span></span><br><span class="line">    <span class="comment">// babel是工具，本身不干，转换es6语法需要告诉：兼容谁-browserc文件</span></span><br><span class="line">    <span class="comment">// 需要：找人完成真正的兼容  --插件的集合preset-env</span></span><br><span class="line">    <span class="comment">// 问题：preset-env不能完成所有功能转换 --polyfill</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">        <span class="comment">// 传参时是以数组，一组组的</span></span><br><span class="line">        [</span><br><span class="line">            <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="comment">// 取值： false默认、usage（根据用户源代码当中所使用到的新语法  按需填充）看代码不看浏览器</span></span><br><span class="line">               <span class="comment">// 功能：FALSE：不对当前的JS做poll填充</span></span><br><span class="line">               <span class="comment">// useBuiltIns: false</span></span><br><span class="line">              </span><br><span class="line">      <span class="comment">//取值： usage（按需填充）：对版本有要求  默认2  如果安得是3 报错 ，so还需配置版本corejs</span></span><br><span class="line">                <span class="comment">// useBuiltIns: &#x27;usage&#x27;,</span></span><br><span class="line">               <span class="comment">//  corejs: 3</span></span><br><span class="line">              </span><br><span class="line">   <span class="comment">//取值： entry: 依据所要兼容的浏览器进行填充 看浏览器不用代码</span></span><br><span class="line">   <span class="comment">// 比如要兼容10款浏览器，它不管代码里用没用  只要10个需要啥就填充啥</span></span><br><span class="line">   <span class="comment">//  安装后 需要手动import引入过来 否则会不生效</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>usage需要注意：开发时可能会用第三方的包，这个包可能也需要polyfill，假如它用了promise，我自己可能也用promise。so  我们需要加配置，去掉node_modules内的东西：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  <span class="attr">exclude</span>: <span class="string">&#x27;/node_modules/&#x27;</span>,   <span class="comment">// 不要对包ployfill</span></span><br><span class="line">  <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="业务代码的使用场景：">业务代码的使用场景：<a class="anchor" href="#业务代码的使用场景：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install @babel/core @babel/preset-env </span><br><span class="line">npm install --save @babel/polyfill</span><br><span class="line"></span><br><span class="line">index.<span class="property">js</span> 引入 <span class="keyword">import</span> <span class="string">&quot;@babel/polyfill&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  <span class="comment">// 第三方库的文件是没有必要做这个的</span></span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">             <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">               <span class="string">&quot;@babel/preset-env&quot;</span>, </span><br><span class="line">               &#123; </span><br><span class="line">                 <span class="attr">targets</span>: &#123;<span class="attr">chrome</span>: <span class="string">&quot;67&quot;</span>,&#125;,  <span class="comment">// 比如chrome版本67以上的，不要做转化了</span></span><br><span class="line">  <span class="comment">// 用 babel-poly-fill 会转化所有低版本没有的es6语法，会加大打包文件大小。</span></span><br><span class="line"><span class="comment">// 用 &#123; useBuiltIns: &#x27;usage&#x27; &#125;，仅转换使用的es6语法从而减小打包文件大小。可以不引入babel-poly-fill 该配置自动转换es6用的语法。</span></span><br><span class="line">                <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>  <span class="comment">//按需引入</span></span><br><span class="line">               &#125;</span><br><span class="line">             ],   </span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="库项目代码，不存在全局污染">库项目代码，不存在全局污染<a class="anchor" href="#库项目代码，不存在全局污染">·</a></h5><ul><li>babel涉及的内容更深层次，甚至比webpack更多，源码里讲了这种转换过程是如何实现的</li><li>打包的过程中，useBuiltIns帮助我们可以根据业务需求来步入polifill里面的内容。但你在开发一个内库、一个第三方模块的时候，组件库的时候，用这种注入是有问题的，它会通过全局变量的方式进行注入，会污染全局环境，所以如果你在打包一个UI组件库的时候，你需要换一种配置</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="string">&quot;plugins&quot;</span>: [[</span><br><span class="line">                      <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">                      &#123;  <span class="comment">//默认false，改为2需额外安包@babel/runtime-corejs2</span></span><br><span class="line">                          <span class="string">&quot;corejs&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                          <span class="string">&quot;helpers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                          <span class="string">&quot;regenerator&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                          <span class="string">&quot;useESModules&quot;</span>: <span class="literal">false</span></span><br><span class="line">                      &#125;</span><br><span class="line">                  ]</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> * 配置 &#123;<span class="attr">corejs</span>: <span class="number">2</span> &#125;作用有时<span class="title class_">Babel</span>可能会在输出中注入一些相同的代码，因此可能会重复使用。使用类转换（没有松散模式）</span><br><span class="line">    </span><br><span class="line">③ 如果私有功能：可以使用babel-poly-fill</span><br><span class="line">  如果是库功能：使用transfrom-runtime，来规避全局变量冲突。</span><br><span class="line"></span><br><span class="line">④ 插件配置优化，单独提出公共文件 </span><br><span class="line">  根目录里创建babelrc 文件  把options里面的代码都拿出来，放在这个文件里</span><br><span class="line">  让插件config内容写入：</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">&quot;corejs&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">&quot;helpers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;regenerator&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;useESModules&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四、plugins">四、plugins<a class="anchor" href="#四、plugins">·</a></h2><p>插件用来干什么呢？你如说，我们更改了配置项，就需要删除dist目录，重新打包生成编译产物，再运行；再比如我们每次打包完成后，每次都要手动修改，也比较麻烦。插件就能帮我们做这些</p><ul><li><p>当有插件时，为什么还会有loader呢？</p><p>核心功能不同</p><ul><li><p>对loader而言，它主要是对特定类型的（非JS）模块进行转换。而loader就承担了这些识别转换的功能。工作的时机就是读取某个特定类型的资源时</p></li><li><p>而插件，可以做的更多。它同样存在自己的生命周期，我们可以认为打包的过程就是一个完整的流水线，那么当前的插件可以在流水线上的任一时机被插进来。比如说，我们希望在打包开始时做一些事情，或在打包进行到某一时机点做些事情，再比如希望写。而loader并不满足这种需求</p></li></ul></li></ul><h3 id="1、clean-webpack-plugin">1、clean-webpack-plugin<a class="anchor" href="#1、clean-webpack-plugin">·</a></h3><p>自动清除打包目录dist：让你不用每次手动清除</p><ul><li><p>实验：</p><ul><li><p>本地安装：clean-webpack-plugin</p></li><li><p>配置：一般plugin的书写：添加plugins</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">     <span class="comment">// 将来在这里写的时候，就是一个plugin，</span></span><br><span class="line">  <span class="comment">// 每个plugin本质就是一个类：自己安装的插件 </span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">myPlugin</span> &#123;</span><br><span class="line">    <span class="comment">// new 的时候会执行的方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="comment">// 允许传的时候传入参数this等</span></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>配置：lg.config.js配置文件的导出文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入插件</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">CleanWebpackPlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line">在导出配置中：</span><br><span class="line"><span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(), <span class="comment">// 内部具体实现去看github官网]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2、html-webpack-plugin">2、html-webpack-plugin<a class="anchor" href="#2、html-webpack-plugin">·</a></h3><ul><li><p>实验：</p><ul><li><p>本地安装：html-webpack-plugin</p></li><li><p>配置：lg.config.js配置文件的导出文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(), </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>打包出的index.html 中的title默认：Webpack App。默认的值与该插件中文档规定过有关，我们可以在new的时候传入参数，定义打包生成的index.html的信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;html-webpack-plugin自定义&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>自定义index.html模板：比如说Vue中所有组件都需要挂载在#app的div上，so需要自定义的样式</p><ul><li><p>新建<strong>public文件夹</strong>，新建index.html文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;title&gt;</span><br><span class="line">  &lt;%= htmlWebpackPlugin.<span class="property">options</span>.<span class="property">title</span> %&gt;  <span class="comment">// 不能随便写或不写，不写传参不生效</span></span><br><span class="line">  &lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>index.html测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>修改配置信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;html-webpack-plugin自定义&#x27;</span>,</span><br><span class="line">  <span class="comment">// 希望打打包时找到自己的模板</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>实验：希望实现像Vue那样的模板，引入资源：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> // 这里的路径是常量</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;icon&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;&quot;</span><span class="attr">favicon.ico</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">        &lt;%= htmlWebpackPlugin.options.title %&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>index.html测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>webpack-define-plugin  内置插件：允许我们往插件中填充数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">DefinePlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)   <span class="comment">// 内置</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 内部可以定义常量，就是键值对</span></span><br><span class="line"><span class="comment">// DefinePlugin配置完成后，会把我们设置的值原封不动拿出去</span></span><br><span class="line"><span class="comment">// 将来如果我们希望以字符串的形式出去，还需要包一层引号</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line"><span class="attr">BASE_URL</span>: <span class="string">&quot;&#x27;./&#x27;&quot;</span>   <span class="comment">// 会去public目录下去查找</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>打包生成结果：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;测试icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./&quot;</span> <span class="attr">favicon.ico</span>&gt;</span>  // 已生效</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>html-webpack-plugin自定义<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/dist/build.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>index.html测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、copy-webpack-plugin">3、copy-webpack-plugin<a class="anchor" href="#3、copy-webpack-plugin">·</a></h3><h5 id="背景：">背景：<a class="anchor" href="#背景：">·</a></h5><ul><li>无论是自己使用webpack打包，还是基于脚手架  内部都有一个基于资源拷贝问题：public里面会存放很多资源，但不希望w对其做打包操作。只需要w打包后能够产生一个自定义的静态资源目录：将来可以将静态资源目录在服务器上部署。我们希望能将这部分直接拷贝过去</li><li>而之前的plugin，只是基于入口文件：src下的index.js生成一个静态HTML文件，但是文件里可能会通过src引入图标，文档等都不能进行处理。so  我们希望对静态资源做拷贝   copy-webpack-plugin</li></ul><h5 id="实验">实验<a class="anchor" href="#实验">·</a></h5><ul><li><p>安装：npm i copy-webpack-plugin -d</p></li><li><p>配置：lg.config.js的plugin</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CopyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="comment">// patterns是数组，里面可以放很多项配置拷贝项</span></span><br><span class="line">            <span class="attr">patterns</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">from</span>: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">                    <span class="comment">// to：默认不写，会自动找output配置中设计的目录</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><ul><li><p>不能直接这样写，因为之前的webpack配置过  将public下的index.html作为模板拷贝到dist目录下，这里又去做了这样类似的事。因此，不是所有的东西都需要拷贝时，可以排除：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">from</span>: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">   <span class="comment">// to：默认不写，会自动找output配置中设计的目录</span></span><br><span class="line">   <span class="attr">globOptions</span>: &#123;</span><br><span class="line">     <span class="attr">ignore</span>: [<span class="string">&#x27;index.html&#x27;</span>]  <span class="comment">//忽略不想拷贝的东西</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>但仍然有问题：坑，当前 from: ‘public’,要求必须写**/</p></li><li><p>遇到版本坑：打包时报错：HookWebpackError: Invalid host defined options  降级到9版本</p><p>https://stackoverflow.com/questions/70080671/copy-webpack-plugin-error-invalid-host-defined-options</p></li></ul></li></ul><h3 id="4、dev-sever">4、dev-sever<a class="anchor" href="#4、dev-sever">·</a></h3><h4 id="1、背景：">1、背景：<a class="anchor" href="#1、背景：">·</a></h4><p>当你的项目开发到一定阶段了，想调试。</p><ul><li><p>做法1：</p><ul><li><p>npm run build  产出静态资源到dist目录。此时dist下面有index.html，此时将它放在浏览器运行就可以了</p></li><li><p>这是在使用file协议直接看，只要出现更新后，手动进行更新</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file:///Users/zhoumoling/kaifa/test/babel/dist/index.html</span><br></pre></td></tr></table></figure></li></ul></li><li><p>做法2：使用插件liver server  自动更新 不用手动刷新</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:5500/dist/index.html</span><br></pre></td></tr></table></figure><p>此时接着修改代码，我希望能看到最新的修改效果。但是看不到，因为打包产物没有变。</p></li></ul><p>so，希望有人能帮忙做到这样的事情：<strong>当文件下面变更后，能自动帮我们完成编译，结合liver server 将生成的内容展示出来</strong></p><h4 id="2、实时打包更新">2、实时打包更新<a class="anchor" href="#2、实时打包更新">·</a></h4><h5 id="模式1：watch命令">模式1：watch命令<a class="anchor" href="#模式1：watch命令">·</a></h5><ul><li><p>修改package.json：添加watch</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config lg.config.js --watch&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>此时它会监控项目下面的文件，只要打包的文件发生变化，就会自动重新打包，刷新页面就是最新生成的</p></li><li><p>但它不够好，我希望你不仅自动打包，<strong>还能自动打开浏览器，还能模拟服务器上的特性</strong>，它做不到 要借助—devserver</p></li></ul><h5 id="模式2：配置文件">模式2：配置文件<a class="anchor" href="#模式2：配置文件">·</a></h5><ul><li><p>lg.config.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ <span class="attr">watch</span>: <span class="literal">true</span>,   <span class="comment">//默认watch是fasle，这是出于性能的考虑。</span></span><br><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line"><span class="attr">devtool</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure></li></ul><h5 id="不足分析：">不足分析：<a class="anchor" href="#不足分析：">·</a></h5><p>分析：当前2种模式能实现更新，但不是效率最优。跟dev-server比还有不足：</p><ul><li>这种模式需要watch+dev-server（webpack内置了dev-server）的加持，某个文件发生了改变都会使得webpack<strong>重新编译所有代码</strong></li><li>CleanWebpackPlugin：每次编译时都会帮我们去重新生成新的dist目录，将产物、静态资源写入。消耗性能</li><li>liver server是vscode生态下的插件，不是webpack的</li><li>模块化开发需要很多组件，<strong>当修改一小部分组件时，全部组件都更新，so不能实现局部刷新</strong>。而webpack中给的<strong>dev-server能做到局部刷新</strong></li></ul><h5 id="模式3：devServer">模式3：devServer<a class="anchor" href="#模式3：devServer">·</a></h5><ul><li><p>配置package.json:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 在5以后，这里需要将命令写全</span></span><br><span class="line"><span class="string">&quot;serve&quot;</span>: <span class="string">&quot;webpack serve&quot;</span></span><br><span class="line"><span class="comment">// 如果不配置config  否则localhost访问的是当前项目的目录展示</span></span><br><span class="line"><span class="string">&quot;serve&quot;</span>: <span class="string">&quot;webpack serve  --config lg.config.js&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件中：w5中没有这些配置了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="attr">devServer</span>: &#123;</span><br><span class="line">   <span class="comment">// contentBase：服务器要在哪个文件夹下开启，因为我们打包在dist下，所以这样写</span></span><br><span class="line">  <span class="attr">contentBase</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>,   <span class="comment">//在运行npm run serve开启服务时， webpack-dev-server会被启动，open会自动的打开浏览器，自动的访问8080端口的内容</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">8000</span>(默认端口<span class="number">8080</span>，如果你想要修改，可以添加此配置)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>它同样是跟live server一样开启了一个静态服务，占用端口8080。当前目录下并没有产出dist目录，而是将数据都写入了内存中，内存的操作读写<strong>速度更快</strong></p></li><li><p>遇到的问题：</p><p>我index.js下写的东西并没有展示出来，修改也不会有所改变，这是为什么呢？</p><p>Content not from webpack is served from ‘/Users/zhoumoling/kaifa/test/babel/public’ directory</p><p>https://stackoverflow.com/questions/42712054/content-not-from-webpack-is-served-from-foo</p></li></ul><h3 id="5、webpack-dev-middleware">5、webpack-dev-middleware<a class="anchor" href="#5、webpack-dev-middleware">·</a></h3><p>可以用来追求自由度更高的模式，但在开发阶段使用过的较少：</p><h4 id="实验-2">实验<a class="anchor" href="#实验-2">·</a></h4><ul><li><p>实现逻辑：</p><p>期望浏览器可以访问一个静态资源：比如8080端口，而这个服务是由middleware来开启这个服务。webpack会将其打包之后的内容交给服务器，服务器监听某个端口上的请求，如果浏览器往这个端口上发送了相应的请求，那就可以将这个结果返回给浏览器展示：</p></li><li><p>要解决问题1：怎么样开启一个服务？可以node-js。也可以借助框架。express</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i express@4.17.1 -d</span><br></pre></td></tr></table></figure></li><li><p>要解决的问题2：怎样把webpack打包之后的结果交给server？</p><p>框架中间件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i webpack-dev-middleware@5.0.0 -d</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个服务，帮我们加载中间件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让webapck可以打包:这个函数拿到配置参数后，会调用 ... </span></span><br><span class="line"><span class="comment">// 返回compare对象，它控制weback的打包流程</span></span><br><span class="line"><span class="comment">// 1. 获取配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./lg.config.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> compiler = <span class="title function_">webpack</span>(config)</span><br><span class="line"><span class="comment">// 2. 打包完成后，将结果交给server</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">webpackDevMiddleware</span>(compiler))</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务运行在3000端口上&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="实现一个dev-server：">实现一个dev-server：<a class="anchor" href="#实现一个dev-server：">·</a></h4><ul><li><p>创建webpack打包判断文件</p></li><li><p>安装webpack中间件        npm i express webpack-dev-middleware -d</p></li><li><p>创建server.js：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);       <span class="comment">// 首先引入webpack库</span></span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用webpack结合配置文件，随时进行代码的编译器，编译器执行一次就会编译一次</span></span><br><span class="line"><span class="keyword">const</span> complier = <span class="title function_">webpack</span>(config);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();    <span class="comment">// 通过express启动一个服务器</span></span><br><span class="line"><span class="comment">// 通过webpack 中间件webpackDevMiddleware监听文件变化，然后重新执行打包 complier</span></span><br><span class="line"><span class="comment">// 第2个参数是对象，只要文件发生改变了，重新输出文件就是config.output.publicPath</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">webpackDevMiddleware</span>(complier, &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: config.<span class="property">output</span>.<span class="property">publicPath</span></span><br><span class="line">&#125;))</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is running&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>package.json文件修改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 当我运行npm run server的时候，我想自己写一个服务器。</span></span><br><span class="line">        <span class="comment">// 当监听到src下面的文件有改变，它会向dev-server重启一个服务器，更新网页内容</span></span><br><span class="line">            <span class="string">&quot;server&quot;</span>: <span class="string">&quot;node server.js&quot;</span>  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、性能优化">五、性能优化<a class="anchor" href="#五、性能优化">·</a></h2><h3 id="0、总结">0、总结<a class="anchor" href="#0、总结">·</a></h3><h4 id="webpack性能：">webpack性能：<a class="anchor" href="#webpack性能：">·</a></h4><ul><li><p>开发环境性能优化：</p><p>① 优化打包构建速度:HMR</p><p>② 优化代码调试:source-map</p></li><li><p>生产环境性能优化</p><p>① 优化打包构建速度：oneOf、babel缓存、多进程打包、externals、dll</p><p>② 运行性能：缓存、tree shaking、code split、懒加载/预加载、pwa</p></li></ul><h3 id="1-HMR优化">1- HMR优化<a class="anchor" href="#1-HMR优化">·</a></h3><h4 id="功能：-2">功能：<a class="anchor" href="#功能：-2">·</a></h4><ul><li><p>作用：在运行时更新各种模块，而无需进行完全刷新。极大的提升开发模式中构建速度</p></li><li><p>特点：</p><ul><li>之前打包后的文件都会放在dist目录上面</li><li>但用webpack-dev-server后，为了让打包更快，是将打包后的文件放在内存中，实际上是有dist目录的</li></ul></li><li><p>对于不同的文件：</p><ul><li><p>样式文件：<strong>可以使用HMR功能:因为<code>style-loader</code>内部实现了</strong></p></li><li><p>js文件：默认不能使用HMR功能  需要<code>修改js代码</code>,添加支持HMR功能的代码</p></li><li><p>html文件：默认不能使用HMR功能，会导致问题:html文件不能热更新了解决：<code>修改entry入口</code>,将html文件引入(不用做HMR功能,毕竟现在流行单页面应用)</p></li><li><p>Vue\React：</p><p>在Vue中，在写js文件的时候也从来不会去写上面那一坨代码，是因为vue-loader也已经帮我们做了。而React是借助了babel-preset，里面也内置了这种HMR的组件。但如果在项目中引入了一些比较偏的文件，比如说数据文件，这些文件的loader里并没有内置HMR效果，我们还需要手动写这样的代码。</p></li></ul></li></ul><h4 id="修改代码：">修改代码：<a class="anchor" href="#修改代码：">·</a></h4><ul><li><p>配置文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">     <span class="attr">contentBase</span>:<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;build&#x27;</span>),<span class="comment">//项目构建后路径</span></span><br><span class="line">     <span class="attr">compress</span>:<span class="literal">true</span>, <span class="comment">//启动gzip压缩</span></span><br><span class="line">     <span class="attr">open</span>:<span class="literal">true</span>,<span class="comment">//自动打开浏览器</span></span><br><span class="line">     <span class="attr">hot</span>:<span class="literal">true</span> <span class="comment">//开启HMR功能,注意:当修改了webpack功能,新配置想要生效,必须重启webpack</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>js进行HMR优化：</p><p>注意:你要监听进行<code>热模块替换</code>,前提是你这个js要<code>在入口文件中导入</code>,然后入口文件中才能监听得到变化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> print <span class="keyword">from</span> <span class="string">&#x27;./print&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;./test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="comment">// 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>([<span class="string">&#x27;./print.js&#x27;</span>,<span class="string">&#x27;./test.js&#x27;</span>], <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//只有一个js文件需要监听打包就直接输入url字符串,不用数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假如有相关DOm操作，记得先移除上次的// document.body.removeChild(document.getElementById(&quot;number&quot;), number())</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;前提是你要在入口文件上导入,才能监听得到变化&quot;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-source-map-优化">2- source-map 优化<a class="anchor" href="#2-source-map-优化">·</a></h3><h4 id="功能：-3">功能：<a class="anchor" href="#功能：-3">·</a></h4><ul><li>提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）分为<code>内联</code>与<code>外部</code>:</li><li>内联和外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快</li></ul><h4 id="不同环境选择">不同环境选择:<a class="anchor" href="#不同环境选择">·</a></h4><ul><li><p><code>开发环境</code>：考虑 速度快，调试更友好① 速度快(eval&gt;inline&gt;cheap&gt;…):  eval-cheap-souce-map &gt; eval-source-map</p><p>​    ② 调试更友好: souce-map &gt; cheap-module-souce-map &gt; cheap-souce-map</p><p>​    ③ 最优选–&gt; <code>eval-source-map</code>  &gt; eval-cheap-module-souce-map</p></li><li><p><code>生产环境</code>：考虑 源代码要不要隐藏? 调试要不要更友好</p><p>​ ① 内联会让代码体积变大，所以在生产环境不用内联</p><p>​     ② 考虑隐藏:nosources-source-map 全部隐藏 &gt;hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</p><p>​     ③ 综合考虑:source-map <code>or</code> cheap-module-souce-map</p></li><li><p>推荐：</p><ul><li>dev环境: cheap-module-eval-source-map  提示错误全，打包速度快</li><li>prod环境: cheap-module-source-map    上线的代码不用映射，但是一旦线上出问题也能提示</li></ul></li></ul><h4 id="配置：">配置：<a class="anchor" href="#配置：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: [],</span><br><span class="line">  <span class="attr">output</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123; <span class="attr">rules</span>: [] &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;&#125;,</span><br><span class="line">   <span class="comment">//选定映射模式</span></span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;eval-source-map&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-oneOf">3-oneOf<a class="anchor" href="#3-oneOf">·</a></h3><h4 id="功能：-4">功能：<a class="anchor" href="#功能：-4">·</a></h4><ul><li><p>正常来说,一个文件会被所有的loader过滤处理一遍</p></li><li><p>而使用<code>oneOf</code>后,而如果放在<code>oneOf</code>中的loader规则有一个匹配到了,<code>oneOf</code>中的其他规则就不会再对这文件匹配</p></li><li><p><code>注意</code>:oneOf中不能有两个loader规则配置处理同一种文件,否则只能生效一个</p><p>例如，对于js进行eslint检测后再进行babel转换</p><p>解决：将eslint抽出到外部,然后优先执行,这样在外部检测完后<code>oneOf</code>内部配置就会再进行检测匹配</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,    <span class="comment">//将eslint抽出到外部</span></span><br><span class="line">    <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>, <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 以下loader只会匹配一个 // 注意：不能有两个配置处理同一种类型文件</span></span><br><span class="line">    <span class="attr">oneOf</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [...commonCssLoader]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [...commonCssLoader, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [</span><br><span class="line">            [</span><br><span class="line">              <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">                <span class="attr">corejs</span>: &#123;<span class="attr">version</span>: <span class="number">3</span>&#125;,</span><br><span class="line">                <span class="attr">targets</span>: &#123;</span><br><span class="line">                  <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                  <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="4-缓存">4-缓存<a class="anchor" href="#4-缓存">·</a></h3><p>缓存需要在<code>server环境</code>中才有效果</p><h4 id="缓存类型">缓存类型<a class="anchor" href="#缓存类型">·</a></h4><p>1、babel缓存:</p><ul><li>在<code>babel</code>的loader选项部分添加 <code>cacheDirectory: true</code> --&gt;让第二次打包构建速度更快</li></ul><p>2、文件资源缓存:</p><ul><li>当你文件名不变时，会默认读取本地缓存。所以当你修改某个文件内容后，并不能实时更新到线上项目中</li><li>解决方法：在每次webpack构建时生成一个唯一的hash值加在文件名中，每次修改便改动文件名，达到更新效果。</li><li>而不同的hash也有不同效果,其中需要选用<code>contenthash</code></li></ul><h4 id="contenthash">contenthash<a class="anchor" href="#contenthash">·</a></h4><p>① hash：每次webpack构建时会生成一个唯一的hash值</p><p>​问题：因为js和css同时使用<code>同一个hash值</code>，如重新打包，会导致所有缓存失效(即使只改动了一个文件)</p><p>② chunkhash：根据chunk生成的hash值，如果打包来源于同一个chunk，那么hash值就一样</p><p>​    问题：js和css的hash值还是一样**, 因为css时在js中被引入的,所以属于同一个chunk**</p><p>③ <code>contenthash</code>：根据文件的内容生成hash值，不同的文件hash一定不一样</p><p>​--&gt;让代码上线运行缓存更好使用(当你线上项目出现紧急BUG时,可以更快的修改)</p><h4 id="实验：-2">实验：<a class="anchor" href="#实验：-2">·</a></h4><ul><li><p>webpack配置文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/built.[contenthash:10].js&#x27;</span>,  <span class="comment">//使用contenthash哈希值</span></span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">presets</span>: [</span><br><span class="line">                [<span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                 &#123; <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>, <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;, <span class="attr">targets</span>: &#123;<span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,<span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span>&#125;&#125; ]</span><br><span class="line">              ],</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 第二次构建时，会读取之前的缓存  // 开启babel缓存</span></span><br><span class="line">              <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          </span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [   </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123; <span class="attr">filename</span>: <span class="string">&#x27;css/built.[contenthash:10].css&#x27;</span> &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>server.js代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// express.static向外暴露静态资源</span></span><br><span class="line"><span class="comment">// maxAge 资源缓存的最大时间，单位ms</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;build&#x27;</span>, &#123; <span class="attr">maxAge</span>: <span class="number">1000</span> * <span class="number">3600</span> &#125;));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-tree-shaking">5-tree shaking<a class="anchor" href="#5-tree-shaking">·</a></h3><h4 id="概念：-3">概念：<a class="anchor" href="#概念：-3">·</a></h4><ul><li>移除 JS上下文中的未引用代码(dead-code)，不要引入所有的，只要需要的，减少代码体积</li><li>使用前提：<ol><li>只支持ES module这种静态引入 如export 但不支持commonJS，require 动态引入</li><li>开启production环境</li><li>w4中,对于嵌套的代码,无法去除</li></ol></li></ul><h4 id="使用：-4">使用：<a class="anchor" href="#使用：-4">·</a></h4><ul><li><p>webpack.config.js配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">   <span class="attr">useExports</span>: <span class="literal">true</span>    <span class="comment">//打包使用部分</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>package.json</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;sideEffects&quot;</span>: <span class="literal">false</span>,<span class="comment">// 禁止tree-shaking 处理不向外暴露方法的插件,将文件标记副作用</span></span><br></pre></td></tr></table></figure><ul><li><p>tree-shaking 会处理没有暴露方法的插件，如 @babel-poly-fill。会使打包报错。</p><p>@babel-poly-fill 是在window上绑定es6语法 如window,pormise，不会向外暴露方法，不是直接导出模块的，treeshaking可能会误认为这个是用不到的，就不打包，会报错</p></li><li><p>所以配置如下解决问题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;sideEffects&quot;</span>: [<span class="string">&#x27;@babel-poly-fill&#x27;</span>, <span class="string">&#x27;*css&#x27;</span>] </span><br><span class="line"><span class="comment">// 或针插件配置如下：  tree-shaking不会处理该插件</span></span><br><span class="line"><span class="comment">// 而如果你引入的是.css文件，也不会有导出文件，所以css文件也不要使用tree shaking</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：</p><ul><li>tree shaking中export used会表现出树摇之后引用的模块，而不是直接删掉没有引用的代码</li><li>这是为了便于调试开发环境下的</li><li>但如果是production，想打包上线的话，记得更改mode、sourcemap、也不用写optimization，树摇会自动生效</li><li>重新打包后，此时线上的代码就是树摇之后的，已经剔除了不需要的代码</li></ul></li></ul><h3 id="6-code-split">6-code split<a class="anchor" href="#6-code-split">·</a></h3><h4 id="1、多入口与单入口打包">1、多入口与单入口打包<a class="anchor" href="#1、多入口与单入口打包">·</a></h4><ul><li><p>通常不使用这个方法,一般使用2、3的方法；</p></li><li><p>多入口：有一个入口，最终输出就有一个bundle</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry: &#x27;./src/js/index.js&#x27;,       // 单入口</span></span><br><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">  <span class="comment">// 多入口：有一个入口，最终输出就有一个bundle</span></span><br><span class="line">  <span class="attr">index</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="string">&#x27;./src/js/test.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// [name]：取文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/[name].[contenthash:10].js&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、splitChunks">2、splitChunks<a class="anchor" href="#2、splitChunks">·</a></h4><ul><li><p>可以将node_modules中代码单独打包一个chunk最终输出</p></li><li><p>自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk(多入口文件)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">  <span class="comment">// 多入口：有一个入口，最终输出就有一个bundle</span></span><br><span class="line">  <span class="attr">index</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="string">&#x27;./src/js/test.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// [name]：取文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/[name].[contenthash:10].js&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="comment">// 将当前模块的记录其他模块的hash单独打包为一个文件 runtime</span></span><br><span class="line"> <span class="comment">// 解决：修改a文件导致b文件的contenthash变化</span></span><br><span class="line">  <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="function"><span class="params">entrypoint</span> =&gt;</span> <span class="string">`runtime-<span class="subst">$&#123;entrypoint.name&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、单入口文件">3、单入口文件<a class="anchor" href="#3、单入口文件">·</a></h4><p>单入口文件且想打包特定js文件为单独文件,在<code>2</code>的配置基础上再写js代码(入口改为单入口)</p><ul><li><p><code> 通过js代码</code>，让某个文件被单独打包成一个chunk，该代码写在入口js文件中</p></li><li><p><code>import动态导入语法</code>：能将某个文件单独打包</p></li><li><p><code>通过注释</code>,可以让js生成的打包文件带上这个名字，在<code>webpack5</code>中的<code>开发模式中可以不用注释加名字</code>,内部有 chunk 命名规则，不再是以 id(0, 1, 2)命名了，当然生产模式还是有必要的</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过注释,可以让js生成的打包文件带上这个名字</span></span><br><span class="line"><span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27; */</span><span class="string">&#x27;./test&#x27;</span>)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; mul, count &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mul</span>(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件加载失败~&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="7-懒加载、预加载">7- 懒加载、预加载<a class="anchor" href="#7-懒加载、预加载">·</a></h3><h4 id="场景：">场景：<a class="anchor" href="#场景：">·</a></h4><ul><li><p>当我们模块很多时，导入的js太多，或者有的js只有使用的时候才有用，而我一开始便加载，就可能造成一些不必要的性能浪费</p></li><li><p>懒加载：当文件需要使用时才加载</p><p><code>可能的问题</code>：当用户第一次使用时，如果js文件过大可能加载时间过长(有延迟)。</p><p>但第二次就不会了，因为懒加载第二次是从缓存中读取文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import &#123; mul &#125; from &#x27;./test&#x27;;</span></span><br><span class="line"><span class="comment">//懒加载</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//懒加载其实也是需要前面Ⅵ代码分割功能,将我的需要加载的文件打包成单独文件</span></span><br><span class="line">  <span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27;*/</span><span class="string">&#x27;./test&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mul</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>预加载 prefetch：等其他资源加载完毕，浏览器空闲了再偷偷加载</p><ul><li>正常加载可以认为时并行加载(同一时间加载多个文件，但是同一时间有上限)</li><li>例如下面例子，有预加载的代码运行效果。页面刷新后，但还未进行使用时，该文件其实已经加载好了</li></ul><p>​    <code>注意</code>：预加载虽然性能很不错，但需要浏览器版本较高，兼容性较差，<code>慎用预加载</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import &#123; mul &#125; from &#x27;./test&#x27;;  //预加载</span></span><br><span class="line"><span class="comment">//在注释参数上添加 webpackPrefetch: true </span></span><br><span class="line">  <span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27;, webpackPrefetch: true */</span><span class="string">&#x27;./test&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mul</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="8-externals">8-externals<a class="anchor" href="#8-externals">·</a></h3><blockquote><p>当你使用外部引入代码时:如<code>CDN引入</code>，不想他将我引入的模块也打包，就需要添加这个配置</p><p>即:声明哪些库是不进行打包的</p><p>–&gt;<code>externals</code>: {}</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">externals</span>: &#123;</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span>      <span class="comment">// 拒绝jQuery被打包进来</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="六、通用、开发、生产">六、通用、开发、生产<a class="anchor" href="#六、通用、开发、生产">·</a></h2><h3 id="1、通用配置">1、通用配置<a class="anchor" href="#1、通用配置">·</a></h3><ul><li><p>webpack.config.js  webpack的配置文件：</p><p>作用: 指示 webpack 干哪些活（当你运行 webpack 指令时，会加载里面的配置）</p><p>所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader的配置  loader: 1. 下载   2. 使用（配置loader）</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细loader配置,如样式打包修改这里</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugins的配置  1. 下载  2. 引入  3. 使用</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 详细plugins的配置 如:html打包配置这里</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、开发环境配置">2、开发环境配置<a class="anchor" href="#2、开发环境配置">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">        <span class="comment">//1.1 处理less资源</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [ <span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//1.2 处理css资源</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//2.1 处理图片资源</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="comment">//压缩后的文件名   压缩后保留后缀名</span></span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="comment">//关闭es6模块化</span></span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">//在built文件中输入位置,这里是放在build中的imgs文件夹中</span></span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//2.2 处理html中的图片资源</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//处理其他资源 先排除以下几个</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(html|js|css|less|jpg|png|gif)/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123; </span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,<span class="comment">// name 打包生成的hash串前10位，前名字 ext打包文件后缀</span></span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;[name].[ext]&#x27;</span>,   </span><br><span class="line">        <span class="attr">outputPath</span>: <span class="string">&#x27;./images&#x27;</span>   <span class="comment">// 打包后制定图片位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;<span class="comment">//打包HTML文件</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="comment">//热更新配置</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.2-基建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fs-文件目录读取</title>
      <link href="/posts/file-read.html"/>
      <url>/posts/file-read.html</url>
      
        <content type="html"><![CDATA[<h4 id="需求：">需求：<a class="anchor" href="#需求：">·</a></h4><p>Article页面有一个menu，其中有5个子menu，点击切换子subMenu，点击menuItem显示对应该Submenu下的.md文档的内容</p><h4 id="设计思路">设计思路<a class="anchor" href="#设计思路">·</a></h4><ul><li>posts文件夹下有很多5个子文件夹，每个文件夹下有4个.md文件</li><li>.md文档里的内容的目录结构与Article中的menu的subMenu是对应的，切换menu，点击menuItem显示对应该Submenu下的.md文档</li><li>我们需要读取每个子文件夹里的.md文档，并按照这种对应关系渲染在页面上</li><li>一些额外考虑的点：<ul><li>不希望对运营人员写文档时，做过多的约束。因此，没有对md文档内容本身做任何限制；</li><li>存放文档的位置：只需要进入既定的文件夹，填写或更新文档即可，方便后期维护</li></ul></li></ul><h4 id="具体实现：">具体实现：<a class="anchor" href="#具体实现：">·</a></h4><ul><li><p>在lib下新建文件post.js，在该文件定义读取文件的操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getAllPagePostsData</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>在要渲染的页面Article中渲染之前，借助在渲染页面之前获取数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> allPageData = <span class="title function_">getAllPagePostsData</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        allPageData</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取数据后，只需要显示借助ReactMarkdown将内容渲染出来即可</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">ReactMarkdown</span> remarkPlugins=&#123;[remarkGfm]&#125;&gt;&#123;markdownInfo.<span class="property">fileContents</span>&#125;&lt;/<span class="title class_">ReactMarkdown</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>getAllPagePostsData</code>d的实现过程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到当前目录</span></span><br><span class="line"><span class="keyword">const</span> postsDirectory = path.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;utils/posts/&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getAllPagePostsData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 拿到所有的子文件目录</span></span><br><span class="line">  <span class="keyword">const</span> subFileDir = fs.<span class="title function_">readdirSync</span>(postsDirectory, <span class="function">(<span class="params">err,files</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> allSubDir = [];</span><br><span class="line">      <span class="comment">//迭代器 异步变同步</span></span><br><span class="line">      (<span class="keyword">function</span> <span class="title function_">iterator</span>(<span class="params">i</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>( i == files.<span class="property">length</span>) <span class="keyword">return</span> allSubDir;</span><br><span class="line">          fs.<span class="title function_">stat</span>(postsDirectory + files[i],<span class="keyword">function</span> (<span class="params">err,stats</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(stats.<span class="title function_">isDirectory</span>())&#123;</span><br><span class="line">                  allSubDir.<span class="title function_">push</span>(files[i])</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="title function_">iterator</span>(i + <span class="number">1</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)(<span class="number">0</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 拿到所有子文件夹得所有md文档信息</span></span><br><span class="line">  <span class="keyword">const</span> allPageData = subFileDir.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取子文件夹中的文件</span></span><br><span class="line">      <span class="keyword">const</span> curPath = path.<span class="title function_">join</span>(postsDirectory, item)</span><br><span class="line">      <span class="keyword">const</span> fileNames = fs.<span class="title function_">readdirSync</span>(curPath)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 拿到一个子文件夹下的所有md文档相关信息：存在curPageAllPostsData里</span></span><br><span class="line">      <span class="keyword">const</span> curPageAllPostsData = fileNames.<span class="title function_">map</span>(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 从文件名中移除后缀.md，定义为文件对应的id</span></span><br><span class="line">          <span class="keyword">const</span> id = fileName.<span class="title function_">replace</span>(<span class="regexp">/\.md$/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="comment">// 获取文件路径    </span></span><br><span class="line">          <span class="keyword">const</span> fullPath = path.<span class="title function_">join</span>(curPath, fileName)</span><br><span class="line">          <span class="comment">// 读取文件内容</span></span><br><span class="line">          <span class="keyword">const</span> fileContents = fs.<span class="title function_">readFileSync</span>(fullPath, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">          <span class="comment">// 读取文件的修改时间</span></span><br><span class="line">          <span class="keyword">const</span> oriDate = fs.<span class="title function_">statSync</span>(curPath, fileName).<span class="property">ctime</span>+<span class="string">&#x27;&#x27;</span></span><br><span class="line">          <span class="comment">// 截取前面部分</span></span><br><span class="line">          <span class="keyword">const</span> modifyDate = oriDate.<span class="title function_">split</span>(<span class="string">&#x27;G&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">          <span class="comment">// 包裹一个文档需要的信息：id，修改时间，文档内容</span></span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">              id,</span><br><span class="line">              modifyDate,</span><br><span class="line">              fileContents</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> curPageAllPostsData.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>);</span><br><span class="line">        <span class="comment">// 在md文档的文件夹中，做了限制：每个md文档命名时必须指定第几个文件夹下的第几个文档</span></span><br><span class="line">        <span class="comment">// 第几个文件夹下的第几个文档在页面渲染Article中对应哪个Submenu下的menuItem</span></span><br><span class="line"><span class="comment">// 二者是匹配的，如果随便写，会导致渲染出来的顺序是乱的   渲染出来的顺序取决于当初文件读取顺序：我们限制了文件名命名就是为了让Article页面拿到的数据是有序对应的  </span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> allPageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="一些拓展：">一些拓展：<a class="anchor" href="#一些拓展：">·</a></h4><p>为了保证页面的渲染顺序，做法是限制文件命名方式，还有一些其他的做法可以参考</p><ol><li><p>限制md文档的书写格式：比如像插件gray-matter那样，必须在文档起初加限制：</p><p>优点：比较方便，我们可以直接拿到想要的信息等</p><p>缺点：必须按照约束的格式去写</p></li><li><p>在每个子文件夹上加上<code>config.js</code>文件，限制它读取文件之前先读该文件，而该文件中定义了文件读取规则：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 2.3-实现Tricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node、Antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改记录-1月</title>
      <link href="/posts/blogChange1.html"/>
      <url>/posts/blogChange1.html</url>
      
        <content type="html"><![CDATA[<h2 id="2022年1月最后一次博客魔改记录">2022年1月最后一次博客魔改记录<a class="anchor" href="#2022年1月最后一次博客魔改记录">·</a></h2><h3 id="已经改完的效果：">已经改完的效果：<a class="anchor" href="#已经改完的效果：">·</a></h3><ul><li><p>博客统计图，文章统计+网站访问统计</p></li><li><p>首页的日历：</p><ul><li>但我并不想放在首页，像自由放置在其他页面，我尝试在其他页面写一个墙，然后将配置中的enable_page更改为对应路由，但是失败了…</li><li>现在不想放了 有点占地方</li></ul></li><li><p>分类的模块：</p><ul><li>存在跟日历同样的需求</li></ul></li><li><p>分类页面的：如何设置子分类呢？我希望有更多级别</p></li><li><p>歌单加入：我最爱的Youngso Kim的指弹曲子收集在aplayer里啦，开心</p></li><li><p>看板娘调整：</p><p>之前的2次元不是我喜欢的效果，这次调整为想要的了。此处要感谢（可以清心），博主很Nice，耐心地教我配</p></li><li><p>加入旋转的小人效果，并且全部换成cdn引入的方式，之前我在本地引入的各种JS文件</p></li><li><p>踩坑：高版本的node 不支持require   node-fetch模块；</p><ul><li>更改方式1：全部升级；node-fetch 3以上&amp;&amp;&amp; node 12以上</li><li>更改方式2：我仍然不可以，so将node-fetch降级了2.6  切为package.json添加了type：module，使其支持require的引入方式</li></ul></li></ul><h3 id="以后待补充的效果：">以后待补充的效果：<a class="anchor" href="#以后待补充的效果：">·</a></h3><ul><li>日历、分类的其他页面迁移功能；</li><li>评论功能：<ul><li>主要是twikoo的功能+美化，有时间了买服务器再一起整</li></ul></li><li>githubActions的自动部署功能问题修复：<ul><li>现在遇到的问题：workflow构建成功，但是部分的样式并没有显示出来，部分样式显示异常；</li><li>疑问：hexo线上部署执行命令时，跟我本地部署时执行那些有什么不同吗？<ul><li>既然一样，它只是代替我做那些命令的事情，我们各自打包出来的有什么不同吗？？</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.1-记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>猫的报恩</title>
      <link href="/posts/cat.html"/>
      <url>/posts/cat.html</url>
      
        <content type="html"><![CDATA[<h1 id="center-猫的报恩-center"><center>猫的报恩</center><a class="anchor" href="#center-猫的报恩-center">·</a></h1><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/Project/猫的报恩-index.webp" alt="img" style="zoom: 100%;" /><h2 id="1-故事情节">1. 故事情节<a class="anchor" href="#1-故事情节">·</a></h2><p>主题曲：幻化成风（翻唱小手拉大手）</p>  <div style="position: relative; width: 100%; height: 0; padding-bottom: 20%;">    <iframe src="//music.163.com/outchain/player?type=2&id=482172" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>  </div><ul><li>故事片段：猫的报恩 &amp;&amp; 侧耳倾听</li></ul>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 60%;">      <iframe src="//player.bilibili.com/player.html?aid=55906649&bvid=BV1E4411G7m5&cid=97731871&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" >      </iframe>    </div><p>故事情节：描述一位平凡且善良的高中女生小春，在一次放学途中用棍网球拍把救了一只猫，意外开启了一趟奇幻冒险经历。小春救的是猫王国的王子，“猫王国度”的猫国王为了报答她，不断送她礼物（甚至还有老鼠），并邀请小春到猫王国作客，猫国王希望她嫁给猫王子。无助的小春向“猫咪事务所”的猫男爵（バロン）求助，遇到肥猫胖胖（ムタ）、乌鸦多多（トト）。突然，小春被一大群猫强行带往猫国，猫男爵和胖胖、多多紧追进入猫国。待在舒服的猫国中，小春渐渐地长出猫胡须和猫耳朵，快变成真正的猫了。在猫王的阻挠之下，小春、猫男爵和胖胖拼命的奔往迷宫出口，想让小春在天亮之前重回人类世界，否则将永远做猫。</p><h2 id="2-主要角色：">2.主要角色：<a class="anchor" href="#2-主要角色：">·</a></h2><h3 id="小春">小春<a class="anchor" href="#小春">·</a></h3><ul><li>一直暗恋的男生町田君；</li><li>奇幻冒险后找回了自己，喜欢上了猫男爵，并勇敢地向他表白</li><li>末段广美告知小春她一直暗恋的男生町田君和他的女朋友分了手，小春表示“现在已经没关系了。”</li></ul><h3 id="男爵">男爵<a class="anchor" href="#男爵">·</a></h3><ul><li>一只陶瓷猫，本名为“佛贝鲁‧冯‧吉金肯”(フンベルト・フォン・ジッキンゲン)，猫咪事务所所长；</li><li>长相帅气，有着沉稳的绅士个性又很聪明，拥有骑士精神</li><li>事务所里挂着一幅在《侧耳倾听》故事中与猫男爵为一对的女猫露意丝的画像：这个神秘的”地球屋“里，不仅有男猫爵，还有一座古董钟：两个苦苦相恋的国王和王后，可惜住在不同的世界，只有在十二点钟时，她才会从羊变回原本的样子，即使如此，国王还是每小时就会准时出现，等待王后…，这是一个很有趣的古董店</li></ul><h3 id="胖胖">胖胖<a class="anchor" href="#胖胖">·</a></h3><ul><li>猫男爵的朋友，本名为“雷纳多‧蒙”（ルナルド・ムーン）</li><li>外型巨大肥胖的白猫，贪吃，嘴巴说的虽有点恶劣但个性不坏。其实他是被猫王国通缉的重大要犯，因为他把猫王国的鱼吃的一点都不剩，此事件也是猫王国史上最恶名昭彰的事件。</li></ul><h3 id="多多">多多<a class="anchor" href="#多多">·</a></h3><ul><li>猫男爵的朋友，为一座乌鸦雕像，是只黑色的乌鸦，常常和胖胖斗嘴。</li></ul><h3 id="拿多露（超可爱的角色）">拿多露（超可爱的角色）<a class="anchor" href="#拿多露（超可爱的角色）">·</a></h3><h2 id="3-迷失自我，反而得不到爱">3. 迷失自我，反而得不到爱<a class="anchor" href="#3-迷失自我，反而得不到爱">·</a></h2><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/CSS/猫的报恩2.webp" alt="img" style="zoom: 60%;" /><ul><li><p>如果一个人真的爱你，他会让你做你自己</p></li><li><p>小春暗恋的男生同时被很多女生喜欢，而自己是永远看不到的存在；</p></li><li><p>在经历一系列事情后，小春拒绝了那个懒懒的没有烦恼的充满诱惑的猫世界而想尽办法恢复为人；</p></li><li><p>故事的最后，小春找到了自己的定位，喜欢上了男爵，并勇敢地向他表白.此时又听到了之前暗恋男生分手的消息，但她一脸微笑地说，我已经不在乎啦</p></li><li><p>或许有一天，你会幻想为所爱之人改变自己原有的样子，那种幻想也许会充满诱惑，可是请你一定要记得做内心最真实的自己喔，否则变成猫咪的你当错过午夜而无法恢复人形时，你会不会后悔呢？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.1-记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虾皮常考的驼峰命名转换</title>
      <link href="/posts/3998253138.html"/>
      <url>/posts/3998253138.html</url>
      
        <content type="html"><![CDATA[<ul><li>网上有小伙伴说，这道题明显就是考正则；</li><li>问题来了，对于没学过正则或者跟我一样对正则只残留一点前世回忆怎么办？</li><li>ok，我们还是可以抢救一下滴</li></ul><h4 id="下划线转驼峰">下划线转驼峰<a class="anchor" href="#下划线转驼峰">·</a></h4><ul><li><p>命名转小驼峰，可能的输入：TestVal，test_val, TEST_VAL ，要求实现驼峰命名的输出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">trans</span> = str =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"> <span class="comment">// case 1</span></span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;_&#x27;</span>) === -<span class="number">1</span>)&#123; </span><br><span class="line">    arr[<span class="number">0</span>] = arr[<span class="number">0</span>].<span class="title function_">toLowerCase</span>();</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// case 2+3</span></span><br><span class="line">  <span class="comment">// 遍历数组元素，每个开头均变成大写的：</span></span><br><span class="line">  arr = str.<span class="title function_">split</span>(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 每个元素是字符串</span></span><br><span class="line">    <span class="keyword">const</span> curArr = arr[i].<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; curArr.<span class="property">length</span>; j++)&#123;</span><br><span class="line">      <span class="comment">// 如果不是第1组的 且是首字母，就是</span></span><br><span class="line">      <span class="keyword">if</span>(i !== <span class="number">0</span> &amp;&amp; j === <span class="number">0</span>)&#123;</span><br><span class="line">        res.<span class="title function_">push</span>(curArr[j].<span class="title function_">toUpperCase</span>());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(curArr[j].<span class="title function_">toLowerCase</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驼峰命名转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6的新特性</title>
      <link href="/posts/ES6.html"/>
      <url>/posts/ES6.html</url>
      
        <content type="html"><![CDATA[<h2 id="ES6概括">ES6概括<a class="anchor" href="#ES6概括">·</a></h2><p>涵盖了<strong>ES2015</strong>、<strong>ES2016</strong>、<strong>ES2017</strong>、<strong>ES2018</strong>、<strong>ES2019</strong>、<strong>ES2020</strong>。更新的内容主要分为以下几点</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f623a94c2f6f4cbeb46b1e8d66e75186~tplv-k3u1fbpfcp-watermark.image" alt="ES6缩略" style="zoom: 25%;" /><ul><li><strong>表达式</strong>：声明、解构赋值</li><li><strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</li><li><strong>语句与运算</strong>：Class、Module、Iterator</li><li><strong>异步编程</strong>：Promise、Generator、Async</li></ul><h2 id="ES2015">ES2015<a class="anchor" href="#ES2015">·</a></h2><h3 id="1、表达式">1、表达式<a class="anchor" href="#1、表达式">·</a></h3><h4 id="1、声明：const、let">1、声明：const、let<a class="anchor" href="#1、声明：const、let">·</a></h4><h4 id="2、解构赋值">2、解构赋值<a class="anchor" href="#2、解构赋值">·</a></h4><h5 id="1、语法：">1、语法：<a class="anchor" href="#1、语法：">·</a></h5><ul><li><strong>字符串解构</strong>：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></li><li><strong>数值解构</strong>：<code>const &#123; toString: s &#125; = 123</code></li><li><strong>布尔解构</strong>：<code>const &#123; toString: b &#125; = true</code></li><li>对象解构<ul><li>形式：<code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></li><li>默认：<code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></li><li>改名：<code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></li></ul></li><li>数组解构<ul><li>规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li><li>形式：<code>const [x, y] = [1, 2]</code></li><li>默认：<code>const [x, y = 2] = [1]</code></li></ul></li><li>函数参数解构<ul><li>数组解构：<code>function Func([x = 0, y = 1]) &#123;&#125;</code></li><li>对象解构：<code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></li></ul></li></ul><h5 id="2、应用场景：-2">2、应用场景：<a class="anchor" href="#2、应用场景：-2">·</a></h5><ul><li>交换变量值：<code>[x, y] = [y, x]</code></li><li>返回函数多个值：<code>const [x, y, z] = Func()</code></li><li>定义函数参数：<code>Func([1, 2])</code></li><li>提取JSON数据：<code>const &#123; name, version &#125; = packageJson</code></li><li>定义函数参数默认值：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>遍历Map结构：<code>for (let [k, v] of Map) &#123;&#125;</code></li><li>输入模块指定属性和方法：<code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></li></ul><h5 id="3、重点难点">3、重点难点<a class="anchor" href="#3、重点难点">·</a></h5><ul><li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li><li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li><li>解构默认值生效条件：属性值严格等于<code>undefined</code></li><li>解构不成功时变量的值等于<code>undefined</code></li><li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li></ul><h3 id="2、内置对象">2、内置对象<a class="anchor" href="#2、内置对象">·</a></h3><h4 id="1、字符串扩展">1、字符串扩展<a class="anchor" href="#1、字符串扩展">·</a></h4><ul><li><strong>Unicode表示法</strong>：<code>大括号包含</code>表示Unicode字符(<code>\u&#123;0xXX&#125;</code>或<code>\u&#123;0XXX&#125;</code>)</li><li><strong>字符串遍历</strong>：可通过<code>for-of</code>遍历字符串</li><li><strong>字符串模板</strong>：可单行可多行可插入变量的增强版字符串</li><li><strong>标签模板</strong>：函数参数的特殊调用</li><li><strong>String.raw()</strong>：返回把字符串所有变量替换且对斜杠进行转义的结果</li><li><strong>String.fromCodePoint()</strong>：返回码点对应字符</li><li><strong>codePointAt()</strong>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</li><li><strong>normalize()</strong>：把字符的不同表示方法统一为同样形式，返回<code>新字符串</code>(Unicode正规化)</li><li><strong>repeat()</strong>：把字符串重复n次，返回<code>新字符串</code></li><li><strong>matchAll()</strong>：返回正则表达式在字符串的所有匹配</li><li><strong>includes()</strong>：是否存在指定字符串</li><li><strong>startsWith()</strong>：是否存在字符串头部指定字符串</li><li><strong>endsWith()</strong>：是否存在字符串尾部指定字符串</li></ul><h4 id="2、数值扩展">2、数值扩展<a class="anchor" href="#2、数值扩展">·</a></h4><ul><li><strong>二进制表示法</strong>：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li><li><strong>八进制表示法</strong>：<code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li></ul><h5 id="1、Number：">1、Number：<a class="anchor" href="#1、Number：">·</a></h5><ul><li><strong>Number.EPSILON</strong>：数值最小精度</li><li><strong>Number.MIN_SAFE_INTEGER</strong>：最小安全数值(<code>-2^53</code>)</li><li><strong>Number.MAX_SAFE_INTEGER</strong>：最大安全数值(<code>2^53</code>)</li><li><strong>Number.parseInt()</strong>：返回转换值的整数部分</li><li><strong>Number.parseFloat()</strong>：返回转换值的浮点数部分</li><li><strong>Number.isFinite()</strong>：是否为有限数值</li><li><strong>Number.isNaN()</strong>：是否为NaN</li><li><strong>Number.isInteger()</strong>：是否为整数</li><li><strong>Number.isSafeInteger()</strong>：是否在数值安全范围内</li></ul><h5 id="2、Math：">2、Math：<a class="anchor" href="#2、Math：">·</a></h5><ul><li><strong>Math.sign()</strong>：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li><li><strong>Math.cbrt()</strong>：返回数值立方根</li><li>对数、立方根、双曲、正弦、、、</li></ul><h4 id="3、对象扩展">3、对象扩展<a class="anchor" href="#3、对象扩展">·</a></h4><ul><li><strong>简洁表示法</strong>：键值相同</li><li><strong>属性名表达式</strong>：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</li><li><strong>属性的可枚举性和遍历</strong>：描述对象的<code>enumerable</code></li><li><strong>super关键字</strong>：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</li><li><strong>Object.assign()</strong>：合并对象(浅拷贝)，返回原对象</li><li><strong>Object.getPrototypeOf()</strong>：返回对象的原型对象</li><li><strong>Object.setPrototypeOf()</strong>：设置对象的原型对象</li><li><strong><strong>proto</strong></strong>：返回或设置对象的原型对象</li></ul><blockquote><p>属性遍历</p></blockquote><ul><li>描述：<code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></li><li>遍历<ul><li><code>for-in</code>：遍历对象<code>自身可继承可枚举</code>属性</li><li><code>Object.keys()</code>：返回对象<code>自身可枚举</code>属性键组成的数组</li><li><code>Object.getOwnPropertyNames()</code>：返回对象<code>自身非Symbol</code>属性键组成的数组</li><li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>自身Symbol</code>属性键组成的数组</li><li><code>Reflect.ownKeys()</code>：返回对象<code>自身全部</code>属性键组成的数组</li></ul></li><li>规则<ul><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有Symbol键，按照加入时间升序排列</li></ul></li></ul><h4 id="4、数组扩展">4、数组扩展<a class="anchor" href="#4、数组扩展">·</a></h4><h5 id="1、语法：-2">1、语法：<a class="anchor" href="#1、语法：-2">·</a></h5><ul><li><strong>扩展运算符(…)</strong></li><li>Array.from()：转换具有Iterator接口的数据结构为真正数组，返回新数组<ul><li>类数组对象：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li><li>可遍历对象：<code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li></ul></li><li><strong>Array.of()</strong>：转换一组值为真正数组，返回新数组</li><li><strong>copyWithin()</strong>：把指定位置的成员复制到其他位置，返回原数组</li><li><strong>find()</strong>：返回第一个符合条件的成员</li><li><strong>findIndex()</strong>：返回第一个符合条件的成员索引值</li><li><strong>fill()</strong>：根据指定值填充整个数组，返回原数组</li><li><strong>keys()</strong>：返回以索引值为遍历器的对象</li><li><strong>values()</strong>：返回以属性值为遍历器的对象</li><li><strong>entries()</strong>：返回以索引值和属性值为遍历器的对象</li></ul><h5 id="2、扩展应用">2、扩展应用<a class="anchor" href="#2、扩展应用">·</a></h5><ul><li>克隆数组：<code>const arr = [...arr1]</code></li><li>合并数组：<code>const arr = [...arr1, ...arr2]</code></li><li>拼接数组：<code>arr.push(...arr1)</code></li><li>代替apply：<code>Math.max.apply(null, [x, y])</code> =&gt; <code>Math.max(...[x, y])</code></li><li>转换字符串为数组：<code>[...&quot;hello&quot;]</code></li><li>转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></li><li>转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></li><li>与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></li></ul><h4 id="5、函数扩展">5、函数扩展<a class="anchor" href="#5、函数扩展">·</a></h4><h5 id="1、参数默认值：为函数参数指定默认值">1、参数默认值：为函数参数指定默认值<a class="anchor" href="#1、参数默认值：为函数参数指定默认值">·</a></h5><ul><li>形式：<code>function Func(x = 1, y = 2) &#123;&#125;</code></li><li>参数赋值：惰性求值(函数调用后才求值)</li><li>参数位置：尾参数</li><li>参数作用域：函数作用域</li><li>声明方式：默认声明，不能用<code>const</code>或<code>let</code>再次声明</li><li>length：返回没有指定默认值的参数个数</li><li>与解构赋值默认值结合：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>应用<ul><li>指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) &#123;&#125;</code></li><li>将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></li></ul></li></ul><h5 id="2、剩余参数-…-：返回函数多余参数">2、剩余参数(…)：返回函数多余参数<a class="anchor" href="#2、剩余参数-…-：返回函数多余参数">·</a></h5><ul><li>形式：以数组的形式存在，之后不能再有其他参数</li><li>作用：代替<code>Arguments对象</code></li><li>length：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li></ul><h5 id="3、箭头函数-：函数简写">3、箭头函数(=&gt;)：函数简写<a class="anchor" href="#3、箭头函数-：函数简写">·</a></h5><ul><li><p>无参数、单个参数、多个参数、解构参数<code>(&#123;x, y&#125;) =&gt; &#123;&#125;</code>、</p></li><li><p>嵌套使用：部署管道机制</p></li><li><p>this指向固定化，这种特性很有利于封装回调函数</p><ul><li>并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></li><li>因为没有<code>this</code>，因此不能用作构造函数</li><li>不可使用<code>Arguments对象</code>，此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li><li>返回对象时必须在对象外面加上括号</li></ul></li></ul><h5 id="4、尾调用优化：只保留内层函数的调用帧">4、尾调用优化：只保留内层函数的调用帧<a class="anchor" href="#4、尾调用优化：只保留内层函数的调用帧">·</a></h5><ul><li>尾调用<ul><li>定义：某个函数的最后一步是调用另一个函数</li><li>形式：<code>function f(x) &#123; return g(x); &#125;</code></li></ul></li><li>尾递归<ul><li>定义：函数尾调用自身</li><li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li><li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul><h4 id="6、正则扩展">6、正则扩展<a class="anchor" href="#6、正则扩展">·</a></h4><h4 id="7、Symbol">7、Symbol<a class="anchor" href="#7、Symbol">·</a></h4><h4 id="8、Set">8、Set<a class="anchor" href="#8、Set">·</a></h4><h5 id="1、用法">1、用法<a class="anchor" href="#1、用法">·</a></h5><ul><li>定义：成员值都是唯一且没有重复的值</li><li>声明：<code>const set = new Set(arr)</code></li><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回Set</li><li><strong>size</strong>：返回实例成员总数</li></ul></li><li>方法<ul><li><strong>add()</strong>：添加值，返回实例            <strong>clear()</strong>：清除所有成员</li><li><strong>delete()</strong>：删除值，返回布尔   <strong>has()</strong>：检查值，返回布尔</li><li><strong>keys()</strong>：返回以属性值为遍历器的对象</li><li><strong>values()</strong>：返回以属性值为遍历器的对象</li><li><strong>entries()</strong>：返回以属性值和属性值为遍历器的对象</li><li><strong>forEach()</strong>：使用回调函数遍历每个成员</li></ul></li></ul><h5 id="2、应用场景-2">2、应用场景<a class="anchor" href="#2、应用场景-2">·</a></h5><ul><li>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></li><li>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></li><li>集合数组<ul><li>声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></li><li>并集：<code>new Set([...a, ...b])</code></li><li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li><li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li></ul></li><li>映射集合<ul><li>声明：<code>let set = new Set(arr)</code></li><li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li></ul></li></ul><h5 id="3、重点难点-2">3、重点难点<a class="anchor" href="#3、重点难点-2">·</a></h5><ul><li>遍历顺序：插入顺序</li><li>没有键只有值，可认为键和值两值相等</li><li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li><li>添加相同的对象时，会认为是不同的对象</li><li>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li><li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li></ul><h4 id="9、WeakSet">9、WeakSet<a class="anchor" href="#9、WeakSet">·</a></h4><h5 id="1、用法-2">1、用法<a class="anchor" href="#1、用法-2">·</a></h5><ul><li>定义：和Set结构类似，成员值只能是对象</li><li>声明：<code>const set = new WeakSet(arr)</code></li><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回WeakSet</li></ul></li><li>方法<ul><li><strong>add()</strong>：添加值，返回实例</li><li><strong>delete()</strong>：删除值，返回布尔</li><li><strong>has()</strong>：检查值，返回布尔</li></ul></li></ul><h5 id="2、应用场景-3">2、应用场景<a class="anchor" href="#2、应用场景-3">·</a></h5><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li><li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动消失</li></ul><h5 id="3、重点难点-3">3、重点难点<a class="anchor" href="#3、重点难点-3">·</a></h5><ul><li>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li><li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet结构不可遍历</code></li><li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet结构</code>中</li></ul><h4 id="10、Map">10、Map<a class="anchor" href="#10、Map">·</a></h4><h5 id="1、用法-3">1、用法<a class="anchor" href="#1、用法-3">·</a></h5><ul><li>定义：成员键是任何类型的值</li><li>声明：<code>const set = new Map(arr)</code></li><li>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回Map</li><li><strong>size</strong>：返回实例成员总数</li></ul></li><li>方法<ul><li><strong>get()</strong>：返回键值对   <strong>set()</strong>：添加键值对，返回实例       <strong>has()</strong>：检查键值对，返回布尔</li><li><strong>delete()</strong>：删除键值对，返回布尔<strong>clear()</strong>：清除所有成员</li><li><strong>keys()</strong>：返回以键为遍历器的对象</li><li><strong>values()</strong>：返回以值为遍历器的对象</li><li><strong>entries()</strong>：返回以键和值为遍历器的对象</li><li><strong>forEach()</strong>：使用回调函数遍历每个成员</li></ul></li></ul><h5 id="2、重点难点">2、重点难点<a class="anchor" href="#2、重点难点">·</a></h5><ul><li>遍历顺序：插入顺序</li><li>对同一个键多次赋值，后面的值将覆盖前面的值</li><li>对同一个对象的引用，被视为一个键</li><li>对同样值的两个实例，被视为两个键</li><li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li><li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li><li><code>Object结构</code>提供<code>字符串—值</code>的对应，<code>Map结构</code>提供<code>值—值</code>的对应</li></ul><h4 id="11、WeakMap">11、WeakMap<a class="anchor" href="#11、WeakMap">·</a></h4><h5 id="1、用法-4">1、用法<a class="anchor" href="#1、用法-4">·</a></h5><ul><li>定义：和Map结构类似，成员键只能是对象</li><li>声明：<code>const set = new WeakMap(arr)</code></li><li>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回WeakMap</li></ul></li><li>方法<ul><li><strong>get()</strong>：返回键值对</li><li><strong>set()</strong>：添加键值对，返回实例</li><li><strong>delete()</strong>：删除键值对，返回布尔</li><li><strong>has()</strong>：检查键值对，返回布尔</li></ul></li></ul><h5 id="2、应用场景-4">2、应用场景<a class="anchor" href="#2、应用场景-4">·</a></h5><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li><li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul><h5 id="3、重点难点-4">3、重点难点<a class="anchor" href="#3、重点难点-4">·</a></h5><ul><li>成员键都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li><li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap结构不可遍历</code></li><li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap结构</code>中</li><li>一旦不再需要，成员会自动消失，不用手动删除引用</li><li>弱引用的<code>只是键而不是值</code>，值依然是正常引用</li><li>即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul><h4 id="12、Proxy">12、Proxy<a class="anchor" href="#12、Proxy">·</a></h4><ul><li>定义：修改某些操作的默认行为</li><li>声明：<code>const proxy = new Proxy(target, handler)</code></li><li>入参<ul><li><strong>target</strong>：拦截的目标对象</li><li><strong>handler</strong>：定制拦截行为</li></ul></li><li>方法<ul><li><strong>Proxy.revocable()</strong>：返回可取消的Proxy实例(返回<code>&#123; proxy, revoke &#125;</code>，通过revoke()取消代理)</li></ul></li><li>拦截方式<ul><li><strong>get()</strong>：拦截对象属性读取</li><li><strong>set()</strong>：拦截对象属性设置，返回布尔</li><li><strong>has()</strong>：拦截对象属性检查<code>k in obj</code>，返回布尔</li><li><strong>deleteProperty()</strong>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔</li><li><strong>defineProperty()</strong>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔</li><li><strong>ownKeys()</strong>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li><li><strong>getOwnPropertyDescriptor()</strong>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li><li><strong>getPrototypeOf()</strong>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li><li><strong>setPrototypeOf()</strong>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔</li><li><strong>isExtensible()</strong>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔</li><li><strong>preventExtensions()</strong>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔</li><li><strong>apply()</strong>：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li><li><strong>construct()</strong>：拦截Proxy实例作为构造函数调用<code>new proxy()</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li><li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li><li><code>set()</code>：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li><li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li><li><code>deleteProperty()</code>：保护内部属性不被删除</li><li><code>defineProperty()</code>：阻止属性被外部定义</li><li><code>ownKeys()</code>：保护内部属性不被遍历</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>要使<code>Proxy</code>起作用，必须针对<code>实例</code>进行操作，而不是针对<code>目标对象</code>进行操作</li><li>没有设置任何拦截时，等同于<code>直接通向原对象</code></li><li>属性被定义为<code>不可读写/扩展/配置/枚举</code>时，使用拦截方法会报错</li><li>代理下的目标对象，内部<code>this</code>指向<code>Proxy代理</code></li></ul><h4 id="13、Reflect">13、Reflect<a class="anchor" href="#13、Reflect">·</a></h4><ul><li>定义：保持<code>Object方法</code>的默认行为</li><li>方法<ul><li><strong>get()</strong>：返回对象属性</li><li><strong>set()</strong>：设置对象属性，返回布尔</li><li><strong>has()</strong>：检查对象属性，返回布尔</li><li><strong>deleteProperty()</strong>：删除对象属性，返回布尔</li><li><strong>defineProperty()</strong>：定义对象属性，返回布尔</li><li><strong>ownKeys()</strong>：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li><li><strong>getOwnPropertyDescriptor()</strong>：返回对象属性描述，返回对象</li><li><strong>getPrototypeOf()</strong>：返回对象原型，返回对象</li><li><strong>setPrototypeOf()</strong>：设置对象原型，返回布尔</li><li><strong>isExtensible()</strong>：返回对象是否可扩展，返回布尔</li><li><strong>preventExtensions()</strong>：设置对象不可扩展，返回布尔</li><li><strong>apply()</strong>：绑定this后执行指定函数</li><li><strong>construct()</strong>：调用构造函数创建实例</li></ul></li></ul><blockquote><p>设计目的</p></blockquote><ul><li>将<code>Object</code>属于<code>语言内部的方法</code>放到<code>Reflect</code>上</li><li>将某些Object方法报错情况改成返回<code>false</code></li><li>让<code>Object操作</code>变成<code>函数行为</code></li><li><code>Proxy</code>与<code>Reflect</code>相辅相成</li></ul><blockquote><p>废弃方法</p></blockquote><ul><li><code>Object.defineProperty()</code> =&gt; <code>Reflect.defineProperty()</code></li><li><code>Object.getOwnPropertyDescriptor()</code> =&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li><li><code>Proxy</code>和<code>Reflect</code>联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li></ul><blockquote><p>数据绑定：观察者模式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observerQueue = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; observerQueue.<span class="title function_">add</span>(fn);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">tgt, key, val, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">v</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123; <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">name</span>: <span class="string">&quot;Yajun&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">print</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> is <span class="subst">$&#123;person.age&#125;</span> years old`</span>);</span><br><span class="line"><span class="title function_">observe</span>(print);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Joway&quot;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="14、Class-15、Module-16、Iterator-17、Promise-18、Generator">14、Class           15、Module    16、Iterator    17、Promise   18、Generator<a class="anchor" href="#14、Class-15、Module-16、Iterator-17、Promise-18、Generator">·</a></h4><h2 id="ES2016">ES2016<a class="anchor" href="#ES2016">·</a></h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b6131b43a2415e8deb82c53a054432~tplv-k3u1fbpfcp-watermark.image" alt="ES2016" style="zoom:25%;" /><h2 id="ES2017">ES2017<a class="anchor" href="#ES2017">·</a></h2><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65ff57811aff4f0e884a9b250fa1b6fb~tplv-k3u1fbpfcp-watermark.image" alt="ES2017" style="zoom:25%;" /><h3 id="1、声明">1、声明<a class="anchor" href="#1、声明">·</a></h3><ul><li><strong>共享内存和原子操作</strong>：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在<code>JS主线程</code>和<code>web-worker线程</code>之间共享</li></ul><h3 id="2、字符串扩展">2、字符串扩展<a class="anchor" href="#2、字符串扩展">·</a></h3><ul><li><strong>padStart()</strong>：把指定字符串填充到字符串头部，返回新字符串</li><li><strong>padEnd()</strong>：把指定字符串填充到字符串尾部，返回新字符串</li></ul><h3 id="3、对象扩展-2">3、对象扩展<a class="anchor" href="#3、对象扩展-2">·</a></h3><ul><li><strong>Object.getOwnPropertyDescriptors()</strong>：返回对象所有自身属性(非继承属性)的描述对象</li><li><strong>Object.values()</strong>：返回以值组成的数组</li><li><strong>Object.entries()</strong>：返回以键和值组成的数组</li></ul><h3 id="4、函数扩展">4、函数扩展<a class="anchor" href="#4、函数扩展">·</a></h3><ul><li><strong>函数参数尾逗号</strong>：允许函数最后一个参数有尾逗号</li></ul><h3 id="5、Async">5、Async<a class="anchor" href="#5、Async">·</a></h3><ul><li>定义：使异步函数以同步函数的形式书写(Generator函数语法糖)</li><li>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</li><li>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></li><li>声明<ul><li>具名函数：<code>async function Func() &#123;&#125;</code></li><li>函数表达式：<code>const func = async function() &#123;&#125;</code></li><li>箭头函数：<code>const func = async() =&gt; &#123;&#125;</code></li><li>对象方法：<code>const obj = &#123; async func() &#123;&#125; &#125;</code></li><li>类方法：<code>class Cla &#123; async Func() &#123;&#125; &#125;</code></li></ul></li><li>await命令：等待当前Promise对象状态变更完毕<ul><li>正常情况：后面是Promise对象则返回其结果，否则返回对应的值</li><li>后随<code>Thenable对象</code>：将其等同于Promise对象返回其结果</li></ul></li><li>错误处理：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</li></ul><blockquote><p>Async对Generator改进</p></blockquote><ul><li>内置执行器</li><li>更好的语义</li><li>更广的适用性</li><li>返回值是Promise对象</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>按顺序完成异步操作</li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>Async函数</code>返回<code>Promise对象</code>，可使用<code>then()</code>添加回调函数</li><li>内部<code>return返回值</code>会成为后续<code>then()</code>的出参</li><li>内部抛出错误会导致返回的Promise对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</li><li>返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></li><li>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</li><li>希望即使前一个异步操作失败也不要中断后面的异步操作<ul><li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li><li><code>await命令Promise对象</code>跟一个<code>catch()</code></li></ul></li><li><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</li><li>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</li><li><code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</li><li>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</li><li>可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</li></ul><h2 id="ES2018">ES2018<a class="anchor" href="#ES2018">·</a></h2><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee2ee331aa642c49fc3119bdf3eb974~tplv-k3u1fbpfcp-watermark.image" alt="ES2018" style="zoom: 25%;" /><h3 id="字符串扩展">字符串扩展<a class="anchor" href="#字符串扩展">·</a></h3><ul><li><strong>放松对标签模板里字符串转义的限制</strong>：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</li></ul><h3 id="对象扩展">对象扩展<a class="anchor" href="#对象扩展">·</a></h3><ul><li><strong>扩展运算符(…)</strong>：转换对象为用逗号分隔的参数序列(<code>&#123; ...obj &#125;</code>，相当于<code>rest/spread参数</code>的逆运算)</li></ul><blockquote><p>扩展应用</p></blockquote><ul><li>克隆对象：<code>const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;</code></li><li>合并对象：<code>const obj = &#123; ...obj1, ...obj2 &#125;</code></li><li>转换字符串为对象：<code>&#123; ...&quot;hello&quot; &#125;</code></li><li>转换数组为对象：<code>&#123; ...[1, 2] &#125;</code></li><li>与对象解构赋值结合：<code>const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3  &#125;</code>(不能复制继承自原型对象的属性)</li><li>修改现有对象部分属性：<code>const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;</code></li></ul><h3 id="正则扩展">正则扩展<a class="anchor" href="#正则扩展">·</a></h3><ul><li><p><strong>s修饰符</strong>：dotAll模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll模式</code>)</p></li><li><p><strong>dotAll</strong>：是否设置<code>s修饰符</code></p></li><li><p><strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</p></li><li><p><strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</p></li><li><p>Unicode属性转义</p><p>：匹配符合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unicode某种属性</span><br></pre></td></tr></table></figure><p>的所有字符</p><ul><li>正向匹配：<code>\p&#123;PropRule&#125;</code></li><li>反向匹配：<code>\P&#123;PropRule&#125;</code></li><li>限制：<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li></ul></li><li><p>具名组匹配</p><p>：为每组匹配指定名字(</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?&lt;GroupName&gt;</span><br></pre></td></tr></table></figure><p>)</p><ul><li>形式：<code>str.exec().groups.GroupName</code></li><li>解构赋值替换<ul><li>声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?\d&#123;4&#125;)-(?\d&#123;2&#125;)-(?\d&#123;2&#125;)/u</code></li><li>匹配：<code>time.replace(regexp, &quot;$/$/$&quot;)</code></li></ul></li></ul></li></ul><h3 id="Promise">Promise<a class="anchor" href="#Promise">·</a></h3><ul><li><strong>finally()</strong>：指定不管最后状态如何都会执行的回调函数</li></ul><h3 id="Async">Async<a class="anchor" href="#Async">·</a></h3><ul><li><strong>异步迭代器(for-await-of)</strong>：循环等待每个<code>Promise对象</code>变为<code>resolved状态</code>才进入下一步</li></ul><h2 id="ES2019">ES2019<a class="anchor" href="#ES2019">·</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ae43118d7ef4e1eb9b3aac7b0f89777~tplv-k3u1fbpfcp-watermark.image" alt="ES2019"></p><h3 id="字符串扩展-2">字符串扩展<a class="anchor" href="#字符串扩展-2">·</a></h3><ul><li><strong>直接输入U+2028和U+2029</strong>：字符串可直接输入<code>行分隔符</code>和<code>段分隔符</code></li><li><strong>JSON.stringify()改造</strong>：可返回不符合UTF-8标准的字符串</li><li><strong>trimStart()</strong>：消除字符串头部空格，返回新字符串</li><li><strong>trimEnd()</strong>：消除字符串尾部空格，返回新字符串</li></ul><h3 id="对象扩展-2">对象扩展<a class="anchor" href="#对象扩展-2">·</a></h3><ul><li><strong>Object.fromEntries()</strong>：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</li></ul><h3 id="数组扩展">数组扩展<a class="anchor" href="#数组扩展">·</a></h3><ul><li><strong>sort()稳定性</strong>：排序关键字相同的项目其排序前后的顺序不变，默认为<code>稳定</code></li><li><strong>flat()</strong>：扁平化数组，返回新数组</li><li><strong>flatMap()</strong>：映射且扁平化数组，返回新数组(只能展开一层数组)</li></ul><h3 id="函数扩展">函数扩展<a class="anchor" href="#函数扩展">·</a></h3><ul><li><strong>toString()改造</strong>：返回函数原始代码(与编码一致)</li><li><strong>catch()参数可省略</strong>：<code>catch()</code>中的参数可省略</li></ul><h3 id="Symbol">Symbol<a class="anchor" href="#Symbol">·</a></h3><ul><li><strong>description</strong>：返回<code>Symbol值</code>的描述</li></ul><h2 id="ES2020">ES2020<a class="anchor" href="#ES2020">·</a></h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4762da8a25d242eb82da69576b05b035~tplv-k3u1fbpfcp-watermark.image" alt="ES2020" style="zoom:25%;" /><h3 id="声明">声明<a class="anchor" href="#声明">·</a></h3><ul><li><p>globalThis</p><p>：作为顶层对象，指向全局环境下的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure><ul><li>Browser：顶层对象是<code>window</code></li><li>Node：顶层对象是<code>global</code></li><li>WebWorker：顶层对象是<code>self</code></li><li>以上三者：通用顶层对象是<code>globalThis</code></li></ul></li></ul><h3 id="数值扩展">数值扩展<a class="anchor" href="#数值扩展">·</a></h3><ul><li><p>BigInt</p><p>：任何位数的整数(新增的数据类型，使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure><p>结尾)</p><ul><li><strong>BigInt()</strong>：转换普通数值为BigInt类型</li><li><strong>BigInt.asUintN()</strong>：转换BigInt为0到2n-1之间对应的值</li><li><strong>BigInt.asIntN()</strong>：转换BigInt为-2n-1 到2n-1-1</li><li><strong>BigInt.parseInt()</strong>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的BigInt类型</li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>BigInt同样可使用各种进制表示，都要加上后缀</li><li>BigInt与普通整数是两种值，它们之间并不相等</li><li>typeof运算符对于BigInt类型的数据返回<code>bigint</code></li></ul><h3 id="对象扩展-3">对象扩展<a class="anchor" href="#对象扩展-3">·</a></h3><ul><li><p>链判断操作符(?.)</p><p>：是否存在对象属性(不存在返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined</span><br></pre></td></tr></table></figure><p>且不再往下执行)</p><ul><li>对象属性：<code>obj?.prop</code>、<code>obj?.[expr]</code></li><li>函数调用：<code>func?.(...args)</code></li></ul></li><li><p><strong>空判断操作符(??)</strong>：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</p></li></ul><h3 id="正则扩展-2">正则扩展<a class="anchor" href="#正则扩展-2">·</a></h3><ul><li><strong>matchAll()</strong>：返回所有匹配的遍历器</li></ul><h3 id="Module">Module<a class="anchor" href="#Module">·</a></h3><ul><li><p>import()</p><p>：动态导入(返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise</span><br></pre></td></tr></table></figure><ul><li>背景：<code>import命令</code>被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li></ul></li><li><p>位置：可在任何地方使用</p><ul><li>区别：<code>require()</code>是<strong>同步加载</strong>，<code>import()</code>是<strong>异步加载</strong></li><li>场景：按需加载、条件加载、模块路径动态化</li></ul></li></ul><h3 id="Iterator">Iterator<a class="anchor" href="#Iterator">·</a></h3><ul><li><strong>for-in遍历顺序</strong>：不同的引擎已就如何迭代属性达成一致，从而使行为标准化</li></ul><h3 id="Promise-2">Promise<a class="anchor" href="#Promise-2">·</a></h3><ul><li><p>Promise.allSettled()</p><p>：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)</p><ul><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>成功：成员包含<code>status</code>和<code>value</code>，<code>status</code>为<code>fulfilled</code>，<code>value</code>为返回值</li><li>失败：成员包含<code>status</code>和<code>reason</code>，<code>status</code>为<code>rejected</code>，<code>value</code>为错误原因</li></ul></li></ul><h2 id="ES提案">ES提案<a class="anchor" href="#ES提案">·</a></h2><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68085d653c054f68a496cb158496ed8b~tplv-k3u1fbpfcp-watermark.image" alt="ES提案" style="zoom:33%;" /><h3 id="声明-2">声明<a class="anchor" href="#声明-2">·</a></h3><ul><li><strong>do表达式</strong>：封装块级作用域的操作，返回内部最后执行表达式的值(<code>do&#123;&#125;</code>)</li><li><strong>throw表达式</strong>：直接使用<code>throw new Error()</code>，无需<code>()</code>或<code>&#123;&#125;</code>包括</li><li><strong>!#命令</strong>：指定脚本执行器(写在文件首行)</li></ul><h3 id="数值扩展-2">数值扩展<a class="anchor" href="#数值扩展-2">·</a></h3><ul><li><strong>数值分隔符(_)</strong>：使用<code>_</code>作为千分位分隔符(增加数值的可读性)</li><li><strong>Math.signbit()</strong>：返回数值符号是否设置</li></ul><h3 id="函数扩展-2">函数扩展<a class="anchor" href="#函数扩展-2">·</a></h3><ul><li><p><strong>函数部分执行</strong>：复用函数功能(<code>?</code>表示单个参数占位符，<code>...</code>表示多个参数占位符)</p></li><li><p><strong>管道操作符(|&gt;)</strong>：把左边表达式的值传入右边的函数进行求值(<code>f(x)</code> =&gt; <code>x |&gt; f</code>)</p></li><li><p>绑定运算符(:😃</p><p>：函数绑定(左边是对象右边是函数，取代</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call</span><br></pre></td></tr></table></figure><p>调用)</p><ul><li>bind：<code>bar.bind(foo)</code> =&gt; <code>foo::bar</code></li><li>apply：<code>bar.apply(foo, arguments)</code> =&gt; <code>foo::bar(...arguments)</code></li></ul></li></ul><h3 id="Realm">Realm<a class="anchor" href="#Realm">·</a></h3><ul><li>定义：提供<code>沙箱功能</code>，允许隔离代码，防止被隔离的代码拿到全局对象</li><li>声明：<code>new Realm().global</code></li></ul><h3 id="Class">Class<a class="anchor" href="#Class">·</a></h3><ul><li><strong>静态属性</strong>：使用<code>static</code>定义属性，该属性<code>不会被实例继承</code>，只能通过类来调用</li><li><strong>私有属性</strong>：使用<code>#</code>定义属性，该属性只能在类内部访问</li><li><strong>私有方法</strong>：使用<code>#</code>定义方法，该方法只能在类内部访问</li><li><strong>装饰器</strong>：使用<code>@</code>注释或修改类和类方法</li></ul><h3 id="Module-2">Module<a class="anchor" href="#Module-2">·</a></h3><ul><li><strong>import.meta</strong>：返回脚本元信息</li></ul><h3 id="Promise-3">Promise<a class="anchor" href="#Promise-3">·</a></h3><ul><li><p>Promise.any()</p><p>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</p><ul><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>成功：其中一个实例状态变成<code>fulfilled</code>，最终状态就会变成<code>fulfilled</code></li><li>失败：只有全部实例状态变成<code>rejected</code>，最终状态才会变成<code>rejected</code></li></ul></li><li><p><strong>Promise.try()</strong>：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</p></li></ul><h3 id="Async-2">Async<a class="anchor" href="#Async-2">·</a></h3><ul><li><strong>顶层Await</strong>：允许在模块的顶层独立使用<code>await命令</code>(借用<code>await</code>解决模块异步加载的问题)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虾皮面试中的数组去重</title>
      <link href="/posts/179783341.html"/>
      <url>/posts/179783341.html</url>
      
        <content type="html"><![CDATA[<ul><li>当时一紧张，只想到了用数据结构存储的思路，补充一下其他方法</li></ul><h3 id="数组去重">数组去重<a class="anchor" href="#数组去重">·</a></h3><p>// 原地修改数组</p><h4 id="法1：双层for-splice-基本数据类型-2">法1：双层for+splice            基本数据类型<a class="anchor" href="#法1：双层for-splice-基本数据类型-2">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.<span class="property">length</span>;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]===arr[j])&#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(j,<span class="number">1</span>)  <span class="comment">//splice是能改变原数组的，slice不行</span></span><br><span class="line">        j--  <span class="comment">//如果有重复元素，删除之后一定要j--</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法2：用额外空间存储已经出现过的元素-2">法2：用额外空间存储已经出现过的元素<a class="anchor" href="#法2：用额外空间存储已经出现过的元素-2">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="title function_">indexOf</span>(arr[i])==-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//  if(!res.includes(arr[i]))&#123;</span></span><br><span class="line">      res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">版本<span class="number">2</span>：对象的键名存储(能对<span class="variable constant_">NAN</span>去重，对象只留前面一个，基本数据类型：)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj.<span class="title function_">hasOwnProperty</span>(<span class="keyword">typeof</span> item + item))&#123;</span><br><span class="line">      res.<span class="title function_">push</span>(item)</span><br><span class="line">      obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">版本<span class="number">3</span>：<span class="title class_">Map</span> 的键名可以是任意类型，而不是像对象那样必须是字符串类型，所以利用这一点，简化版本<span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.<span class="title function_">has</span>(item))&#123;  <span class="comment">//map没有当前元素键名</span></span><br><span class="line">      res.<span class="title function_">push</span>(item)</span><br><span class="line">      map.<span class="title function_">set</span>(item,<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法3：filter-indexOf，基本数据类型：-2">方法3：filter+indexOf，基本数据类型：<a class="anchor" href="#方法3：filter-indexOf，基本数据类型：-2">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">法<span class="number">1</span>：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">cur,index</span>)&#123;</span><br><span class="line">    <span class="comment">// indexOf:返回的是元素在数组中跟的索引位置，-1代表不存，</span></span><br><span class="line">    <span class="comment">// 否则结果是索引位置，且是从左到右第一次找到的与该元素相等或就是该元素的位置</span></span><br><span class="line">    <span class="comment">// 所以arr.indexOf(cur) == index说明是第一次出现的元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(cur) == index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">法<span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> arr.<span class="title function_">indexOf</span>(i) === arr.<span class="title function_">lastIndexOf</span>(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法4：Set，基本数据类型：NaN能去重，对象不可以-2">方法4：Set，基本数据类型：NaN能去重，对象不可以<a class="anchor" href="#方法4：Set，基本数据类型：NaN能去重，对象不可以-2">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">  <span class="comment">// 或者：return Array.from(new Set(arr))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组去重、虾皮一面、虾皮二面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的5种遍历</title>
      <link href="/posts/229643181.html"/>
      <url>/posts/229643181.html</url>
      
        <content type="html"><![CDATA[<h2 id="前、中、后、层遍历">前、中、后、层遍历<a class="anchor" href="#前、中、后、层遍历">·</a></h2><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><h3 id="1、前序遍历-144简">1、前序遍历          144简<a class="anchor" href="#1、前序遍历-144简">·</a></h3><h4 id="递归版本">递归版本<a class="anchor" href="#递归版本">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  res.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">preorderTraversal</span>(root.<span class="property">left</span>, res);</span><br><span class="line">  <span class="title function_">preorderTraversal</span>(root.<span class="property">right</span>, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非递归版本">非递归版本<a class="anchor" href="#非递归版本">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(n.<span class="property">val</span>);</span><br><span class="line">    n.<span class="property">right</span> &amp;&amp; stack.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">    n.<span class="property">left</span> &amp;&amp; stack.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、中序遍历-94简">2、中序遍历 94简<a class="anchor" href="#2、中序遍历-94简">·</a></h3><h4 id="递归版本-2">递归版本<a class="anchor" href="#递归版本-2">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="title function_">inorderTraversal</span>(root.<span class="property">left</span>, res);</span><br><span class="line">  res.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">inorderTraversal</span>(root.<span class="property">right</span>, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非递归版本-2">非递归版本<a class="anchor" href="#非递归版本-2">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> cur = root;</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span> || cur)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(cur);</span><br><span class="line">      cur = cur.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">      res.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">      cur = node.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：遍历到了所有的节点，O(N)，N就是节点数</li><li>空间复杂度：使用了线性增长的栈，是一个数组，所以O(N)</li></ul><h3 id="3、后序遍历-145简">3、后序遍历        145简<a class="anchor" href="#3、后序遍历-145简">·</a></h3><p>根-右-左，再倒过来就是后续遍历了。而前面跟先序遍历很像</p><h4 id="递归版本-3">递归版本<a class="anchor" href="#递归版本-3">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="title function_">postorderTraversal</span>(root.<span class="property">left</span>, res);</span><br><span class="line">  <span class="title function_">postorderTraversal</span>(root.<span class="property">right</span>, res);</span><br><span class="line">  res.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非递归版本：先序取反">非递归版本：先序取反<a class="anchor" href="#非递归版本：先序取反">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="comment">// 中 右 左</span></span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(n.<span class="property">val</span>);</span><br><span class="line">    n.<span class="property">left</span> &amp;&amp; stack.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">    n.<span class="property">right</span> &amp;&amp; stack.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(res.<span class="property">length</span> / <span class="number">2</span>); i++)&#123;</span><br><span class="line">    [res[i], res[res.<span class="property">length</span>-<span class="number">1</span>-i]]= [res[res.<span class="property">length</span>-<span class="number">1</span>-i], res[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、广度优先遍历">2、广度优先遍历<a class="anchor" href="#2、广度优先遍历">·</a></h4><h5 id="非递归版本-3">非递归版本<a class="anchor" href="#非递归版本-3">·</a></h5><ul><li>新建一个队列，把根节点入队</li><li>把队头出队并访问。</li><li>把队头的children挨个入队，重复二三，直到队列为空</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span> &gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//2.1根节点出队</span></span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="comment">//2.2访问出队的值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>)</span><br><span class="line">    <span class="comment">//3.将children入队</span></span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">left</span>)&#123;stack.<span class="title function_">push</span>(n.<span class="property">left</span>)&#125;</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">right</span>)&#123;stack.<span class="title function_">push</span>(n.<span class="property">right</span>)&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bfs</span>(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、层序遍历-102简">4、层序遍历           102简<a class="anchor" href="#4、层序遍历-102简">·</a></h3><p>即逐层地，从左到右访问所有节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">    res.<span class="title function_">push</span>([]);</span><br><span class="line">    <span class="keyword">let</span> len = queue.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">      <span class="keyword">let</span> n = queue.<span class="title function_">shift</span>();</span><br><span class="line">      res[res.<span class="property">length</span> - <span class="number">1</span>].<span class="title function_">push</span>(n.<span class="property">val</span>);</span><br><span class="line">      n.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">      n.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)，广度优先遍历，遍历每个节点,N是节点数</li><li>空间复杂度：线性增长的q，数组中元素的个数取决于节点数，O(N)</li></ul><h3 id="5、层序遍历2-107中-快手">5、层序遍历2           107中   快手<a class="anchor" href="#5、层序遍历2-107中-快手">·</a></h3><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。即取反层序遍历102</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span>[];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">    res.<span class="title function_">push</span>([]);</span><br><span class="line">    <span class="keyword">let</span> len = queue.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">      <span class="keyword">let</span> n = queue.<span class="title function_">shift</span>();</span><br><span class="line">      res[res.<span class="property">length</span> - <span class="number">1</span>].<span class="title function_">push</span>(n.<span class="property">val</span>);</span><br><span class="line">      n.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">      n.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">reverse</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)，广度优先遍历，遍历每个节点,N是节点数</li><li>空间复杂度：线性增长的q，数组中元素的个数取决于节点数，O(N)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典の排序算法</title>
      <link href="/posts/3691095479.html"/>
      <url>/posts/3691095479.html</url>
      
        <content type="html"><![CDATA[<h2 id="十大经典排序算法">十大经典排序算法<a class="anchor" href="#十大经典排序算法">·</a></h2><h3 id="0、分类比较">0、分类比较<a class="anchor" href="#0、分类比较">·</a></h3><h4 id="1、分类-2">1、分类<a class="anchor" href="#1、分类-2">·</a></h4><ul><li><p><strong>非线性时间比较类排序</strong>：通过<strong>比较来决定元素间的相对次序</strong>，由于其时间不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</p></li></ul><img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402132530342-980121409.png" alt="img" style="zoom: 33%;" /><h4 id="2、复杂度对比">2、复杂度对比<a class="anchor" href="#2、复杂度对比">·</a></h4><ul><li><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p></li></ul><img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png" alt="img" style="zoom:33%;" /><h3 id="1、冒泡排序">1、冒泡排序<a class="anchor" href="#1、冒泡排序">·</a></h3><ul><li><p>最简单的一个，但性能最差，工作很少用，但面试可能会遇到</p></li><li><p>原理：</p><ul><li>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</li><li>走访数列的工作是重复地进行直到没有再需要交换</li></ul></li><li><p>图示：</p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img" style="zoom: 50%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bubbleSort</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">//this就是调用的数组</span></span><br><span class="line">  <span class="comment">// 外层循环：控制有多少趟：每趟冒泡一个最大值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>-<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 内层循环：控制每趟比较时，需要比较多少次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">this</span>.<span class="property">length</span>-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>[j] &gt; <span class="variable language_">this</span>[j+<span class="number">1</span>])&#123;</span><br><span class="line">        [<span class="variable language_">this</span>[j], <span class="variable language_">this</span>[j+<span class="number">1</span>]] = [<span class="variable language_">this</span>[j+<span class="number">1</span>], <span class="variable language_">this</span>[j]]; <span class="comment">// 相邻元素交换</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">arr.<span class="title function_">bubbleSort</span>();</span><br></pre></td></tr></table></figure><ul><li>时间：两个for循环嵌套，O(n^2)</li></ul></li></ul><h3 id="2、选择排序">2、选择排序<a class="anchor" href="#2、选择排序">·</a></h3><ul><li><p>原理：（类似于老师安排小朋友排队）</p><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li></ul></li><li><p>图示：</p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="img" style="zoom:50%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">selectSort</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//第一轮经过循环，找到最小值，并进行交换</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="variable language_">this</span>.<span class="property">length</span>-<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> indexMin = i;    <span class="comment">// 记录indexMin，遍历后面的查找是否有更小的，然后交换二者位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; <span class="variable language_">this</span>.<span class="property">length</span>; j++)&#123; <span class="comment">// 之前的都已经排好了</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>[j] &lt; <span class="variable language_">this</span>[indexMin]) indexMin = j;</span><br><span class="line">      <span class="comment">//找到了最小值的索引，然后交换第一位</span></span><br><span class="line">      <span class="keyword">if</span>(indexMin !== i) &#123;</span><br><span class="line">        [<span class="variable language_">this</span>[i], <span class="variable language_">this</span>[indexMin]] = [<span class="variable language_">this</span>[indexMin], <span class="variable language_">this</span>[i]];<span class="comment">//将最小值交换过来</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  * 时间：两个嵌套循环，也是O(n^2)，跟冒泡一样性能差</span><br><span class="line">  * 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好</span><br><span class="line"></span><br><span class="line">### 3、插入排序 ###</span><br><span class="line"></span><br><span class="line">* 原理：</span><br><span class="line"></span><br><span class="line">  通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</span><br><span class="line"></span><br><span class="line">* 具体步骤：</span><br><span class="line"></span><br><span class="line">  * 从第一个元素开始，该元素可以认为已经被排序；</span><br><span class="line">  * 取出下一个元素，在已经排序的元素序列中从后向前扫描；</span><br><span class="line">  * 如果该元素（已排序）大于新元素，将该元素移到下一位置；</span><br><span class="line">  * 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</span><br><span class="line">  * 将新元素插入到该位置后；</span><br><span class="line">  * 重复步骤2~5。</span><br><span class="line">  </span><br><span class="line">* 图示：</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif&quot; alt=&quot;img&quot; style=&quot;zoom: 33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  Array.prototype.insertSort = function()&#123;</span><br><span class="line">    for(let i = 1; i &lt; this.length; i++)&#123;</span><br><span class="line">      const tempValue = this[i];</span><br><span class="line">      let j = i;  // 记录当前索引，从当前开始往前比较</span><br><span class="line">      while(j&gt;0)&#123;</span><br><span class="line">        //如果前面有第一个比它大的元素，前面元素后移一位</span><br><span class="line">        if(this[j-1] &gt; tempValue)&#123; </span><br><span class="line">          this[j] = this[j-1]; // 如果前面有比它大的，将那个元素后移一位</span><br><span class="line">        &#125;</span><br><span class="line">        else break; </span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      //放到合适的位置</span><br><span class="line">      this[j] = tempValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4、希尔排序">4、希尔排序<a class="anchor" href="#4、希尔排序">·</a></h3><ul><li><p>第一个突破O(n2)的排序算法，是简单插入排序的改进版。</p></li><li><p>它与插入排序的不同之处，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p></li><li><p>原理：</p><ul><li>核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列</li></ul></li><li><p>图示：</p><img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif" alt="img" style="zoom:33%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shellSort</span> = <span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;         <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、归并排序">5、归并排序<a class="anchor" href="#5、归并排序">·</a></h3><h4 id="基本算法">基本算法<a class="anchor" href="#基本算法">·</a></h4><ul><li><p>分治法的一个非常典型的应用。</p></li><li><p>原理：</p><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p><p>若将两个有序表合并成一个有序表，称为2-路归并。</p></li><li><p>实现思路</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li></ul></li><li><p>将两个排序好的子序列合并成一个最终的排序序列。</p></li><li><p>图示：</p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt="img" style="zoom:33%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mergeSort</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid);</span><br><span class="line">  <span class="keyword">const</span> right = arr.<span class="title function_">slice</span>(mid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> orderLeft = <span class="title function_">mergeSort</span>(left); <span class="comment">// 递归到最深处</span></span><br><span class="line">  <span class="keyword">const</span> orderRight = <span class="title function_">mergeSort</span>(right);</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">merge</span>(orderLeft, orderRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>)&#123;</span><br><span class="line">  <span class="comment">// 比较左右：同时对头出队，比较，合并到res中</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span> &amp;&amp; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> curVal = left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]? left.<span class="title function_">shift</span>() : right.<span class="title function_">shift</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(curVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span>) res.<span class="title function_">push</span>(left.<span class="title function_">shift</span>());</span><br><span class="line">  <span class="keyword">while</span> (right.<span class="property">length</span>) res.<span class="title function_">push</span>(right.<span class="title function_">shift</span>());</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分：O(logN)，每次都把数组劈成两半，logN次。log这个函数用于求2的多少次方等于n，一个数组劈多少次变成n个数字，就是logN次。一般二分操作，基本可以联想到logN</li><li>合并的复杂度：O(n)，while循环实现的       所以总体时间: O(n*logN)</li><li>稳定排序</li></ul></li></ul><h4 id="变形面试题：合并有序数组">变形面试题：合并有序数组<a class="anchor" href="#变形面试题：合并有序数组">·</a></h4><ul><li><p>a和b都是有序的数组，利用归并排序实现合并为一个有序数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reSort</span> = (<span class="params">arr1, arr2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="title class_">Math</span>.<span class="title function_">min</span>(arr1.<span class="property">length</span>, arr2.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> curVal = arr1[i] &lt; arr2[i] ? arr1.<span class="title function_">shift</span>(): arr2.<span class="title function_">shift</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(curVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(arr1.<span class="property">length</span>) res.<span class="title function_">push</span>(...arr1);</span><br><span class="line">  <span class="keyword">if</span>(arr2.<span class="property">length</span>) res.<span class="title function_">push</span>(...arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6、快速排序">6、快速排序<a class="anchor" href="#6、快速排序">·</a></h3><ul><li><p>原理：</p><p>通过一趟排序，用分治法来把一个串（list）分为两个子串（sub-lists），分别对这两部分继续排序，以达到整个有序</p></li><li><p>实现思路：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重排数列，所有比基准值小的放在基准前面，所有比基准值大的摆在基准后面（相同的数可以到扔一边）。在这个分区退出之后，该基准就处于数列的中间位置。这称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></li><li><p>图示：</p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt="img" style="zoom: 50%;" /><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr, left, right</span>)&#123;  <span class="comment">// 版本1：</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> partitionIndex = <span class="title function_">partition</span>(arr, left, right);</span><br><span class="line">    <span class="title function_">quickSort</span>(arr, left, partitionIndex-<span class="number">1</span>);</span><br><span class="line">    <span class="title function_">quickSort</span>(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">arr, left ,right</span>) &#123;    <span class="comment">// 分区操作</span></span><br><span class="line">  <span class="keyword">let</span> pivot = left;                    <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">  <span class="keyword">let</span> index = pivot + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;  <span class="comment">// 小于基准的，扔左边</span></span><br><span class="line">      [arr[i], arr[index]] = [arr[index], arr[i]];</span><br><span class="line">      index++;</span><br><span class="line">    &#125;       </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将基准值移到正确位置index-1</span></span><br><span class="line">[arr[pivot], arr[index - <span class="number">1</span>]] = [arr[index - <span class="number">1</span>], arr[pivot]];</span><br><span class="line">  <span class="keyword">return</span> index-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">quickSort</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">const</span> left = [];</span><br><span class="line">  <span class="keyword">const</span> right = [];</span><br><span class="line">  <span class="keyword">const</span> mid = arr[<span class="number">0</span>]; <span class="comment">// 基准</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; mid)&#123;</span><br><span class="line">      left.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="title function_">rec</span>(left), mid, ...<span class="title function_">rec</span>(right)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7、堆排序">7、堆排序<a class="anchor" href="#7、堆排序">·</a></h3><h4 id="1、堆：数据结构">1、堆：数据结构<a class="anchor" href="#1、堆：数据结构">·</a></h4><ul><li><p>堆是一个完全二叉树，每层节点都完全填满，最后一层如果不是满的，则只缺少右边的</p></li><li><p>堆上的任意节点值都必须大于等于（<strong>大顶堆</strong>）或小于等于（<strong>小顶堆</strong>）其左右子节点值</p></li><li><p>二叉树是用Object来构建的，堆是一种完全二叉树的结构，为何堆用数组构建呢？</p><p>因为堆的结构，用数组表示符合以下规律</p><ul><li>第<code>i</code>个元素：其父节点为：<code>(n-1)/2</code>，左子节点为 <code>2i+1</code> ，右子节点为 <code>2i+2</code></li><li>最后一个非叶子节点为： <code>Math.floor(array.length / 2) - 1</code></li></ul><p>例如<strong>大顶堆：</strong></p><img src="https://pic.leetcode-cn.com/1624163681-hJGivE-image.png" alt="image.png" style="zoom: 50%;" /><p>对堆中的节点按层进行编号，映射到数组中如下图</p><img src="https://pic.leetcode-cn.com/1624163693-HYBERK-image.png" alt="image.png" style="zoom:50%;" /></li><li><p>建堆方式：</p><ol start="2"><li>原地创建：又称<strong>堆化</strong>，给定一组节点，实现一个大顶堆（或小顶堆）</li><li>插入式创建：每次插入一个节点，实现一个大顶堆（或小顶堆）</li></ol></li><li><p>用途：</p><ul><li>高效快速的找出<strong>最大值/最小值</strong>，时间复杂度：O(1)。最上面的就是最大/最小</li><li>找出<strong>第K个最大（小）元素</strong><ul><li>构建一个<strong>最小堆</strong>，并将元素依次插入堆中</li><li>当堆的容量超过K，就删除堆顶（最小元素）</li><li>插入结束后，堆顶就是第K个最大元素</li></ul></li></ul></li></ul><h4 id="2、堆化建堆">2、堆化建堆<a class="anchor" href="#2、堆化建堆">·</a></h4><h5 id="思路总结：">思路总结：<a class="anchor" href="#思路总结：">·</a></h5><ul><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素「沉」到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶与当前末尾元素，反复执行调整、交换步骤，直到整个序列有序。</li></ul><h5 id="构造初始堆">构造初始堆<a class="anchor" href="#构造初始堆">·</a></h5><ol><li><p>给定无序序列结构</p><img src="https://pic.leetcode-cn.com/1624163715-VXPhZJ-image.png" alt="image.png" style="zoom:50%;" /></li><li><p><strong>此时从最后一个非叶子节点开始调整</strong>，从左到右，从上到下进行调整。也就是 元素为 6 的节点。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较时：先让 5 与 9 比较，得到最大那个，再和 6 比较，发现 9 大于 6，则调整他们的位置</span><br></pre></td></tr></table></figure></li><li><p>找到第二个非叶子节点 4，由于 <code>[4,9,8]</code> 中，9 元素最大，则 4 和 9 交换</p><img src="https://pic.leetcode-cn.com/1624163737-nWDnEx-image.png" alt="image.png" style="zoom: 67%;" /></li><li><p>此时，交换导致子根 <code>[4,5,6]</code> 结构混乱，将其继续调整。<code>[4,5,6]</code> 中 6 最大，将 4 与 6 调整。此时，就将一个无序序列构造成了一个大顶堆。</p><img src="https://pic.leetcode-cn.com/1624163748-vVZNTN-image.png" alt="image.png" style="zoom: 67%;" /></li></ol><h5 id="代码实现">代码实现<a class="anchor" href="#代码实现">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从最后一个非叶子节点开始构建大顶堆</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">adjustHeap</span>(arr, i, arr.<span class="property">length</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从左向右，自上而下的调整节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">adjustHeap</span>(<span class="params">arr, i, len</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = i * <span class="number">2</span> + <span class="number">1</span>;             <span class="comment">// 左子节点索引</span></span><br><span class="line">  <span class="keyword">let</span> right = i * <span class="number">2</span> + <span class="number">2</span>;            <span class="comment">// 右子节点索引</span></span><br><span class="line">  <span class="keyword">let</span> maxIndex = i;                <span class="comment">// 最大值索引</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录最大值索引</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[maxIndex]) maxIndex = left;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[maxIndex]) maxIndex = right;</span><br><span class="line">  <span class="comment">// maxIndex为父节点，若发生改变则说明不是最大节点，需要交换</span></span><br><span class="line">  <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">    [arr[maxIndex], arr[i]] = [arr[i], arr[maxIndex]];</span><br><span class="line">    <span class="title function_">adjustHeap</span>(arr, maxIndex, len); <span class="comment">// 交换之后，结构会混乱，so递归再次调整比较</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildMaxHeap</span>([<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>]))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">nums,heapSize</span>)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="title class_">Math</span>.<span class="title function_">floor</span>(heapSize/<span class="number">2</span>)-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="title function_">maxHeapify</span>(nums,i,heapSize)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 从左向右，自上而下的调整节点</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">maxHeapify</span>(<span class="params">nums,i,heapSize</span>)&#123;</span><br><span class="line">       <span class="keyword">let</span> l=i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">       <span class="keyword">let</span> r=i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">       <span class="keyword">let</span> largest=i</span><br><span class="line">       <span class="keyword">if</span>(l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest])&#123;</span><br><span class="line">           largest=l</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest])&#123;</span><br><span class="line">           largest=r</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(largest!==i)&#123;</span><br><span class="line">           <span class="title function_">swap</span>(nums,i,largest) <span class="comment">// 进行节点调整</span></span><br><span class="line">           <span class="comment">// 继续调整下面的非叶子节点</span></span><br><span class="line">           <span class="title function_">maxHeapify</span>(nums,largest,heapSize)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、插入式建堆">3、插入式建堆<a class="anchor" href="#3、插入式建堆">·</a></h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/1727787c5661104a~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 25%;" /><ul><li>时间复杂度：O(logk),k为插入堆中的元素的大小,上移操作上最多循环次数是堆的高度，而二叉树中堆的高度与节点的关系是logk</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大顶堆创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">shiftUp</span>(<span class="params">index</span>)&#123;        <span class="comment">//插入过程中的上移操作</span></span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//上移到堆顶了</span></span><br><span class="line">    <span class="keyword">const</span> parentIndex = (index-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">//Math.floor((i-1)/2)简化代码</span></span><br><span class="line">    <span class="comment">//与父节点比较,条件必须最后父节点小于等于该节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">heap</span>[parentIndex] &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[index])&#123; <span class="comment">//小顶堆这里改为 大于&gt;</span></span><br><span class="line">      [<span class="variable language_">this</span>.<span class="property">heap</span>[parentIndex], <span class="variable language_">this</span>.<span class="property">heap</span>[index]] = [<span class="variable language_">this</span>.<span class="property">heap</span>[index], <span class="variable language_">this</span>.<span class="property">heap</span>[parentIndex]];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">shiftUp</span>(parentIndex); <span class="comment">// 注意传参是父节点了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">push</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">shiftUp</span>(<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span>-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h = <span class="keyword">new</span> <span class="title class_">MinHeap</span>();</span><br><span class="line">h.<span class="property">heap</span> = [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">h.<span class="title function_">insert</span>(<span class="number">8</span>); <span class="comment">//h.heap: [  8, 5, 6, 1, 3, 2, 4]</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>删除堆顶</strong>：</p><ul><li>**删除堆顶：**直接删除堆顶，后面的元素会前移，会破坏堆结构。所以要用数组的尾部元素来替换堆顶，然后下移，将新堆顶和他的子节点进行交换，直到子节点大于等于这个新堆顶<ul><li>时间复杂度：O(logk)，时间主要花在下移的操作，操作也是堆的高度</li></ul></li><li><strong>获取堆顶和堆的大小</strong><ul><li>获取堆顶：数组的头部</li><li>获取堆的大小：数组的长度</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.删除栈顶</span></span><br><span class="line"><span class="title function_">pop</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">shiftDown</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">shiftDown</span>(<span class="params">index</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> leftIndex = index*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> rightIndex = index*<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 若子节点“左或右大于当前节点</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">heap</span>[leftIndex] &gt; <span class="variable language_">this</span>.<span class="property">heap</span>[index])&#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">heap</span>[leftIndex], <span class="variable language_">this</span>.<span class="property">heap</span>[index]] = [<span class="variable language_">this</span>.<span class="property">heap</span>[index], <span class="variable language_">this</span>.<span class="property">heap</span>[leftIndex]]; <span class="comment">// 交换位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">shiftDown</span>(leftIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">heap</span>[rightIndex] &gt; <span class="variable language_">this</span>.<span class="property">heap</span>[index])&#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">heap</span>[rightIndex], <span class="variable language_">this</span>.<span class="property">heap</span>[index]] = [<span class="variable language_">this</span>.<span class="property">heap</span>[index], <span class="variable language_">this</span>.<span class="property">heap</span>[rightIndex]]; <span class="comment">// 交换位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">shiftDown</span>(rightIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、堆排序">4、堆排序<a class="anchor" href="#4、堆排序">·</a></h4><ul><li><p>堆排序可以认为是<strong>选择排序的改进版</strong>，像<a href="https://juejin.cn/post/7034819462687621133">选择排序</a>一样将输入划分为已排序和待排序</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="title function_">heapSort</span>(arr);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> len = array.<span class="property">length</span>;</span><br><span class="line">  <span class="title function_">buildMaxHeap</span>(array); <span class="comment">// 构建一个大顶堆</span></span><br><span class="line">  <span class="comment">// 调整为大顶堆后，顶元素为最大元素并与末尾元素交换</span></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123; <span class="comment">// 当len&lt;= 0时，说明已经到堆顶</span></span><br><span class="line">    [array[<span class="number">0</span>], array[len - <span class="number">1</span>]] = [array[len - <span class="number">1</span>], array[<span class="number">0</span>]]; <span class="comment">// 交换</span></span><br><span class="line">    len--; <span class="comment">// 交换之后相当于把树中的最大值弹出去了，所以len--</span></span><br><span class="line">    <span class="comment">// 交换值并剔除了最大值后，继续调整使之再次成为大顶堆</span></span><br><span class="line">    <span class="title function_">adjustHeap</span>(array, <span class="number">0</span>, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>建堆过程的时间是 <code>O(n)</code> ，排序过程的时间是 <code>O(nlogn)</code> ，整体时间是 <code>O(nlogn)</code></li></ul></li></ul><h3 id="8、计数排序-略">8、计数排序  略<a class="anchor" href="#8、计数排序-略">·</a></h3><h3 id="9、桶排序-略">9、桶排序    略<a class="anchor" href="#9、桶排序-略">·</a></h3><h3 id="10、基数排序-略">10、基数排序  略<a class="anchor" href="#10、基数排序-略">·</a></h3>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的一些方法</title>
      <link href="/posts/2799443321.html"/>
      <url>/posts/2799443321.html</url>
      
        <content type="html"><![CDATA[<h3 id="数组方法">数组方法<a class="anchor" href="#数组方法">·</a></h3><h4 id="1、splice-2">1、splice<a class="anchor" href="#1、splice-2">·</a></h4><p>作用：向数组中添加/删除项目，然后返回被删除的项目构成的新数组，同时原数组也发生了改变</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure><ul><li><p>index：添加/删除项目的位置，使用负数可从数组结尾处规定位置 —必需</p></li><li><p>howmany：要删除的项目数量。<strong>如果设置为 0</strong>，<strong>则不会删除项目</strong> --必需</p></li><li><p>第3项：向数组添加的新项目      --可选</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;William&quot;</span>)<span class="comment">//创建一个新数组，并将索引为2的那项添加wiliam，后面的索引依次后移</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;William&quot;</span>) <span class="comment">//删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;William&quot;</span>) <span class="comment">//删除从 index 2 (&quot;Thomas&quot;) 开始的三个元素，并添加一个新元素 (&quot;William&quot;) 来替代被删除的元素</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、slice：没有修改原数组，返回新数组-2">2、slice：没有修改原数组，返回新数组<a class="anchor" href="#2、slice：没有修改原数组，返回新数组-2">·</a></h4><p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</p><ul><li>若传参为空，则返回数组拷贝</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arrayObject.<span class="title function_">slice</span>(start,end)</span><br></pre></td></tr></table></figure><ul><li>start：从何处开始选取。负数，从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。  —必需</li><li>end：从何处结束选取。如果没有指定，那么start到数组结束的所有元素，负数，从数组尾部开始算起   --可选</li></ul><h4 id="3、filter-2">3、filter<a class="anchor" href="#3、filter-2">·</a></h4><ul><li><p>遍历数组中每一个元素，返回所有函数返回结果为true的元素，这些元素构成的数组就是filter()方法的返回值</p></li><li><pre><code class="language-js">// 定义数组var names = [&quot;abc&quot;, &quot;cb&quot;, &quot;mba&quot;, &quot;dna&quot;]// 获取names中所有包含'a'字符的元素var newNames = names.filter(function (t) &#123;    return t.indexOf(&quot;a&quot;) != -1&#125;)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">array.filter(function(value,index,array),contetx)</span><br><span class="line">- value—当前数组值，必须</span><br><span class="line">- index—数组索引，非必须</span><br><span class="line">- array—当前数组，非必须</span><br><span class="line">- context—指定回调函数的this值，一般不穿，默认是undefined的</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>实现如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFilter</span> = <span class="keyword">function</span>(<span class="params">fn,context</span>)&#123;</span><br><span class="line">  <span class="comment">// 调用.myFilter方法的那个数组</span></span><br><span class="line">      <span class="keyword">var</span> arr = <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">var</span> newArr = []</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fn.<span class="title function_">call</span>(context,arr[i],i,arr))&#123;</span><br><span class="line">          newArr.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduceToFilter</span> = <span class="keyword">function</span> (<span class="params">fn,context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, current, index)) &#123;</span><br><span class="line">      target.<span class="title function_">push</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、map-2">4、map<a class="anchor" href="#4、map-2">·</a></h4><ul><li>遍历数组，每个元素经过某函数的作用后，变成新元素，最后形成一个新数组</li><li>与forEach的区别：<ol><li>forEach返回的是undefined，因此它也不支持链式调用；而map不改变原数组但是会 返回新数组</li><li>forEach没有返回值，不可以中断，不能使用return返回到外层函数；map可以break中断循环，可以return返回到外层函数<ul><li>forEach() 对于空数组是不会执行回调函数的。</li><li>for可以用continue跳过循环中的一个迭代，forEach用continue会报错。</li><li>forEach() 需要用 return 跳过循环中的一个迭代，跳过之后会执行下一个迭代。</li></ul></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">value,index,array</span>), context)</span><br><span class="line">- value—当前数组值，必须</span><br><span class="line">- index—数组索引，非必须</span><br><span class="line">- array—该数组，非必须</span><br><span class="line">- context—指定回调函数的<span class="variable language_">this</span>值</span><br></pre></td></tr></table></figure><ul><li>实现如下</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMap</span> = <span class="keyword">function</span>(<span class="params">fn, context</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//map处理完就push</span></span><br><span class="line">    newArr.<span class="title function_">push</span>(fn.<span class="title function_">call</span>(context, arr[i], i, arr))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">用reduce实现map</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduceToMap</span> = <span class="keyword">function</span> (<span class="params">fn, context</span>) &#123;</span><br><span class="line"><span class="comment">// this就是使用map的数组实例</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">target.<span class="title function_">push</span>(fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, current, index))</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5、reduce-2">5、reduce<a class="anchor" href="#5、reduce-2">·</a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">pre,cur,index,arr</span>),initalval)</span><br><span class="line">- pre—当前累加值，必须</span><br><span class="line">- cur—当前数组值，必须</span><br><span class="line">- index—数组索引，非必须</span><br><span class="line">- arr—该数组，非必须</span><br><span class="line">- initalVal—累加值初始值，非必须，**不传值的话，数组第一个元素为默认值**</span><br></pre></td></tr></table></figure><ul><li>实现核心：没有传入initalVal时，初始值设为数组第1个元素，并从第2个元素开始便利。回到函数应该处理第二个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReduce</span>=<span class="keyword">function</span>(<span class="params">fn,inital</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">let</span> total = inital ? <span class="attr">inital</span>:arr[<span class="number">0</span>]  <span class="comment">//关键</span></span><br><span class="line">      <span class="keyword">let</span> startIndex = inital ? <span class="number">0</span>:<span class="number">1</span>       <span class="comment">//关键</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=startIndex; i&lt;arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        total = fn.<span class="title function_">call</span>(<span class="literal">null</span>,total,arr[i],i,arr); <span class="comment">//注意要传入一个null，第二个是total</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Sort-2">6、Sort<a class="anchor" href="#6、Sort-2">·</a></h4><p>在原数组上排序，不生成副本</p><ul><li><p>若参数为空，按照字符编码的顺序进行排序</p></li><li><p>其他标准：提供比较函数</p><ul><li><p>该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数 a 和 b，其返回值如下：</p><ul><li><p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</p></li><li><p>若 a 等于 b，则返回 0。</p></li><li><p>若 a 大于 b，则返回一个大于 0 的值</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="title class_">Array</span>.<span class="title function_">from</span>(map).<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 如果a是较小的，那么b[1]-a[1]就是正的。a应该在b之后。所以输出是降序排列</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7、some-2">7、some<a class="anchor" href="#7、some-2">·</a></h4><p>只要有一个元素比对结果为true，返回结果就为true</p><h4 id="8、every-2">8、every<a class="anchor" href="#8、every-2">·</a></h4><ul><li><p>使用指定函数检测数组中的所有元素是否都符合指定条件，所有符合，return true，否则返回false</p></li><li><p>不会改变原始数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), thisValue)</span><br></pre></td></tr></table></figure></li></ul><h4 id="9、Array-from-2">9、Array.from<a class="anchor" href="#9、Array-from-2">·</a></h4><ul><li>从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例<ul><li>伪数组对象（拥有一个 <code>length</code> 属性和若干索引属性的任意对象）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/iterable">可迭代对象</a>（可以获取对象中的元素,如 Map和 Set 等）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">// [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ] 从 String 生成数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]);  从 <span class="title class_">Set</span> 生成数组</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(set);     <span class="comment">// [ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapper = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]);  <span class="comment">//从 Map 生成数组</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(map);    <span class="comment">//[[&#x27;1&#x27;, &#x27;a&#x27;], [&#x27;2&#x27;, &#x27;b&#x27;]]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(mapper.<span class="title function_">values</span>());  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;];</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(mapper.<span class="title function_">keys</span>());   <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;];</span></span><br><span class="line"></span><br><span class="line">从类数组对象（<span class="variable language_">arguments</span>）生成数组</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">x</span> =&gt;</span> x + x);       <span class="comment">// [2, 4, 6] 在 Array.from 中使用箭头函数</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i);    <span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="title class_">Array</span>.<span class="title function_">from</span>(map).<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="是否改变数组">是否改变数组<a class="anchor" href="#是否改变数组">·</a></h3><ul><li><h4 id="改变：push、unshift、pop、shift、reverse-、sort、splice-2">改变：push、unshift、pop、shift、reverse 、sort、splice<a class="anchor" href="#改变：push、unshift、pop、shift、reverse-、sort、splice-2">·</a></h4></li><li><h4 id="不改变：concat-、map、every、some-、filter、toString、slice-、join、indexOf-2">不改变：concat 、map、every、some 、filter、toString、slice 、join、indexOf<a class="anchor" href="#不改变：concat-、map、every、some-、filter、toString、slice-、join、indexOf-2">·</a></h4></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域中的CORS、JSONP</title>
      <link href="/posts/2971665882.html"/>
      <url>/posts/2971665882.html</url>
      
        <content type="html"><![CDATA[<h3 id="方案1、CORS（跨域资源共享）">方案1、CORS（跨域资源共享）<a class="anchor" href="#方案1、CORS（跨域资源共享）">·</a></h3><p>浏览器与服务器商量后的一个结果</p><h4 id="1、概念-2">1、概念<a class="anchor" href="#1、概念-2">·</a></h4><ul><li><p>是一种机制，使用额外的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FHTTP">HTTP</a> 头来允许服务器声明哪些源 可以通过浏览器有权限访问哪些资源。</p></li><li><p>不需要在客户端做任何特殊的操作，浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p></li><li><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><ul><li>简单请求：不会触发预检请求的请求</li><li>复杂请求：除了简单请求</li></ul></li></ul><h4 id="2、简单请求如何工作">2、简单请求如何工作<a class="anchor" href="#2、简单请求如何工作">·</a></h4><p>浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息添加一个<code>Origin</code>字段：</p><ul><li>用来说明，本次请求来自哪个源（协议 + 域名 + 端口）</li><li>服务器根据这个值，决定是否同意这次请求</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="title class_">Host</span>: api.<span class="property">alice</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure><ol><li><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应：</p><p>浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获</p><p>【注意】：这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200</p></li><li><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p></li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line">// 指定后，可以返回`FooBar`字段的值</span><br><span class="line"><span class="attribute">Access-Control-Expose-Headers</span><span class="punctuation">: </span>FooBar</span><br><span class="line"></span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><ul><li>必须。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求</li></ul><p><strong>（2）Access-Control-Allow-Credentials</strong></p><ul><li><p>可选。它的值是一个布尔值，表示<strong>是否允许发送Cookie</strong></p></li><li><p>默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p></li><li><p>这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可</p></li></ul><p><strong>（3）Access-Control-Expose-Headers</strong></p><ul><li><p>可选，CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code></p></li><li><p>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定</p></li></ul><h4 id="3、-withCredentials-属性">3、 withCredentials 属性<a class="anchor" href="#3、-withCredentials-属性">·</a></h4><ol><li>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段</li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理</li></ol><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</li></ol><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></blockquote><p>【注意】：</p><ol><li>如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</li><li>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传</li><li>且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie</li></ol><h4 id="4、复杂请求如何工作">4、复杂请求如何工作<a class="anchor" href="#4、复杂请求如何工作">·</a></h4><p>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求，通过该请求来知道服务端是否允许跨域请求</p><ul><li>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段</li><li>只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错</li></ul><h4 id="4-1、预检请求的发送">4.1、预检请求的发送<a class="anchor" href="#4-1、预检请求的发送">·</a></h4><ul><li><p>&quot;预检&quot;请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p></li><li><p>除了<code>Origin</code>字段，&quot;预检&quot;请求的头信息包括两个特殊字段</p></li></ul><p><strong>（1）Access-Control-Request-Method</strong></p><ul><li>必须，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code></li></ul><p><strong>（2）Access-Control-Request-Headers</strong></p><ul><li>是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code></li></ul><p>下面是一段浏览器的JavaScript脚本。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://api.alice.com/cors&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></blockquote><p>这个&quot;预检&quot;请求的HTTP头信息。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2、预检请求的回应">4.2、预检请求的回应<a class="anchor" href="#4-2、预检请求的回应">·</a></h4><ul><li><p>服务器收到&quot;预检&quot;请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应</p></li><li><p>HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure></blockquote><ol><li>HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li><p>如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但没有任何CORS相关的头信息字段</p><p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure></li><li><p>服务器回应的其他CORS相关字段如下。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span><span class="punctuation">: </span>1728000</span><br></pre></td></tr></table></figure></blockquote><h5 id="（1）Access-Control-Allow-Methods">（1）Access-Control-Allow-Methods<a class="anchor" href="#（1）Access-Control-Allow-Methods">·</a></h5><ul><li>必须，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</li><li>返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求</li></ul><h5 id="（2）Access-Control-Allow-Headers">（2）Access-Control-Allow-Headers<a class="anchor" href="#（2）Access-Control-Allow-Headers">·</a></h5><ul><li>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的</li><li>也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段</li></ul><h5 id="（3）Access-Control-Allow-Credentials">（3）Access-Control-Allow-Credentials<a class="anchor" href="#（3）Access-Control-Allow-Credentials">·</a></h5><ul><li>该字段与简单请求时的含义相同</li></ul><h5 id="（4）Access-Control-Max-Age">（4）Access-Control-Max-Age<a class="anchor" href="#（4）Access-Control-Max-Age">·</a></h5><ul><li>可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天）</li><li>在此期间，不用发出另一条预检请求</li></ul></li></ol><h4 id="4-3-、浏览器的正常请求和回应">4.3 、浏览器的正常请求和回应<a class="anchor" href="#4-3-、浏览器的正常请求和回应">·</a></h4><ul><li><p>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会自动有一个<code>Origin</code>头信息字段。</p></li><li><p>服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p></li></ul><p>下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">X-Custom-Header</span><span class="punctuation">: </span>value</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure></blockquote><p>下面是服务器正常的回应</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-4、配置流程：">4.4、配置流程：<a class="anchor" href="#4-4、配置流程：">·</a></h4><ul><li><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如上面所说的，后端是实现 CORS 通信的关键</p></li><li><p>前端：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;name=xiamen&#x27;</span> <span class="comment">// cookie不能跨域</span></span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span> <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;http://localhost:4000/getData&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xiamen&#x27;</span>)</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">      <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure></li><li><p>后端配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server1.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server2.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">&#x27;http://localhost:3000&#x27;</span>] <span class="comment">//设置白名单</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.<span class="property">headers</span>.<span class="property">origin</span>;</span><br><span class="line">  <span class="keyword">if</span> (whitList.<span class="title function_">includes</span>(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)</span><br><span class="line">    <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">    <span class="comment">// 允许携带cookie</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 预检的存活时间</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 允许返回的头</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> === <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      res.<span class="title function_">end</span>() <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">put</span>(<span class="string">&#x27;/getData&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">headers</span>)</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jw&#x27;</span>) <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/getData&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">headers</span>)</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname))</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">4000</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、与JSONP比较">5、与JSONP比较<a class="anchor" href="#5、与JSONP比较">·</a></h4><p>使用目的相同，但是比JSONP更强大：</p><ul><li>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求</li><li>JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</li></ul><h4 id="6、简单、复杂请求">6、简单、复杂请求<a class="anchor" href="#6、简单、复杂请求">·</a></h4><h5 id="1、简单请求">1、简单请求<a class="anchor" href="#1、简单请求">·</a></h5><p>不会触发 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS%23Preflighted_requests">CORS 预检请求</a>。这样的请求为“简单请求”：</p><ul><li><p>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</p><ul><li>get、head、post</li></ul></li><li><p>情况二: 人为设置以下集合外的请求头</p><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept"><code>Accept</code></a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept-Language"><code>Accept-Language</code></a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Language"><code>Content-Language</code></a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Type"><code>Content-Type</code></a> （需要注意额外的限制）</li><li><code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code></li></ul></li><li><p>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 application/json 为非简单请求)</p><ul><li><code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code></li></ul></li><li><p>情况四:</p><p>请求中的任意<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest%2Fupload"><code>XMLHttpRequest.upload</code></a> 属性访问</p></li><li><p>情况五:</p><p>请求中没有使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FReadableStream"><code>ReadableStream</code></a> 对象</p></li></ul><h5 id="2、复杂请求">2、复杂请求<a class="anchor" href="#2、复杂请求">·</a></h5><p>除了简单请求</p>]]></content>
      
      
      <categories>
          
          <category> 1.3-Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>animation动画的demo</title>
      <link href="/posts/511687579.html"/>
      <url>/posts/511687579.html</url>
      
        <content type="html"><![CDATA[<h2 id="明天再复习一下，会再更新的…">明天再复习一下，会再更新的…<a class="anchor" href="#明天再复习一下，会再更新的…">·</a></h2><h3 id="animation动画demo">animation动画demo<a class="anchor" href="#animation动画demo">·</a></h3><h4 id="实现物体移动">实现物体移动<a class="anchor" href="#实现物体移动">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-8874535.c42328d7.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>定义不同时间点来让物体元素移动一圈，这里就可以不设置<code>from/to</code> 系统将定义为元素初始状态。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">2px</span> white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e67e22</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;&#125;  // 不设置：仍然是原始状态</span><br><span class="line">  <span class="number">25%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">300%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">300%</span>, <span class="number">300%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">75%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">300%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="炫彩背景">炫彩背景<a class="anchor" href="#炫彩背景">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-8878649.86285441.gif" alt="Untitled" style="zoom: 25%;" /><p>声明三个动画，使用 <code>animation-duration</code>为每个动画设置不同执行的时间</p><ul><li><p>DOm结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">main</span>&gt;&lt;/<span class="selector-tag">main</span>&gt;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#34495e</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: scale, colors, rotate;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>, <span class="number">5s</span>, <span class="number">1s</span>;   // <span class="number">3</span>种动画执行次数不同</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>旋转、颜色、大小：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> scale &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> colors &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#e67e22</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#34495e</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#16a085</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rotate &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="心动的感觉">心动的感觉<a class="anchor" href="#心动的感觉">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-8894047.f0ee8861.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>心的构成：两个圆+正方形，圆把正方形压住。整体旋转正</p><img src="https://doc.houdunren.com/assets/img/image-20190919170506721.7bd12d30.png" alt="image-20190919170506721" style="zoom:25%;" /></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;heart&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);<span class="comment">/*旋转变正*/</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">animation-name</span>: heart;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">::before</span> &#123;   <span class="comment">/* 两个圆的1号圆：圆的直径等于正方形的边长*/</span></span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0px</span>);  <span class="comment">/* 在垂直方向居中 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">::after</span> &#123;  <span class="comment">/* 两个圆的2号圆*/</span></span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> heart &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">3</span>) <span class="built_in">rotate</span>(<span class="number">45deg</span>); <span class="comment">/*此处的rotate(45deg)不要拿掉了，原本是这样的*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">rotate</span>(<span class="number">45deg</span>);<span class="comment">/*变大：跳动*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个心跳">多个心跳<a class="anchor" href="#多个心跳">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-9072635.d0d86895.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>Dom结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>normal<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>reverse<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>alternate<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>alternate-reverse<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>主要样式部分：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  // 设置具体宽高....</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">// 设置<span class="selector-tag">li</span>下面列方向排列....</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd;  </span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&gt;<span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">animation-direction</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&gt;<span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">animation-direction</span>: reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)&gt;<span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>)&gt;<span class="selector-tag">i</span><span class="selector-class">.fa</span> &#123;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="弹跳的小球">弹跳的小球<a class="anchor" href="#弹跳的小球">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-8895617.c0966e33.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>使用合适的运动方向 <code>alternate-reverse</code> 制作跳动的小球：0-100  100 -0</p><ul><li>球落下和弹起，相反的过程；</li><li>落下和弹起时阴影模糊程度变大，减轻</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  // 设置阴影</span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置球的样式 */</span> ....省略</span><br><span class="line">  <span class="attribute">animation-name</span>: ball;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> ball &#123;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">600px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: shadow;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> shadow &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">9</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="微场景">微场景<a class="anchor" href="#微场景">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-8899531.e8d14a71.gif" alt="Untitled" style="zoom: 33%;" /><ul><li><p>基本Dom结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  后盾人</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lesson&quot;</span>&gt;</span></span><br><span class="line">    系统课程是多个实战课程的组合，用来全面掌握一门</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;video hd-translate&quot;</span>&gt;</span></span><br><span class="line">    fsgdgfh艾弗森课程的组合，用来全面掌握一门语</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">  houdunren.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CSS部分：重点是动画设置：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-translate;  // 隐藏---出现</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-rotate;  // 隐藏---出现 +选择<span class="number">1</span>圈（xy平面）</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-class">.lesson</span> &#123;</span><br><span class="line">  //... 基本布局</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100vw</span>, -<span class="number">100vh</span>); //控制原始状态隐藏</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-rotate;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-class">.video</span> &#123;</span><br><span class="line">  //... 基本布局</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-translate;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100vw</span>, -<span class="number">100vh</span>);</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  //... 基本布局</span><br><span class="line">  <span class="attribute">animation-name</span>: hd-skew; // 倾斜</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">3s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100vw</span>);</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd-translate &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100vw</span>, -<span class="number">100vh</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd-rotate &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100%</span>, -<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd-skew &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>) <span class="built_in">skew</span>(-<span class="number">45deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="柱状起落">柱状起落<a class="anchor" href="#柱状起落">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-9379048.a9342460.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>5条不同的柱状，下降曲线不同的效果</p></li><li><p>Dom结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ease<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ease-in<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ease-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ease-in-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>linear<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>样式设置：</p><ul><li></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr;  //只有<span class="number">1</span>行<span class="number">1</span>列</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;houdunren.com&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">5</span>, <span class="number">1</span>fr);  // <span class="number">1</span>行<span class="number">5</span>列</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">10px</span>;   //每列间隔</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">animation-name</span>: move;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">3s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">90vh</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="改进弹跳小球">改进弹跳小球<a class="anchor" href="#改进弹跳小球">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-9139804.a095202a.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>改进的点：优化小球弹起过程幅度越来越小</p></li><li><p>如果想多个小球，可以再设置一个，位置上区分开，动画延时错开</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  //...</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0vw</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(at right top, <span class="number">#f39c12</span>, <span class="number">#d35400</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: jump;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> jump &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">30%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">10vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">60%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">40vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">80%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">60vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">95%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">75vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">15%</span>,<span class="number">45%</span>,<span class="number">70%</span>,<span class="number">85%</span>,<span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">80vh</span>);</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="魔术的小球">魔术的小球<a class="anchor" href="#魔术的小球">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-8904065.907dbaa9.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>效果：一群球不同时间进去，不同时间出来</p></li><li><p>乱跳的效果：控制动画%更小一点，精细一点</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  // ....</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">20vw</span>, -<span class="number">300%</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(at right top, <span class="number">#f39c12</span>, <span class="number">#d35400</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: jump;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1.5s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: .<span class="number">2s</span>;    <span class="comment">/*分别延迟不同的时间*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> jump &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">20vw</span>, -<span class="number">300%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">10%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">15vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">20%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">20vw</span>, -<span class="number">200%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">30%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">30vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">40%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">40vw</span>, -<span class="number">120%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">50vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">60%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">60vw</span>, -<span class="number">70%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">70%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">70vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">80%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">80vw</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">90%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">90vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">95%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">95vw</span>, -<span class="number">30%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">9</span>) <span class="built_in">translate</span>(<span class="number">100vw</span>, <span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="comment">/* transform: translateY(-400%); */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="comment">/* right: 100px; */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="按钮提交">按钮提交<a class="anchor" href="#按钮提交">·</a></h4><ul><li><p>模拟向后台提交数据时，等待的那种效果</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 只保留了主要功能代码 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="comment">/*移动第一个宽度   3个宽度   5个宽度*/</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">0</span> currentColor, <span class="number">9px</span> <span class="number">0</span> currentColor, <span class="number">15px</span> <span class="number">0</span> currentColor;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">animation-name</span>: point;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> point &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;  //起始的时候没有点</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">30%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">0</span> currentColor; // 只有<span class="number">1</span>个点</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">60%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">0</span> currentColor, <span class="number">9px</span> <span class="number">0</span> currentColor; //<span class="number">2</span>个点</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">90%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">0</span> currentColor, <span class="number">9px</span> <span class="number">0</span> currentColor, <span class="number">15px</span> <span class="number">0</span> currentColor; //<span class="number">3</span>个点</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>阴影使用API：原理就是底下有个黑盒子，所以最大水平移动自己宽度，再继续移就出来了。</p></li><li><p>如果给某个元素设置颜色color，就是阴影的颜色</p></li><li><p>background-color:orange;是元素本身的颜色</p></li><li><p>concurentColor：指的是当前的文本颜色</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>h-shadow</em></td><td style="text-align:left">必需。水平阴影的位置。允许负值。</td></tr><tr><td style="text-align:left"><em>v-shadow</em></td><td style="text-align:left">必需。垂直阴影的位置。允许负值。</td></tr><tr><td style="text-align:left"><em>blur</em></td><td style="text-align:left">可选。模糊距离。</td></tr><tr><td style="text-align:left"><em>spread</em></td><td style="text-align:left">可选。阴影的尺寸。</td></tr><tr><td style="text-align:left"><em>color</em></td><td style="text-align:left">可选。阴影的颜色。请参阅 CSS 颜色值。</td></tr><tr><td style="text-align:left">inset</td><td style="text-align:left">可选。将外部阴影 (outset) 改为内部阴影。</td></tr></tbody></table></li></ul></li></ul><h4 id="步进动画steps">步进动画steps<a class="anchor" href="#步进动画steps">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-9469170.45d93747.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p><code>steps(n,start)</code> 可以简单理解为从第二个开始，<code>steps(n,end)</code> 从第一个开始</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">main</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">1</span> &lt;small&gt;houdunren<span class="selector-class">.com</span>&lt;/small&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">2</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">3</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">4</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">5</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">6</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">7</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;<span class="number">8</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">main</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;END&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;  //父元素相对定位，<span class="attribute">z-index</span>浮在上面</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e67e22</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">animation-name</span>: move;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">4</span>, end);</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;START&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#9b59b6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">animation-name</span>: move;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">4</span>, start); //从<span class="number">2</span>开始的</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">400px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改效果为：在1-2之间来回走</p><img src="https://doc.houdunren.com/assets/img/Untitled-9484950.4ca2375f.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>此时如果只是修改translate的距离100，step的n为1就不可以，不会动，因为你只有1步</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)<span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2.5s</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;START&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#8e44ad</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: step-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;END&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#27ae60</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: step-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd &#123;</span><br><span class="line">  <span class="number">50%</span> &#123; </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);  //修改此处</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);  //回到原处</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="纯css轮播">纯css轮播<a class="anchor" href="#纯css轮播">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-9059867.a86bf9bf.gif" alt="Untitled" style="zoom: 33%;" /><ul><li><p>使用无JS参与的图片轮换效果，图片切换使用<code>steps</code> 步进与<code>animation-play-state</code>播放状态</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">5px</span> <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">section</span> &#123; // 鼠标经过暂停：图片+数字</span><br><span class="line">  <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">ul</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">animation-name</span>: slide;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">4s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">4</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> <span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  //<span class="attribute">flex</span>居中...</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  //<span class="attribute">flex</span>居中...</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  //画圆....</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">animation-name</span>: num;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">4s</span>;   //时间一致保持同步</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">4</span>, end);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> slide &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> num &#123;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="效果对比">效果对比<a class="anchor" href="#效果对比">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-9067254.58a8233a.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>具体区别：</p><ol><li>none：等待后，第1帧–结束–直接恢复到起始状态</li><li>backwards：等待过程中，使用的是第一帧的效果</li><li>forwards：执行技术完后，定在结束帧（等待验收）</li><li>both：结合两个，起始的时候使用的就是第一帧的效果，执行技术完后，定在结束帧（等待验收）</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>none<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>backwards<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>forwards<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>both<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>houdunren.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ecf0f1</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation-name</span>: hd;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: backwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hd &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#9b59b6</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>animation动画基本使用</title>
      <link href="/posts/2959925095.html"/>
      <url>/posts/2959925095.html</url>
      
        <content type="html"><![CDATA[<h3 id="动画animation">动画animation<a class="anchor" href="#动画animation">·</a></h3><h4 id="1、关键帧">1、关键帧<a class="anchor" href="#1、关键帧">·</a></h4><ul><li>使用<code>@keyframes</code> 规则配置动画中的各个帧<ul><li>from 表示起始点（可以用 0% 代替），to表示终点（可以用 100% 代替）</li><li>可以用百分数如 20%，动画运行到20%时间时</li><li>动画命名不要使用CSS关键字如 <code>none</code></li></ul></li></ul><h4 id="2、时间点">2、时间点<a class="anchor" href="#2、时间点">·</a></h4><p>帧动画需要定义在不同时间执行的动作，开始与结束可以用 <code>form/to</code> 或 <code>0%/100%</code> 声明。</p><ul><li>必须添加百分号，25%是正确写法</li><li>时间点没有顺序要求，即100%写在25%前也可以</li><li>未设置<code>0%</code>与<code>100%</code> 时<strong>将使用元素原始状态</strong></li><li>时间点可以动画样式一样时可以一起声明（类似于h1, h2 样式一样时，写在一起）。</li></ul><h4 id="3、动画名">3、动画名<a class="anchor" href="#3、动画名">·</a></h4><ul><li><p>使用<code>animation-name</code> 规则可以在元素身上<strong>同时使用多个动画。</strong></p><ul><li><p>使用多个动画时用逗号分隔</p></li><li><p>多个动画有相同属性时，<strong>后面动画的属性优先使用</strong>：多个动画对用一个元素操作同一属性时，后面动画优先级更高</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation-name</span>: scale, colors, rotate; </span><br><span class="line">// 假如rotate与colors设置过相同的属性，优先rotate设置，rotate时间用完了，才会有colors用，因此入股ocolors的持续时间=== 或&lt; rotate的时间，是没机会生效的</span><br><span class="line"><span class="attribute">animation-duration</span>: <span class="number">1s</span>, <span class="number">5s</span>, <span class="number">1s</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>不是所有的属性都会产生动画效果：</p><ul><li><p>一般有中间值的属性都可以设置动画如宽度、透明度等。但是宽度不能设置auto这样的值，因为无法计算中间值。如果是auto会马上变成最终效果，没有动画过渡效果。</p></li><li><p>比如solid和dotted这种，没有中间值，不是慢慢演化改变的。</p></li></ul></li></ul><h4 id="4、持续时间">4、持续时间<a class="anchor" href="#4、持续时间">·</a></h4><ul><li>使用 <code>animation-duration</code> 可以声明动画播放的时间，即把所有帧执行一遍所需要的时间。<ul><li>可以使用m秒，ms毫秒时间单位</li><li>可为不同动画单独设置执行时间</li><li>如果动画数量大于时间数量，将重新从时间列表中计算</li></ul></li></ul><h4 id="5、重复播放次数-循环">5、重复播放次数-循环<a class="anchor" href="#5、重复播放次数-循环">·</a></h4><ul><li><code>animation-iteration-count</code> 规则设置动画<strong>重复执行</strong>次数，设置值为 <code>infinite</code> 表示无限循环执行。<ul><li>可同时设置元素的多个动画重复，使用逗号分隔</li><li>如果动画数量大于重复数量定义，后面的动画将重新计算重复</li></ul></li></ul><h4 id="6、-运行方向">6、 运行方向<a class="anchor" href="#6、-运行方向">·</a></h4><ul><li><code>animation-direction</code> 控制动画运行的方向<ul><li>normal：从0%到100%运行动画，活干完了，<strong>一下子瞬间收回去；</strong></li><li>reverse：从100%到0%运行动画</li><li>alternate：先从0%到100%，然后从100%到0%，活干完了，<strong>慢慢再收回去；</strong></li><li>alternate-reverse：先从100%到0%，然后从0%到100%</li></ul></li></ul><h4 id="7、动画延迟">7、动画延迟<a class="anchor" href="#7、动画延迟">·</a></h4><ul><li>使用 <code>animation-delay</code> 规则定义动画等待多长时间后执行；</li><li>使用情况分析：<ul><li>假如希望一个动画，先延迟2秒再执行，可以通过将50%的样式设置为跟初始一样，比如scale(1)；</li><li>但如果动画执行次数是无限次，那么每次开始前都有等待时间，但我不想这样的效果，希望每次开始后，不要再等了：此时就可以用 <code>animation-delay</code> 这个属性了。</li></ul></li><li>例子：微场景</li></ul><h4 id="8、动画速率">8、动画速率<a class="anchor" href="#8、动画速率">·</a></h4><ul><li><h5 id="系统属性：可以在帧中单独定义，将影响当前帧的速率">系统属性：可以在帧中单独定义，将影响当前帧的速率<a class="anchor" href="#系统属性：可以在帧中单独定义，将影响当前帧的速率">·</a></h5><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">linear</td><td style="text-align:left">规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td></tr><tr><td style="text-align:left">ease</td><td style="text-align:left">开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）</td></tr><tr><td style="text-align:left">ease-in</td><td style="text-align:left">开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)）</td></tr><tr><td style="text-align:left">ease-out</td><td style="text-align:left">开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)）</td></tr><tr><td style="text-align:left">ease-in-out</td><td style="text-align:left">中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)）</td></tr><tr><td style="text-align:left">cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td style="text-align:left">在 cubic-bezier 函数中定义自己的值</td></tr></tbody></table></li><li><h5 id="贝塞尔曲线">贝塞尔曲线<a class="anchor" href="#贝塞尔曲线">·</a></h5><p>需要设置四个值 <code>cubic-bezier(, , , )</code>，来控制曲线速度，可在 <a href="https://cubic-bezier.com/">https://cubic-bezier.com (opens new window)</a>网站在线体验效果。</p><img src="https://doc.houdunren.com/assets/img/image-20190917143208598.d3bc3aad.png" alt="image-20190917143208598" style="zoom:50%;" /></li></ul><h4 id="9、步进速度">9、步进速度<a class="anchor" href="#9、步进速度">·</a></h4><ul><li><p>一帧一帧的感觉，有点像现实生活中的机械舞，下面是把过渡分五步完成。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>steps(n,start)</td><td>设置n个时间点，第一时间点变化状态</td></tr><tr><td>steps(n,end)</td><td>设置n个时间点，第一时间点初始状态</td></tr><tr><td>step-start</td><td>等于steps(1,start)，可以理解为从下一步开始</td></tr><tr><td>step-end</td><td>等于steps(1,end)，可以理解为从当前步开始</td></tr></tbody></table></li></ul><h4 id="10、播放状态">10、播放状态<a class="anchor" href="#10、播放状态">·</a></h4><ul><li>使用 <code>animation-play-state</code> 可以控制动画的暂停与运行。<ul><li>paused：暂停</li><li>running：运行</li></ul></li></ul><h4 id="11、填充模式">11、填充模式<a class="anchor" href="#11、填充模式">·</a></h4><ul><li><p><code>animation-fill-mode</code> 用于定义动画播放结束后的处理模式，是回到原来状态还是停止在动画结束状态。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>需要等延迟结束，起始帧属性才应用</td></tr><tr><td>backwards</td><td>动画效果在起始帧，不等延迟结束</td></tr><tr><td>forwards</td><td>结束后停留动画的最后一帧</td></tr><tr><td>both</td><td>包含backwards与forwards规则，即动画效果在起始帧，不等延迟结束，并且在结束后停止在最后一帧</td></tr></tbody></table></li></ul><h4 id="12、组合定义">12、组合定义<a class="anchor" href="#12、组合定义">·</a></h4><ul><li><p>和CSS中的其他属性一样，可以使用<code>animation</code>组合定义帧动画。animation 属性是一个简写属性，用于设置六个动画属性：</p><ul><li>animation-name</li><li>animation-duration</li><li>animation-timing-function</li><li>animation-delay</li><li>animation-iteration-count</li><li>animation-direction</li></ul><p>必须存在 <code>animation-duration</code>属性，否则过渡时间为0没有动画效果。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>transform动画的demo</title>
      <link href="/posts/3253065341.html"/>
      <url>/posts/3253065341.html</url>
      
        <content type="html"><![CDATA[<p>只标注了部分关键代码，并没有传全部代码</p><h3 id="transform的实现demo">transform的实现demo<a class="anchor" href="#transform的实现demo">·</a></h3><h4 id="1、实现动感渐变表单">1、实现动感渐变表单<a class="anchor" href="#1、实现动感渐变表单">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7851179.821af195.gif" alt="Untitled" style="zoom:50%;" /><ul><li><p>鼠标放上去时，下面呈现波纹效果：</p><ul><li><p>控制鼠标放上去时，translateX的移动</p></li><li><p>未放上去时，在左侧区域，并overflow不展示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入后盾人帐号&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  //居中显...</span><br><span class="line">  // <span class="attribute">flex</span>设置子元素居中...</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">5px</span> silver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.field</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;  </span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.field</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, white, <span class="number">#1abc9c</span>, <span class="number">#f1c40f</span>, <span class="number">#e74c3c</span>, white);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>);  //一开始不显示</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.field</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100%</span>); // 显示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2、页面切换">2、页面切换<a class="anchor" href="#2、页面切换">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7584912.730ab731.gif" alt="Untitled" style="zoom:50%;" /><p>移动效果制作的页面切换效果。</p><ul><li><p>点击不同菜单时，有不同的动画效果，呈现不同的效果</p><ul><li>控制底部的3个bar不同的样式的伪类target；</li><li>分别设置3个伪类添加时的样式不同；</li><li>颜色使用过渡展示；</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-home&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    houdunren.com</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-vimeo&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;live&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-viadeo&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#video&quot;</span>&gt;</span>video<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#live&quot;</span>&gt;</span>live<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  // <span class="attribute">flex</span>居中...</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">border-right</span>: solid <span class="number">1px</span> <span class="number">#aaa</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: solid <span class="number">1px</span> <span class="number">#aaa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  // <span class="attribute">flex</span>居中...</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, -<span class="number">100%</span>);  // y轴上的平移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:target</span> &#123;  // 点击时，平移</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0%</span>, <span class="number">0%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)<span class="selector-pseudo">:target</span> &#123;  // 点击时换颜色</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#3498db</span>;</span><br><span class="line">&#125;</span><br><span class="line">...同理，别的子元素</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、缩放菜单">3、缩放菜单<a class="anchor" href="#3、缩放菜单">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7638319.e0db60be.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>鼠标没放上去时：缩放transform：scale（0）</p></li><li><p>放上去后，再显示出来：scale（1）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">main</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">strong</span>&gt;<span class="selector-tag">VIDEO</span>&lt;/<span class="selector-tag">strong</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;PHP&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;hdcms&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;laravel&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">strong</span>&gt;LIVE&lt;/<span class="selector-tag">strong</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;houdunren&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;angular&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot;&gt;css3&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">main</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;   // 垂直水平居中....&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">strong</span>+<span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;  // 缩放的基点位置  左上 <span class="number">0</span>， <span class="number">0</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);      //隐藏</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transition</span>: .<span class="number">6s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">strong</span>+<span class="selector-tag">div</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;  // 要转成块级才能<span class="attribute">transform</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">strong</span>+<span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);   //hover时显示出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、相册放大">4、相册放大<a class="anchor" href="#4、相册放大">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7641188.78385d23.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>Dom结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>hover时目标对象放大，且靠近；</p></li><li><p>非目标元素缩小scale</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  // felx居中...</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">8</span>) <span class="built_in">translateY</span>(-<span class="number">30px</span>);   // 缩小，向下移动了<span class="number">30px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.6</span>);  //目标对象放大</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;  //要把别的盖住</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、旋转文字">5、旋转文字<a class="anchor" href="#5、旋转文字">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7605104.746a27d4.gif" alt="Untitled" style="zoom:50%;" /><ul><li><p>注意：transition添加到哪里 main 的div的strong</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>h<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>ou<span class="tag">&lt;<span class="name">strong</span>&gt;</span>d<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>unren.com</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line"><span class="attribute">transition</span>: <span class="number">3s</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">strong</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">strong</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6、酷炫按钮：">6、酷炫按钮：<a class="anchor" href="#6、酷炫按钮：">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7636893.3e63a4ce.gif" alt="Untitled" style="zoom:50%;" /><ul><li><p>初始宽度为0，经过后，宽度扩大为200%，离开后，再反向恢复</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line">    HOUDUNREN</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  //... 主要实现水平居中等</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.btn</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">8s</span>;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0%</span>;    <span class="comment">/* 从0过渡到200% */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;   <span class="comment">/* 保证背景色，不要把文字遮盖住 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skewX</span>(-<span class="number">45deg</span>);  <span class="comment">/* 产生倾斜效果 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.btn</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7、立体盒子按钮：">7、立体盒子按钮：<a class="anchor" href="#7、立体盒子按钮：">·</a></h4><img src="https://doc.houdunren.com/assets/img/image-20190906135344963.f9a01bf5.png" alt="image-20190906135344963" style="zoom:33%;" /><ul><li><p>重点理解，盒子左下，右下阴影怎么实现的；</p></li><li><p>宽高设置、left的意义</p></li><li><p>要为什么skewY， 还要translate的位移</p></li></ul>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;btn&quot;&gt; Nightwish&lt;/<span class="selector-tag">a</span>&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">25deg</span>) <span class="built_in">rotate</span>(-<span class="number">15deg</span>); // 再调这边的，控制的整个btn</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  // 宽、高居中 等样式设置...</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">10px</span>; <span class="comment">/* 刚好能抵消 width为10的宽度*/</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skewY</span>(-<span class="number">45deg</span>) <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">5px</span>); // 先调这边的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">10px</span>; <span class="comment">/* 刚好能抵消 height为10 */</span> </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skewX</span>(-<span class="number">45deg</span>) <span class="built_in">translate</span>(-<span class="number">5px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、三维旋转">8、三维旋转<a class="anchor" href="#8、三维旋转">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7932004.12f1c62a.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>实现立体的旋转，可以指定角度。不同的transform-origin原点不同，效果不同：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  //...居中代码</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">5px</span> silver;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">900px</span>) <span class="built_in">rotateX</span>(<span class="number">60deg</span>);  // 是以y、z轴构成的平面选择。默认是中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  // ...居中代码</span><br><span class="line">  // 不加，是翻书效果：很好玩</span><br><span class="line">  <span class="attribute">transform-origin</span>: left bottom <span class="number">200px</span>;  //加了<span class="number">200px</span>,其实是z轴方向，可以飞起来</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">3s</span>;   // 持续<span class="number">3</span>秒</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">720deg</span>);  <span class="comment">/* 旋转2圈*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9、新年贺卡">9、新年贺卡<a class="anchor" href="#9、新年贺卡">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7939019.ed7152ba.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>注意透视加的位置，翻书效果实现</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span>houdunren<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"> // 居中设置.... </span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;  //实现卡片透视效果</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">900px</span>) <span class="built_in">rotateX</span>(<span class="number">35deg</span>) <span class="built_in">rotateY</span>(<span class="number">15deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">3s</span>;   //注意<span class="attribute">transition</span>添加的位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;新年&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;快乐&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;  // 宽度为一半</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform-origin</span>: right bottom;   // 翻书效果 ==<span class="attribute">right</span> == <span class="attribute">right</span> center</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(-<span class="number">179deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">179deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10、电子时钟：">10、电子时钟：<a class="anchor" href="#10、电子时钟：">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7645507.b3731f7b.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>整体Dom结构：</p><ul><li>main是整体的大表盘：（两个盘叠加，z-index控制层叠）<ul><li>带渐变色的大表盘最大（scale 1.2），但是z-index小，所以相比于main大表盘，只会漏出外环</li><li>main：最大表盘，大小刚好设置为彩带环内大小</li></ul></li><li>line是插入6条线的部分：6条白色的线，旋转不同的角度；<ul><li>6条线都垂直水平居中，并在环内不同角度旋转，旋转原点是自己中点</li></ul></li><li>mark：是小表盘，叠在线上面，（scale 0.8）</li><li>圆点：同样宽、高更小，50%  设置为圆。垂直水平居中 ，且要提高他的z-index</li><li>时、分、秒：大致一样的，<ul><li>指针长度不同：wid控制即可</li><li>旋转的圆点：left bottom</li></ul></li><li>动画：hover时，旋转指定度数</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mark&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;point&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hour&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;minute&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">      houdunren.com <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      向军大叔</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>首先画大圆盘：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#34495e</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;    // 带渐变色的大表盘</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;   </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.2</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(at right, <span class="number">#27ae60</span>, <span class="number">#e67e22</span>, <span class="number">#e67e22</span>, <span class="number">#27ae60</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着画大圆盘的时针，要漏出来一点：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">section</span> class=&quot;line&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">section</span>&gt;</span><br><span class="line">  </span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;  // 线</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">95%</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">120deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.line</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotate</span>(<span class="number">150deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>小表盘：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-tag">div</span><span class="selector-attr">[class=<span class="string">&quot;mark&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#34495e</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表盘的圆点：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&gt;<span class="selector-class">.point</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>时针：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.hour</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#95a5a6</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.minute</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">35%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#3498db</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left bottom;  // 旋转：末端</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.second</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">35%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f1c40f</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表盘经过的效果、文字效果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.second</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">10s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">260deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">20px</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11、动态旋转菜单">11、动态旋转菜单<a class="anchor" href="#11、动态旋转菜单">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-8015150.745be0aa.gif" alt="Untitled" style="zoom:50%;" /><ul><li><p>首选画这么多个圆，然后围绕这几个圆的中心旋转；</p></li><li><p>将这几个圆挪到圆中间：让ul垂直水平居中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">nav</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-<span class="selector-tag">address</span>-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-adjust&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-bars&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-bug&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-compress&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-ban&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-beer&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">i</span> class=&quot;fa fa-bus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">nav</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">150px</span> <span class="number">150px</span>;   // 按几个圆的正中心位置</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">40deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&gt;<span class="selector-tag">span</span> &#123; //控制字体显示不要歪</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">1040deg</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">80deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">// ... 旋转不同的角度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制显、隐</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transition</span>: .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;   <span class="comment">/* 控制图标歪 */</span></span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;  <span class="comment">/* 控制span */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="12、3D旋转图集">12、3D旋转图集<a class="anchor" href="#12、3D旋转图集">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7838254.e56c8d56.gif" alt="Untitled" style="zoom:33%;" /><ul><li><p>实现思路：</p><ul><li><p>DOM结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">main</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">5</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">1</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">3</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">5</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">1</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;<span class="number">3</span><span class="selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">main</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>每个图像设置在一起，但是Y轴旋转角度不同，且旋转不是以xz轴，而是以</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center center -<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">120deg</span>);</span><br><span class="line">&#125;//...</span><br></pre></td></tr></table></figure></li><li><p>而是将旋转麻木的中心点设置为旋转原点</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d; <span class="comment">/* 开启3D视觉， 此时要把rotateX调整下方便看*/</span></span><br><span class="line">  <span class="attribute">transform-origin</span>: center center -<span class="number">300px</span>; <span class="comment">/* 调整旋转中心是旋转木马中心*/</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotateX</span>(-<span class="number">45deg</span>);</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">6s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="comment">/* translate(-50%, -50%)： 不加，会导致旋转跑偏了*/</span> </span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">rotateX</span>(-<span class="number">45deg</span>) <span class="built_in">rotateY</span>(<span class="number">900deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="立方体">立方体<a class="anchor" href="#立方体">·</a></h4><img src="https://doc.houdunren.com/assets/img/Untitled-7784965.483715b7.gif" alt="Untitled" style="zoom:25%;" /><ul><li><p>四个边的盒子旋转以z轴中间作为基点，分别旋转rotateY90 180 270</p></li><li><p>两个盖子，分别以y轴旋转rotateX</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>后盾人<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">       <span class="attribute">position</span>: absolute;</span><br><span class="line">       // 居中...</span><br><span class="line">       <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">       <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">50%</span> <span class="number">50px</span>;  //在z轴中心旋转</span><br><span class="line">       <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">main</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">180deg</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span> &#123;</span><br><span class="line">       <span class="attribute">position</span>: absolute;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">       //... 居中</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: right;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#1abc9c</span>;</span><br><span class="line">       <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">200px</span>) <span class="built_in">rotateX</span>(-<span class="number">90deg</span>);</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: right;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#27ae60</span>;</span><br><span class="line">       <span class="attribute">transform-origin</span>: top;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">200px</span>) <span class="built_in">rotateX</span>(<span class="number">90deg</span>);</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#e67e22</span>;</span><br><span class="line">       <span class="attribute">transform-origin</span>: right;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">200px</span>) <span class="built_in">rotateY</span>(<span class="number">90deg</span>);</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: top;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#8e44ad</span>;</span><br><span class="line">       <span class="attribute">transform-origin</span>: left;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>) <span class="built_in">rotateY</span>(-<span class="number">90deg</span>);</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#ecf0f1</span>;</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">8</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) &#123;</span><br><span class="line">       <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">       <span class="attribute">background</span>: <span class="number">#ecf0f1</span>;</span><br><span class="line">       <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">200px</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>transform动画基本使用</title>
      <link href="/posts/680535600.html"/>
      <url>/posts/680535600.html</url>
      
        <content type="html"><![CDATA[<h3 id="transform-C3新增">transform  C3新增<a class="anchor" href="#transform-C3新增">·</a></h3><p>使用 <code>transform</code> 规则控制元素的变形操作，包括控制移动translate、旋转rotate、缩放scale、倾斜skew、3D转换等</p><h4 id="1、translate位移">1、translate位移<a class="anchor" href="#1、translate位移">·</a></h4><h5 id="基本使用">基本使用<a class="anchor" href="#基本使用">·</a></h5><ul><li><p>改变元素形状或位置，不会影响页面布局（<strong>不脱标</strong>，也不会对别的元素影响，比如挤别的盒子）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(x,y) // 定义 <span class="number">2</span>D 转换， 同时控制x, y  不定宽高时，实现水平垂直居中</span><br><span class="line">transform: <span class="built_in">translate3d</span>(x, y, z)  // <span class="number">3</span>d效果 同时控制X/Y/Z轴的移动，三个值必须输入如果某个轴不需要移动时设置为零</span><br><span class="line"></span><br><span class="line">transform: <span class="built_in">translateX</span>() 延 X 轴平移  +： 向右、向下        -： 向左、向上</span><br><span class="line">transform: <span class="built_in">translateY</span>() 延 Y 轴平移 </span><br><span class="line">transform: <span class="built_in">translateZ</span>() 延 Z 轴平移</span><br></pre></td></tr></table></figure></li></ul><h5 id="遵守的规则：">遵守的规则：<a class="anchor" href="#遵守的规则：">·</a></h5><ol><li><p>重复设置变形操作时只在原形态上操作，同时设置多个，只有最后一个生效；除非，伪类上在原有基础上，再进行这样的位移，这样的可以生效</p></li><li><p>设置该属性的元素，相对于自己原位置来改变，<strong>不脱标</strong></p></li><li><p>位移时，<strong>默认原点</strong>是元素的中心位置；</p></li><li><p>在平移元素时，可以是具体像素或百分比，百分比是相对于自身计算</p></li><li><p>行内元素不产生变形效果，将其转为 <code>inline-block</code> 或 <code>block</code> 以及弹性元素时都可以产生变化效果</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">span</span>&gt;算法大多数&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>) <span class="built_in">translateX</span>(<span class="number">50px</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#9b59b6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="translateZ：">translateZ：<a class="anchor" href="#translateZ：">·</a></h5><ul><li><p>控制Z轴移动，正向外、负向里移动。因为Z轴是透视轴没有像X/Y一样的固定尺寸，so不能用百分数</p></li><li><p>如果想体现纵向的视觉效果：需要设置perspective，加了后才有近大远小的效果；</p><img src="https://doc.houdunren.com/assets/img/Untitled-7827784.63fc4fc8.gif" alt="Untitled" style="zoom:25%;" /></li></ul><h4 id="2、scale缩放">2、scale缩放<a class="anchor" href="#2、scale缩放">·</a></h4><ul><li><p>对元素进行等比例缩放：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(x, y)  按n倍缩放  n&gt;<span class="number">1</span>放大效果，&lt;<span class="number">1</span> 缩小效果</span><br><span class="line">transform: <span class="built_in">scale3d</span>(x, y, z) 沿X/Y/Z三个轴绽放元素</span><br><span class="line"></span><br><span class="line">transform: <span class="built_in">scaleX</span>() </span><br><span class="line">transform: <span class="built_in">scaleY</span>()</span><br><span class="line">transform: <span class="built_in">scaleZ</span>() // 沿Z轴缩放元素，需要有<span class="number">3</span>D透视才可以查看到效果</span><br></pre></td></tr></table></figure></li><li><p>应用场景：</p><p><strong>菜单缩放：</strong></p><ul><li>效果：鼠标放上去，子菜单显示；不放上去，不显示子菜单；</li><li>实现：<ul><li>没放上去时：缩放transform：scale（0）</li><li>放上去后，再显示出来：scale（1）</li><li>默认缩放原点是中心，如果想左上方式： transform-origin：left top;</li></ul></li></ul><p><strong>图片放大</strong></p></li></ul><h4 id="3、rotate旋转">3、rotate旋转<a class="anchor" href="#3、rotate旋转">·</a></h4><ul><li><p>默认绕着中心位置旋转</p></li><li><p>一般不会单独使用，会结合keyframes关键帧使用 或者与 translate 连用，先后位置影响视觉效果</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>()// 在X与Y轴平面旋转，效果与使用 rotateZ 相同</span><br><span class="line"> - x, y 一样时，沿着对角线旋转</span><br><span class="line"> - 谁大，转的时候偏那边的较多</span><br><span class="line"><span class="built_in">rotate3d</span>(tx,ty,tz,angle) //  同时设置X/Y/Z轴的旋转向量值来控制元素的旋转</span><br><span class="line"></span><br><span class="line">transform: <span class="built_in">rotateX</span>(<span class="number">0</span>-<span class="number">360</span>度) // rotateX（<span class="number">30deg</span>）</span><br><span class="line">transform: <span class="built_in">rotateY</span>()</span><br><span class="line">transform: <span class="built_in">rotateZ</span>()  // 沿Z轴旋转元素，效果就是沿 X/Y轴的平面 旋转</span><br></pre></td></tr></table></figure></li><li><p>旋转90deg不可见；旋转89deg，只会看到一条线</p></li><li><p>父级透视：当X旋转90度后无法看到元素，这时可以控制父级旋转从上看子元素。</p></li><li><p>只旋转x轴：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(<span class="number">35deg</span>);</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 只旋转x轴：</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(<span class="number">35deg</span>) <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">645deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 只旋转y轴</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(-<span class="number">645deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">// xy旋转</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(<span class="number">35deg</span>) <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">645deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">// xz旋转：加入适当的Z向量值，可增加元素沿Z轴旋转的力度。</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">main</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">600px</span>) <span class="built_in">rotateY</span>(<span class="number">35deg</span>) <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">0</span>, .<span class="number">5</span>, -<span class="number">245deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、skew倾斜变换">4、skew倾斜变换<a class="anchor" href="#4、skew倾斜变换">·</a></h4><ul><li><p>对元素进行倾斜：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">skew</span>(x, y);  // x、y轴的同时倾斜角度</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewX</span>();</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewY</span>();</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、旋转点transform-origin">5、旋转点transform-origin<a class="anchor" href="#5、旋转点transform-origin">·</a></h4><ul><li><p>变化的起点：默认 center，用<strong>transform-origin</strong> 可以改变变形的起始点</p></li><li><p>元素移动不受变形基点所影响：基点是元素原始空间位，而不是translate移动后的空间位</p></li><li><p>rotate、skew都可以</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: left/right  center/bottom;</span><br><span class="line"><span class="attribute">transform-origin</span>: left top;   === <span class="number">0</span> <span class="number">0</span>;  左上角  <span class="number">1</span>, <span class="number">1</span>  中心原点  </span><br><span class="line"><span class="attribute">transform-origin</span>: <span class="number">100%</span>， <span class="number">100%</span>;  右下角  === <span class="attribute">right</span> <span class="attribute">bottom</span></span><br><span class="line"><span class="attribute">transform-origin</span>: <span class="number">200%</span> <span class="number">200%</span>;  <span class="comment">/* 可以在外部，也可以在内部*/</span>  也可以是具体像素位置</span><br></pre></td></tr></table></figure></li></ul><h4 id="6、透视perspective：">6、透视perspective：<a class="anchor" href="#6、透视perspective：">·</a></h4><h5 id="1、perspective">1、perspective<a class="anchor" href="#1、perspective">·</a></h5><ul><li><p>视觉效果上：近大远小</p></li><li><p>舞台透视：</p><ul><li><code>perspective</code> 规则用于<strong>将父级整个做为透视元素</strong>，会造成里面的每个子元素的透视是不一样的。就像现实中摆一排杯子，是使用统一透视的，每个杯子的透视不一样，造成有大有小。</li></ul></li><li><p>单独透视：</p><ul><li><code>perspective</code> 函数用于为元素设置单独透视，每个元素的透视效果是一样的</li></ul></li><li><p>3D透视：transform-style用于控制3d透视</p><ul><li><p>应用于舞台即变形元素的父级元素</p></li><li><p>设置 <code>overflow:visible</code> 时 <code>preserve-3d</code> 才无效</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">flat<span class="number">2</span>D平面舞台</span><br><span class="line">preserve-<span class="number">3</span>d<span class="number">3</span>D透视舞台</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2、视角perspective-origin">2、视角perspective-origin<a class="anchor" href="#2、视角perspective-origin">·</a></h5><ol><li><p><code>perspective-origin</code>用于控制视线的落点，就像我们眼睛看物体时的聚焦点。</p></li><li><p>可以理解眼镜看物体的位置，比如看一台汽车，是在看车头左边看还是车头右边看。</p><ul><li><p>需要设置 <code>perspective</code> 透视后才可以看到效果。</p></li><li><p>一般设置在舞台元素上来控制子元素</p></li></ul></li><li><p>使用规则：</p><ul><li>x-axis：定义该视图在 x 轴上的位置。默认值：50%。可值：left、center、right、length、%</li><li>y-axis：定义该视图在 y 轴上的位置。默认值：50%。可值：top、center、bottom、length、%</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5的新特性</title>
      <link href="/posts/3631469724.html"/>
      <url>/posts/3631469724.html</url>
      
        <content type="html"><![CDATA[<h3 id="H5新特性">H5新特性<a class="anchor" href="#H5新特性">·</a></h3><h4 id="一、声明方式">一、声明方式<a class="anchor" href="#一、声明方式">·</a></h4><ul><li><p>HTML4 规定了三种不同的 <code>&lt;!DOCTYPE&gt;</code> 声明，分别是：Strict、Transitional 和 Frameset;</p><p><strong>HTML4 Strict</strong> / 严格</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span><span class="string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>HTML4 Transitional</strong> /过渡</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>HTML4 Frameset</strong>/框架集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>而HTML5因为不是<code>SGML</code>(一般指标准通用置标语言)的子集，只需要<code>&lt;!DOCTYPE&gt;</code>就可以了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">对于中文网页需要使用 <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> 声明编码，否则会出现乱码</span><br></pre></td></tr></table></figure></li></ul><h4 id="二、语义化标签">二、语义化标签<a class="anchor" href="#二、语义化标签">·</a></h4><h5 id="语义化：根据内容-选择合适的标签">语义化：根据内容, 选择合适的标签<a class="anchor" href="#语义化：根据内容-选择合适的标签">·</a></h5><ul><li>有利于 <strong>‘SEO’</strong>：和搜索引擎建立良好沟通, 有助于爬虫抓取更多的有效信息。爬虫依赖于 标签 来确定, 上下文 和各个关键字的权重</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><h5 id="常见的语义标签功能：">常见的语义标签功能：<a class="anchor" href="#常见的语义标签功能：">·</a></h5><img src="https://www.runoob.com/wp-content/uploads/2013/07/html5-layout.jpg" alt="HTML5 语义元素" style="zoom: 50%;" /><p>H5 提供了 8 个新 HTML <strong>语义</strong> 元素来明确一个Web页面的不同部分，都是 <strong>块级</strong> 元素:</p><ul><li><p>header：文档的头部区域，用于定义内容的介绍展示区域，在页面中该元素可以使用多次</p></li><li><p>nav：定义导航链接的部分；但是，不是所有的链接都需要包含在 nav 元素中!</p></li><li><p>article：定义页面主区域内容之外的内容（比如侧边栏），内容应与主区域内容相关</p></li><li><p>section：定义文档中的节（section、区段）；区块（有语义化的div）</p></li><li><p>aside：定义其所处内容之外的内容（侧边）；</p></li><li><p>footer：描述了文档的底部区域，可使用多次</p><p>一个页脚通常包含文档的作者，著作权信息，链接的使用条款，联系信息等；</p></li></ul><h4 id="三、多媒体">三、多媒体<a class="anchor" href="#三、多媒体">·</a></h4><ul><li><h4 id="多媒体标签：Video-Audio">多媒体标签：Video/Audio<a class="anchor" href="#多媒体标签：Video-Audio">·</a></h4><ol><li><p>提供了 播放、暂停和音量控件来控制视频</p></li><li><p>width 和 height 属性控制视频的尺寸</p></li><li><p>JS控制：</p><p>属性：时长、音量、是否可以播放</p><p>方法：开始播放、已暂停，已停止</p><p>事件：用于播放、暂停以及加载</p></li><li><p>source标签：定义多种媒体资源；track标签定义在媒体播放器文本轨迹（歌词）</p></li></ol></li></ul><h4 id="四、表单元素">四、表单元素<a class="anchor" href="#四、表单元素">·</a></h4><ul><li><p>新的表单输入类型，提供了更好的输入控制和验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color、date、datetime、datetime-local、email、month、number、range、</span><br><span class="line">search、tel、time、url、week</span><br></pre></td></tr></table></figure><ul><li>更有利于移动端做表单时候，比如电话号码，email，输入类型的限制；</li><li><strong>但是</strong>：真正做项目时，不能光靠这个来校验，不仅前端要校验，一个合格的后端不应该相信前端传入的任何数据</li></ul></li></ul><h4 id="五、6个API">五、6个API<a class="anchor" href="#五、6个API">·</a></h4><ul><li>本地存储、离线存储、websocket、webworker、canvas、地理定位</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS和CSRF攻击</title>
      <link href="/posts/2062301197.html"/>
      <url>/posts/2062301197.html</url>
      
        <content type="html"><![CDATA[<h2 id="XSS和CSRF攻击">XSS和CSRF攻击<a class="anchor" href="#XSS和CSRF攻击">·</a></h2><h3 id="1、XSS攻击">1、XSS攻击<a class="anchor" href="#1、XSS攻击">·</a></h3><h4 id="1、概念：-3">1、概念：<a class="anchor" href="#1、概念：-3">·</a></h4><ul><li>跨站脚本攻击，攻击者在<strong>网站注入恶意脚本</strong>，当用户浏览网页时，嵌入网页的Script代码会执行，通过对用户浏览器进行控制或者拿到用户隐私数据</li><li>重点不在于跨站点，XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</li><li>攻击者可以通过这种攻击方式可以进行以下操作：<ul><li>获取页面的数据，如DOM、cookie、localStorage；</li><li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li><li>破坏页面结构；</li><li>流量劫持（将链接指向某网站）；</li></ul></li></ul><h4 id="2、类型">2、类型<a class="anchor" href="#2、类型">·</a></h4><h5 id="1、反射型-非持久型">1、反射型/非持久型<a class="anchor" href="#1、反射型-非持久型">·</a></h5><ul><li>攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 需要服务端交互</li><li><strong>反射型 XSS 的攻击步骤：</strong><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol></li><li>场景：通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</li></ul><h5 id="2、存储型-持久型">2、存储型/持久型<a class="anchor" href="#2、存储型-持久型">·</a></h5><ul><li><p>把恶意脚本<strong>存储到服务器的数据库</strong>当中，浏览器请求数据时，脚本就被传回并执行，达到攻击效果</p></li><li><p><strong>存储型 XSS 的攻击步骤：</strong></p><ol><li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li><li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol></li><li><p>举例：</p><p>当有人在留言内容中插入恶意脚本时，留言肯定会保存到服务器中。</p><p>由于服务器要像每一个访客展示之前的留言内容，所以后面的访客自然会接收到之前留言中的恶意脚本而不幸躺枪</p></li><li><p>场景：带有用户保存数据的网站功能，比如论坛发帖、商品评价、用户私信等等</p></li><li><p>反射型 XSS 跟存储型 XSS 的区别是：</p><p>存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥</p></li></ul><h5 id="3、DOM型">3、DOM型<a class="anchor" href="#3、DOM型">·</a></h5><ul><li>不需要服务端交互，<strong>纯粹发生在客户端</strong></li><li>通过恶意脚本修改DOM结构，通过修改页面的 DOM 节点形成的 XSS。</li><li><strong>DOM 型 XSS 的攻击步骤：</strong><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL。</li><li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol></li><li>举例：看小说的时候下面有小广告，直接改变当前页面的Dom结构</li><li>DOM 型 XSS 跟前两种 XSS 的区别：<ul><li>DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</li></ul></li></ul><h4 id="3、防范措施：">3、防范措施：<a class="anchor" href="#3、防范措施：">·</a></h4><h5 id="方式1：从浏览器的执行来进行预防，使用纯前端的方式：">方式1：从浏览器的执行来进行预防，<strong>使用纯前端的方式：</strong><a class="anchor" href="#方式1：从浏览器的执行来进行预防，使用纯前端的方式：">·</a></h5><ol><li>使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）</li><li>对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。<ul><li>拒绝innerHTML, 使用.innerText、.setAttribute、.style，</li><li>Vue：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<strong>绝不要</strong>对用户提供的内容使用插值</li></ul></li></ol><h5 id="方式2：使用CSP白名单">方式2：使用CSP白名单<a class="anchor" href="#方式2：使用CSP白名单">·</a></h5><ul><li>CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li><li>对于用户的任何输入要进行<strong>转码</strong>和<strong>过滤</strong>。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。<ol><li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li><li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式</li></ol></li></ul><h5 id="方式3：cookie安全策略：">方式3：cookie安全策略：<a class="anchor" href="#方式3：cookie安全策略：">·</a></h5><ul><li><p>很多xss攻击都是为获取cookie中内容，这样浏览器禁止JS访问带有HTTPOnly属性的cookie，也可以使用验证码，避免脚本伪装成用户执行一些操作。</p></li><li><p><strong>使用场景：</strong></p><p>我们访问网站的时候账户信息可能存储在cookie中，方便用户验证信息，转账等页面操作。这种操作可能引发XSS攻击（<strong>反射型</strong>），通过执行当前页面的JS代码，获取到cookie里信息，发给攻击者的网站</p></li><li><p>**做法：**在服务端设置首部字段set-cookie为HTTPOnly，这样可以防止用户通过JS获取cookie。对cookie的读写/发送一般有如下字段设置：</p><ul><li>HTTP-Only：只允许HTTPS/http请求读取cookie，JS代码是无法读取cookie的，发送请求时自动发送cookie</li><li>secure-Only：只允许HTTPS请求读取，发送请求时自动发送cookie</li><li>host-Only：只允许主机域名与domain设置完成一致的网站才才能访问cookie</li></ul></li></ul><h3 id="2、CSRF">2、CSRF<a class="anchor" href="#2、CSRF">·</a></h3><h4 id="1、概念">1、概念<a class="anchor" href="#1、概念">·</a></h4><p>跨站请求伪造：</p><ul><li>攻击者诱导用户进入一个第三方网站，然后该网站向<strong>被攻击网站</strong>发送跨站请求。</li><li>如果用户在<strong>被攻击网站中保存了登录状态</strong>，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</li><li>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></li></ul><p>举例：</p><ul><li>比如登录一个银行的网页，在没有退出当前网页时（保存了登陆态），一般是黑客诱使用户点击链接，打开<strong>第三方网站</strong>黑客网站会发起请求，</li><li>然后利用用户的cookie（包含用户信息）欺骗服务器，服务器以为请求时正常用户发的就正常处理</li><li>攻击者盗用了用户的身份，以用户的名义发送了恶意请求<img src="https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg" alt="img" style="zoom: 50%;" /></li></ul><h4 id="2、攻击类型：">2、攻击类型：<a class="anchor" href="#2、攻击类型：">·</a></h4><ul><li>get型：恶意网站会自动发送http请求，向目标网站发起攻击。比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li><li>post型：会利用表单提交，向目标网站发送post请求，达到攻击效果。比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li><li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击</li></ul><h4 id="3、防范措施">3、防范措施<a class="anchor" href="#3、防范措施">·</a></h4><h5 id="1、进行同源检测">1、进行同源检测<a class="anchor" href="#1、进行同源检测">·</a></h5><ul><li>服务器根据 http 请求头中 origin 或者 referer 信息来<strong>判断请求是否为允许访问的站点</strong>，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。<ul><li><strong>origin</strong>：包含请求的域名（不包含path及query）</li><li><strong>refer</strong>：包含具体的URL地址</li></ul></li><li>这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li></ul><h5 id="2、token验证">2、token验证<a class="anchor" href="#2、token验证">·</a></h5><p>CSRF成功的原因就是攻击的网络请求带有cookie而cookie中有正常用户的身份信息，欺骗了服务器。故在HTTP请求中加入一个随机产生的token，服务器拦截验证这个token是否合法，不合法就拒绝这个网络请求。</p><ul><li><p>服务器需要生成一个通过加密算法加密的 Token；</p></li><li><p>将该 Token 保存在 Session 或者 Redis；</p></li><li><p>将该 Token 传给客户端，客户端在请求时要将其 Token 一并带上，如 <code>GET</code> 请求 <code>/api/message?token=xxx</code> 或 <code>POST</code> 请求在form表单追加或 <code>Ajax</code> 请求在页面添加，通过 JS 去获取该 meta 值；</p></li><li><p>请求到服务器后，服务器就可以通过解密对比来判断该 Token 的有效性了。</p></li></ul><h5 id="3、Set-Cookie：SameSite-√">3、Set-Cookie：SameSite                     √<a class="anchor" href="#3、Set-Cookie：SameSite-√">·</a></h5><p><strong>限制 cookie 不能作为被第三方使用</strong>，即在响应头 <code>Set-Cookie</code> 设置 SameSite 属性，表示该 Cookie 访问同源网站而非来源第三方网站。从而可以避免被攻击者利用。</p><ul><li>Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用</li></ul><h3 id="3、网络劫持有哪几种，如何防范？">3、网络劫持有哪几种，如何防范？<a class="anchor" href="#3、网络劫持有哪几种，如何防范？">·</a></h3><p>⽹络劫持分为两种:</p><p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)</p><ul><li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li><li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li></ul><p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p><p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>]]></content>
      
      
      <categories>
          
          <category> 3.2-浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我不允许你还不知道啥是HTTP缓存</title>
      <link href="/posts/http_cache.html"/>
      <url>/posts/http_cache.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP缓存">HTTP缓存<a class="anchor" href="#HTTP缓存">·</a></h2><h3 id="1、缓存基本">1、缓存基本<a class="anchor" href="#1、缓存基本">·</a></h3><ul><li><h4 id="概念：">概念：<a class="anchor" href="#概念：">·</a></h4><p>浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了</p></li><li><h4 id="为什么要有缓存？">为什么要有缓存？<a class="anchor" href="#为什么要有缓存？">·</a></h4><ol><li><p>减少了请求的次数，提高了网站的性能，加快客户端加载网页的速度， 提升用户体验。</p><p>浏览器的缓存，主要针对的是前端的静态资源，最好的效果是，在发请求之后，拉取相应的静态资源，并存在本地。</p></li></ol><ul><li>如果服务器的静态资源没更新，那在下次请求时，就直接从本地读取即可</li><li>如果服务器的静态资源已更新，那再次请求时，就到服务器拉取新的资源，并存在本地</li></ul><ol start="2"><li>降低服务器的压力</li></ol></li><li><h4 id="分类">分类<a class="anchor" href="#分类">·</a></h4><ul><li><p>命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，<strong>即客户端与服务器之间存在一次通信。</strong></p></li><li><p>在 <code>chrome</code> 中<strong>强缓存</strong>（虽然没发出真实的 <code>http</code> 请求）的<strong>请求状态码</strong>返回是 <code>200 (from cache)</code>；</p></li><li><p>而命中协商缓存，请求状态码是 <code>304 (not modified)</code></p><blockquote><p>其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。<img src="https://segmentfault.com/img/remote/1460000021661660" alt="image.png"></p></blockquote></li></ul></li></ul><h3 id="2、请求流程">2、请求流程<a class="anchor" href="#2、请求流程">·</a></h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6837d8d1c74cf2894d8967a20115d9~tplv-k3u1fbpfcp-watermark.awebp" alt="业务流程图1.png" style="zoom: 50%;" /><ol><li><p>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 <code>response header</code> ，以供下次加载时对比使用；</p></li><li><p>下一次加载资源时，会获取该缓存资源的 <code>header</code> 中的信息。由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差：</p><p>如果没有超过<code>cache-control</code> 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则用 <code>expires</code> 头判断是否过期；</p></li><li><p>如果资源已过期，则表明<strong>强制缓存没被命中，则协商缓存</strong>，浏览器就会发送请求到服务器，这次请求会带上 <code>IF-Modified-Since</code> 或者 <code>IF-None-Match</code>, 它们的值分别是第一次请求返回 <code>Last-Modified</code>或者 <code>Etag</code></p></li><li><p>服务器收到请求后，优先根据  <code>Etag</code>的值判断被请求的文件有没有做修改</p><ul><li><code>Etag</code>值一致则没有修改，命中协商缓存，返回 304；</li><li>如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li></ul><p>很多网站的资源后面都加了版本号，目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器缓存，<strong>强制改变版本号</strong>，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，<strong>以保证用户能够及时获得网站的最新更新。</strong></p></li></ol><h3 id="3-强缓存">3. 强缓存<a class="anchor" href="#3-强缓存">·</a></h3><p>强缓存是根据返回头中的 <code>Expires</code> 或者 <code>Cache-Control</code> 两个字段来控制的，都是表示资源的缓存有效时间。</p><ul><li><code>Expires</code> ：http 1.0，值是一个<code>GMT</code> 格式的时间点字符串，比如 <code>Expires:Mon,18 Oct 2066 23:59:59 GMT</code> 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存<ul><li>缺点：失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。</li></ul></li><li><code>Cache-Control</code>： <code>http 1.1</code> 的规范，一般常用该字段的 <code>max-age</code> 值来进行判断，它是一个相对时间，比如 .<code>Cache-Control:max-age=3600</code> 代表资源的有效期是 3600 秒。并且返回头中的 <code>Date</code> 表示消息发送的时间，表示当前资源在 <code>Date ~ Date +3600s</code> 这段时间里都是有效的。<code>Cache-Control</code> 还有其他几个值可以设置：<ul><li><code>no-cache</code> 不使用本地缓存。需要使用协商缓存。</li><li><code>no-store</code>直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 <code>network</code> 中的 <code>disabled cache</code>。</li><li><code>public</code> 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。</li><li><code>private</code> 只能被终端用户的浏览器缓存。</li></ul></li><li>如果 <code>Cache-Control</code>与 <code>Expires</code> 同时存在的话， <code>Cache-Control</code> 的优先级高于 <code>Expires</code></li></ul><h3 id="4-协商缓存">4. 协商缓存<a class="anchor" href="#4-协商缓存">·</a></h3><p>由服务器来确定缓存资源是否可用，这次请求会带上 <code>IF-Modified-Since</code> 或者 <code>IF-None-Match</code>, 它们的值分别是第一次请求返回 <code>Last-Modified</code>或者 <code>Etag</code>，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段</p><ul><li><p><code>Last-Modified/If-Modified-Since</code> ：二者的值都是 GMT 格式的时间字符串，</p><p><code>Last-Modified</code> ：标记最后文件修改时间， 下一次请求时，请求头中会带上 <code>If-Modified-Since</code> 值就是 <code>Last-Modified</code> 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化</p><ul><li>如果文件没有变更则返回 <code>304 Not Modified</code> ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 <code>304 Not Modified</code> 的响应时，<code>response header</code> 中不会再添加的 <code>Last-Modified</code> 去试图更新本地缓存的 <code>Last-Modified</code>， 因为没变化</li><li>如果资源有变化，就正常返回返回资源内容，新的 <code>Last-Modified</code> 会在 <code>response header</code> 返回，并在下次请求之前更新本地缓存的 <code>Last-Modified</code>，下次请求时，<code>If-Modified-Since</code>会启用更新后的 <code>Last-Modified</code>。</li></ul></li><li><p><code>Etag/If-None-Match</code>：值都是由服务器为每一个资源生成的<strong>唯一标识串</strong>，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 <code>ETag</code>字段返回给浏览器，接收到 <code>If-None-Match</code> 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。</p><ul><li>与 <code>Last-Modified</code> <strong>不一样的是</strong>，当服务器返回 <code>304 Not Modified</code> 的响应时，由于在服务器上<code>ETag</code> 重新计算过，<code>response header</code>中还会把这个 <code>ETag</code> 返回，即使这个 <code>ETag</code> 跟之前的没变化</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优先级： Cache-Control  &gt; expires &gt; Etag &gt; Last-Modified</span><br></pre></td></tr></table></figure><h3 id="5-为什么要有-Etag">5. 为什么要有 Etag<a class="anchor" href="#5-为什么要有-Etag">·</a></h3><p><code>HTTP1.1</code> 中 <code>Etag</code> 的出现主要是为了解决几个 <code>Last-Modified</code> 比较难解决的问题：</p><ol><li><p>时间的精确度：</p><p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，这样会造成缓存命中的不准确。使用 <code>Etag</code> 就能够保证这种需求下客户端在 1 秒内能刷新 N 次 cache。</p></li><li><p>周期性改动：</p><p>一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；</p></li></ol><h3 id="6-用户行为">6. 用户行为<a class="anchor" href="#6-用户行为">·</a></h3><p>用户行为对浏览器缓存的影响：</p><table><thead><tr><th>用户操作</th><th>Expires/Cache-Control</th><th>Last-Modied/Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td>有效</td><td>有效</td></tr><tr><td>页面链接跳转</td><td>有效</td><td>有效</td></tr><tr><td>新开窗口</td><td>有效</td><td>有效</td></tr><tr><td>前进回退</td><td>有效</td><td>有效</td></tr><tr><td>F5 刷新</td><td>无效(有争议，不同浏览器反馈不一致)</td><td>有效</td></tr><tr><td>Ctrl+F5 强制刷新</td><td>无效</td><td>无效</td></tr></tbody></table><ul><li><p><strong>点击刷新按钮或者按 F5：</strong> 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</p><p><strong>用户按 Ctrl+F5（强制刷新）：</strong> 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</p><p>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</p></li></ul><h3 id="浏览器资源缓存的位置">浏览器资源缓存的位置<a class="anchor" href="#浏览器资源缓存的位置">·</a></h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p><ol><li><strong>Service Worker</strong>：Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。<ul><li>它可以让我们自由控制缓存哪些文件、如何匹配缓存、读取缓存，且<strong>缓存是持续性的</strong>。</li><li>当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch</code> 函数获取  数据。也就是说，会根据缓存查找优先级去查找数据。</li><li><strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。</strong></li></ul></li><li><strong>Memory Cache：</strong> 内存缓存，效率最快，**但持续性很短，会随着进程的释放而释放。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li><li><strong>Disk Cache：</strong> 硬盘缓存，读取速度慢点，但是什么都能存储到磁盘中<ul><li>比之 Memory Cache <strong>胜在容量和存储时效性上。</strong></li><li>它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></li></ul></li></ol><p><strong>Push Cache：</strong> 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：</p><ul><li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li><li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>可以给其他域名推送资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.2-浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie、session、Token</title>
      <link href="/posts/cookie&amp;&amp;session.html"/>
      <url>/posts/cookie&amp;&amp;session.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、为什么会诞生cookie与session？">1、为什么会诞生cookie与session？<a class="anchor" href="#1、为什么会诞生cookie与session？">·</a></h3><p>二者诞生的契机：http是一个无状态协议</p><ul><li><p>什么是无状态呢？</p><p>这一次请求和上一次请求是没有任何关联的，这种无状态的的好处是快速。但坏处就是：无法把<code>www.zhihu.com/login.html</code>和<code>www.zhihu.com/index.html</code>关联起来</p></li><li><p>session和cookie出现解决了什么？</p><ul><li>由于http的无状态性，服务端并不知道是张三还是李四在和自己打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合</li><li>SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</li></ul></li></ul><h3 id="2、cookie和session如何配合">2、cookie和session如何配合<a class="anchor" href="#2、cookie和session如何配合">·</a></h3><h4 id="1、用户首次登录时：">1、用户首次登录时：<a class="anchor" href="#1、用户首次登录时：">·</a></h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/2/1730fcc51a6e8670~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li><p>用户访问 <code>a.com/pageA</code>，并输入密码登录</p></li><li><p>服务器验证密码无误后，会创建 SessionId，并将它保存起来</p><p>服务器端的 SessionId 可能存放在很多地方，例如：内存、文件、数据库等</p></li><li><p>服务器端发送一个http响应到客户端，这个响应头中就包含Set-Cookie头部，该头部包含了sessionId，Set-Cookie格式如下：<code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></p></li><li><p>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中：</p><ul><li>浏览器安装目录下会<strong>专门有一个 cookie 文件夹</strong>存放各个域下设置的cookie</li><li>当网页要发请求时，浏览器<strong>自动检查</strong>是否有相应的cookie，有则自动添加在request header中的cookie字段中</li></ul></li></ol><h4 id="2、第2次访问">2、第2次访问<a class="anchor" href="#2、第2次访问">·</a></h4><p>**后续的访问：**就可以直接使用 Cookie 身份验证了：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/2/1730fcc51a81b9f8~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li>用户访问 <code>a.com/pageB</code> 页面时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动在请求头中添加cookie</li><li>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 找对应的 Session 信息，如果没找到，说明用户没有登录或登录失效</li><li>如果找到 Session 证明用户已经登录，可执行后面操作</li></ol><h4 id="问题1：可以只用cookie，不用session吗？">问题1：可以只用cookie，不用session吗？<a class="anchor" href="#问题1：可以只用cookie，不用session吗？">·</a></h4><p>此时账户信息全存在客户端：安全、存储空间</p><ul><li>账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露</li><li>客户端数据量变大，网络传输的数据量也会变大。而用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。</li></ul><h4 id="问题2：cookie被禁用怎么办">问题2：cookie被禁用怎么办<a class="anchor" href="#问题2：cookie被禁用怎么办">·</a></h4><p>既然服务端根据 Cookie 中的信息判断用户是否登录，那如果浏览器中禁止 Cookie，如何保障整个机制的正常运转？</p><h5 id="1、方案1：请求参数">1、方案1：请求参数<a class="anchor" href="#1、方案1：请求参数">·</a></h5><ul><li>每次请求中都携带一个 SessionID 参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code></li></ul><h5 id="2、方案2：Token-机制">2、方案2：Token 机制<a class="anchor" href="#2、方案2：Token-机制">·</a></h5><ul><li><p>在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">typeof</span>(<span class="title class_">Storage</span>)!==<span class="string">&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>常用API：</p><ul><li>保存数据：localStorage.setItem(key,value); localStorage.keyname= “菜鸟教程”;</li><li>读取数据：localStorage.getItem(key);</li><li>删除单个、所有数据：localStorage.removeItem(key)、localStorage.clear();</li><li>得到某个索引的key：localStorage.key(index);</li></ul></li></ul><h3 id="3、cookie相关API">3、cookie相关API<a class="anchor" href="#3、cookie相关API">·</a></h3><ul><li>存储形式：由<strong>键值对</strong> key=value构成，<strong>键值对之间由一个分号和一个空格隔开</strong></li><li>前端原生API获取cookie的方法：<strong>document.cookie</strong>，但只能获取 HttpOnly 类型的cookie</li></ul><h4 id="1、cookie常见属性：">1、cookie常见属性：<a class="anchor" href="#1、cookie常见属性：">·</a></h4><p>设置这些属性时，属性之间由一个分号和一个空格隔开：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly&quot;</span></span><br></pre></td></tr></table></figure><h5 id="expires：">expires：<a class="anchor" href="#expires：">·</a></h5><ul><li>GMT 格式时间，如不设置，默认有效期为session，即会话cookie。浏览器关闭就没</li><li>http/1.0 —&gt; expires(失效时刻) ,  http/1.1 ----&gt;由 max-age 选项代替(cookie失效时刻= 创建时刻+ max-age)<ul><li>max-age 的默认值是 -1(即有效期为 session )</li><li>有三种可能值：负数（有效期session）、0（删除）、正数（创建时刻+ max-age）</li></ul></li></ul><h5 id="domain-和-path：">domain 和 path：<a class="anchor" href="#domain-和-path：">·</a></h5><ul><li>域名+路径，两者构成了 URL，共同限制 cookie 能被哪些 URL 访问，所以决定了cookie何时被浏览器自动添加到请求头部中发送出去</li><li>若没有显式设置，则浏览器会自动取 url 的 host 作为 domain 值</li><li>path默认值为设置该cookie的网页所在的目录</li></ul><p>【注意1】：<strong>跨域xhr请求时</strong>，即使请求URL的域名和路径都满足 cookie 的 domain 和 path，默认情况下<strong>cookie也不会自动被添加到请求头</strong>：为什么？</p><ul><li><p>在<code>CORS</code>标准中规定，默认情况下，浏览器发跨域请求时，不能发任何认证信息（<code>credentials</code>）如&quot;<code>cookies</code>&quot;和&quot;<code>HTTP authentication schemes</code>&quot;，除非<code>xhr.withCredentials</code>为<code>true</code>（<code>xhr</code>对象一个属性，默认值为<code>false</code>）</p></li><li><p><code>cookies</code>也是一种认证信息，在跨域请求中，<code>client</code>端必须<strong>手动设置</strong><code>xhr.withCredentials=true</code>，且<code>server</code>端也<strong>必须允许</strong><code>request</code>能携带认证信息（即<code>response header</code>中包含<code>Access-Control-Allow-Credentials:true</code>），这样浏览器才会自动将<code>cookie</code>加在<code>request header</code>中</p><p>【特别注意】：</p><ul><li>一旦跨域<code>request</code>能携带认证信息，<code>server</code>端一定不能将<code>Access-Control-Allow-Origin</code>设为<code>*</code>，而必须设为请求页面的域名</li></ul></li></ul><p>【注意2】：domain是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀 public suffix</p><ul><li><p>如果页面域名为 www.baidu.com, domain可以设置为“www.baidu.com”，或“baidu.com”，但不能设置为“.com”或“com”</p></li><li><p>显式设置 domain 时，如果 value 最前面带点，则浏览器处理时会将这个点去掉，所以最后浏览器存的就是没有点的</p></li><li><p>前面带点‘.’和不带点‘.’有啥区别：</p><p>带点：任何 subdomain 都可以访问，包括父 domain</p><p>不带点：只有完全一样的域名才能访问，subdomain 不能（但在 IE 下比较特殊，它支持 subdomain 访问）</p></li></ul><h5 id="secure">secure<a class="anchor" href="#secure">·</a></h5><p>当请求是HTTPS或其他安全协议时，包含 secure 选项的 cookie才能被发至服务器，<strong>默认cookie不带secure选项</strong></p><ul><li><p>设置一个 secure类型的 cookie：可在控制台看见</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;name=huang; secure&quot;;</span><br></pre></td></tr></table></figure></li></ul><p>【注意】：在网页中通过 js 设置secure类型的 cookie，必须保证网页是https协议的。在http协议的网页中是无法设置secure类型cookie的</p><h5 id="httpOnly">httpOnly<a class="anchor" href="#httpOnly">·</a></h5><ul><li><p>用来<strong>设置cookie能否通过 js 访</strong>问，这个选项<strong>只能由服务端设置，客户端不可</strong>，且凡是httpOnly类型的cookie，其 HTTP 一列都会打上√</p><p>通过document.cookie是<strong>不能获取的，也不能修改</strong></p></li><li><p>默认cookie不带httpOnly选项，此时客户端是可通过js代码去访问（包括读取、修改、删除等）cookie</p></li><li><p>当cookie带httpOnly选项时，客户端无法通过js代码访问</p></li></ul><p>【httpOnly与安全】：**为什么要限制客户端去访问cookie？**安全</p><p>如果任何 cookie 都能被客户端通过document.cookie获取会发生什么可怕的事情</p><ol><li>当网页遭受 XSS 攻击，一段恶意script脚本插到网页中，脚本通过document.cookie读取用户身份验证相关的 cookie，并将这些 cookie 发到了攻击者的服务器</li><li><strong>攻击者轻而易举就拿到了用户身份验证信息</strong>，充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证</li></ol><h4 id="2、操作cookie">2、操作cookie<a class="anchor" href="#2、操作cookie">·</a></h4><h5 id="操作方：">操作方：<a class="anchor" href="#操作方：">·</a></h5><ul><li><p>客户端设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;name=Jonh; &quot;;</span><br><span class="line">document.cookie=&quot;age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;;</span><br></pre></td></tr></table></figure><ul><li>没有设置的选项会采用默认值</li><li>无法设置HttpOnly选项</li><li>secure：有条件，必须安全才能设置</li><li>多个cookie设置，不能一下子：document.cookie = “name=Jonh; age=12; class=111”;</li></ul></li><li><p>服务端设置：</p><ul><li><p>请求资源文件、ajax请求时，服务端返回的response header中的<strong>set-cookie</strong>，是服务端专门用来设置cookie的</p></li><li><p>set-cookie字段的值就是普通的字符串，一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段</p></li><li><p>服务端可设置cookie 所有选项：expires、domain、path、secure、HttpOnly</p><img src="https://img-blog.csdn.net/20180306222521824" alt="img" style="zoom:33%;" /></li></ul></li></ul><h5 id="修改、删除cookie：">修改、删除cookie：<a class="anchor" href="#修改、删除cookie：">·</a></h5><ul><li><p>修改cookie：</p><p>重新赋值，覆盖旧的。【注意】：在设置新cookie时，path/domain这几个选项一定要旧cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie</p></li><li><p>删除cookie：（下面封装思路有）</p><p>重新赋值，新cookie的expires 设为一个过去的时间点。</p><p>【注意】：path/domain/这几个选项一定要旧cookie 保持一样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">var</span> cookieExpire=date.<span class="title function_">getTime</span>()-<span class="number">1000</span>; <span class="comment">// 设置为一个过去的时间</span></span><br><span class="line"><span class="comment">// 删除 cookie 时，名称、路径和域名必须相同</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot; username=JavaScript  ; expire= &quot;</span> + cookieExpire + <span class="string">&quot; ;path=/;domain=www.bababa.org &quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="cookie-编码：">cookie 编码：<a class="anchor" href="#cookie-编码：">·</a></h5><ul><li><p>cookie是个字符串，但其中<strong>逗号、分号、空格</strong>被当做了特殊符号</p></li><li><p>所以当cookie的 key 和 value 中含有这3个特殊字符时，要对其额外编码；</p></li><li><p>一般用escape编码，读取时用unescape解码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="built_in">escape</span>(<span class="string">&quot;name;value&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> value = <span class="built_in">escape</span>(<span class="string">&quot;this is a value contain , and ;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>= key + <span class="string">&quot;=&quot;</span> + value + <span class="string">&quot;; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、封装一个cookie">3、封装一个cookie<a class="anchor" href="#3、封装一个cookie">·</a></h4><ul><li><p>设置、删除、获取指定名称的cookie、打印所有cookie</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Cookie</span> = &#123;</span><br><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line">  <span class="attr">setCookie</span>: <span class="function">(<span class="params">name, value</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="title class_">Days</span> = <span class="number">30</span>;</span><br><span class="line">       <span class="keyword">const</span> exp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">       exp.<span class="title function_">setTime</span>(exp.<span class="title function_">getTime</span>() + <span class="title class_">Days</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">       <span class="variable language_">document</span>.<span class="property">cookie</span> =</span><br><span class="line">         name + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">escape</span>(value) + <span class="string">&#x27;;expires=&#x27;</span> + exp.<span class="title function_">toUTCString</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 删除cookie</span></span><br><span class="line">  <span class="attr">delCookie</span>: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="title class_">Days</span> = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">const</span> exp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">     <span class="keyword">const</span> value = <span class="title class_">Cookie</span>.<span class="title function_">getCookie</span>(name);</span><br><span class="line">     exp.<span class="title function_">setTime</span>(exp.<span class="title function_">getTime</span>() + <span class="title class_">Days</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">cookie</span> =</span><br><span class="line">       name + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">escape</span>(value) + <span class="string">&#x27;;expires=&#x27;</span> + exp.<span class="title function_">toUTCString</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 打印所有cookie</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> strcookie = <span class="variable language_">document</span>.<span class="property">cookie</span>;<span class="comment">//获取cookie字符串</span></span><br><span class="line">      <span class="keyword">var</span> arrcookie = strcookie.<span class="title function_">split</span>(<span class="string">&quot;;&quot;</span>);<span class="comment">//分割</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//遍历匹配</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrcookie.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> arr = arrcookie[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>] +<span class="string">&quot;：&quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 获取指定名称的cookie</span></span><br><span class="line">  <span class="attr">getCookie</span>: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 正则匹配</span></span><br><span class="line">     <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;(^| )&#x27;</span> + name + <span class="string">&#x27;=([^;]*)(;|$)&#x27;</span>);</span><br><span class="line">     <span class="keyword">const</span> arr = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">match</span>(reg);</span><br><span class="line">     <span class="keyword">if</span> (arr != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(arr[<span class="number">2</span>]);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 循环，不借助正则</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">name</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> strcookie = <span class="variable language_">document</span>.<span class="property">cookie</span>;<span class="comment">//获取cookie字符串</span></span><br><span class="line">      <span class="keyword">var</span> arrcookie = strcookie.<span class="title function_">split</span>(<span class="string">&quot;; &quot;</span>);<span class="comment">//分割</span></span><br><span class="line">      <span class="comment">//遍历匹配</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrcookie.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> arr = arrcookie[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (arr[<span class="number">0</span>] == name)&#123;</span><br><span class="line">              <span class="keyword">return</span> arr[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Cookie</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、cookie与session特点对比">4、cookie与session特点对比<a class="anchor" href="#4、cookie与session特点对比">·</a></h3><h4 id="1、存储大小和位置">1、存储大小和位置<a class="anchor" href="#1、存储大小和位置">·</a></h4><ul><li>cookie：<ul><li>服务端生成，<strong>客户端维护和存储</strong>，以键值对的形式。</li><li>每个域名下Cookie的数量不能超过20个，单个 Cookie 保存的数据不能超过 4K；</li></ul></li><li>Session：<ul><li>客户端请求服务端，服务端会为这次请求生成一个 <strong>Session 对象</strong>，代表着服务器和客户端一次会话的过程</li><li>session对象：结构为 <code>ConcurrentHashMap</code>，存储特定用户会话所需属信息</li><li>session基于cookie实现的，要先攻破cookie获取sessionID</li></ul></li></ul><h4 id="2、生存期">2、生存期<a class="anchor" href="#2、生存期">·</a></h4><ul><li>Cookie分类： Session Cookies、持久性 Cookie<ul><li>如 Cookie 不包含到期日期，则视为会话 Cookie。存在内存中不会写入磁盘，当浏览器关闭时， Cookie 将永久丢失</li><li>如 Cookie 包含<code>有效期</code> ，则视为持久性 Cookie。在到期时，Cookie 将从磁盘中删除</li></ul></li><li>Session：<ul><li>存储在 Session 对象中的变量，在整个用户会话中一直存在下去</li><li>当客户端关闭会话，或者 Session 超时失效时会话结束</li></ul></li></ul><h4 id="3、隐私策略">3、隐私策略<a class="anchor" href="#3、隐私策略">·</a></h4><ul><li><p>Cookie：</p><ul><li><p>存在客户端，容易被窃取</p></li><li><p>同源窗口共享：同一域名发送http请求，会携带相同cookie，服务器拿到cookie解析得到客户端状态。不支持跨域名</p></li></ul></li><li><p>Session 存储在服务端，安全性相对 Cookie 要好一些。并且session基于cookie实现的</p><ul><li>要先攻破cookie获取session ID，session ID是加密的</li><li>如果禁用cookie就要通过重写url的方式：把sessionID放到url中</li></ul></li></ul><h4 id="4、缺点">4、缺点<a class="anchor" href="#4、缺点">·</a></h4><ul><li><p>cookie：</p><ul><li><p>性能缺陷：cookie紧跟域名，域名相同的请求，不管是否需要都携带，浪费性能</p></li><li><p>安全问题：HTTP明文传递，第三方攻击拦截；或者获取本地文件就能获取cookie数据</p><p>易遭受XSS攻击，所以有<strong>cookie安全策略</strong>；</p><p>易遭受XSRF攻击，所以有<strong>Set-Cookie：SameSite</strong></p></li></ul></li><li><p>session：比如 A 服务器存储了 Session，做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 访问，但B 服务器并没有存 A 的 Session，会导致 Session 失效</p></li></ul><h3 id="5、cookie和session的缺陷">5、cookie和session的缺陷<a class="anchor" href="#5、cookie和session的缺陷">·</a></h3><p>存在一些问题：存储空间、分布式问题、安全</p><ol><li>存储空间：由于服务器端需要对接大量的客户端，也就需要存放大量的 SessionId，这样会导致服务器存储压力过大。</li><li>分布式问题：如果服务器端是一个集群，为了同步登录态，需要将 SessionId 同步到每一台机器上，增加服务器端维护成本。</li><li>安全：由于 SessionId 存放在 Cookie 中，所以无法避免 CSRF 攻击：<ul><li>攻击者诱导用户进入一个第三方网站，然后该网站向<strong>被攻击网站</strong>发送跨站请求。</li><li>如果用户在<strong>被攻击网站中保存了登录状态</strong>，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</li><li>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></li></ul></li></ol><h3 id="6、Token机制">6、Token机制<a class="anchor" href="#6、Token机制">·</a></h3><ul><li><p>诞生的原因：为了解决 Session + Cookie 机制问题：</p><ul><li>安全：存登录凭证相关信息，不必放在cookie中；</li><li>存储空间：不再存储，而是验证即可</li></ul></li><li><p>Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌</p><ul><li><p>当第一次登录后，服务器会生成一个 Token 并返回给客户端；</p></li><li><p>客户端后续访问时，只需带上这个 Token 即可完成身份认证。</p></li></ul></li></ul><h4 id="1、Token-机制实现流程">1、Token 机制实现流程<a class="anchor" href="#1、Token-机制实现流程">·</a></h4><p>用户<strong>首次登录</strong>时：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/2/1730fcc51ab8a1db~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由<strong>客户端自由保存</strong>。</li></ol><p><strong>后续页面访问时：</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/2/1730fcc519ee3add~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li>用户访问 <code>a.com/pageB</code> 时，带上第一次登录时获取的 Token。</li><li>服务器端验证 Token ，有效则身份验证成功。</li></ol><h4 id="2、Token-机制的特点">2、Token 机制的特点<a class="anchor" href="#2、Token-机制的特点">·</a></h4><p>根据上面的案例，分析出 Token 的优缺点：</p><ul><li>服务器端<strong>无需维护Token存储空间</strong>，只需要首次生成Token，<strong>后续验证即可：</strong><ul><li>所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本</li></ul></li><li>Token 可存放在前端任何地方，可以不用存在 Cookie 中，提升页面安全性</li><li>Token 下发之后，只要在生效时间之内，就一直有效，如果服务器端<strong>想收回此 Token 的权限，并不容易</strong></li></ul><h4 id="3、Token-的生成步骤">3、Token 的生成步骤<a class="anchor" href="#3、Token-的生成步骤">·</a></h4><ul><li><p>最常见： JWT（Json Web Token），通信双方之间以 JSON 对象的形式安全的传递信息</p></li><li><h4 id="JWT构成：主要分为-3-个部分：header（头信息），playload（消息体），signature（签名）">JWT构成：主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）<a class="anchor" href="#JWT构成：主要分为-3-个部分：header（头信息），playload（消息体），signature（签名）">·</a></h4><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210206202812405.png" alt="image-20210206202812405" style="zoom: 33%;" /><ol><li><p>header 部分指定了该 JWT 使用的签名算法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">header = <span class="string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   </span><br><span class="line"> <span class="comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名：同一个密钥加密解密</span></span><br><span class="line"> <span class="comment">// JWT，固定值，通常都写成JWT即可</span></span><br></pre></td></tr></table></figure></li><li><p>playload 部分：携带的数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     </span><br><span class="line"><span class="comment">//iat 表示令牌生成的时间</span></span><br><span class="line"><span class="comment">// exp（expiration time）：过期时间</span></span><br></pre></td></tr></table></figure></li><li><p>signature 部分为 JWT 的签名：</p><p>主要为了让 JWT 不能被随意篡改，签名的方法分为两个步骤：</p><ol><li>输入 <code>base64url</code> 编码的 header 部分、 <code>.</code> 、<code>base64url</code> 编码的 playload 部分，输出 unsignedToken。</li><li>输入服务器端私钥、unsignedToken，输出 signature 签名</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Header = <span class="title function_">encodeBase64</span>(header)</span><br><span class="line"><span class="keyword">const</span> base64Payload = <span class="title function_">encodeBase64</span>(payload)</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;服务器私钥&#x27;</span></span><br><span class="line"></span><br><span class="line">signature = <span class="title function_">HMAC</span>(key, unsignedToken)</span><br></pre></td></tr></table></figure></li><li><p>最后的 Token 计算：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> base64Signature = <span class="title function_">encodeBase64</span>(signature)</span><br><span class="line">token = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>.<span class="subst">$&#123;base64Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="4、服务器解密Token">4、服务器解密Token<a class="anchor" href="#4、服务器解密Token">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [base64Header, base64Payload, base64Signature] = token.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature1 = <span class="title function_">decodeBase64</span>(base64Signature);</span><br><span class="line"><span class="keyword">const</span> unsignedToken = <span class="string">`<span class="subst">$&#123;base64Header&#125;</span>.<span class="subst">$&#123;base64Payload&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> signature2 = <span class="title function_">HMAC</span>(<span class="string">&#x27;服务器私钥&#x27;</span>, unsignedToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signature1 === signature2) <span class="keyword">return</span> <span class="string">&#x27;签名验证成功，token 没有被篡改&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload =  <span class="title function_">decodeBase64</span>(base64Payload)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Date</span>() - payload.<span class="property">iat</span> &lt; <span class="string">&#x27;token 有效期&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;token 有效&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="7、分布式session问题">7、分布式session问题<a class="anchor" href="#7、分布式session问题">·</a></h3><p>前面说到了session+cookie的3点缺陷，其实token只解决了两点。而对于分布式问题：</p><ul><li>互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来撑前端用户请求</li><li>那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会登录失效问题</li></ul><h4 id="解决方案：">解决方案：<a class="anchor" href="#解决方案：">·</a></h4><ul><li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li><li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li><li>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致   推荐这一种</li></ul><h3 id="8、localStorage-sessionStorage">8、localStorage &amp; sessionStorage<a class="anchor" href="#8、localStorage-sessionStorage">·</a></h3><h4 id="1、诞生的契机">1、诞生的契机<a class="anchor" href="#1、诞生的契机">·</a></h4><ul><li><p>cookie：</p><p>设置“<strong>每次请求都要携带的信息（最典型的就是身份认证信息</strong>）”就特别适合放在cookie中，免去了重复添加操作，其他类型的数据就不适合了</p></li><li><p>在 localStorage 出现之前，cookie被滥用当做了存储工具。什么数据都放在cookie中，即使这些数据只在页面中使用而不需要随请求传送到服务</p></li></ul><h4 id="2、localStorage">2、localStorage<a class="anchor" href="#2、localStorage">·</a></h4><ul><li>**持久化存储：**长期存数据，浏览器关闭后数据不丢失，存的数据没有过期时间，直到手动去除；</li><li>**同源: **   同源窗口中都是共享的</li></ul><h4 id="3、sessionStorage">3、sessionStorage<a class="anchor" href="#3、sessionStorage">·</a></h4><ul><li>**持久化存储：**临时存储数据，在关闭窗口或标签页之后会删除</li><li>**同源问题: **   更严苛：不仅要求同源，还要求同一个浏览器窗口中打开</li></ul><img src="https://www.runoob.com/wp-content/uploads/2019/04/3793073884-56950753e65db_articlex.png" alt="img" style="zoom: 33%;" /><h4 id="4、存储超容量问题">4、存储超容量问题<a class="anchor" href="#4、存储超容量问题">·</a></h4><p><strong>localstorage超容量会怎样？</strong>                    美团</p><p>问题根源：</p><ul><li>同一个域名共享同一个 localStorage，而同一个域名下存在过多独立的业务线，业务线之间各自为政，毫无节制的攫取公共资源</li></ul><p>问题本质：</p><ul><li><p>localStorage 归根结底就两个作用：<strong>持久化存储与跨页面传数据</strong>。问题就出在跨页面传数据上，上一个页面因为 localStorage 存满导致数据没有写入，下一个页面读取数据为空，从而导致错误。</p></li><li><p>浏览器反应：</p><ul><li>不存储数据, 也不会覆盖现有数据。</li><li>引发 QUOTA_EXCEEDED_ERR 异常。</li></ul></li><li><p>该怎么办？</p><p>1、划分域名：各域名下的存储空间由各业务组统一规划使用</p><p>2、跨页面传数据：考虑单页应用、优先采用 url 传数据。</p><ul><li>每一个域名下的localStorage容量是5M，假如a.com域名下localstorage存不下了</li><li>可以用iframe创建b.com域框架(子页面)用于存 a.com剩下的数据。然后用postMessage读写数据</li></ul><p>3、indexDB</p><p>4、最后的兜底方案：清掉别人的存储</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.2-浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-大顶堆与小顶堆</title>
      <link href="/posts/2803057116.html"/>
      <url>/posts/2803057116.html</url>
      
        <content type="html"><![CDATA[<h3 id="6-1、第K个最大元素-215中">6.1、第K个最大元素       215中<a class="anchor" href="#6-1、第K个最大元素-215中">·</a></h3><p>在未排序的数组中找到第 <strong>k 个最大</strong>的元素。</p><h4 id="思路1：大顶堆">思路1：大顶堆<a class="anchor" href="#思路1：大顶堆">·</a></h4><p>思路总结：</p><ul><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素「沉」到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶与当前末尾元素，反复执行调整、交换步骤，直到整个序列有序。</li></ul><h4 id="1、构造初始堆">1、构造初始堆<a class="anchor" href="#1、构造初始堆">·</a></h4><ol><li><p>给定无序序列结构</p><img src="https://pic.leetcode-cn.com/1624163715-VXPhZJ-image.png" alt="image.png" style="zoom:50%;" /></li><li><p><strong>此时从最后一个非叶子节点开始调整</strong>，从左到右，从上到下进行调整。也就是 元素为 6 的节点。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较时：先让 5 与 9 比较，得到最大那个，再和 6 比较，发现 9 大于 6，则调整他们的位置</span><br></pre></td></tr></table></figure></li><li><p>找到第二个非叶子节点 4，由于 <code>[4,9,8]</code> 中，9 元素最大，则 4 和 9 交换</p><img src="https://pic.leetcode-cn.com/1624163737-nWDnEx-image.png" alt="image.png" style="zoom: 67%;" /></li><li><p>此时，交换导致子根 <code>[4,5,6]</code> 结构混乱，将其继续调整。<code>[4,5,6]</code> 中 6 最大，将 4 与 6 调整。此时，就将一个无序序列构造成了一个大顶堆。</p><img src="https://pic.leetcode-cn.com/1624163748-vVZNTN-image.png" alt="image.png" style="zoom: 67%;" /></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从最后一个非叶子节点开始 自下而上构建一颗大顶堆</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">arr, heapSize</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">adjustHeap</span>(arr, i, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从左向右，自上而下的调整节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">adjustHeap</span>(<span class="params">arr, i, heapSize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = i * <span class="number">2</span> + <span class="number">1</span>;             <span class="comment">// 左子节点索引</span></span><br><span class="line">  <span class="keyword">let</span> right = i * <span class="number">2</span> + <span class="number">2</span>;            <span class="comment">// 右子节点索引</span></span><br><span class="line">  <span class="keyword">let</span> maxIndex = i;                <span class="comment">// 最大值索引</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最大的给父节点</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[maxIndex]) maxIndex = left;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[maxIndex]) maxIndex = right;</span><br><span class="line">  <span class="comment">// maxIndex为父节点，若发生改变则说明不是最大节点，需要交换</span></span><br><span class="line">  <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">    [arr[maxIndex], arr[i]] = [arr[i], arr[maxIndex]];</span><br><span class="line">    <span class="title function_">adjustHeap</span>(arr, maxIndex, heapSize); <span class="comment">// 继续调整下面的非叶子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、将堆顶元素与末尾元素交换">2、将堆顶元素与末尾元素交换<a class="anchor" href="#2、将堆顶元素与末尾元素交换">·</a></h4><p>将堆顶元素与末尾元素交换，使其末尾元素最大。然后继续调整，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p><ol><li><p>将堆顶元素 9 和末尾元素 4 交换</p><img src="https://pic.leetcode-cn.com/1624163757-rooMsP-image.png" alt="image.png" style="zoom:50%;" /></li><li><p>重新调整结构，使其继续满足堆定义</p><img src="https://pic.leetcode-cn.com/1624163766-WsYato-image.png" alt="image.png" style="zoom:50%;" /></li><li><p>再将堆顶元素 8 与末尾元素 5 交换，得到第二大元素 8</p><img src="https://pic.leetcode-cn.com/1624163783-IhXOJT-image.png" alt="image.png" style="zoom:50%;" /></li><li><p>后续过程，继续进行调整、交换，如此反复进行，最终使得整个序列有序</p><img src="https://pic.leetcode-cn.com/1624163793-fGUBxG-image.png" alt="image.png" style="zoom:50%;" /></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> heapSize = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="title function_">buildMaxHeap</span>(nums, heapSize); <span class="comment">// 构建好一个大顶堆</span></span><br><span class="line">  <span class="comment">// 进行下沉 大顶堆是最大元素下沉到末尾</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = nums.<span class="property">length</span>-<span class="number">1</span>; i&gt;=nums.<span class="property">length</span>-k+<span class="number">1</span>; i--)&#123;</span><br><span class="line">    [nums[i], nums[<span class="number">0</span>]] = [nums[<span class="number">0</span>], nums[i]];</span><br><span class="line">    heapSize--; <span class="comment">// 下沉后的元素不参与到大顶堆的调整</span></span><br><span class="line">    <span class="comment">// 重新调整大顶堆</span></span><br><span class="line">    <span class="title function_">adjustHeap</span>(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk)</li><li>空间复杂度：O(k)</li></ul><h4 id="3、总结：">3、总结：<a class="anchor" href="#3、总结：">·</a></h4><ul><li>注意事项（代码实现的关键思路）：<ul><li>第一步构建初始堆：是自底向上构建，从最后一个非叶子节点开始。</li><li>第二步就是<strong>下沉操作</strong>让尾部元素与堆顶元素交换，最大值被放在数组末尾，并且<strong>缩小数组的length</strong>，不参与后面大顶堆的调整</li><li>第三步就是调整：是<strong>从上到下，从左到右</strong>,因为堆顶元素下沉到末尾了，要重新调整这颗大顶堆</li></ul></li></ul><h3 id="6-2、前-K-个高频元素-347中">6.2、前 K 个高频元素   347中<a class="anchor" href="#6-2、前-K-个高频元素-347中">·</a></h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><ul><li>输入: nums = [1,1,1,2,2,3], k = 2           输出: [1,2]</li></ul><h4 id="思路1：map-小顶堆">思路1：map + 小顶堆<a class="anchor" href="#思路1：map-小顶堆">·</a></h4><ul><li><p>遍历一遍数组统计每个元素频率，并将元素值（ key ）与出现的频率（ value ）存到 map</p></li><li><p>遍历 map ，将所有元素构建一个小顶堆</p></li><li><p>再逐个从小顶堆的第1个淘汰，置换到尾部：从len — k个</p><ul><li>从len-1开始，直到索引为k；</li><li>注意，每次淘汰一个，都要将数组中删除该元素，不要再参与后续堆调整</li></ul></li><li><p>淘汰结束，剩下数组中的就是前k个频率最高的元素了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="comment">// 统计次数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    map.<span class="title function_">set</span>(num, (map.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> arr = [...map.<span class="title function_">keys</span>()];</span><br><span class="line">  <span class="keyword">let</span> heapSize = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span>(map.<span class="property">size</span> &lt;= k) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">buildMinHeap</span>(arr, heapSize, map);<span class="comment">// 构建小堆顶</span></span><br><span class="line">  <span class="comment">// 下沉 小顶堆是最小元素下沉到末尾</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.<span class="property">length</span>-<span class="number">1</span>; i&gt;= k; i--)&#123;</span><br><span class="line">    [arr[i], arr[<span class="number">0</span>]] = [arr[<span class="number">0</span>], arr[i]];</span><br><span class="line">     <span class="comment">// 下沉后的元素不参与到小顶堆的调整</span></span><br><span class="line">    heapSize--;</span><br><span class="line">    <span class="comment">// 重新调整小顶堆</span></span><br><span class="line">    arr.<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">    <span class="title function_">adjustHeap</span>(arr, <span class="number">0</span>, heapSize, map);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildMinHeap</span>(<span class="params">arr, heapSize, map</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">adjustHeap</span>(arr, i, heapSize, map);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">adjustHeap</span>(<span class="params">arr, i, heapSize, map</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = i * <span class="number">2</span> + <span class="number">1</span>;             </span><br><span class="line">  <span class="keyword">let</span> right = i * <span class="number">2</span> + <span class="number">2</span>;          </span><br><span class="line">  <span class="keyword">let</span> minIndex = i;                </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left&lt;heapSize &amp;&amp; map.<span class="title function_">get</span>(arr[left])&lt;map.<span class="title function_">get</span>(arr[minIndex])) minIndex = left;</span><br><span class="line">  <span class="keyword">if</span> (right&lt;heapSize &amp;&amp; map.<span class="title function_">get</span>(arr[right])&lt;map.<span class="title function_">get</span>(arr[minIndex])) minIndex = right;</span><br><span class="line">  <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">    [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];</span><br><span class="line">    <span class="title function_">adjustHeap</span>(arr, minIndex, heapSize, map); <span class="comment">// 交换之后递归再次调整比较</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于前端页面渲染</title>
      <link href="/posts/162997961.html"/>
      <url>/posts/162997961.html</url>
      
        <content type="html"><![CDATA[<h2 id="这部分的东西会结合JS的整个运行重新梳理，这个笔记不太满意">这部分的东西会结合JS的整个运行重新梳理，这个笔记不太满意<a class="anchor" href="#这部分的东西会结合JS的整个运行重新梳理，这个笔记不太满意">·</a></h2><h2 id="1、Webkit渲染流程">1、Webkit渲染流程<a class="anchor" href="#1、Webkit渲染流程">·</a></h2><p>浏览器获取到html，然后解析，渲染</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d69da20c3f84782948226798effc60a~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:50%;" /><h3 id="1、DOM树构建">1、DOM树构建<a class="anchor" href="#1、DOM树构建">·</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure><h4 id="1、转换">1、转换<a class="anchor" href="#1、转换">·</a></h4><ul><li>浏览器将获得的HTML内容是0/1这样的原始 <code>字节流</code>，根据文件的指定编码 (例如 UTF-8) 将它们转换成各个 <code>字符</code></li></ul><h4 id="2、分词">2、分词<a class="anchor" href="#2、分词">·</a></h4><ul><li><p>进行 <code>词法解析</code> ，把字符流初步解析成我们可理解的 <code>词</code>，学名叫 <code>token</code></p></li><li><p><code>词</code> 是编译原理中的最小单元，如标签开始、属性、标签结束、注释、CDATA节点</p></li><li><p><code>Tokens</code> 这个阶段中会标识出当前 <code>Token</code> 是 <code>开始标签</code> 或是 <code>结束标签</code> 亦或是 <code>文本</code> 等信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;haha&quot;</span>&gt;haha&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;div# 哦，看到了&lt;div，这是一个div标签的开始</span><br><span class="line"><span class="number">2.</span> <span class="keyword">class</span>=<span class="string">&quot;haha&quot;</span> # 这是一个<span class="keyword">class</span>属性</span><br><span class="line"><span class="number">3.</span> &gt;# 哦，到这儿是一个完整的div开始标签</span><br><span class="line"><span class="number">4.</span> haha# 嗯，这是一个文本</span><br><span class="line"><span class="number">5.</span> &lt;<span class="regexp">/div&gt;# 奥，看到了&lt;/</span>div&gt;，整个div标签结束了</span><br></pre></td></tr></table></figure><img src="https://segmentfault.com/img/remote/1460000013662139" alt="img" style="zoom: 67%;" /></li></ul><h4 id="3、节点创建">3、节点创建<a class="anchor" href="#3、节点创建">·</a></h4><ul><li>在每个 <code>Token</code> 被生成后，会立刻消耗这个 <code>Token</code> 创建出节点对象，就是 节点 (Nodes) 阶段</li><li>把开始结束标签配对、属性赋值好、父子关系这些都连接好了，最终就构成了 <code>DOM</code> 树</li><li>到此 <code>DOM Tree</code> 就解析完了</li></ul><h3 id="2、解析CSS—-CSSOM">2、解析CSS—&gt;CSSOM<a class="anchor" href="#2、解析CSS—-CSSOM">·</a></h3><ul><li><p>CSS规则树的生成也是类似</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure><p>譬如<code>style.css</code>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的CSSOM树就是：</p><img src="https://segmentfault.com/img/remote/1460000013662141" alt="img" style="zoom: 50%;" /></li></ul><h4 id="2、CSS阻塞">2、CSS阻塞<a class="anchor" href="#2、CSS阻塞">·</a></h4><ul><li><p>节点样式是可以继承的，所以在构建的过程中浏览器得递归 <code>DOM</code> 树来确定元素到底是什么样式</p></li><li><p>为了 <code>CSSOM</code> 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 <code>DOM</code> 已经构建完了，也得等 <code>CSSOM</code>，在 CSSOM 构建完毕之前，不会渲染任何已处理的内容</p></li><li><p>所以 <code>CSS</code> 的加载速度与构建 <code>CSSOM</code> 的速度<strong>会影响首屏渲染速度</strong>，这就是常说的 <code>CSS</code> 资源的加载会阻塞渲染</p></li></ul><h3 id="3、解析JS脚本">3、解析JS脚本<a class="anchor" href="#3、解析JS脚本">·</a></h3><h4 id="1-1、JS既会阻塞HTML、CSS的解析">1.1、JS既会阻塞HTML、CSS的解析<a class="anchor" href="#1-1、JS既会阻塞HTML、CSS的解析">·</a></h4><ul><li><p>解析 <code>JS</code> 的步骤是不固定的，因为在构建DOM 树的过程中，当 <code>HTML</code> 解析器遇到一个 <code>script</code> 标记时，<strong>即遇到了js，立即阻塞DOM树的构建</strong></p></li><li><p>就会将控制权移交给 <code>JS</code> 引擎，等到 <code>JS</code> 引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建</p></li><li><p>设计的原因：JS可以对DOM操作节点，浏览器无法预测未来的DOM节点的具体内容，<strong>为了防止无效操作，节省资源，只能阻塞DOM树的构建</strong></p><p>假如不阻塞，若 JS 删了某个DOM节点A，那么浏览器为构建此节点A花费的资源是无效的</p></li><li><p><strong>遇到img图片类资源</strong></p><p>直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p></li></ul><h4 id="1-2、优化：">1.2、优化：<a class="anchor" href="#1-2、优化：">·</a></h4><ol><li><p>尽量将JavaScript文件放在body的最后</p><p>若在 HTML 头部加载 JS 文件，由于 JS 阻塞，会推迟页面的首绘，所以为了加快页面渲染，一般将 JS 文件放到HTML 底部进行加载</p></li><li><p>script标签引入：对 JS 文件执行 <code>async</code> 或 <code>defer</code> 加载</p><ul><li><code>script</code>立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li><li><code>async</code> 是下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；一定在 <code>onload</code> 前，但不确定在 <code>DOMContentLoaded</code> 事件的前或后</li><li><code>defer</code> 是加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行，所以在浏览器看起来的效果像是将脚本放在了 <code>body</code> 后面一样，按规范应该是在 <code>DOMContentLoaded</code> 事件前，但不同浏览器不同</li></ul></li></ol><h5 id="loaded-domcontentloaded">loaded/domcontentloaded<a class="anchor" href="#loaded-domcontentloaded">·</a></h5><ul><li><p><code>DOMContentLoaded</code> ：仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)，所以js可以访问所有DOM节点，初始化界面</p></li><li><p><code>load </code>：页面上所有的DOM，样式表，脚本，图片都已经加载完成了</p></li><li><p><code>unload</code> – 当用户离开页面的时候触发，可以询问用户是否保存了更改以及是否确定要离开页面,，可是我们无法阻止用户转移到另一个页面上。</p></li><li><p><code>beforeunload</code>:用户即将离开页面或者关闭窗口时，beforeunload事件将会被触发以进行额外的确认</p></li><li><p><code>document.readyState</code>表征页面的加载状态，可以在<code>readystatechange</code>中追踪页面的变化状态：</p><ul><li><code>loading</code> — 页面正在加载中。</li><li><code>interactive</code> – 页面解析完毕，时间上和 <code>DOMContentLoaded</code>同时发生，不过顺序在它之前。</li><li><code>complete</code> – 页面上的资源都已加载完毕，时间上和<code>window.onload</code>同时发生，不过顺序在他之前</li></ul></li></ul><h4 id="2-1、CSS阻塞页面渲染">2.1、CSS阻塞页面渲染<a class="anchor" href="#2-1、CSS阻塞页面渲染">·</a></h4><p>使用CSS有三种方式：使用<strong>link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p><ul><li><p><strong>link</strong>：浏览器会派发一个新等线程(<strong>HTTP线程</strong>)去加载资源文件，<strong>与此同时GUI渲染线程</strong>会继续向下渲染代码</p></li><li><p><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(<strong>阻碍浏览器渲染</strong>)</p></li><li><p><strong>style</strong>：GUI直接渲染，减少关键渲染资源从服务器端到客户端的往返次数，因为不用link那样请求</p></li><li><p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p></li><li><p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p></li></ul><p><strong>针对DOM树、CSSOM树：</strong> 可以通过以下几种方式来减少渲染的时间：</p><ul><li>HTML文件的代码层级尽量不要太深</li><li>使用语义化的标签，来避免不标准语义化的特殊处理</li><li>减少CSSD代码的层级，因为选择器是从左向右进行解析的</li></ul><h4 id="3、-CSS-如何阻塞JS脚本执行？">3、 CSS 如何阻塞JS脚本执行？<a class="anchor" href="#3、-CSS-如何阻塞JS脚本执行？">·</a></h4><ul><li>JS脚本执行时<strong>可能在文档的解析过程中请求样式信息</strong>，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</li><li>所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将<strong>延迟 JS 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建</strong></li><li>在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JS，最后再继续文档的解析。</li></ul><h3 id="4、构建render树">4、构建render树<a class="anchor" href="#4、构建render树">·</a></h3><h4 id="1、构建顺序">1、构建顺序<a class="anchor" href="#1、构建顺序">·</a></h4><ul><li>渲染树 由 <code>DOM树</code>、<code>CSSOM树</code> 合并而成，但并不是必须等 <code>DOM树</code> 及 <code>CSSOM树</code> 加载完成后才开始合并构建 <code>渲染树</code></li><li>三者的构建并无先后条件，也并非完全独立，而是会有交叉，并行构建，因此会形成一边加载，一边解析，一边渲染的工作现象</li><li>渲染树的节点被称为<strong>渲染对象</strong>，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，<strong>不可见的 DOM 元素不会被插入渲染树</strong>。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li></ul><h4 id="2、render树构建流程">2、render树构建流程<a class="anchor" href="#2、render树构建流程">·</a></h4><ol><li>浏览器首先会从DOM树的根节点开始遍历每个可见节点<ul><li>例如脚本标记、元标记等有些节点不可见，因为它们不会体现在渲染输出中，所以会被忽略</li><li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如上图的其中一个 <code>span</code> 标签有 <code>display: none</code> 属性，也会被忽略</li><li>一般来说，渲染树和DOM树不是严格对应。因为有一些不可见的DOM元素不会插入到渲染树中，如<strong>head这种不可见的标签</strong>或者<code>display: none</code>等</li></ul></li><li>对于每个可见节点，找到其对应的的 CSSOM 规则并应用它们</li><li>输出可见节点，连同其内容和计算的样式</li></ol><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/22/1719d8c1564c3947~tplv-t2oaga2asx-watermark.awebp" alt="image-20200418220809467" style="zoom:67%;" /><h3 id="5、布局阶段">5、布局阶段<a class="anchor" href="#5、布局阶段">·</a></h3><ul><li><p>至此，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们还没有计算它们在设备 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fdesign-and-ux%2Fresponsive%3Fhl%3Dzh-cn%23set-the-viewport">视口</a> 内的确切位置和大小，而这就是 <code>布局</code> ( Layout ) 阶段，也称为 <code>回流</code> ( Reflow )</p></li><li><p>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p></li><li><p>布局流程的输出是一个 <code>盒模型</code>，它会精确地捕获每个元素在视口内的确切位置和尺寸，当然，所有相对测量值都转换为屏幕上的绝对像素</p></li></ul><h3 id="6、绘制">6、绘制<a class="anchor" href="#6、绘制">·</a></h3><ul><li>由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，我们将这些信息传递给最后一个阶段将渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 <code>绘制</code> 或 <code>栅格化</code></li></ul><h4 id="1、重绘">1、重绘<a class="anchor" href="#1、重绘">·</a></h4><ul><li>元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了，这叫做 <code>重绘</code> ( Repaint )</li><li>outline, visibility, color, background-color等</li></ul><h4 id="2、回流">2、回流<a class="anchor" href="#2、回流">·</a></h4><ul><li><p>一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p></li><li><h4 id="回流的场景：">回流的场景：<a class="anchor" href="#回流的场景：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line">4.窗口resize，字体大小会引起回流!!!</span><br><span class="line">5.最复杂的一种：获取某些属性，引发回流，很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （1）offset(Top/Left/Width/Height)</span><br><span class="line">     (2) scroll(Top/Left/Width/Height)</span><br><span class="line">     (3) cilent(Top/Left/Width/Height)</span><br><span class="line">     (4) width,height</span><br><span class="line">     (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、如何减少和避免回流重绘">3、如何减少和避免回流重绘<a class="anchor" href="#3、如何减少和避免回流重绘">·</a></h4><p>其实就是尽量避免上面那些操作</p><ul><li>减少逐项更改样式，最好一次性更改 <code>style</code>，或者将样式定义为 <code>class</code> 并一次性更新</li><li>避免循环操作DOM，让DOM离线后再修改<ul><li>创建一个 <code>documentFragment</code> ，在它上面应用所有DOM操作，最后再把它添加到 <code>window.document</code></li><li>先把DOM节点 <code>display:none</code> ( 会触发一次回流)，然后做修改后，再把它显示出来</li><li>克隆一个DOM节点在内存里，修改之后，与在线的节点相替换</li></ul></li><li>避免多次读取offset等属性，无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li><li>改变字体大小也会引发回流，所以尽可能减少这种操作</li><li>table布局，一个小改动会造成整个table的重新布局，所以，少用为好</li></ul><h3 id="7、合成">7、合成<a class="anchor" href="#7、合成">·</a></h3><p>到目前我们经历渲染过程如下</p><ul><li>首先解析 <code>HTML</code> 文档，形成 DOM 树</li><li>接着解析 <code>CSS</code>，产生 CSSOM树</li><li>在DOM和CSSOM树解析过程中，遇到 JS，会立即阻塞DOM树的构建，JS解析完成，接着走上面两步</li><li>再接着，浏览器通过DOM和CSSOM树构建渲染树<ul><li>这个过程中，DOM中不可见标签元素不会放到渲染树中，就像<code> 或 display:none</code></li><li>CSSOM树规则会附加给渲染树的每个元素上</li></ul></li><li>渲染树构建完成，浏览器会对这些元素进行定位和布局，这一步也叫 重排/回流 ( <code>Reflow</code>) 或 布局(<code>Layout</code> )</li><li>接下来绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做 重绘 (<code>Repaint</code>)</li><li>再接下来是我们这最后一步合成( <code>composite</code> )，浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</li></ul><h3 id="8、浏览器渲染方式">8、浏览器渲染方式<a class="anchor" href="#8、浏览器渲染方式">·</a></h3><p>浏览器在渲染图形的时候，有一个绘图上下文，绘图上下文又分成两种类型</p><ul><li>第一种是用来绘制2D图形的上下文，称之为2D绘图上下文</li><li>第二种是绘制3D图形的上下文，称之为3D绘图上下文</li></ul><p>网页也有三种渲染方式</p><ul><li>软件渲染（CPU内存）</li><li>使用软件绘图的合成化渲染（GPU内存）CSS3D、WebGL</li><li>硬件加速的合成化渲染（GPU内存）</li></ul><h4 id="1、软件渲染技术">1、软件渲染技术<a class="anchor" href="#1、软件渲染技术">·</a></h4><p>Webkit 在不需要硬件加速内容的时候（包括但不限于 <code>CSS3 3D变形</code>、<code>CSS3 3D变换</code> 、 <code>WebGL</code> 和 <code>视频</code>），它就可以使用 <code>软件渲染技术</code> 来完成页面绘制</p><p>对于每个渲染对象，需要三个阶段绘制自己</p><ul><li>第一阶段是绘制该层中所有块的背景和边框</li><li>第二阶段是绘制浮动内容</li><li>第三阶段是前景 ( Foreground ) ，也就是内容部分、轮廓、字体颜色、大小等 ( 内嵌元素的背景、边框等发生在这一阶段 )</li></ul><h4 id="2、硬件加速技术">2、硬件加速技术<a class="anchor" href="#2、硬件加速技术">·</a></h4><p>硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页 ( GPU的作用主要是用来绘制3D图形并且性能很 nice )</p><h4 id="3、普通图层和复合图层">3、普通图层和复合图层<a class="anchor" href="#3、普通图层和复合图层">·</a></h4><p>浏览器渲染的图层一般包含两大类：<code>普通图层</code> 以及 <code>复合图层</code></p><ul><li><p><strong>普通文档流：</strong></p><p>叫它<code>默认复合层</code>，因为里面不管添加多少元素，其实都是在同一个复合图层中</p><p><code>absolute</code> 布局、 <code>fixed</code> 也一样，虽然可以脱离普通文档流，但它仍然属于 <code>默认复合层</code></p></li><li><p><strong>复合图层：</strong></p><p>可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p><p>但也不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大</p></li><li><p>GPU中，各个复合图层是单独绘制的，所以也互不影响</p></li><li><p>通过 <code>硬件加速</code> 的方式，会声明一个 <code>新的复合图层</code> ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 <code>默认复合层</code> 里的回流重绘</p></li></ul><h4 id="4、何为复合图层-硬件加速">4、何为复合图层/硬件加速<a class="anchor" href="#4、何为复合图层-硬件加速">·</a></h4><p>复合图层或者说硬件加速，其实就是仅触发合成 <code>composite</code> ，那么也就必须符合以下三个条件</p><ul><li>不影响文档流</li><li>不依赖文档流</li><li>不会造成重绘</li></ul><p>可以做到这种情况得</p><ul><li><p>最常用的方式是 <code>transform</code></p><p>假如我们给一个元素加了 <code>transform</code> 属性吧，那么该元素就不会影响也不会依赖文档流，也不会造成重绘，就变成了一个复合图层</p><p>也就可以说我们对它使用了传说中的 <code>硬件加速技术</code></p></li><li><p><code>opacity</code> 属性 / 过渡动画 (需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态)</p></li><li><p><code>will-chang</code> 属性 (这个比较偏僻)，一般配合 <code>opacity</code> 与 <code>translate</code> 使用，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层，作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作 (最好用完后就释放)</p></li></ul><h4 id="5、absolute？">5、absolute？<a class="anchor" href="#5、absolute？">·</a></h4><p><code>absolute</code> 是脱离文档流，为什么上面复合图层或者说硬件加速中没有 <code>absolute</code> 呢？</p><ul><li>其实，<code>absolute</code> 虽然可以脱离普通文档流，但是无法脱离默认复合层，就像它的 <code>left</code> 属性可以使用百分比的值，依赖于它的 <code>offset parent</code></li><li>所以，就算 <code>absolute</code> 中信息改变时不会改变普通文档流中的 <code>渲染树</code></li><li>但浏览器最终绘制时，是整个复合层绘制的，所以 <code>absolute</code> 中信息改变，仍会影响整个复合层的绘制，浏览器还是会重绘它</li><li>如果复合层中内容多，<code>absolute</code> 带来的绘制信息变化过大，资源消耗也非常严重</li><li>硬件加速，那直接就是在另一个复合层了，所以它的信息改变不会影响默认复合层，当然内部肯定会影响属于自己的复合层，仅仅是引发最后的合成渲染</li></ul><h3 id="9、页面渲染优化">9、页面渲染优化<a class="anchor" href="#9、页面渲染优化">·</a></h3><p>总结下页面渲染这块的优化实践：</p><ul><li>HTML文档结构层次尽量少，最好不深于六层</li><li>JS 脚本尽量后放</li><li>样式结构层次尽量简单</li><li>少量首屏样式使用内联方式放在标签内</li><li>在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流</li><li>减少通过 JS 代码修改元素样式，尽量使用修改 <code>class</code> 名方式操作样式或动画</li><li>尽量减少浏览器重排和重绘的一些情况发生</li><li>2020年了！就不要使用 <code>table</code> 布局了</li><li>CSS 动画中尽量只使用 <code>transform</code> 和 <code>opacity</code> ，不会发生重排和重绘</li><li>隐藏在屏幕外，或在页面滚动时，尽量停止动画</li><li>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</li><li>避免浏览器的隐式合成</li><li>改变复合层的尺寸</li></ul><h3 id="10、如何优化关键渲染路径？">10、如何优化关键渲染路径？<a class="anchor" href="#10、如何优化关键渲染路径？">·</a></h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p><p>（1）关键资源的数量。</p><p>（2）关键路径长度。</p><p>（3）关键字节的数量。</p><ul><li>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</li><li>同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。</li><li>要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</li></ul><p>优化关键渲染路径的常规步骤如下：</p><p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p><p>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p><p>（3）优化关键字节数以缩短下载时间（往返次数）。</p><p>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>]]></content>
      
      
      <categories>
          
          <category> 3.2-浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页面解析渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于跨域问题</title>
      <link href="/posts/http-cache.html"/>
      <url>/posts/http-cache.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、跨域问题">1、跨域问题<a class="anchor" href="#1、跨域问题">·</a></h3><ul><li><p>**什么是跨域：**一个网页向另一个不同域名/不同协议/不同端口的网页请求资源</p></li><li><p>**跨域条件：**协议，域名，端口，有一个不同就算跨域</p></li><li><p><strong>为什么会产生跨域请求：</strong></p><p>浏览器同源策略，规定了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的重要安全机制</p></li></ul><h3 id="2、非同源限制">2、非同源限制<a class="anchor" href="#2、非同源限制">·</a></h3><ul><li>无法共享非同源网页的 Cookie、LocalStorage 和 IndexedDB     <strong>cookie跨域</strong></li><li>无法接触非同源网页的 DOM         <strong>跨域窗口iframe</strong></li><li>无法向非同源地址发送 AJAX 请求</li></ul><h3 id="方案1、CORS（跨域资源共享）-2">方案1、CORS（跨域资源共享）<a class="anchor" href="#方案1、CORS（跨域资源共享）-2">·</a></h3><p>浏览器与服务器商量后的一个结果</p><h4 id="1、概念-3">1、概念<a class="anchor" href="#1、概念-3">·</a></h4><ul><li><p>是一种机制，使用额外的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FHTTP">HTTP</a> 头来允许服务器声明哪些源 可以通过浏览器有权限访问哪些资源。</p></li><li><p>不需要在客户端做任何特殊的操作，浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p></li><li><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><ul><li>简单请求：不会触发预检请求的请求</li><li>复杂请求：除了简单请求</li></ul></li></ul><h4 id="2、简单请求如何工作-2">2、简单请求如何工作<a class="anchor" href="#2、简单请求如何工作-2">·</a></h4><p>浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息添加一个<code>Origin</code>字段：</p><ul><li>用来说明，本次请求来自哪个源（协议 + 域名 + 端口）</li><li>服务器根据这个值，决定是否同意这次请求</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="title class_">Host</span>: api.<span class="property">alice</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure><ol><li><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应：</p><p>浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获</p><p>【注意】：这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200</p></li><li><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p></li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line">// 指定后，可以返回`FooBar`字段的值</span><br><span class="line"><span class="attribute">Access-Control-Expose-Headers</span><span class="punctuation">: </span>FooBar</span><br><span class="line"></span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><ul><li>必须。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求</li></ul><p><strong>（2）Access-Control-Allow-Credentials</strong></p><ul><li><p>可选。它的值是一个布尔值，表示<strong>是否允许发送Cookie</strong></p></li><li><p>默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p></li><li><p>这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可</p></li></ul><p><strong>（3）Access-Control-Expose-Headers</strong></p><ul><li><p>可选，CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code></p></li><li><p>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定</p></li></ul><h4 id="3、-withCredentials-属性-2">3、 withCredentials 属性<a class="anchor" href="#3、-withCredentials-属性-2">·</a></h4><ol><li>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段</li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理</li></ol><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</li></ol><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></blockquote><p>【注意】：</p><ol><li>如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</li><li>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传</li><li>且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie</li></ol><h4 id="4、复杂请求如何工作-2">4、复杂请求如何工作<a class="anchor" href="#4、复杂请求如何工作-2">·</a></h4><p>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求，通过该请求来知道服务端是否允许跨域请求</p><ul><li>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段</li><li>只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错</li></ul><h4 id="4-1、预检请求的发送-2">4.1、预检请求的发送<a class="anchor" href="#4-1、预检请求的发送-2">·</a></h4><ul><li><p>预检&quot;请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p></li><li><p>除了<code>Origin</code>字段，&quot;预检&quot;请求的头信息包括两个特殊字段</p></li></ul><p><strong>（1）Access-Control-Request-Method</strong></p><ul><li>必须，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code></li></ul><p><strong>（2）Access-Control-Request-Headers</strong></p><ul><li>是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code></li></ul><p>下面是一段浏览器的JavaScript脚本。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://api.alice.com/cors&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></blockquote><p>这个&quot;预检&quot;请求的HTTP头信息。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2、预检请求的回应-2">4.2、预检请求的回应<a class="anchor" href="#4-2、预检请求的回应-2">·</a></h4><ul><li><p>服务器收到&quot;预检&quot;请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应</p></li><li><p>HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure></blockquote><ol><li>HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</li></ol><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li><p>如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段</p><p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure></li><li><p>服务器回应的其他CORS相关字段如下。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span><span class="punctuation">: </span>1728000</span><br></pre></td></tr></table></figure></blockquote><h5 id="（1）Access-Control-Allow-Methods-2">（1）Access-Control-Allow-Methods<a class="anchor" href="#（1）Access-Control-Allow-Methods-2">·</a></h5><ul><li>必须，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</li><li>返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求</li></ul><h5 id="（2）Access-Control-Allow-Headers-2">（2）Access-Control-Allow-Headers<a class="anchor" href="#（2）Access-Control-Allow-Headers-2">·</a></h5><ul><li>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的</li><li>也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段</li></ul><h5 id="（3）Access-Control-Allow-Credentials-2">（3）Access-Control-Allow-Credentials<a class="anchor" href="#（3）Access-Control-Allow-Credentials-2">·</a></h5><ul><li>该字段与简单请求时的含义相同</li></ul><h5 id="（4）Access-Control-Max-Age-2">（4）Access-Control-Max-Age<a class="anchor" href="#（4）Access-Control-Max-Age-2">·</a></h5><ul><li>可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天）</li><li>在此期间，不用发出另一条预检请求</li></ul></li></ol><h4 id="4-3-、浏览器的正常请求和回应-2">4.3 、浏览器的正常请求和回应<a class="anchor" href="#4-3-、浏览器的正常请求和回应-2">·</a></h4><ul><li><p>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会自动有一个<code>Origin</code>头信息字段。</p></li><li><p>服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p></li></ul><p>下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">X-Custom-Header</span><span class="punctuation">: </span>value</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure></blockquote><p>下面是服务器正常的回应</p><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-4、配置流程：-2">4.4、配置流程：<a class="anchor" href="#4-4、配置流程：-2">·</a></h4><ul><li><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键</p></li><li><p>前端：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;name=xiamen&#x27;</span> <span class="comment">// cookie不能跨域</span></span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span> <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;http://localhost:4000/getData&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xiamen&#x27;</span>)</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">      <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure></li><li><p>后端配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server1.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server2.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">&#x27;http://localhost:3000&#x27;</span>] <span class="comment">//设置白名单</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.<span class="property">headers</span>.<span class="property">origin</span></span><br><span class="line">  <span class="keyword">if</span> (whitList.<span class="title function_">includes</span>(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)</span><br><span class="line">    <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">    <span class="comment">// 允许携带cookie</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 预检的存活时间</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 允许返回的头</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> === <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      res.<span class="title function_">end</span>() <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">put</span>(<span class="string">&#x27;/getData&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">headers</span>)</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jw&#x27;</span>) <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/getData&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">headers</span>)</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname))</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">4000</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、与JSONP比较-2">5、与JSONP比较<a class="anchor" href="#5、与JSONP比较-2">·</a></h4><p>使用目的相同，但是比JSONP更强大：</p><ul><li>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求</li><li>JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</li></ul><h4 id="6、简单、复杂请求-2">6、简单、复杂请求<a class="anchor" href="#6、简单、复杂请求-2">·</a></h4><h5 id="1、简单请求-2">1、简单请求<a class="anchor" href="#1、简单请求-2">·</a></h5><p>不会触发 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS%23Preflighted_requests">CORS 预检请求</a>。这样的请求为“简单请求”：</p><ul><li><p>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</p><ul><li>get、head、post</li></ul></li><li><p>情况二: 人为设置以下集合外的请求头</p><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept"><code>Accept</code></a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept-Language"><code>Accept-Language</code></a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Language"><code>Content-Language</code></a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Type"><code>Content-Type</code></a> （需要注意额外的限制）</li><li><code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code></li></ul></li><li><p>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 application/json 为非简单请求)</p></li><li><p><code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code></p></li><li><p>情况四:</p><p>请求中的任意<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest%2Fupload"><code>XMLHttpRequest.upload</code></a> 属性访问</p></li><li><p>情况五:</p><p>请求中没有使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FReadableStream"><code>ReadableStream</code></a> 对象</p></li></ul><h5 id="2、复杂请求-2">2、复杂请求<a class="anchor" href="#2、复杂请求-2">·</a></h5><p>除了简单请求</p><h3 id="方案2：JSONP">方案2：JSONP<a class="anchor" href="#方案2：JSONP">·</a></h3><h4 id="1、JSONP如何产生的？">1、JSONP如何产生的？<a class="anchor" href="#1、JSONP如何产生的？">·</a></h4><ul><li>AJAX直接请求普通文件存在跨域无权访问的问题；网页中<strong>拥有<code>src</code>属性的标签</strong>天然具备跨域能力，页面上调用js文件时则不受是否跨域的影响：<ul><li>img、script、link、iframe</li></ul></li><li>JSON：纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被JS原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</li></ul><h4 id="2、实现思想：">2、实现思想：<a class="anchor" href="#2、实现思想：">·</a></h4><ol><li>允许用户传递一个<code>callback</code>参数给服务端</li><li>然后服务端返回数据时会将这个<code>callback</code>参数作为函数名来包裹住JSON数据</li><li>这样客户端就可以随意定制自己的函数来自动处理返回数据了</li></ol><h4 id="3、实现例子：">3、实现例子：<a class="anchor" href="#3、实现例子：">·</a></h4><ul><li>客户端：<ol><li>定义获取数据后调用的回调函数</li><li>动态生成对服务端JS进行引用的代码<ul><li>设置<code>url</code>为提供<code>jsonp</code>服务的<code>url</code>地址，并在该<code>url</code>中设置相关<code>callback</code>参数</li><li>创建<code>script</code>标签，并设置其<code>src</code>属性</li><li>把<code>script</code>标签加入<code>head</code>，此时<strong>调用开始</strong></li></ul></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 1. 动态的创建一个 script 标签</span></span><br><span class="line">   <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//2. 设置 script 的 src， 设置回调函数</span></span><br><span class="line">   script.<span class="property">src</span> = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span>;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">abc</span>(<span class="params">data</span>) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(data.<span class="property">name</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="comment">// 3. 将 script 添加到 body 中，调用开始</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><ul><li>服务端：将客户端发送的<code>callback</code>参数作为函数名来包裹住<code>JSON</code>数据，返回数据至客户端</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 服务器中路由的处理-------</span></span><br><span class="line"> router.<span class="title function_">get</span>(<span class="string">&quot;/testAJAX&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到请求&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> callback = req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="attr">ame</span>: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">   &#125;</span><br><span class="line">   res.<span class="title function_">send</span>(callback + <span class="string">&quot;(&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h4 id="4、缺点：">4、缺点：<a class="anchor" href="#4、缺点：">·</a></h4><ol><li><p>**安全问题：**JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。 此时除了完全删除 JSONP 没有其他办法</p></li><li><p><strong>只接受GET请求方式</strong>：<code>script</code>，<code>link</code>，<code>img</code> 等标签引入外部资源，都是<code>GET</code>请求的，那么就决定了 <strong>JSONP 一定是GET</strong>的</p></li><li><p>不确定请求是否失败：虽然 HTML5 规定了<script>元素的 onerror 事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应，但这并不准确</p></li></ol><h4 id="5、AJAX与JSONP的不同：">5、AJAX与JSONP的不同：<a class="anchor" href="#5、AJAX与JSONP的不同：">·</a></h4><ul><li><p>**相同点：**调用方式上“看起来”很像，目的也一样，都是请求一个<code>url</code>，然后把服务器返回的数据处理</p></li><li><p>**不同点：**本质上是不同的东西</p><ol><li><p><strong>AJAX的核心</strong>：通过<code>XmlHttpRequest</code>获取非本页内容</p></li><li><p>**JSONP的核心：**动态添加<code>script</code>标签来调用服务器提供的js脚本</p><p>JSONP是一种方式，如同AJAX一样，它也不一定非要用JSON格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用JSONP提供公开服务</p></li><li><p><strong>所以区别不在于是否跨</strong>：AJAX通过服务端代理一样可以实现跨域，JSONP本身也不排斥同域的数据的获取</p></li></ol></li></ul><h3 id="方案3：正向代理">方案3：正向代理<a class="anchor" href="#方案3：正向代理">·</a></h3><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域，,它没有同源策略的限制</p><h4 id="1、脚手架中的">1、脚手架中的<a class="anchor" href="#1、脚手架中的">·</a></h4><ul><li><h4 id="webpack配置proxy">webpack配置proxy<a class="anchor" href="#webpack配置proxy">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: 8000,</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    &quot;/api&quot;: &#123;</span><br><span class="line">      target: &quot;http://localhost:8080&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><h4 id="vue-cli"><code>vue-cli</code><a class="anchor" href="#vue-cli">·</a></h4><p>配置 proxyTable 来进行跨域：</p><p><code>webpack</code> 提供一个<code>http</code>代理服务器。请求接口时,实际上是请求的<code>webpack</code>提供的这个<code>http</code>代理服务器。再由这个代理服务器请求真实的数据服务器。</p><p>最后数据经由<code>webpack</code>代理服务器,最后转交给<code>vue</code>程序</p><img src="https:////upload-images.jianshu.io/upload_images/2701794-8c98b9b1fb747a35.png?imageMogr2/auto-orient/strip|imageView2/2/w/1011/format/webp" alt="img" style="zoom:50%;" /></li></ul><h4 id="2、使用代理工具">2、使用代理工具<a class="anchor" href="#2、使用代理工具">·</a></h4><ul><li>使用代理库：cors-anywhere</li><li>charles代理工具：利用 charles 进行跨域，本质就是请求的拦截与代理</li></ul><h3 id="方案4：反向代理？？？">方案4：反向代理？？？<a class="anchor" href="#方案4：反向代理？？？">·</a></h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h3 id="方案5-Node中间件代理-两次跨域-？？？">方案5. Node中间件代理(两次跨域)？？？<a class="anchor" href="#方案5-Node中间件代理-两次跨域-？？？">·</a></h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> 代理服务器，需要做以下几个步骤：</p><ul><li><p>接受客户端请求</p></li><li><p>将请求 转发给服务器</p></li><li><p>拿到服务器 响应 数据</p></li><li><p>将 响应 转发给客户端</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/17/1685c5bed77e7788~tplv-t2oaga2asx-watermark.awebp" alt="img"></p></li></ul><p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html(http://127.0.0.1:5500)</span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;xiamen&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">contentType</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">// server1.js 代理服务器(http://localhost:3000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 第一步：接受客户端请求</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span></span><br><span class="line">  response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 第二步：将请求转发给服务器</span></span><br><span class="line">  <span class="keyword">const</span> proxyRequest = http</span><br><span class="line">    .<span class="title function_">request</span>(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">4000</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: request.<span class="property">method</span>,</span><br><span class="line">        <span class="attr">headers</span>: request.<span class="property">headers</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="params">serverResponse</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第三步：收到服务器的响应</span></span><br><span class="line">        <span class="keyword">var</span> body = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        serverResponse.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">          body += chunk</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The data is &#x27;</span> + body)</span><br><span class="line">          <span class="comment">// 第四步：将响应结果转发给浏览器</span></span><br><span class="line">          response.<span class="title function_">end</span>(body)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_">end</span>()</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The proxyServer is running at http://localhost:3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server2.js(http://localhost:4000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">title</span>: <span class="string">&#x27;fontend&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">url</span> === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">4000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The server is running at http://localhost:4000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>&#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</code></p><h3 id="方案6：Websocket">方案6：Websocket<a class="anchor" href="#方案6：Websocket">·</a></h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// socket.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let socket = new WebSocket(&#x27;ws://localhost:3000&#x27;);</span><br><span class="line">    socket.onopen = function () &#123;</span><br><span class="line">      socket.send(&#x27;我爱你&#x27;);//向服务器发送数据</span><br><span class="line">    &#125;</span><br><span class="line">    socket.onmessage = function (e) &#123;</span><br><span class="line">      console.log(e.data);//接收服务器返回的数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br><span class="line">// server.js</span><br><span class="line">let express = require(&#x27;express&#x27;);</span><br><span class="line">let app = express();</span><br><span class="line">let WebSocket = require(&#x27;ws&#x27;);//记得安装ws</span><br><span class="line">let wss = new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class="line">wss.on(&#x27;connection&#x27;,function(ws) &#123;</span><br><span class="line">  ws.on(&#x27;message&#x27;, function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    ws.send(&#x27;我不爱你&#x27;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2、跨域窗口">2、跨域窗口<a class="anchor" href="#2、跨域窗口">·</a></h2><p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p><ul><li><p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myIFrame&quot;</span>).<span class="property">contentWindow</span>.<span class="property">document</span></span><br><span class="line"><span class="comment">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span></span><br></pre></td></tr></table></figure></blockquote><p>反之亦然，子窗口获取主窗口的DOM也会报错。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">document</span>.<span class="property">body</span></span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>对<strong>于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</strong></p><blockquote><ul><li>window.name+iframe</li><li>location.hash+iframe</li><li>跨文档通信API（postMessage   ）</li></ul></blockquote></li></ul><h3 id="方案7：window-name-iframe">方案7：window.name+iframe<a class="anchor" href="#方案7：window-name-iframe">·</a></h3><p>浏览器窗口有<code>window.name</code>属性。这个<strong>属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</strong></p><p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = data;</span><br></pre></td></tr></table></figure></blockquote><p>接着，子窗口跳回一个与主窗口同域的网址。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location = <span class="string">&#x27;http://parent.url.com/xxx.html&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><p>然后，主窗口就可以读取子窗口的<code>window.name</code>了。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myFrame&#x27;</span>).<span class="property">contentWindow</span>.<span class="property">name</span>;</span><br></pre></td></tr></table></figure></blockquote><p>优点：<code>window.name</code>容量很大，可以放置非常长的字符串；</p><p>缺点：必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p><h3 id="方案8：location-hash-iframe">方案8：location.hash+iframe<a class="anchor" href="#方案8：location-hash-iframe">·</a></h3><ul><li><p>URL的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p><p>父窗口可以把信息，写入子窗口的片段标识符。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIFrame&#x27;</span>).<span class="property">src</span> = src;</span><br></pre></td></tr></table></figure></blockquote><p>子窗口通过监听<code>hashchange</code>事件得到通知。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = checkMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> message = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>同样的，子窗口也可以改变父窗口的片段标识符。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.<span class="property">location</span>.<span class="property">href</span>= target + <span class="string">&quot;#&quot;</span> + hash;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="方案9：postMessage">方案9：postMessage<a class="anchor" href="#方案9：postMessage">·</a></h3><h4 id="1、概念-4">1、概念<a class="anchor" href="#1、概念-4">·</a></h4><p>HTML5为解决这个问题，引入了一全新的API：是可以跨域操作的window属性之一，用于解决：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li></ul><h4 id="2、使用-2">2、使用<a class="anchor" href="#2、使用-2">·</a></h4><ul><li><p>这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，<strong>允许跨窗口通信，不论这两个窗口是否同源。</strong></p><p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://bbb.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line">popup.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>, <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote></li><li><pre><code>someWindow.postMessage(message, targetOrigin, [transfer]);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * someWindow ：窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames</span><br><span class="line">  * message 将要发送到其他 window的数据。</span><br><span class="line">  * targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;（表示无限制）。不提供确切的目标将导致数据泄露等安全问题</span><br><span class="line">  * transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</span><br><span class="line"></span><br><span class="line">* `message`事件的事件对象`event`，提供以下三个属性。</span><br><span class="line"></span><br><span class="line">  &gt; * `event.source`：发送消息的窗口</span><br><span class="line">  &gt; * `event.origin`: 消息发向的网址</span><br><span class="line">  &gt; * `event.data`: 消息内容</span><br><span class="line"></span><br><span class="line">* 通过`window.postMessage`，读写其他窗口的 LocalStorage 也可以</span><br><span class="line"></span><br><span class="line">#### 3、举例 ####</span><br><span class="line"></span><br><span class="line">* // a.html</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">   &lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt; //等它加载完触发一个事件</span><br><span class="line">    //内嵌在http://localhost:3000/a.html</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">        function load() &#123;</span><br><span class="line">          let frame = document.getElementById(&#x27;frame&#x27;)</span><br><span class="line">          frame.contentWindow.postMessage(&#x27;我爱你&#x27;, &#x27;http://localhost:4000&#x27;) //发送数据</span><br><span class="line">          window.onmessage = function(e) &#123; //接受返回数据</span><br><span class="line">            console.log(e.data) //我不爱你</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/script&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>// b.html</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>) <span class="comment">//我爱你</span></span><br><span class="line">    e.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;我不爱你&#x27;</span>, e.<span class="property">origin</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方案10：cookie跨域">方案10：cookie跨域<a class="anchor" href="#方案10：cookie跨域">·</a></h3><ul><li><p>Cookie：只有同源的网页才能共享。但是，<strong>两个网页一级域名相同，只是二级域名不同</strong>，浏览器允许通过设置<code>document.domain</code>共享 Cookie</p><p>举例来说，A网页是<code>http://w1.example.com/a.html</code>，B网页是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享Cookie</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;example.com&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><p>现在，A网页通过脚本设置一个 Cookie</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;test1=hello&quot;</span>;</span><br></pre></td></tr></table></figure></blockquote><p>B网页就可以读到这个 Cookie</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookie = <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>注意，这种方法<strong>只适用于 Cookie 和 iframe 窗口</strong>，<strong>LocalStorage 和 IndexDB 无法通过这种方法</strong>，规避同源政策，而要使用PostMessage API</p></li><li><p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。</p></li></ul><blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>key=value; domain=.example.com; path=/</span><br></pre></td></tr></table></figure></blockquote><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HTTP</title>
      <link href="/posts/2218506745.html"/>
      <url>/posts/2218506745.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、HTTP概述-2">1、HTTP概述<a class="anchor" href="#1、HTTP概述-2">·</a></h3><h4 id="1、是什么：-2">1、是什么：<a class="anchor" href="#1、是什么：-2">·</a></h4><ol><li>超文本传输协议，基于TCP/IP协议，<strong>是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></li><li>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如&quot;HTTP/1.1 200 OK&quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息</li></ol><h4 id="2、特点：-2">2、特点：<a class="anchor" href="#2、特点：-2">·</a></h4><h5 id="1、灵活可扩展-2">1、灵活可扩展<a class="anchor" href="#1、灵活可扩展-2">·</a></h5><ul><li>一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。</li><li>另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据</li></ul><h5 id="2、请求-应答模式-2">2、请求-应答模式<a class="anchor" href="#2、请求-应答模式-2">·</a></h5><ul><li>通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等</li></ul><h5 id="3、可靠传输-2">3、可靠传输<a class="anchor" href="#3、可靠传输-2">·</a></h5><ul><li>HTTP是基于TCP/IP，因此把这一特性继承了下来</li></ul><h5 id="4、无状态-2">4、无状态<a class="anchor" href="#4、无状态-2">·</a></h5><ul><li><p>指协议对于事物处理没有记忆能力。不对请求和响应之间的通信状态进行保存</p></li><li><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传</p></li><li><p>无状态协议解决办法：</p><p>1、通过、Cookie</p><p>2、通过Session会话保存</p></li></ul><h4 id="3、优、缺点-2">3、优、缺点<a class="anchor" href="#3、优、缺点-2">·</a></h4><h5 id="1、无状态-2">1、无状态<a class="anchor" href="#1、无状态-2">·</a></h5><ul><li>有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等</li><li>另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说</li></ul><h5 id="2、明文传输-2">2、明文传输<a class="anchor" href="#2、明文传输-2">·</a></h5><ul><li>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式</li><li>这让HTTP的报文信息暴露给了外界，给攻击者带来了便利</li><li>不验证对方信息，会遭遇伪装；</li></ul><h5 id="3、队头阻塞-2">3、队头阻塞<a class="anchor" href="#3、队头阻塞-2">·</a></h5><ul><li>当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题</li></ul><h3 id="2、HTTP-状态码-2">2、HTTP 状态码<a class="anchor" href="#2、HTTP-状态码-2">·</a></h3><p>RFC 规定 HTTP 的状态码为**「三位数」**，第一个数字定义了响应的类别，被分为五类:</p><ul><li><strong>「1xx」</strong>: 代表请求已被接受，需要继续处理。</li><li><strong>「2xx」</strong>: 表示成功状态。</li><li><strong>「3xx」</strong>: 重定向状态。</li><li><strong>「4xx」</strong>: 客户端错误。</li><li><strong>「5xx」</strong>: 服务器端错误。</li></ul><h4 id="1、1xx-信息类-2">1、1xx 信息类<a class="anchor" href="#1、1xx-信息类-2">·</a></h4><ul><li>100继续 ：指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100允许客户端继续或用417告诉客户端不同意接受附件。     HTTP 1.1中新加入的</li><li>101转换协议：指服务器将按照其上的头信息变为一个不同的协议。 HTTP 1.1中新加入的</li></ul><h4 id="2、2xx-成功-2">2、2xx 成功<a class="anchor" href="#2、2xx-成功-2">·</a></h4><ul><li><p>200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页</p></li><li><p>201 （已创建） 请求成功并且服务器创建了新的资源。</p></li><li><p>204：请求得到了成功处理，但返回的响应报文中不含实体的主体部分（没有资源可以返回）</p></li><li><p>206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 <strong>「Content-Range」</strong> 指定范围的实体内容。</p></li></ul><h4 id="3、3xx-重定向-2">3、3xx 重定向<a class="anchor" href="#3、3xx-重定向-2">·</a></h4><h5 id="同样是重定向，307，303，302的区别？-2">同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？<a class="anchor" href="#同样是重定向，307，303，302的区别？-2">·</a></h5><ul><li><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。</p><ul><li>303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。</li><li>307会遵照浏览器标准，不会从post变为get。</li></ul></li><li><p>301 （永久移动）表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI，新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。</p><ul><li>若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址</li><li>使用场景：<ul><li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul></li></ul></li><li><p>302 （临时移动） 表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。</p><ul><li>302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。</li><li>若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</li><li>同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li><li>使用场景：<ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。</li></ul></li></ul></li><li><p>303 （查看其他位置）表示由于请求对应的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源</p><ul><li>和 302 Found 状态码有着相似的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源</li><li>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</li><li>注意：<ul><li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li><li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做</li></ul></li></ul></li><li><p><strong>304 （未修改，协商缓存可用） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</strong></p><p>304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系</p><ol><li><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul></li><li><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。</li></ul></li><li><p><strong>HTTP状态码304是多好还是少好</strong></p><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。</p><p>若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p></li></ol></li><li><p>305 （使用<strong>代理</strong>） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</p></li><li><p>307 （临时重定向）会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容</p></li></ul><h4 id="4、4XX-客户端错误-2">4、4XX 客户端错误<a class="anchor" href="#4、4XX-客户端错误-2">·</a></h4><ul><li><p>400  请求报文存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p></li><li><p>401 unauthorized，表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败。</p><ul><li><p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p></li><li><p>出现401场景：</p><ul><li>401.1 - 登录失败。</li><li>401.2 - 服务器配置导致登录失败。</li><li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li><li>401.4 - 筛选器授权失败。</li><li>401.5 - ISAPI/CGI 应用程序授权失败。</li><li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li></ul></li></ul></li><li><p>403 forbidden，表示对请求资源的访问被服务器拒绝。服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。**进入该状态后，不能再继续进行验证。**该访问是永久禁止的，并且与应用逻辑密切相关。</p></li><li><p>404 not found，表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：</p></li><li><p>405  表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。</p><p>GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、5XX-服务器错误-2">5、5XX 服务器错误<a class="anchor" href="#5、5XX-服务器错误-2">·</a></h4><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误。</li><li>502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li></ul><h3 id="3、HTTP版本差异-2">3、HTTP版本差异<a class="anchor" href="#3、HTTP版本差异-2">·</a></h3><h4 id="1、HTTP-0-9-2">1、HTTP 0.9<a class="anchor" href="#1、HTTP-0-9-2">·</a></h4><ul><li>91年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，已过时。</li></ul><h4 id="2、HTTP-1-0-2">2、HTTP 1.0<a class="anchor" href="#2、HTTP-1-0-2">·</a></h4><ul><li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件</li><li>除了GET命令，还引入了POST命令和HEAD命令</li><li>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</li><li>只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li><li>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</li></ul><h4 id="3、HTTP-1-1-2">3、HTTP 1.1<a class="anchor" href="#3、HTTP-1-1-2">·</a></h4><p><strong>http1.1是目前最为主流的http协议版本</strong>，从1999年发布至今，仍是主流的http协议版本。</p><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li><li>引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率</li><li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效</li><li>支持断点续传，通过使用请求头中的 <code>Range</code> 来实现</li><li>使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE</li></ul><h4 id="3-2、总结1-0与1-1区别-2">3.2、总结1.0与1.1区别<a class="anchor" href="#3-2、总结1-0与1-1区别-2">·</a></h4><ul><li><p><strong>连接方面</strong></p><p>http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延</p></li><li><p><strong>资源请求方面</strong></p><p>在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</p></li><li><p><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p></li><li><p>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</p></li><li><p>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</p></li></ul><h4 id="4、http1-x版本问题-2">4、http1.x版本问题<a class="anchor" href="#4、http1-x版本问题-2">·</a></h4><ul><li><h4 id="安全：-2">安全：<a class="anchor" href="#安全：-2">·</a></h4><p>在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性</p></li><li><h4 id="队头阻塞：-2">队头阻塞：<a class="anchor" href="#队头阻塞：-2">·</a></h4><p>HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞</p></li><li><h4 id="Keep-alive性能问题-2">Keep-alive性能问题<a class="anchor" href="#Keep-alive性能问题-2">·</a></h4><p>http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间</p></li></ul><h4 id="5、HTTP-2-0-2">5、HTTP 2.0<a class="anchor" href="#5、HTTP-2-0-2">·</a></h4><h5 id="1、二进制分帧-2">1、<code>二进制分帧</code><a class="anchor" href="#1、二进制分帧-2">·</a></h5><ul><li>这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;：头信息帧和数据帧。</li><li>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li></ul><h5 id="2、头部压缩-2">2、<code>头部压缩</code><a class="anchor" href="#2、头部压缩-2">·</a></h5><ul><li>HTTP 1.1版本会出现 <strong>「User-Agent、Cookie、Accept、Server、Range」</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。</li><li>HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li></ul><h5 id="3、多路复用-2">3、<code>多路复用</code><a class="anchor" href="#3、多路复用-2">·</a></h5><ul><li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</li></ul><h5 id="4、服务器推送-2">4、<code>服务器推送</code><a class="anchor" href="#4、服务器推送-2">·</a></h5><ul><li>允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li></ul><h5 id="5、请求优先级-2">5、<code>请求优先级</code><a class="anchor" href="#5、请求优先级-2">·</a></h5><ul><li>可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验</li></ul><h4 id="6、3-0-QUIC-协议-2">6、3.0  QUIC 协议<a class="anchor" href="#6、3-0-QUIC-协议-2">·</a></h4><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a0a2ec0ef143b49d79256cea543418~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:25%;" /><h5 id="1-特点：-2">1. 特点：<a class="anchor" href="#1-特点：-2">·</a></h5><ul><li>HTTP/3 是基于 UDP 实现的，实现了类似于 TCP 的多路数据流、传输可靠性等功能，称为 QUIC 协议<ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li><li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li><li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li><li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li></ul></li></ul><h5 id="2-HTTP-3-的挑战-2">2. HTTP/3 的挑战<a class="anchor" href="#2-HTTP-3-的挑战-2">·</a></h5><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ul><h3 id="4、对HTTP-2理解-2">4、对HTTP/2理解<a class="anchor" href="#4、对HTTP-2理解-2">·</a></h3><h4 id="1、头部压缩-2">1、头部压缩<a class="anchor" href="#1、头部压缩-2">·</a></h4><ul><li><p>由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。</p><ul><li><p>所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p></li><li><p><strong>「User-Agent、Cookie、Accept、Server、Range」</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重</p></li></ul></li><li><p>HTTP/2 实现了头信息压缩，引入了头信息压缩机制。</p><ul><li>一方面，头信息使用 gzip 或 compress 压缩后再发送；</li><li>另一方面，客户端和服务器同时维护一张头信息表<code>HPACK</code> 算法，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了</li></ul></li><li><h4 id="HPACK-算法：-传索引-2"><code>HPACK</code> 算法：  传索引<a class="anchor" href="#HPACK-算法：-传索引-2">·</a></h4><ul><li>类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引</li><li>对于之前出现过的头部信息，只需要把**「索引」**(比如1，2，…)传给对方，对方拿到索引查表就行了</li></ul></li></ul><img src="https://user-images.githubusercontent.com/34484322/89356545-a3fd4100-d6f0-11ea-8e0a-8870d832e96e.png" alt="img" style="zoom: 33%;" /><ul><li><h4 id="好处：-2">好处：<a class="anchor" href="#好处：-2">·</a></h4><ol><li><p>这种**「传索引」**的方式，可以说让请求头字段得到极大程度的精简和复用</p></li><li><p>其次是对于整数和字符串进行**「哈夫曼编码」**</p><p>哈夫曼编码的原理就是先将所有出现的字符建立一张索引表</p><p>然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的**「索引序列」**，可以达到非常高的压缩率</p></li></ol></li></ul><h4 id="2、多路复用-2">2、多路复用<a class="anchor" href="#2、多路复用-2">·</a></h4><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p><h5 id="HTTP2中：-2">HTTP2中：<a class="anchor" href="#HTTP2中：-2">·</a></h5><ul><li><p>同域名下所有通信都在单个连接上完成。</p></li><li><p>单个连接可以承载任意数量的双向数据流。</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是<code>Stream ID</code>，流标识符</p><p>有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。</p></li><li><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了**“队头堵塞”**的问题。</p></li></ul><h4 id="3、服务器推送-2">3、服务器推送<a class="anchor" href="#3、服务器推送-2">·</a></h4><ul><li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送，这样就可以相对减少一些延迟时间</li><li>需要注意的是 http2 下服务器主动推送的是<strong>静态资源</strong>，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><h5 id="相比较http-1-1的优势👇-2">相比较http/1.1的优势👇<a class="anchor" href="#相比较http-1-1的优势👇-2">·</a></h5><ul><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li></ul><h4 id="4、二进制分帧与数据流-2">4、二进制分帧与数据流<a class="anchor" href="#4、二进制分帧与数据流-2">·</a></h4><h5 id="二进制帧：-2">二进制帧：<a class="anchor" href="#二进制帧：-2">·</a></h5><ul><li><p>在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。</p></li><li><p>HTTP/2 则是一个彻底的二进制协议，一个报文格式就被拆分为一个个二进制帧，帧的概念是它实现多路复用的基础。</p><ul><li><p>用**「Headers帧」<strong>存放头部字段，</strong>「Data帧」**存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了HTTP队头阻塞问题</p></li><li><p>HTTP/2采用二进制格式，全部传输01串，便于机器解码</p><p>明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低</p></li></ul></li></ul><h5 id="数据流：-2">数据流：<a class="anchor" href="#数据流：-2">·</a></h5><ul><li>在客户端与服务器之间，双方都可以互相发送二进制帧，这样子**「双向传输的序列」<strong>，称为<code>流</code>，所以HTTP/2中以</strong>流<strong>来</strong>表示一个TCP连接上进行多个数据帧的通信**，这就是<strong>多路复用</strong>概念</li><li>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。<ul><li>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流；</li><li>每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li></ul></li></ul><h5 id="那乱序的二进制帧，是如何组装成对于的报文呢？-2">那乱序的二进制帧，是如何组装成对于的报文呢？<a class="anchor" href="#那乱序的二进制帧，是如何组装成对于的报文呢？-2">·</a></h5><ul><li>乱序，指的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的</li><li>接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文</li><li>二进制帧中有一些字段，控制着<code>优先级</code>和<code>流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验</li></ul><h5 id="队头阻塞-2">队头阻塞<a class="anchor" href="#队头阻塞-2">·</a></h5><ul><li>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的；</li><li>HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。</li><li>队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理；</li><li>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</li></ul><h3 id="5、keep-alive-2">5、keep-alive<a class="anchor" href="#5、keep-alive-2">·</a></h3><h4 id="1、什么是keep-alive-2">1、什么是keep-alive<a class="anchor" href="#1、什么是keep-alive-2">·</a></h4><ul><li><h4 id="普通模式：-2">普通模式：<a class="anchor" href="#普通模式：-2">·</a></h4><p>HTTP协议采用“请求-应答”模式，当使用普通模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接，这就是<strong>短连接</strong>。（HTTP协议为无连接的协议）</p></li><li><h4 id="Keep-Alive模式：-2">Keep-Alive模式：<a class="anchor" href="#Keep-Alive模式：-2">·</a></h4><p>当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 ，这就是<strong>长连接</strong>。</p></li></ul><h4 id="2、为什么要使用keep-alive-2">2、为什么要使用keep-alive<a class="anchor" href="#2、为什么要使用keep-alive-2">·</a></h4><ul><li>**创建目的：**能在多次HTTP之前重用同一个TCP连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）</li></ul><img src="https://user-images.githubusercontent.com/34484322/89356849-64832480-d6f1-11ea-8f53-5372f8c30f39.png" alt="img" style="zoom:50%;" /><ul><li>优点：<ul><li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li><li>允许请求和应答的HTTP管线化；</li><li>降低拥塞控制 （TCP连接减少了）；</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li><li>报告错误⽆需关闭TCP连；</li></ul></li><li>缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li></ul><h4 id="3、客户端如何开启-2">3、客户端如何开启<a class="anchor" href="#3、客户端如何开启-2">·</a></h4><p>Keep-Alive的<strong>建立过程</strong>：</p><ul><li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li><li>服务器收到请求并处理 Connection字段</li><li>服务器回送Connection:Keep-Alive字段给客户端</li><li>客户端接收到Connection字段</li><li>Keep-Alive连接建立成功</li></ul><p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p><ul><li>客户端向服务器只是发送内容报文（不包含Connection字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有Connection字段，断开连接</li></ul><p><strong>客户端请求断开连接过程</strong>：</p><ul><li>客户端向服务器发送Connection:close字段</li><li>服务器收到请求并处理connection字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接</li></ul><h3 id="6、请求方法get-post-2">6、请求方法get/post<a class="anchor" href="#6、请求方法get-post-2">·</a></h3><h4 id="1、HTTP请求方法-2">1、HTTP请求方法<a class="anchor" href="#1、HTTP请求方法-2">·</a></h4><ul><li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</li><li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li></ul><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li><p>GET：                请求获取Request-URI所标识的资源</p></li><li><p>POST：              在Request-URI所标识的资源后附加新的数据</p></li><li><p>HEAD：             请求获取由Request-URI所标识的资源的响应消息报头，没有响应体</p></li><li><p>PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）</p><ul><li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等</li><li>也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li></ul></li><li><p>OPTIONS：       用于请求获得由<code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项</p><ul><li>通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</li></ul><p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p><ul><li><p>获取服务器对该资源支持的所有HTTP请求方法；</p><p>该方法会用’*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。</p></li><li><p>用来检查访问权限。例如：JS 的 XMLHttpRequest对象在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</p></li></ul></li><li><p>DELETE：          请求服务器删除对应所标识的资源</p></li><li><p>TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断</p></li><li><p>CONNECT：      建立连接隧道，用于代理服务器</p></li></ul><h4 id="2、谈一谈GET-和-POST-的区别-2">2、谈一谈GET 和 POST 的区别<a class="anchor" href="#2、谈一谈GET-和-POST-的区别-2">·</a></h4><p>本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。</p><p>从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册</p><p>想装逼请参考 https://zhuanlan.zhihu.com/p/22536382</p><h5 id="1、缓存角度-2">1、缓存角度<a class="anchor" href="#1、缓存角度-2">·</a></h5><ul><li>GET 请求后浏览器会主动缓存，POST 默认情况下不能</li></ul><h5 id="2、参数角度-2">2、参数角度<a class="anchor" href="#2、参数角度-2">·</a></h5><ul><li>GET请求一般放在URL中，因此不太安全，因为请求的 url 会被保留在历史记录中</li><li>POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的</li></ul><h5 id="3、编码角度-2">3、编码角度<a class="anchor" href="#3、编码角度-2">·</a></h5><ul><li>GET请求只能进行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。</li></ul><h5 id="3-2、请求长度：-2">3.2、请求长度：<a class="anchor" href="#3-2、请求长度：-2">·</a></h5><ul><li><p>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</p><p><strong>为什么会限制长度？</strong></p><ul><li>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。</li><li>get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span>的长度值 = <span class="variable constant_">URL</span>（<span class="number">2083</span>）- （你的<span class="title class_">Domain</span>+<span class="title class_">Path</span>）-<span class="number">2</span>（<span class="number">2</span>是get请求中?=两个字符的长度）</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、请求幂等-2">4、请求幂等<a class="anchor" href="#4、请求幂等-2">·</a></h5><ul><li>GET请求幂等</li><li>POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致</li></ul><h5 id="5、请求时-2">5、请求时<a class="anchor" href="#5、请求时-2">·</a></h5><ul><li>GET请求会一次性发送请求报文</li><li>POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分</li></ul><h4 id="3、POST与PUT的区别-2">3、POST与PUT的区别<a class="anchor" href="#3、POST与PUT的区别-2">·</a></h4><ul><li>PUT不会产生新数据，只是覆盖老数据，是幂等的</li><li>POST请求一次就产生一个新数据，是非幂等的</li></ul><h3 id="请求头、响应头">请求头、响应头<a class="anchor" href="#请求头、响应头">·</a></h3><h4 id="HTTP-Request-Header-常见的请求头：-2"><strong>HTTP Request Header 常见的请求头：</strong><a class="anchor" href="#HTTP-Request-Header-常见的请求头：-2">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Accept:浏览器能够处理的内容类型</span><br><span class="line">* Accept-Charset:浏览器能够显示的字符集</span><br><span class="line">* Accept-Encoding：浏览器能够处理的压缩编码</span><br><span class="line">* Accept-Language：浏览器当前设置的语言</span><br><span class="line">* Connection：浏览器与服务器之间连接的类型</span><br><span class="line">* Cookie：当前页面设置的任何Cookie</span><br><span class="line">* Host：发出请求的页面所在的域</span><br><span class="line">* Referer：发出请求的页面的URL</span><br><span class="line">* User-Agent：浏览器的用户代理字符串</span><br></pre></td></tr></table></figure><h4 id="响应头：-2">响应头：<a class="anchor" href="#响应头：-2">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP Responses Header 常见的响应头：</span><br><span class="line"></span><br><span class="line">Date：表示消息发送的时间，时间的描述格式由rfc822定义</span><br><span class="line">server:服务器名称</span><br><span class="line">Connection：浏览器与服务器之间连接的类型</span><br><span class="line">Cache-Control：控制HTTP缓存</span><br><span class="line">content-type:表示后面的文档属于什么MIME类型</span><br></pre></td></tr></table></figure><h4 id="常见的-Content-Type-属性值有四种：-2">常见的 Content-Type 属性值有四种：<a class="anchor" href="#常见的-Content-Type-属性值有四种：-2">·</a></h4><p>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><p>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。</p><p>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p><h3 id="7、对URL组成-2">7、对URL组成<a class="anchor" href="#7、对URL组成-2">·</a></h3><h4 id="1、URL与URI-3">1、URL与URI<a class="anchor" href="#1、URL与URI-3">·</a></h4><ul><li><p>URI：统一资源标识符</p><p>父类        表示请求服务器资源，定位这个资源</p></li><li><p>URL：统一资源定位符，常常被称为网址，是因特网上标准的资源地址</p><p>子类       而URL还要表示如何访问这个资源</p><p>通用的格式：scheme://host[:port]/path/…/?query#anchor</p></li></ul><h4 id="2、组成格式：-3">2、组成格式：<a class="anchor" href="#2、组成格式：-3">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.aspxfans.com:8080/news/index.…</span><br></pre></td></tr></table></figure><ul><li><p>**协议：**访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等后面一定接上://</p></li><li><p>**域名：**该URL的域名部分为“www.aspxfans.com”</p></li><li><p>**port：**跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。</p><ul><li>端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li></ul></li><li><p>（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</p></li><li><p><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</p></li><li><p><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分</p><ul><li>如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分</li><li>如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。</li><li>本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li></ul></li><li><p><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例的锚部分是“name”。锚部分也不是一个URL必须的部分；</p></li><li><p><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。</p><p>本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ul><h4 id="3、URL-编码-3">3、URL 编码<a class="anchor" href="#3、URL-编码-3">·</a></h4><ul><li>URL 只能使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3school.com.cn%2Ftags%2Fhtml_ref_ascii.asp">ASCII 字符集</a>来通过因特网进行发送。</li><li>由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</li><li>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</li><li>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">天天`转换为有效的ASCII格式就是`%CC%EC%CC%EC</span><br></pre></td></tr></table></figure><h3 id="8、队头阻塞问题-2">8、队头阻塞问题<a class="anchor" href="#8、队头阻塞问题-2">·</a></h3><h4 id="1、什么是队头阻塞？-2">1、什么是队头阻塞？<a class="anchor" href="#1、什么是队头阻塞？-2">·</a></h4><ul><li>对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的</li><li>一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<code>HTTP队头阻塞</code>问题</li></ul><h4 id="2、解决1：并发连接-2">2、解决1：并发连接<a class="anchor" href="#2、解决1：并发连接-2">·</a></h4><ul><li>我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务</li><li>在<code>RFC规范</code>中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。</li></ul><h4 id="3、解决2：域名分片-2">3、解决2：域名分片<a class="anchor" href="#3、解决2：域名分片-2">·</a></h4><ul><li>可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器</li><li>就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题</li></ul><p>比如<code>TianTian.com</code>，可以分出很多二级域名，比如<code>Day1.TianTian.com</code>，<code>Day2.TianTian.com</code>,<code>Day3.TianTian.com</code>,这样子就可以有效解决队头阻塞问题</p><h3 id="9、谈一谈HTTP数据传输-2">9、谈一谈HTTP数据传输<a class="anchor" href="#9、谈一谈HTTP数据传输-2">·</a></h3><p>大概遇到的情况就分为**「定长数据」** 与 **「不定长数据」**的处理吧。</p><h4 id="1、定长数据-2">1、定长数据<a class="anchor" href="#1、定长数据-2">·</a></h4><ul><li>发送端在发送数据的过程中，需要设置<code>Content-Length</code>,来指明发送数据的长度。如果采用了Gzip压缩的话，Content-Length设置的就是压缩后的传输长度</li></ul><p>【注意】：</p><ul><li>Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。</li><li>如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。</li><li>那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。</li><li>在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于<code>Content-Length</code>,若是非Keep-alive，跟前面情况一样，Content-Length可有可无</li></ul><h4 id="2、不定长数据-2">2、不定长数据<a class="anchor" href="#2、不定长数据-2">·</a></h4><p>现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>通过chunked机制，可以完成对不定长数据的处理，当然了，你需要知道的是</p><ul><li>如果头部信息中有<code>Transfer-Encoding</code>,优先采用Transfer-Encoding里面的方法来找到对应的长度。</li><li>如果设置了Transfer-Encoding，那么Content-Length将被忽视。</li><li>使用长连接的话，会持续的推送动态内容。</li></ul><p>那我们来模拟一下吧👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const server = require(&#x27;http&#x27;).createServer();</span><br><span class="line">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  if(req.url === &#x27;/index&#x27;) &#123;</span><br><span class="line">   // 设置数据类型</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);</span><br><span class="line">    res.setHeader(&#x27;Content-Length&#x27;, 10);</span><br><span class="line">    res.setHeader(&#x27;Transfer-Encoding&#x27;, &#x27;chunked&#x27;);</span><br><span class="line">    </span><br><span class="line">    res.write(&quot;你好，使用的是Transfer-Encoding设置传输数据形式&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输数据给您&lt;br/&gt;&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    res.write(&quot;骚等一下&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输数据给您&quot;);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;成功启动--TinaTian&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的进程、线程</title>
      <link href="/posts/1168384896.html"/>
      <url>/posts/1168384896.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、进程与线程">1、进程与线程<a class="anchor" href="#1、进程与线程">·</a></h3><h4 id="1、什么是进程">1、什么是进程<a class="anchor" href="#1、什么是进程">·</a></h4><ul><li><code>CPU</code>是计算机的核心，承担所有的计算任务，<code>CPU</code> 可以有很多进程，<code>进程</code>是<code>CPU</code>资源分配的最小单位</li><li><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源<ul><li>我们的电脑每打开一个软件就会产生一个或多个 <code>进程</code> ，为什么电脑运行的软件多就会卡，是因为 <code>CPU</code> 给每个 <code>进程</code> 分配资源空间，但是一个 <code>CPU</code> 一共就那么多资源，分出去越多，越卡</li><li>每个<code>进程</code>之间是相互独立的， <code>CPU</code> 在运行一个 <code>进程</code> 时，其他的进程处于非运行状态，<code>CPU</code> 使用 <a href="https://link.juejin.cn?target=undefined">时间片轮转调度算法</a> 来实现同时运行多个进程</li></ul></li></ul><h4 id="2、什么是线程">2、什么是线程<a class="anchor" href="#2、什么是线程">·</a></h4><ul><li><p><code>线程</code> 是 <code>CPU</code> 调度的最小单位</p></li><li><p>线程 是建立在 <code>进程</code> 的基础上的一次程序运行单位，通俗点解释 <code>线程</code> 就是程序中的一个执行流，一个 <code>进程</code> 可以有多个 <code>线程</code></p></li><li><p>一个 <code>进程</code> 中只有一个执行流称作 <code>单线程</code> ，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行</p></li><li><p>一个 <code>进程</code> 中有多个执行流称作 <code>多线程</code>，即在一个程序中可以同时运行多个不同的 <code>线程</code> 来执行不同的任务， 也就是说允许单个程序创建多个并行执行的 <code>线程</code> 来完成各自的任务</p></li></ul><h4 id="3、进程和线程的区别">3、进程和线程的区别<a class="anchor" href="#3、进程和线程的区别">·</a></h4><ol><li><p>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位</p></li><li><p>一个 <code>进程</code> 由一个或多个 <code>线程</code> 组成，<code>线程</code> 可以理解为是一个进程中代码的不同执行路线</p></li><li><p><code>进程</code> 之间相互独立，但同一进程下的各个 <code>线程</code> 间共享程序的内存空间 (包括代码段、数据集、堆等) 及一些进程级的资源 (如打开文件和信号)</p></li><li><p>调度和切换：线程上下文切换比进程上下文切换要快得多</p></li></ol><h4 id="4、多进程和多线程">4、多进程和多线程<a class="anchor" href="#4、多进程和多线程">·</a></h4><ul><li><h4 id="多进程：">多进程：<a class="anchor" href="#多进程：">·</a></h4><ul><li><p>同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态</p></li><li><p>多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰</p></li></ul></li><li><h4 id="多线程：">多线程：<a class="anchor" href="#多线程：">·</a></h4><ul><li><p>指程序中包含多个执行流</p></li><li><p>即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</p></li></ul></li></ul><h3 id="2、JS为什么是单线程">2、JS为什么是单线程<a class="anchor" href="#2、JS为什么是单线程">·</a></h3><h4 id="1、与它的用途有关：">1、与它的用途有关：<a class="anchor" href="#1、与它的用途有关：">·</a></h4><ul><li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题</li><li>假定 <code>JS</code> 同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</li></ul><h4 id="2、-js-还有-Worker-线程">2、 <code>js</code> 还有 <code>Worker</code> 线程<a class="anchor" href="#2、-js-还有-Worker-线程">·</a></h4><ul><li>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许 <code>JavaScript</code> 脚本创建多个线程</li><li>但是子线程是完全受主线程控制的，而且不得操作DOM</li><li>所以，这个标准并没有改变JavaScript是单线程的本质</li></ul><h3 id="3、浏览器是多进程的">3、浏览器是多进程的<a class="anchor" href="#3、浏览器是多进程的">·</a></h3><h4 id="1、浏览器包含哪些进程">1、浏览器包含哪些进程<a class="anchor" href="#1、浏览器包含哪些进程">·</a></h4><h5 id="1、Browser进程">1、Browser进程<a class="anchor" href="#1、Browser进程">·</a></h5><ul><li>浏览器的主进程(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul><h5 id="2、第三方插件进程">2、第三方插件进程<a class="anchor" href="#2、第三方插件进程">·</a></h5><ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul><h5 id="3、GPU进程">3、GPU进程<a class="anchor" href="#3、GPU进程">·</a></h5><ul><li>该进程也只有一个，用于3D/动画绘制等等</li></ul><h5 id="4、渲染进程-重">4、渲染进程(重)<a class="anchor" href="#4、渲染进程-重">·</a></h5><ul><li>即通常所说的浏览器内核(Renderer进程，内部是多线程)</li><li>每个Tab页面都有一个渲染进程，互不影响</li><li>主要作用为页面渲染，脚本执行，事件处理等</li></ul><h4 id="2、为什么浏览器要多进程">2、为什么浏览器要多进程<a class="anchor" href="#2、为什么浏览器要多进程">·</a></h4><ul><li>避免单个page崩溃影响整个浏览器</li><li>避免第三方插件崩溃影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li><li>浏览器进程有很多，每个进程又有很多线程，都会占用内存,内存等资源消耗会很大，有点拿空间换时间的意思</li></ul><h3 id="4、渲染进程">4、渲染进程<a class="anchor" href="#4、渲染进程">·</a></h3><p>渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程</p><h4 id="1、GUI渲染线程">1、GUI渲染线程<a class="anchor" href="#1、GUI渲染线程">·</a></h4><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等<ul><li>解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree</li><li>解析css，生成CSSOM(CSS规则树)</li><li>把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)</li></ul></li><li>当修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)</li><li>当修改元素的尺寸，页面就会回流(Reflow)</li><li>当页面需要Repaing和Reflow时<strong>GUI线程执行</strong>，绘制页面</li><li>回流比重绘的成本要高，要尽量避免Reflow和Repaint</li><li><strong>GUI渲染线程与JS引擎线程是互斥的</strong><ul><li>当JS引擎执行时GUI线程会被挂起(相当于被冻结了)</li><li>GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</li></ul></li></ul><h4 id="2、JS引擎线程">2、JS引擎线程<a class="anchor" href="#2、JS引擎线程">·</a></h4><ul><li>JS引擎线程就是JS内核，负责(例如V8引擎)解析Javascript脚本，运行代码</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的</li><li>一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序</li></ul></li><li><strong>GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程</strong><ul><li>就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)   结合React15、16的变迁</li><li>例如浏览器渲染的时候遇到<code>script</code>标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容</li><li>所以如果js执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h4 id="3、事件触发线程">3、事件触发线程<a class="anchor" href="#3、事件触发线程">·</a></h4><ul><li>属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)</li><li>当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理</li></ul><h4 id="4、定时触发器线程">4、定时触发器线程<a class="anchor" href="#4、定时触发器线程">·</a></h4><p><code>setInterval</code> 与 <code>setTimeout</code> 所在线程：</p><ol><li>浏览器定时计数器并不是由JS引擎计数的 (因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li>通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms</li></ol><h4 id="5、异步http请求线程">5、异步http请求线程<a class="anchor" href="#5、异步http请求线程">·</a></h4><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行</li><li>简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应 (准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行</li></ul><h3 id="5、Browser进程、渲染进程的通信">5、Browser进程、渲染进程的通信<a class="anchor" href="#5、Browser进程、渲染进程的通信">·</a></h3><ul><li><p>打开任务管理器，然后打开一个浏览器，就可以看到：<strong>任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）</strong></p><img src="https://segmentfault.com/img/remote/1460000012925881" alt="img" style="zoom:50%;" /></li><li><p>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</p></li><li><p>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</p><ul><li><p>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</p></li><li><p>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</p></li><li><p>最后Render进程将结果传递给Browser进程</p></li><li><p>Browser进程接收到结果并将结果绘制出来</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.2-浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/posts/1634682499.html"/>
      <url>/posts/1634682499.html</url>
      
        <content type="html"><![CDATA[<h2 id="前端性能优化">前端性能优化<a class="anchor" href="#前端性能优化">·</a></h2><p><a href="https://juejin.cn/post/6981673766178783262#heading-13">写给中高级前端关于性能优化的9大策略和6大指标 | 网易四年实践 - 掘金 (juejin.cn)</a></p><h3 id="1、九大策略">1、九大策略<a class="anchor" href="#1、九大策略">·</a></h3><h4 id="1、网络层面">1、网络层面<a class="anchor" href="#1、网络层面">·</a></h4><p><strong>网络层面</strong>的性能优化，无疑是如何让资源<code>体积更小加载更快</code>，四方面：</p><ul><li><p><strong>构建策略</strong>：基于构建工具(<code>Webpack/Rollup/Parcel/Esbuild/Vite/Gulp</code>)</p><p>围绕<code>webpack</code>的<code>性能优化</code>，从<code>时间层面</code>和<code>体积层面</code></p><ul><li><strong>减少打包时间</strong>：<code>缩减范围</code>、<code>缓存副本</code>、<code>定向搜索</code>、<code>提前构建</code>、<code>并行构建</code>、<code>可视结构</code></li><li><strong>减少打包体积</strong>：<code>分割代码</code>、<code>摇树优化</code>、<code>动态垫片</code>、<code>按需加载</code>、<code>作用提升</code>、<code>压缩资源</code></li></ul></li><li><p><strong>图像策略</strong>：基于图像类型(<code>JPG/PNG/SVG/WebP/Base64</code>)</p><ul><li><strong>图像选型</strong>：了解所有图像类型的特点及其何种应用场景最合适</li><li><strong>图像压缩</strong>：在部署到生产环境前使用工具或脚本对其压缩处理</li></ul></li><li><p><strong>分发策略</strong>：基于内容分发网络(<code>CDN</code>)</p><ul><li><strong>所有静态资源走CDN</strong>：开发阶段确定哪些文件属于静态资源</li><li><strong>把静态资源与主页面置于不同域名下</strong>：避免请求带上<code>Cookie</code></li></ul></li><li><p><strong>缓存策略</strong>：基于浏览器缓存(<code>强缓存/协商缓存</code>)</p><ul><li><strong>考虑拒绝一切缓存策略</strong>：<code>Cache-Control:no-store</code></li><li><strong>考虑资源是否每次向服务器请求</strong>：<code>Cache-Control:no-cache</code></li><li><strong>考虑资源是否被代理服务器缓存</strong>：<code>Cache-Control:public/private</code></li><li><strong>考虑资源过期时间</strong>：<code>Expires:t/Cache-Control:max-age=t,s-maxage=t</code></li><li><strong>考虑协商缓存</strong>：<code>Last-Modified/Etag</code></li></ul></li></ul><h4 id="2、渲染层面">2、渲染层面<a class="anchor" href="#2、渲染层面">·</a></h4><p><strong>渲染层面</strong>的性能优化，无疑是如何让代码<code>解析更好执行更快</code>。因此笔者从以下五方面做出建议。</p><ul><li><strong>CSS策略</strong>：基于CSS规则<ul><li>避免出现超过三层的<code>嵌套规则</code></li><li>避免为<code>ID选择器</code>添加多余选择器</li><li>避免使用<code>标签选择器</code>代替<code>类选择器</code></li><li>避免使用<code>通配选择器</code>，只对目标节点声明规则</li><li>避免重复匹配重复定义，关注<code>可继承属性</code></li></ul></li><li><strong>DOM策略</strong>：基于DOM操作<ul><li>缓存<code>DOM计算属性</code></li><li>避免过多<code>DOM操作</code></li><li>使用<code>DOMFragment</code>缓存批量化<code>DOM操作</code></li></ul></li><li><strong>阻塞策略</strong>：基于脚本加载<ul><li>脚本与<code>DOM/其它脚本</code>的依赖关系很强：对设置<code>defer</code></li><li>脚本与<code>DOM/其它脚本</code>的依赖关系不强：对设置<code>async</code></li></ul></li><li><strong>回流重绘策略</strong>：基于回流重绘<ul><li>缓存<code>DOM计算属性</code></li><li>使用类合并样式，避免逐条改变样式</li><li>使用<code>display</code>控制<code>DOM显隐</code>，将<code>DOM离线化</code></li></ul></li><li><strong>异步更新策略</strong>：基于异步更新<ul><li>在<code>异步任务</code>中修改<code>DOM</code>时把其包装成<code>微任务</code></li></ul></li></ul><h3 id="2、六大指标">2、六大指标<a class="anchor" href="#2、六大指标">·</a></h3><p><code>六大指标</code>基本囊括大部分<code>性能优化</code>细节，可作为<code>九大策略</code>的补充。分为以下六方面</p><h4 id="1、-加载优化：资源在加载时可做的性能优化">1、 <strong>加载优化</strong>：资源在加载时可做的性能优化<a class="anchor" href="#1、-加载优化：资源在加载时可做的性能优化">·</a></h4><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a890d76ed4a748b1b745e85dde126989~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-加载优化.png" style="zoom: 33%;" /><h4 id="2、执行优化：资源在执行时可做的性能优化">2、<strong>执行优化</strong>：资源在执行时可做的性能优化<a class="anchor" href="#2、执行优化：资源在执行时可做的性能优化">·</a></h4><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5898aa8a121b40e896c457d9e95ac6f6~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-执行优化.png" style="zoom:33%;" /><h4 id="3、渲染优化：资源在渲染时可做的性能优化">3、渲染优化：资源在渲染时可做的性能优化<a class="anchor" href="#3、渲染优化：资源在渲染时可做的性能优化">·</a></h4><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57664767785349ca8d00c712de02989d~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-渲染优化.png" style="zoom:33%;" /><h4 id="4、样式优化：样式在编码时可做的性能优化">4、<strong>样式优化</strong>：样式在编码时可做的性能优化<a class="anchor" href="#4、样式优化：样式在编码时可做的性能优化">·</a></h4><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/589007e1d9c144629803dc242b69861e~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-样式优化.png" style="zoom:33%;" /><h4 id="5、脚本优化：脚本在编码时可做的性能优化">5、<strong>脚本优化</strong>：脚本在编码时可做的性能优化<a class="anchor" href="#5、脚本优化：脚本在编码时可做的性能优化">·</a></h4><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a2c1427695424e8a274ee747950bee~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-脚本优化.png" style="zoom:50%;" /><h4 id="6、V8引擎优化：针对V8引擎特征可做的性能优化">6、<strong>V8引擎优化</strong>：针对<code>V8引擎</code>特征可做的性能优化<a class="anchor" href="#6、V8引擎优化：针对V8引擎特征可做的性能优化">·</a></h4><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae8786a5bac5483f9589b0494604705b~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-V8引擎优化.png" style="zoom:33%;" /><h2 id="补充CDN">补充CDN<a class="anchor" href="#补充CDN">·</a></h2><h3 id="1-概念-2">1. 概念<a class="anchor" href="#1-概念-2">·</a></h3><ul><li>CDN 是 内容分发网络，本质利用缓存技术，将数据快速可靠从源站传递给用户。用户获取数据，不需要直接从源站获取，而是通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。</li><li><strong>优势：</strong><ul><li><strong>CDN可以加速用户访问速度，减少源站中心负载压力</strong>。如果网络上的数据都使用从源站直接交付到用户的方法，那么极有可能会出现访问拥塞的情况</li><li>CDN是将数据缓存在离用户最近的地方，使用户以最快的速度获取，对于减少网站的出口带宽压力，减少网络传输的拥堵情况</li></ul></li></ul><h3 id="2-CDN的原理">2. CDN的原理<a class="anchor" href="#2-CDN的原理">·</a></h3><p>用户在通过浏览器访问数据时</p><ul><li><p>未使用CDN加速网站的大致过程：</p><img src="https://img-blog.csdnimg.cn/20201104183734785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTY4NDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 50%;" /><p>①用户在浏览器中输入要访问的域名。②浏览器向DNS服务器请求对该域名的解析。③DNS服务器返回该域名的IP地址给浏览器。④浏览器使用该IP地址向服务器请求内容。⑤服务器将用户请求的内容返回给浏览器。</p></li><li><p>使用了CDN:</p><img src="https://img-blog.csdnimg.cn/20201104184159165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTY4NDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 50%;" /><p>①用户在浏览器中输入要访问的域名。②浏览器向DNS服务器请求对域名进行解析。而DNS服务器将域名的解析权交给 CDN专用DNS服务器③CDN专用DNS服务器 将CDN负载均衡设备的IP地址返回给用户。④用户向 CDN负载均衡设备 发起内容URL访问请求。</p><ul><li><p>CDN负载均衡设备会为用户选择一台合适的 CDN缓存服务器 提供服务，选择的依据包括：</p><ul><li>根据用户IP地址，判断哪一台服务器距离用户最近；</li><li>根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；</li><li>查询各个服务器的负载情况，判断哪一台服务器的负载较小。</li></ul><p>基于以上这些依据的综合分析之后，负载均衡设置会把缓存服务器的IP地址返回给用户。</p></li></ul><p>⑤负载均衡设置会把缓存服务器的IP地址返回给用户</p><p>⑥用户向缓存服务器发出请求。⑦缓存服务器响应用户请求，将用户所需内容传送到用户。</p><ul><li>如果这台缓存服务器上并没有用户想要的内容，而负载均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉取到本地</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.2-基建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的DOM+BOM</title>
      <link href="/posts/2292260110.html"/>
      <url>/posts/2292260110.html</url>
      
        <content type="html"><![CDATA[<h2 id="DOM-3">DOM<a class="anchor" href="#DOM-3">·</a></h2><h3 id="1、DOM概念、组成">1、DOM概念、组成<a class="anchor" href="#1、DOM概念、组成">·</a></h3><h4 id="1、概念-5">1、概念<a class="anchor" href="#1、概念-5">·</a></h4><ul><li>文档对象模型，是W3C的标准，该标准中，定义了页面的结构、表现、行为；DOM是独于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式</li><li>它是针对xml经过扩展用于html的应用程序编程接口，我们又叫API；</li><li>DOM把整个页面映射为一个多层的节点结构，html或xml页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据</li></ul><h4 id="2、为什么操作DOM昂贵">2、为什么操作DOM昂贵<a class="anchor" href="#2、为什么操作DOM昂贵">·</a></h4><ul><li><p>ES和 DOM是两种东西，每次连接都需要消耗性能：</p><p>浏览器中通常把二者独立实现，使得<strong>二者相互独立</strong>，<strong>JS与DOM每次连接都需要消耗性能</strong></p><p>所以有了<strong>每操作一次DOM就多做点事</strong>的理念，尽可能以最少的次数处理最多的DOM操作</p></li><li><p>而修改DOM更昂贵，因为首先得访问Dom</p><p>操作DOM会导致重排和重绘，重排会占用、消耗<strong>CPU</strong>; 重绘会占用、消耗<strong>GPU</strong></p></li></ul><h4 id="3-智能“节流”操作DOM">3. 智能“节流”操作DOM<a class="anchor" href="#3-智能“节流”操作DOM">·</a></h4><ul><li><p>实现队列化修改，批量执行：</p><ul><li>浏览器会有一个“队列”，用以存放（攒着）需要操作DOM的js程序。每当执行一次js操作dom的代码，这个队列里就先暂存一个程序。</li><li>等到一段时间后，浏览器再集中、批量的链接一次&quot;ES岛&quot;和&quot;DOM岛&quot;（就是让JS引擎去链接渲染引擎），进而触发一次DOM操作。“过一段时间发一班车”</li></ul></li><li><p>但我们如果误操作打断浏览器的“节流”步骤。迫使浏览器中断当前的“等待”，去赶紧、立马进行一次dom操作。让浏览器赶紧执行完他攒在“队列”里的JS操作DOM的程序后返回最新的DOM位置信息给我们</p></li><li><p><strong>减少在循环内进行DOM操作，在循环外部进行DOM缓存</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化前代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;loop1&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; <span class="number">15000</span>; count++) &#123;</span><br><span class="line">       <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;text&#x27;</span>).<span class="property">innerHTML</span> += <span class="string">&#x27;dom&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;loop1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Loop2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;loop2&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; <span class="number">15000</span>; count++) &#123;</span><br><span class="line">        content += <span class="string">&#x27;dom&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;text2&#x27;</span>).<span class="property">innerHTML</span> += content;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;loop2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>只控制DOM节点的显示或隐藏，而不是直接去改变DOM结构</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;staff-list&quot;</span> :<span class="keyword">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;staff-list-ul&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in staffList&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow($index)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span>item.staff_name | addSpace <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;staff_phone&quot;</span>&gt;</span>item.phone_no <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">上面代码的优化原理即先生成所有<span class="variable constant_">DOM</span>节点，但是所有节点均不显示出来，利用vue.<span class="property">js</span>中的v-show，根据计算的随机数来控制显示某个&lt;li&gt;，来达到文字滚动效果。</span><br></pre></td></tr></table></figure></li><li><p><strong>操作DOM前，先把DOM节点删除或隐藏</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = $(<span class="string">&quot;.list1&quot;</span>);</span><br><span class="line">list1.<span class="title function_">hide</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    item.<span class="title function_">append</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    list1.<span class="title function_">append</span>(item);</span><br><span class="line">&#125;</span><br><span class="line">list1.<span class="title function_">show</span>();</span><br></pre></td></tr></table></figure><p>display属性值为none的元素不在渲染树中，因此对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行多次DOM操作，可以先将其隐藏，操作完成后再显示。这样只在隐藏和显示时触发2次重排，而不会是在每次进行操作时都出发一次重排。</p></li><li><p><strong>最小化重绘和重排</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//优化前代码：每对element进行一次样式更改都会影响该元素的集合结构，最糟糕情况下会触发三次重排。</span><br><span class="line">var element = document.getElementById(&#x27;mydiv&#x27;);</span><br><span class="line">element.style.height = &quot;100px&quot;;  </span><br><span class="line">element.style.borderLeft = &quot;1px&quot;;  </span><br><span class="line">element.style.padding = &quot;20px&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//优化后代码：利用js对该元素的class重新赋值，获得新的样式，这样减少了多次的DOM操作</span><br><span class="line">//js操作</span><br><span class="line">.newStyle &#123;  </span><br><span class="line">    height: 100px;  </span><br><span class="line">    border-left: 1px;  </span><br><span class="line">    padding: 20px;  </span><br><span class="line">&#125;  </span><br><span class="line">element.className = &quot;newStyle&quot;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、文档类型历史">2、文档类型历史<a class="anchor" href="#2、文档类型历史">·</a></h3><h4 id="1、定义：">1、定义：<a class="anchor" href="#1、定义：">·</a></h4><ul><li>**SGML ：**标准通用标记语言，是所有电子文档标记语言的起源    1985</li><li>**HTML：**超文本标记语言，它定义了网页内容的含义和结构。用途：结构化信息（段落、表格），描述文档的外观、语义                     1993</li><li>**XML：**可扩展标记语言，和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限                 1998</li><li>**XHTML ：**基于 XML 的标记语言，他与 HTML 没什么本质的区别，但他更严格</li></ul><h4 id="2、XHTML">2、XHTML<a class="anchor" href="#2、XHTML">·</a></h4><p>为了规范 HTML，W3C 结合 XML 制定了 XHTML1.0 标准，与 HTML 4.01 几乎是相同的，按照 XML 的要求来规范 HTML，两者最主要的区别：</p><ul><li>文档顶部 doctype 声明不同，XHTML 的 doctype 顶部声明中明确规定了xhtml DTD的写法</li><li>XHTML 元素必须被正确地嵌套。</li><li>XHTML 元素必须被关闭。</li><li>标签名必须用小写字母，标签必须成双成对：标签名和属性对大小写敏感</li><li>XHTML 文档必须拥有根元素：所有的 XHTML 元素必须被嵌套于 <html> 根元素中</li><li>属性值必须用双引号 <code>&quot;&quot;</code> 括起来</li></ul><h3 id="3、DOM节点">3、DOM节点<a class="anchor" href="#3、DOM节点">·</a></h3><h4 id="1、节点的概念">1、节点的概念<a class="anchor" href="#1、节点的概念">·</a></h4><ul><li>可以将任何HTML描绘成一个由多层节点构成的结构，节点分为12种不同类型</li><li>每种类型分别表示文档中不同的信息及标记，每个节点都拥有各自的特点、数据和方法，也与其他节点存在某种关系</li><li>节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构</li></ul><h4 id="2、HTML的DOM节点">2、HTML的DOM节点<a class="anchor" href="#2、HTML的DOM节点">·</a></h4><ol><li>元素节点：<html>、<body>、<p>等都是元素节点，即标签。</li><li>文本节点:向用户展示的内容，如<li>…</li>中的JavaScript、DOM、CSS等文本。</li><li>属性节点:元素属性，如<a>标签的链接属性href</li></ol><h4 id="3、节点类型">3、节点类型<a class="anchor" href="#3、节点类型">·</a></h4><ul><li>DOM1级定义了一个Node接口，它在javascript中是作为Node类型来实现的；</li><li>每个节点都有一个nodeType属性，用于表明节点的类型</li><li>通过定义数值常量和字符常量两种方式来表示，IE只支持数值常量</li><li>节点类型一共有12种，常用7种：</li></ul><p>​    <a href="https://link.juejin.cn?target=https%3A%2F%2Fcamo.githubusercontent.com%2F0c63f3fd6ccb91445ac1149b2ad3c109135c87c6%2F687474703a2f2f7777312e73696e61696d672e636e2f6d773639302f6165343962613537677931666539727a316c6b32776a323068613037327462772e6a7067"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/c09202a794fc92f73181eaa8aab51d95~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /></a><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/b0622da786234b4efda4820c4bc6d57a~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 50%;" /></p><h5 id="1、Element-元素">1、Element(元素)<a class="anchor" href="#1、Element-元素">·</a></h5><ul><li><p>它表示了html、xml文档中的元素。通常元素因为有<strong>子元素</strong>、<strong>文本节点</strong>或者两者的结合；</p></li><li><p>元素节点是唯一能够拥有属性的节点类型</p></li><li><p><strong><code>html</code>、<code>head</code>、<code>meta</code>、<code>title</code>、<code>body</code>、<code>div</code>、<code>ul</code>、<code>li</code>、<code>script</code>都属于Element(元素节点);</strong></p></li><li><h4 id="操作元素属性：">操作元素属性：<a class="anchor" href="#操作元素属性：">·</a></h4><ul><li>getAttribute()：实际中主要用于获取自定义属性<ul><li>元素的style属性，自定义属性，返回的是css文本</li><li>元素的事件属性：onclick事件处理程序，属性值是一段JS代码，返回代码字符串</li></ul></li><li>setAttribute(A,B)：设置特性</li><li>removeAttribute()：删除特性</li></ul></li><li><h4 id="所有节点类型共享了两个方法：">所有节点类型共享了两个方法：<a class="anchor" href="#所有节点类型共享了两个方法：">·</a></h4><ul><li><p>克隆节点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.cloneNode(false/true)</span><br><span class="line">//返回改调用节点的副本。括号内参数为true是深度拷贝，为空格或false则是浅拷贝。</span><br></pre></td></tr></table></figure><ul><li>参数true：表示深复制，复制节点及整个子DOM树</li><li>false：浅复制，只复制该节点，没有子节点，没有指定父节点，称作孤儿节点</li><li>该方法只复制HTML属性，而不复制事件处理程序，但IE会，这是个bug，它复制前要先删除事件</li></ul></li><li><p>normolize()：处理文档子树中的文本节点，相邻同胞节点合为一个文本节点，删除空文本节点等</p></li></ul></li></ul><h5 id="2、Attr-属性">2、Attr(属性)<a class="anchor" href="#2、Attr-属性">·</a></h5><ul><li>代表了元素中的属性；</li><li>因为属性实际上是附属于元素的，因此属性节点不能被看做是元素的子节点，因而在DOM中属性没有被认为是文档树的一部分</li><li>也就是说：属性节点其实被看做是包含它的元素节点的一部分，它并不作为单独的一个节点在文档树中出现</li><li><code>lang</code>、<code>charset</code>、<code>id</code>、<code>class</code>都属于Attr(属性节点);</li></ul><h5 id="3、Text-文本">3、Text(文本)<a class="anchor" href="#3、Text-文本">·</a></h5><ul><li>是只包含文本内容的节点；</li><li>它可以由更多的信息组成，也可以只包含空白。</li><li>在文档树中元素的文本内容和属性的文本内容都是由文本节点来表示的</li><li><code>DocumentFragment文档片段节点</code>、<code>test1</code>、<code>test2</code>、<code>元素节点之后的空白区域</code>都属于Text(文本节点)</li></ul><h5 id="4、Comment-注释-略">4、Comment(注释)  略<a class="anchor" href="#4、Comment-注释-略">·</a></h5><h5 id="5、DocumentType-文档类型">5、DocumentType(文档类型)<a class="anchor" href="#5、DocumentType-文档类型">·</a></h5><ul><li>每一个Document都有一个DocumentType属性，它的值或者是null，或者是DocumentType对象。比如声明文档类型时&lt;!doctype html&gt;就是文档类型节点</li><li>！<strong><code>DOCTYPE html</code></strong> 就属于DocumentType(文档类型节点);</li></ul><h5 id="6、DocumentFragment-文档片段">6、DocumentFragment(文档片段)<a class="anchor" href="#6、DocumentFragment-文档片段">·</a></h5><ul><li>是轻量级的或最小的Document对象，它表示文档的一部分或者是一段，不属于文档树</li><li>它有一个特殊的行为：<ol><li>把一个DocumentFragment节点插入到文档的时候，插入的不是DocumentFragment自身，而是它的所有的子孙节点</li><li>这使得DocumentFragment成了有用的占位符，暂时存放那些一次插入文档的节点，同时它还有利于实现文档的剪切、复制和粘贴等操作</li></ol></li><li><strong>例子中的:<code>var frag = document.createDocumentFragment();</code>就属于DocumentFragment(文档片段节点);</strong></li></ul><h4 id="4、特殊的文档节点document">4、特殊的文档节点document<a class="anchor" href="#4、特殊的文档节点document">·</a></h4><h5 id="位置：是文档树的根节点，是文档中其他所有节点的父节点；">位置：是文档树的根节点，是文档中其他所有节点的父节点；<a class="anchor" href="#位置：是文档树的根节点，是文档中其他所有节点的父节点；">·</a></h5><ol><li><p>在浏览器中，文档对象 document 是HTMLdocument的一个实例，表示<strong>整个HTML页面</strong></p></li><li><p>也是<strong>window对象的一个属性</strong>，因此是一个全局对象</p></li><li><p>!Doctype html、html作为Document(文档节点)的子节点出现;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.documentElement：指向&lt;html&gt;元素</span><br><span class="line">document.body：指向&lt;body&gt;元素</span><br><span class="line">document.doctype获取到文档中独立的部分：&lt;!doctype&gt;</span><br></pre></td></tr></table></figure></li></ol><h5 id="2、【注意】">2、【注意】<a class="anchor" href="#2、【注意】">·</a></h5><ol><li>文档节点并不是html、xml文档的根元素，因为在xml文档中，处理指令、注释等内容可以出现在根元素之外</li><li>所以我们在构造DOM树的时候，根元素并不适合作为根节点，因此就有了文档节点，而根元素是作为文档节点的子节点出现的</li></ol><ul><li>Document 类型的节点有以下特征：<ul><li>nodeType 等于 9；</li><li>nodeName 值为&quot;#document&quot;；</li><li>nodeValue 、parentNode 、ownerDocument值为 null；</li><li>值为 null；</li><li>子节点可以是 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment 类型</li></ul></li></ul><h5 id="功能1：提供文档信息">功能1：提供文档信息<a class="anchor" href="#功能1：提供文档信息">·</a></h5><ul><li>提供浏览器所加载网页的信息，所有这些信息都可以在请求的 HTTP 头部信息中获取，只是在 JS 中通过这几个属性暴露出来<ul><li>title：过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改 title 属性无效</li><li>URL：包含当前页面的完整 URL（地 址栏中的 URL）</li><li>domain ：含页面的域名（唯一可设置的）</li><li>referrer：包含链接到当前页面的那个页面的 URL，如 果当前页面没有来源，则 referrer 属性包含空字符串</li></ul></li></ul><h5 id="功能2：查找元素节点">功能2：查找元素节点<a class="anchor" href="#功能2：查找元素节点">·</a></h5><h5 id="功能3：文档写入">功能3：文档写入<a class="anchor" href="#功能3：文档写入">·</a></h5><p>document对象有向<strong>网页输出流</strong>写入内容的能力，write()、 writeln()、open()和 close()</p><ul><li>document.write():向一个已经加载，并且没有调用过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/open"><code>document.open()</code></a> 的文档写入数据时，会自动调用 <code>document.open</code>。一旦完成了数据写入，建议调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/close"><code>document.close()</code></a>，以告诉浏览器当前页面已经加载完毕。写入的数据会被解析到文档结构模型（DOM）里。</li><li>document.onload()：<strong>页面包含图片等文件在内的所有元素都加载完成</strong>，即页面加载完毕执行的事，会有覆盖性</li></ul><h5 id="功能4：创建元素">功能4：创建元素<a class="anchor" href="#功能4：创建元素">·</a></h5><ul><li><h5 id="document-createElement-：">document.createElement()：<a class="anchor" href="#document-createElement-：">·</a></h5><p>创建元素节点，参数为要创建元素的标签名，div、h2等,要把元素，通过appendChild等操作节点的方式添加到文档树上，才能在浏览器中渲染出来</p></li></ul><ul><li><h5 id="document-createTextNode-：">document.createTextNode()：<a class="anchor" href="#document-createTextNode-：">·</a></h5><p>创建文本节点，参数为要插入的字符串</p></li></ul><h3 id="4、增删改查元素节点">4、增删改查元素节点<a class="anchor" href="#4、增删改查元素节点">·</a></h3><h4 id="4-1、通过选择器查找">4.1、通过选择器查找<a class="anchor" href="#4-1、通过选择器查找">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据CSS选择器去页面中查询一个元素，如果匹配到的元素有多个，则它会返回查询到的第一个元素：</span><br><span class="line">document.querySelector(&#x27;selector&#x27;) </span><br><span class="line"></span><br><span class="line">根据CSS选择器去页面中查询一组元素，会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个</span><br><span class="line">document.querySelectorAll(&#x27;selector)</span><br><span class="line"></span><br><span class="line">获取或设置HtmL</span><br><span class="line">elem.innerHTML(HTML片段)</span><br><span class="line">elem.textContent(纯文本内容)</span><br></pre></td></tr></table></figure><h4 id="4-2-通过document对象调用">4.2 通过document对象调用<a class="anchor" href="#4-2-通过document对象调用">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html  docunment.documentElement   获取页面中html根元素</span><br><span class="line">head  document.head</span><br><span class="line">body  document.body = document.getElementsByTagName(&quot;body&quot;)[0];  </span><br><span class="line">document.all  =  document.getElementsByTagName(&quot;*&quot;) 获取页面中的所有元素</span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;id&#x27;)</span><br><span class="line">document.getElementsByTagName(&#x27;p&#x27;)</span><br><span class="line">document.getelementsByName(&#x27;text&#x27;)</span><br><span class="line">document.getElementsByClassName(&#x27;userClass&#x27;)</span><br></pre></td></tr></table></figure><h4 id="4-3、通过元素节点关系">4.3、通过元素节点关系<a class="anchor" href="#4-3、通过元素节点关系">·</a></h4><ul><li><p>节点的层次关系：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/4ed4cb033ac7ecd2b1f921d896eff506~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 67%;" /></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找节点：</span><br><span class="line">elem.parentNode 查找elem的父节点</span><br><span class="line">elem.childNodes 找elem的所有直接子节点</span><br><span class="line">elem.firstChild 找elem的第一个直接子节点</span><br><span class="line">elem.lastChild 找elem的最后一个直接子节点</span><br><span class="line">elem.previousSibling 找elem的前一个兄弟</span><br><span class="line">elem.nextSibling 找elem的下一个兄弟</span><br><span class="line">查找元素：</span><br><span class="line">elem.parentElement 找父元素</span><br><span class="line">elem.children 找所有直接子元素</span><br><span class="line">elem.firstElementChild 第一个直接子元素</span><br><span class="line">elem.lastElementChild 最后一个直接子元素</span><br><span class="line">elem.previousElementSibling 前一个兄弟元素</span><br><span class="line">elem.nextElementSibling 下一个兄弟元素</span><br></pre></td></tr></table></figure><h4 id="4-4、增加、删除、修改元素节点">4.4、增加、删除、修改元素节点<a class="anchor" href="#4-4、增加、删除、修改元素节点">·</a></h4><p><strong>先获取父节点，并有子节点，再操作其子节点</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、创建节点</span><br><span class="line">document.creatElement(&#x27;tagName&#x27;)</span><br><span class="line">document.createTextNode(&quot;xxx&quot;)创建文本节点</span><br><span class="line"></span><br><span class="line">2、增加节点</span><br><span class="line">1. 尾部添加：node.appendChild(A)：</span><br><span class="line">2. 插入添加：node.insertBefore(新节点,旧节点)；在node的孩子节点B前面，插入A节点</span><br><span class="line"></span><br><span class="line">3、删除节点</span><br><span class="line">node.removeChild(子节点)：移除node的A节点</span><br><span class="line">推荐方式：子节点.parentNode.removeChild(子节点)**  </span><br><span class="line"></span><br><span class="line">4、替换节点</span><br><span class="line">node.replaceChild(新节点,旧节点)：用A节点替换B节点</span><br></pre></td></tr></table></figure><h3 id="5、JS操作Dom修改样式属性">5、JS操作Dom修改样式属性<a class="anchor" href="#5、JS操作Dom修改样式属性">·</a></h3><h4 id="1、读取、修改内联样式：">1、读取、修改内联样式：<a class="anchor" href="#1、读取、修改内联样式：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取：元素节点.style.样式名 </span><br><span class="line">修改：元素.style.样式名 = 样式值</span><br></pre></td></tr></table></figure><p>【注意】：</p><ol><li><strong>通过style修改和读取的样式都是内联样式</strong>，由于内联样式的优先级比较高，所以通过JS来修改的样式，往往会立即生效</li><li><strong>但是如果样式中设置了!important，则内联样式将不会生效。</strong></li></ol><h4 id="2、读取元素的当前样式">2、读取元素的当前样式<a class="anchor" href="#2、读取元素的当前样式">·</a></h4><ul><li><h4 id="getComputedStyle-元素节点，-一般null">getComputedStyle(元素节点， 一般null)<a class="anchor" href="#getComputedStyle-元素节点，-一般null">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getComputedStyle(box, null)[&quot;width&quot;]; </span><br></pre></td></tr></table></figure><ul><li>是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式</li><li>该方法读取到样式都是只读的不能修改</li></ul></li><li><h4 id="window对象的方法">window对象的方法<a class="anchor" href="#window对象的方法">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert</span><br><span class="line"><span class="built_in">setInterval</span>、<span class="built_in">setTimeout</span>、<span class="built_in">clearInterval</span>、<span class="built_in">clearTimeout</span></span><br><span class="line">scrollBy、scrollTo、resizeBy、resizeTo</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、样式相关属性">3、样式相关属性<a class="anchor" href="#3、样式相关属性">·</a></h4><p>以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clientHeight、clientWidth： 元素的可见高/宽度，包括元素的内容区和内边距的高度  </span><br><span class="line"></span><br><span class="line">scrollHeight、scrollWidth：  获取元素滚动区域的高度和宽度 </span><br><span class="line">scrollTop、scrollLeft：      获取元素垂直和水平滚动条滚动的距离 </span><br><span class="line"></span><br><span class="line">offsetHeight、offfsetWidth：  整个元素的高度，包括内容区、内边距、边框</span><br><span class="line">offsetLeft、offsetTop： 当前元素和定位父元素之间的偏移量</span><br><span class="line"></span><br><span class="line">offsetParent：  当前元素的定位父元素、离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断滚动条是否滚动到底  </span><br><span class="line"> 垂直滚动条  </span><br><span class="line">scrollHeight -scrollTop = clientHeight  </span><br><span class="line">  </span><br><span class="line"> 水平滚动  </span><br><span class="line">scrollWidth -scrollLeft = clientWidth</span><br></pre></td></tr></table></figure><h3 id="6、DomReady">6、DomReady<a class="anchor" href="#6、DomReady">·</a></h3><h4 id="1、基本概念-2">1、基本概念<a class="anchor" href="#1、基本概念-2">·</a></h4><ul><li><strong>domReady</strong>：<ol><li>操作DOM的时候，要先确保HTML解析工作已经完成，否则，拿不到DOM节点；</li><li>指的是DOM树构建完毕，也就是HTML解析第一步完成。节点是以树的形式组织的，当页面上所有的html都转换为节点以后，就叫做domReady；</li></ol></li></ul><h4 id="2、实现策略">2、实现策略<a class="anchor" href="#2、实现策略">·</a></h4><h5 id="1、body标签最后">1、body标签最后<a class="anchor" href="#1、body标签最后">·</a></h5><ul><li><p>浏览器是从上到下，从左向右渲染元素的，这样实例中的js代码一定在domReady之后去执行的</p></li><li><p>但为什么很少用？</p><p>在实际项目中，js文件往往非常多，而且之间会相互调用，大多数都是外部引用的，不把js代码直接写在页面上。</p><p>这时候就不能自由地去调用jS了，就需要一个domReady，不管逻辑代码写在哪里，都是等到domReady之后去执行的</p></li></ul><h5 id="2、window-onload方法：">2、window.onload方法：<a class="anchor" href="#2、window-onload方法：">·</a></h5><ul><li>表示当页面<strong>所有的元素</strong>都加载完毕，并且<strong>所有要请求的资源也加载完毕</strong>才触发执行；</li><li>在文档外部资源不多的情况下不会有什么问题，但当页面中有<strong>大量远程图片或要请求的远程资源时</strong>：<ol><li>需要让js在点击每张图片时，进行相应的操作；</li><li>如果此时外部资源还没有加载完毕，点击图片是不会有任何反应的，大大降低了用户体验。</li></ol></li></ul><h5 id="3、DOMContentLoaded-事件：">3、DOMContentLoaded 事件：<a class="anchor" href="#3、DOMContentLoaded-事件：">·</a></h5><p>为了解决window.onload的短板，w3c 新增了一个 DOMContentLoaded 事件。</p><ul><li><p>不支持的就用来自Diego Perini发现的著名Hack兼容。兼容原理大概就是通过IE中的document，documentElement.doScroll(‘left’)来判断DOM树是否创建完毕</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myReady</span>(<span class="params">fn</span>)&#123;  </span><br><span class="line">    <span class="comment">//对于现代浏览器，对DOMContentLoaded事件的处理采用标准的事件绑定方式  </span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="variable language_">document</span>.<span class="property">addEventListener</span> ) &#123;  </span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, fn, <span class="literal">false</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="title class_">IEContentLoaded</span>(fn);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//IE模拟DOMContentLoaded  </span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">IEContentLoaded</span> (fn) &#123;  </span><br><span class="line">        <span class="keyword">var</span> d = <span class="variable language_">window</span>.<span class="property">document</span>;  </span><br><span class="line">        <span class="keyword">var</span> done = <span class="literal">false</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//只执行一次用户的回调函数init()  </span></span><br><span class="line">        <span class="keyword">var</span> init = <span class="keyword">function</span> (<span class="params"></span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!done) &#123;  </span><br><span class="line">                done = <span class="literal">true</span>;  </span><br><span class="line">                <span class="title function_">fn</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        (<span class="keyword">function</span> (<span class="params"></span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// DOM树未创建完之前调用doScroll会抛出错误  </span></span><br><span class="line">                d.<span class="property">documentElement</span>.<span class="title function_">doScroll</span>(<span class="string">&#x27;left&#x27;</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;  </span><br><span class="line">                <span class="comment">//延迟再试一次~  </span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>, <span class="number">50</span>);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 没有错误就表示DOM树创建完毕，然后立马执行用户回调  </span></span><br><span class="line">            <span class="title function_">init</span>();  </span><br><span class="line">        &#125;)();  </span><br><span class="line">        <span class="comment">//监听document的加载状态  </span></span><br><span class="line">        d.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果用户是在domReady之后绑定的函数，就立马执行  </span></span><br><span class="line">            <span class="keyword">if</span> (d.<span class="property">readyState</span> == <span class="string">&#x27;complete&#x27;</span>) &#123;  </span><br><span class="line">                d.<span class="property">onreadystatechange</span> = <span class="literal">null</span>;  </span><br><span class="line">                <span class="title function_">init</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7、DOM节点继承层次">7、DOM节点继承层次<a class="anchor" href="#7、DOM节点继承层次">·</a></h3><h4 id="1、DOM节点继承层次">1、DOM节点继承层次<a class="anchor" href="#1、DOM节点继承层次">·</a></h4><ul><li><h4 id="为什么操作DOM耗费性能？">为什么操作DOM耗费性能？<a class="anchor" href="#为什么操作DOM耗费性能？">·</a></h4><p>对DOM节点每一个属性的访问，有时候可能会向上向上溯寻到N多个原型链，因此DOM操作是个非常耗性能的操作；</p><p>前端框架提出了虚拟DOM的概念，合并和屏蔽了很多无效的DOM操作</p></li></ul><h4 id="2、元素节点（Element）的创建过程">2、元素节点（Element）的创建过程<a class="anchor" href="#2、元素节点（Element）的创建过程">·</a></h4><p>举例<strong>创建一个p元素一共溯寻了7层原型链：</strong></p><ol><li><p>使用document.createElement(“p”)创建p元素</p></li><li><p>document.createElement(“p”)是HTMLParagraphElement的一个实例；</p></li><li><p>HTMLParagraphElement的父类是HTMLElement</p></li><li><p>HTMLElement的父类是Element</p></li><li><p>Element的父类是Node</p></li><li><p>Node的父类是EventTarget</p></li><li><p>EventTarget的父类是Function</p></li><li><p>Function的父类是Object</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/4c794f63d00b456f059056c4d3db3fa3~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /></li></ol><ul><li><h4 id="查看document-createElement-“p”-自身属性：">查看document.createElement(“p”)自身属性：<a class="anchor" href="#查看document-createElement-“p”-自身属性：">·</a></h4><h5 id="遍历对象属性方法3种：">遍历对象属性方法3种：<a class="anchor" href="#遍历对象属性方法3种：">·</a></h5><ol><li>for-in循环:会遍历对象自身的属性,以及原型属性,包括enumerable 为 false(不可枚举属性);</li><li>Object.keys():可以得到自身可枚举的属性，但得不到原型链上的属性;</li><li>Object.getOwnPropertyNames():可以得到**自身所有的属性(**包括不可枚举),但得不到原型链上的属性,Symbols属性</li></ol></li></ul><h4 id="3、文本节点（Text）的创建过程">3、文本节点（Text）的创建过程<a class="anchor" href="#3、文本节点（Text）的创建过程">·</a></h4><p>举例<strong>创建一个文本节点一共溯寻了6层原型链</strong>：</p><ol><li>使用document.createTextNode(“xxx”)创建文本节点；</li><li>document.createTextNode(“xxx”)是Text的一个实例</li><li>而Text的父类是CharactorData — CharactorData的父类是Node</li><li>Node的父类是EventTarget  ---- EventTarget的父类是Function</li><li>Function的父类是Object</li></ol><p>​    <a href="https://link.juejin.cn?target=https%3A%2F%2Fcamo.githubusercontent.com%2F562ed479af47c93aa1579ab297326c74bec35e7d%2F687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f6165343962613537677931666561347368657332676a32306979306b38646b332e6a7067"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/23bec759f6a82d45f491c8d96ca36406~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" /></a></p><p>【注意】：所有节点的继承层次都不简单，但相比较而言，元素节点是更可怕的。从HTML1升级到HTML3.2，再升级到HTML4.1，再到HTML5。除了不断地增加新类型、新的嵌套规则以外，每个元素也不断的添加新属性。</p><h4 id="4、空的div元素的自有属性">4、空的div元素的自有属性<a class="anchor" href="#4、空的div元素的自有属性">·</a></h4><ul><li><p>空的div元素，并且没有插入到DOM里边，看它有多少自有属性（不包括原型链继承来的属性）</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/4/5/b8a4c92310facfc3b40671b9f8e7db18~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:25%;" /></li><li><p>在新的HTML规范中，许多元素的固有属性（比如value）都放到了原型链当中，数量就更加庞大了</p></li><li><p>而框架：比如MVVM框架，将所有的DOM操作都转交给框架内部做精细处理，包括虚拟DOM</p></li></ul><h2 id="事件">事件<a class="anchor" href="#事件">·</a></h2><h3 id="1、事件、事件流">1、事件、事件流<a class="anchor" href="#1、事件、事件流">·</a></h3><ul><li>事件三要素：事件源、事件类型、事件处理程序</li><li>事件流：事件传递时在元素节点之间按照特定的顺序传播，描述了页面接收事件的顺序。IE（事件冒泡）和网景（事件捕获）提出了相反的事件流方案</li></ul><h3 id="2、事件对象">2、事件对象<a class="anchor" href="#2、事件对象">·</a></h3><h4 id="1、概念：-4">1、概念：<a class="anchor" href="#1、概念：-4">·</a></h4><ol><li><p>在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 <strong>event</strong> 的对象中</p></li><li><p>这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型等；</p></li><li><p>event 对象<strong>只在事件处理程序执行期间存在</strong>，一旦执行完毕，就会被销毁</p></li></ol><h4 id="2、属性：">2、属性：<a class="anchor" href="#2、属性：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e.target                        //返回触发事件的对象 标准</span><br><span class="line">e.srcElement;                   //返回触发事件的对象 非标准</span><br><span class="line">e.type;                         //返回事件的类型 ，如click</span><br><span class="line">eventPhase 属性可用于确定事件流当前所处的阶段</span><br><span class="line">    捕获阶段被调用，则 eventPhase 等于 1；</span><br><span class="line">    目标上被调用，则 eventPhase 等于 2；</span><br><span class="line">    冒泡阶段被调用，则 eventPhase 等于 3</span><br></pre></td></tr></table></figure><h4 id="3、currentTarget-、target区别">3、currentTarget 、target区别<a class="anchor" href="#3、currentTarget-、target区别">·</a></h4><ol><li><p>事件处理程序内部this始终等于 currentTarget 的值，而 target 只包含事件的实际目标；</p></li><li><p>如果事件处理直接添加在了意图的目标，则3者一致；</p></li><li><p>如果这个事件处理程序是添加到外层：</p><p>this 和 currentTarget 都等于<strong>注册事件</strong>处理程序的元素</p><p>target 属性等于按钮本身，这是因为那<strong>才是 click 事件真正的目标</strong>。由于按钮本身并没有注册事件处理程序，因此 click 事件冒泡到外层，从而触发了在它上面注册的处理程序</p></li></ol><h4 id="4、方法：">4、方法：<a class="anchor" href="#4、方法：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preventDefault()方法：用于阻止特定事件的默认动作。比如，链接的默认行为</span><br><span class="line">stopPropagation()方法：用于立即阻止事件流在DOM结构中传播，取消后续事件捕获或冒泡</span><br></pre></td></tr></table></figure><h3 id="3、事件绑定、解除">3、事件绑定、解除<a class="anchor" href="#3、事件绑定、解除">·</a></h3><h4 id="1、添加事件属性-基本不用">1、添加事件属性   基本不用<a class="anchor" href="#1、添加事件属性-基本不用">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(&#x27;Clicked&#x27;)&quot;/&gt; </span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot;/&gt; </span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(event.type)&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(this.value)&quot;&gt; </span><br></pre></td></tr></table></figure><ul><li>this 值相当于事件的目标元素；</li><li>这个函数有一个特殊的局部变量 event，其中保存的就是 event 对象。有了这个对象，就不用开发者另外定义其他变量，也不用从包装函数的参数列表中去取了</li></ul><p><strong>缺点：</strong></p><ul><li><p>时差问题：有可能 HTML 元素已经显示在页面上，用户都与其交互了，而事件处理程序的代码还无法执行。比如函数定义放在后面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;try&#123;showMessage();&#125;catch(ex) &#123;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>为此，大多数 HTML 事件处理程序会封装在 try/catch 块中，错误在浏览器收到之前已经被拦截了，就不会发生 JavaScript 错误了</li></ul></li><li><p>HTML 与 JavaScript 强耦合：如果要更换事件处理程序，就要改动两个地方:HTML代码和JS代码，这非常不利于后期代码的维护</p></li></ul><h4 id="2、DOM0-函数赋值">2、DOM0  函数赋值<a class="anchor" href="#2、DOM0-函数赋值">·</a></h4><ul><li><p>做法：把一个函数赋值给（DOM 元素的）一个事件处理程序属性，要使用 JavaScript 指定事件处理程序，必须先取得要操作对象的引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let btn = document.getElementById(&quot;myBtn&quot;); </span><br><span class="line">// 赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即 this 等于元素</span><br><span class="line">btn.onclick = function() &#123;  </span><br><span class="line"> console.log(this.id); // &quot;myBtn&quot; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>事件处理程序会在元素的作用域中运行，即 this 等于元素。通过 this 可以访问元素的任何属性和方法</p><ul><li>以这种方式添加事件处理程序是注册在事件流的<strong>冒泡阶段</strong>的。</li></ul></li><li><p><strong>缺点：</strong></p><ul><li>只能给该元素绑定一个事件，会覆盖</li></ul></li></ul><h4 id="3、DOM2">3、DOM2<a class="anchor" href="#3、DOM2">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addEventListener(事件名，事件处理函数，布尔值)</span><br><span class="line"></span><br><span class="line">true 表示在捕获阶段调用事件处理程序</span><br><span class="line">false（默认值）表示在冒泡阶段调用事件处理程序</span><br></pre></td></tr></table></figure><ul><li>优点：为同一个事件添加<strong>多个</strong>事件处理程序，以添加<strong>顺序</strong>来触发</li><li>注意：大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好</li></ul><h4 id="4、解除绑定">4、解除绑定<a class="anchor" href="#4、解除绑定">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移除通过 DOM0 方式添加的事件处理程序</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">removeEventListener</span>(事件名，事件处理函数，布尔值)</span><br><span class="line">-- <span class="literal">true</span> 表示在捕获阶段调用事件处理程序</span><br><span class="line">-- <span class="literal">false</span>（默认值）表示在冒泡阶段调用事件处理程序</span><br><span class="line">-- 添加的匿名函数无法移除，因为移除方式与添加一样</span><br></pre></td></tr></table></figure><ul><li>添加的匿名函数无法移除，因为移除方式与添加一样</li></ul><h4 id="性能问题：-2">性能问题：<a class="anchor" href="#性能问题：-2">·</a></h4><ul><li><p>删除时带来的问题：由于无用的事件处理程序长驻内存导致Web 应用性能不佳</p><ul><li><p>第一个是删除带有事件处理程序的元素。比如通过真正的 DOM方法 removeChild()或 replaceChild()删除节点</p></li><li><p>使用 innerHTML 整体替换页面的 某一部分。这时候，被 innerHTML 删除的元素上如果有事件处理程序，就不会被垃圾收集程序正常清理。很有可能元素的引用和事件处理程序的引用都会残留在内存中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btn.onclick = null; // 删除事件处理程序    推荐</span><br></pre></td></tr></table></figure></li><li><p>另一个可能导致内存中残留引用的问题是页面卸载。浏览器每次加载和卸载页面（比如通过前进、后退或刷新），内存中残留对象的数量都会增加，这是因为事件处理程序不会被回收</p><p>记住：onload 事件处理程序中做了什么，最好在 onunload 事件处理程序中恢复</p></li></ul></li><li><p>删除会阻止事件冒泡。只有事件目标仍然存在于文档中时，事件才会冒泡</p></li></ul><h3 id="4、事件传播3个阶段">4、事件传播3个阶段<a class="anchor" href="#4、事件传播3个阶段">·</a></h3><h4 id="1、事件冒泡-√">1、事件冒泡         √<a class="anchor" href="#1、事件冒泡-√">·</a></h4><ul><li><p>概念：事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发</p></li><li><p>优点：<strong>事件委托</strong>，大多是有益的</p></li><li><p>缺点：有时候我们需要<strong>阻止冒泡</strong></p><p>需求：比如存在这么一个页面A–&gt;B–&gt;C，c是最内层元素，如果用户点击c，则跳转页面，点击b，无反应，点击a，关闭页面；</p><p>做法：我们给A加一个点击事件关闭，给C加一个单击跳转事件，这时候如果点B，会产生冒泡就会关闭页面</p><p>解决：如果不想关闭页面，那么就需要给B绑定一个单击响应事件，添加上阻止冒泡函数**event.stopPropagation();**即可</p></li><li><p><strong>阻止事件冒泡的方式：</strong></p><ul><li><p>方式1：事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（执行超链接的跳转）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://www.csdn.net/&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式2：连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式3：阻止事件冒泡也会阻止默认事件；</p><p>可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2、目标阶段">2、目标阶段<a class="anchor" href="#2、目标阶段">·</a></h4><p>​ 事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p><h4 id="3、事件捕获">3、事件捕获<a class="anchor" href="#3、事件捕获">·</a></h4><p>​最不具体的节 点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。</p><ul><li>如果希望在捕获阶段就触发事件，可以将<strong>addEventListener()<strong>的第三个参数设置为true<br>一般情况下我们</strong>不会希望在捕获阶段触发事件</strong>，所以这个参数一般都是false</li></ul><h3 id="5、事件委托-√">5、事件委托     √<a class="anchor" href="#5、事件委托-√">·</a></h3><ul><li><p>作用：解决“事件处理程序过多”的办法，利用<strong>事件冒泡</strong>，只指定一个事件处理程序，就可以管理某一类型的所有事件</p><ul><li>首先，每个函数都是对象，都<strong>占用内存空间</strong>，对象越多，性能越差。</li><li>其次，为指定事件处理程序所需<strong>访问 DOM 的次数会先期造成整个页面交互的延迟</strong></li></ul></li><li><p>做法：一般把事件绑定到父级元素或者更外层元素，当子元素发生该事件，由于事件冒泡，事件会被父级元素监听到，从而触发事件处理程序</p></li><li><p>优点：</p><ul><li>document 对象随时可用，任何时候都可以给它添加事件处理程序，这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用</li><li>节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也 可以节省时间。</li><li>减少整个页面所需的内存，提升整体性能</li></ul></li><li><p>缺点：</p><ul><li>1.部分事件如 focus、blur 等无冒泡机制，所以无法委托。2.事件委托有对子元素的查找过程，委托层级过深，可能会有性能问题3.频繁触发的事件如 mousemove、mouseout、mouseover等，经常需要计算元素位置，不适合事件委托</li></ul></li></ul><h3 id="6、事件类型">6、事件类型<a class="anchor" href="#6、事件类型">·</a></h3><ul><li><p>DOM3 Events 定义了如下事件类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 用户界面事件：load、scroll、resize</span><br><span class="line"></span><br><span class="line">* 焦点事件：在元素获得和失去焦点时触发</span><br><span class="line"></span><br><span class="line">* 鼠标事件：鼠标在页面上执行某些操作时触发</span><br><span class="line"></span><br><span class="line">* 滚轮事件：使用鼠标滚轮（或类似设备）时触发</span><br><span class="line"></span><br><span class="line">* 输入事件：向文档中输入文本时触发</span><br><span class="line"></span><br><span class="line">* 键盘事件：键盘在页面上执行某些操作时触发</span><br></pre></td></tr></table></figure></li></ul><h4 id="1、用户界面事件">1、用户界面事件<a class="anchor" href="#1、用户界面事件">·</a></h4><ul><li><p>load：会在整个页面（包括 所有外部资源如图片、JavaScript 文件和 CSS 文件）加载完成后触发</p><ul><li>第一种是 JavaScript 方式：  √</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&quot;load&quot;, (event) =&gt; &#123; </span><br><span class="line"> console.log(&quot;Loaded!&quot;); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><ul><li>第二种指定 load 事件处理程序的方式是向元素添加 onload 属性</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body onload=&quot;console.log(&#x27;Loaded!&#x27;)&quot;&gt; </span><br></pre></td></tr></table></figure></li><li><p>scroll：虽然 scroll 事件发生在 window 上，但实际上反映的是页面中相应元素的变化</p></li><li><p>resize：窗口的尺寸缩放到新高度/新宽度时，这个事件在 window 上触发，因此 可以通过 JavaScript 在 window 上或者为元素添加 onresize 属性来指定事件处理程序</p></li></ul><h4 id="2、鼠标事件：">2、鼠标事件：<a class="anchor" href="#2、鼠标事件：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">click、mouseover、mouseout</span><br></pre></td></tr></table></figure><ul><li><p>由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。</p><p>比如，click 事件触发的前提是 mousedown 事件触发后，紧接着又在同一个元素上触发了 mouseup 事件。如果 mousedown 和 mouseup 中的任意一个事件被取消，那么 click 事件就不会触发。</p><p>这 4 个事件永远会按照如下顺序触发：</p><p>(1) mousedown  (2) mouseup (3)  click (4) mousedown (5) mouseup (6) click (7) dblclick</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e.pageX、e.pageY                  //返回鼠标相对于浏览器可视窗口的X、Y坐标</span><br><span class="line">e.clientX、e.clientY              //返回鼠标相对于文档页面的X、Y坐标</span><br><span class="line">e.screenX、e.screenY              //返回鼠标相对于电脑屏幕的X、Y坐标</span><br></pre></td></tr></table></figure><ul><li><p>页面坐标</p><p>事件发生时鼠标光标在页 面上的坐标，通过 event 对象的 pageX 和 pageY 可以获取</p><p>在页面没有滚动时，pageX 和 pageY 与 clientX 和 clientY 的值相同</p></li><li><p>客户端坐标</p><p>事件发生时鼠标光标在视口中的坐标，通过 event 对象的 clientX 和clientY 获取</p><p>注意客户端坐标不考虑页面滚动，因此这两个值并不代表鼠标在页面 上的位置</p></li><li><p>屏幕坐标</p><p>可以通过 event 对象的 screenX 和 screenY 属性获取鼠标光标在屏幕上的坐标</p></li></ul><h4 id="3、键盘事件">3、键盘事件<a class="anchor" href="#3、键盘事件">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onkeydown、onkeyup</span><br><span class="line">keyCode  获取按键的编码，判断哪个按键被按下</span><br><span class="line">altKey、ctrlKey、shiftKey  这个三个用来判断alt ctrl 和 shift是否被按下  </span><br></pre></td></tr></table></figure><h4 id="4、触摸事件">4、触摸事件<a class="anchor" href="#4、触摸事件">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* touchstart：手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。</span><br><span class="line">* touchmove：手指在屏幕上滑动时连续触发。在这个事件中调用 preventDefault()可以阻止 滚</span><br><span class="line">* touchend：手指从屏幕上移开时触发。 </span><br><span class="line">* touchcancel：系统停止跟踪触摸时触发。文档中并未明确什么情况下停止跟踪</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提供的一些属性：clientX、clientY、screenX、screenY</span><br></pre></td></tr></table></figure><p><strong>用于跟踪触点的3个属性：</strong></p><ol><li><strong>touches</strong>：Touch 对象的数组，表示当前屏幕上的每个触点。touchend 事件触发时 touches 集合中什么也没有，这是因为没有滚动的触点了。此时必须使用 changedTouches 集合</li><li>**targetTouches：**Touch 对象的数组，表示特定于事件目标的触点</li><li>**changedTouches：**Touch 对象的数组，表示自上次用户动作之后变化的触点</li></ol><h2 id="BOM">BOM<a class="anchor" href="#BOM">·</a></h2><h3 id="1、BOM的定义、与DOM的区别">1、BOM的定义、与DOM的区别<a class="anchor" href="#1、BOM的定义、与DOM的区别">·</a></h3><ul><li><p>BOM ：浏览器对象模型，它代表浏览器的一个实例，BOM可以使我们通过JS来操作浏览器</p><ul><li><p>BOM的核心对象是 window，它是用于与浏览器窗口进行交互对象</p></li><li><p>window对象包含了DOM：可以console.dir(window)查看window的属性和方法</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c42ebb19c64402ebbfa210374122e3a~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20210801105424814的副本.png" style="zoom:33%;" /></li><li><p>所以，BOM当然也就包含了DOM</p></li></ul></li></ul><h3 id="2、Navigator">2、Navigator<a class="anchor" href="#2、Navigator">·</a></h3><ul><li>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</li></ul><h3 id="3、Location">3、Location<a class="anchor" href="#3、Location">·</a></h3><ul><li><p>代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</p><table><thead><tr><th><strong>属性</strong></th><th></th></tr></thead><tbody><tr><td>location.href</td><td>返回完整的URL</td></tr><tr><td>location.host</td><td>返回域名</td></tr><tr><td>location.search</td><td>返回一个URL的查询部分</td></tr><tr><td><strong>方法</strong></td><td></td></tr><tr><td>location.assign()</td><td>用来跳转到其他的页面，作用和直接修改location一样</td></tr><tr><td>location.reload()</td><td>用于重新加载当前页面，作用和刷新按钮一样<br />如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面</td></tr><tr><td>location.replace()</td><td>可以使用一个新的页面替换当前页面，调用完毕也会跳转页面  <br/>不会生成历史记录，不能使用回退按钮回退</td></tr></tbody></table></li></ul><h3 id="4、History">4、History<a class="anchor" href="#4、History">·</a></h3><ul><li><p>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录</p><p>由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页</p><p>而且该操作只在当次访问时有效</p><table><thead><tr><th><strong>属性</strong></th><th></th></tr></thead><tbody><tr><td>history.length</td><td>返回历史列表中的网址数</td></tr><tr><td><strong>方法</strong></td><td></td></tr><tr><td>history.forward()</td><td>加载 history 列表中的前一个 URL</td></tr><tr><td>history.back()</td><td>加载 history 列表中的下一个 URL</td></tr><tr><td>history.go()</td><td>加载 history 列表中的某个具体页面</td></tr></tbody></table></li></ul><h3 id="5、Screen">5、Screen<a class="anchor" href="#5、Screen">·</a></h3><ul><li>代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</li></ul><h3 id="6、Window">6、Window<a class="anchor" href="#6、Window">·</a></h3><ul><li><p>整个浏览器的窗口，同时window也是网页中的全局对象</p></li><li><p>在浏览器中，window有着双重的角色，这些BOM对象在浏览器中都是作为window对象的属性保存的</p><ol><li>是JS访问浏览器窗口的接口，又是ES标准规定的Global对象</li><li>这也就是说“在网页定义的任何对象、变量、函数都以window作为其Global对象</li></ol></li></ul><h4 id="1、循环定时器">1、循环定时器<a class="anchor" href="#1、循环定时器">·</a></h4><ul><li><h4 id="setInterval-，-返回值：">setInterval() ， 返回值：<a class="anchor" href="#setInterval-，-返回值：">·</a></h4></li></ul><ol><li>返回一个Number类型的数据，这个数字用来作为定时器的唯一标识</li><li>每次调用间隔的时间，单位是毫秒</li></ol><ul><li><h4 id="clearInterval">clearInterval()<a class="anchor" href="#clearInterval">·</a></h4><p>需要一个定时器的标识作为参数，这样将关闭标识对应的定时器</p><p>如果参数不是一个有效的标识，则什么也不做</p></li></ul><h4 id="2、延时调用">2、延时调用<a class="anchor" href="#2、延时调用">·</a></h4><ul><li><strong>setTimeout</strong></li><li>延时调用一个函数不马上执行，隔一段时间以后在执行，而且只会执行一次</li></ul><p>返回值：</p><ol><li>返回一个Number类型的数据，这个数字用来作为定时器的唯一标识</li><li>每次调用间隔的时间，单位是毫秒</li></ol><ul><li>clearTimeout(timer);  关闭一个延时调用</li></ul><h4 id="3、应用">3、应用<a class="anchor" href="#3、应用">·</a></h4><p>轮播图</p><h2 id="JSON">JSON<a class="anchor" href="#JSON">·</a></h2><h3 id="1、语法规则">1、语法规则<a class="anchor" href="#1、语法规则">·</a></h3><ol><li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li><li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</li><li>字符串<strong>必须使用双引号表示</strong>，不能使用单引号。</li><li>对象的键名必须放在双引号里面。</li><li>数组或对象最后一个成员的后面，不能加逗号。</li><li>JSON和JS对象的格式一样，只不过<strong>JSON字符串中的属性名必须加双引号</strong></li></ol><ul><li><h4 id="分类：对象-、数组">分类：对象 {} 、数组 []<a class="anchor" href="#分类：对象-、数组">·</a></h4></li><li><p>转换：</p><p>JSON.parse（）：将一个JS对象转换为JSON字符串</p><p>JSON.stringify（）：将JSON字符串转换为JS对象</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue监听数组和对象</title>
      <link href="/posts/3611094049.html"/>
      <url>/posts/3611094049.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue监听对象和数组">Vue监听对象和数组<a class="anchor" href="#Vue监听对象和数组">·</a></h2><h3 id="1、initData-2件事">1、initData  2件事<a class="anchor" href="#1、initData-2件事">·</a></h3><p>initData 里面的 observe劫持 是响应式数据核心：</p><ol><li><p>对定义 <code>data</code> 函数返回数据的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上</p></li><li><p>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式</p><p>对于<strong>数组</strong>会调用 <code>observeArray</code> 方法：遍历数组再次调用 <code>observe</code> 方法</p><p>对<strong>纯对象</strong>调用 <code>walk</code> 方法：遍历对象的 key 调用 <code>defineReactive</code> 方法</p></li></ol><h3 id="2、这样的劫持方式对对象有什么影响？">2、这样的劫持方式对对象有什么影响？<a class="anchor" href="#2、这样的劫持方式对对象有什么影响？">·</a></h3><p>对象新增或者删除的属性无法被 set 监听到 只有对象本身存在的属性修改才会被劫持，因为：</p><ul><li><p>必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。否则就不是响应式的；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>   <span class="comment">// `vm.a` 是响应式的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">b</span> = <span class="number">2</span>   <span class="comment">// `vm.b` 是非响应式的     数据发生了变化，但不会响应在视图上</span></span><br></pre></td></tr></table></figure></li><li><p>解决：<code>Vue.set(object, propertyName, value)</code> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(vm.<span class="property">someObject</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">someObject</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、这样的劫持方式对数组有什么影响？">3、这样的劫持方式对数组有什么影响？<a class="anchor" href="#3、这样的劫持方式对数组有什么影响？">·</a></h3><h4 id="1、影响：Vue-不能检测以下变动的数组：">1、影响：<code>Vue</code> 不能检测以下变动的数组：<a class="anchor" href="#1、影响：Vue-不能检测以下变动的数组：">·</a></h4><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">items</span>[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.<span class="property">items</span>.<span class="property">length</span> = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure><h4 id="2、原因：">2、原因：<a class="anchor" href="#2、原因：">·</a></h4><ol><li><code>Object.defineProperty</code>对数组检测是有缺陷的，不能检测到数组长度的变化，准确的说是<strong>通过改变length</strong>而增加的长度不能监测到</li><li>性能代价和获得的用户体验收益不成正比<ol><li>如果一个数组里面有上千上万个元素 每一个元素下标都添加 get 和 set 方法 。当给数组某一项赋值的时候，触发了setter的时候，数据更新又会调用一遍getter函数，如果数组长度很大也会造成性能问题</li><li>如果你知道数组的长度，理论上是可以预先给所有的索引设置getter/setter的，很多场景下我们是不知道的</li></ol></li></ol><h4 id="3、解决Array变化监听">3、解决Array变化监听<a class="anchor" href="#3、解决Array变化监听">·</a></h4><p>**思路：**我们知道，改变数组的方法有很多，比如说<code>push</code>方法吧，如果我们能拦截到原型上的<code>push</code>方法，是不是就可以做一些事情呢？</p><p>实现过程：</p><ol><li>先获取原生 <code>Array</code> 的原型方法</li><li>对 <code>Array</code> 的原型方法做一些拦截操作：使用<code>Object.defineProperty</code> 的writable配合value，进行重写覆盖</li><li>把需要被拦截的 <code>Array</code> 类型的数据原型指向改造后原型</li></ol><h4 id="4、源码分析-数组变异实现">4、源码分析 数组变异实现<a class="anchor" href="#4、源码分析-数组变异实现">·</a></h4><h5 id="1、重写">1、重写<a class="anchor" href="#1、重写">·</a></h5><p><code>Vue</code>在<code>array.js</code>中重写了<code>methodsToPatch</code>中七个方法，并将重写后的原型暴露出去：pop push shift unshift splice  sort  reverse</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义属性函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">def</span> (<span class="attr">obj</span>: <span class="title class_">Object</span>, <span class="attr">key</span>: string, <span class="attr">val</span>:any,enumerable?:boolean) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">value</span>: val,</span><br><span class="line">    <span class="attr">enumerable</span>: !!enumerable,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.defineProperty的封装</span></span><br><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得原型上的方法</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue拦截的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上面的方法重写</span></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">method</span>) &#123;</span><br><span class="line">    <span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span> (...args) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method&#x27;</span>, method); <span class="comment">// 获取方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;args&#x27;</span>, args); <span class="comment">// 获取参数</span></span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">            inserted = args</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">            inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...功能如上述，监听到某个方法执行后，做一些对应的操作</span></span><br><span class="line">      <span class="comment">// 1、将开发者的参数传给原生的方法，保证数组按照开发者的想法被改变</span></span><br><span class="line">        <span class="comment">// 2、视图更新等通过notify更新视图。inserted代表新数据插入，需要对新数据进行obsserve</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto);</span><br></pre></td></tr></table></figure><h5 id="2、observer">2、observer<a class="anchor" href="#2、observer">·</a></h5><ul><li>在进行数据<code>observer</code>绑定的时候，我们先判断是否<code>hasProto</code>，如果存在<code>__proto__</code>，就直接将<code>value</code> 的 <code>__proto__</code>指向重写过后的原型</li><li>如果不能使用 <code>__proto__</code>，就直接循环 <code>arrayMethods</code>把它身上的这些方法直接装到 <code>value</code> 身上好了。毕竟调用某个方法是先去自身查找，当自身找不到这关方法的时候，才去原型上查找</li><li>没有直接修改 <code>Array.prototype</code>，而是直接把 <code>arrayMenthods</code> 赋值给 <code>value</code> 的 <code>__proto__</code> 。因为这样不会污染全局的Array， <code>arrayMenthods</code> 只对 <code>data</code>中的<code>Array</code> 生效</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否有__proto__，因为部分浏览器是没有__proto__</span></span><br><span class="line"><span class="keyword">const</span> hasProto = <span class="string">&#x27;__proto__&#x27;</span> <span class="keyword">in</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 重写后的原型</span></span><br><span class="line"><span class="keyword">import</span> &#123; arrayMethods &#125; <span class="keyword">from</span> <span class="string">&#x27;./array&#x27;</span></span><br><span class="line"><span class="comment">// 方法名</span></span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(arrayMethods);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observeArray</span> (value) &#123;</span><br><span class="line">    <span class="comment">// 如果有__proto__，直接覆盖                </span></span><br><span class="line">    <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="title function_">protoAugment</span>(value, arrayMethods);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有__proto__就把方法加到属性自身上</span></span><br><span class="line">        <span class="title function_">copyAugment</span>(value, arrayMethods, )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型的赋值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">protoAugment</span> (target, src) &#123;</span><br><span class="line">    target.<span class="property">__proto__</span> = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyAugment</span> (target, src, keys) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[i]</span><br><span class="line">        <span class="title function_">def</span>(target, key, src[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 响应式更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的虚拟DOM</title>
      <link href="/posts/2621268747.html"/>
      <url>/posts/2621268747.html</url>
      
        <content type="html"><![CDATA[<h2 id="5、虚拟DOM">5、虚拟DOM<a class="anchor" href="#5、虚拟DOM">·</a></h2><h3 id="1、what、how">1、what、how<a class="anchor" href="#1、what、how">·</a></h3><ul><li><p>虚拟DOM是什么？</p><p>虚拟Dom本质上是JS和Dom之间的一个映射缓存，在形态上表现为：一个能够描述Dom结构及其属性信息的JS对象。</p><p>是JS对象 2.是对Dom的描述</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122012139311.png" alt="image-20211122012139311" style="zoom:33%;" /></li><li><h4 id="挂载阶段">挂载阶段<a class="anchor" href="#挂载阶段">·</a></h4><p>React将结合JSX的描述，构建出虚拟的Dom树，然后通过ReactDom.render()将虚拟DOM映射到真实Dom（触发渲染流水线）</p></li><li><h4 id="更新阶段">更新阶段<a class="anchor" href="#更新阶段">·</a></h4><p>页面的变化会先作用于虚拟Dom，虚拟Dom将在JS层借助算法先对比出具体有哪些真实Dom需要做改变，然后再将这些改变作用于真实Dom</p></li></ul><h3 id="2、why">2、why<a class="anchor" href="#2、why">·</a></h3><p>为什么需要虚拟Dom，虚拟Dom是否伴随着更好的性能？虚拟Dom的优势何在？</p><p>虚拟Dom在历史开发场合的位置：</p><ol><li><p>人肉可见的Dom时期：原生JS支配下的“展示”属性远远强于其“交互”的属性</p><p>这就导致了JS的定位只能是“辅助”，在很长时间里，开发者花费很多时间实现静态的Dom，待结束后再补充少量的JS，简单的业务需求不需要做过多的Dom操作</p></li><li><p>jquery时期：大量Dom操作需求带来的前端开发量激增</p><p>简单的交互效果已无法满足用户体验，与之而来的是大量Dom操作需求带来的前端开发量激增。原生JS提供的API不好使，jquery解决了这个问题，将DomAPI封装成了简单优雅的形式，同时做掉了浏览器的兼容工作，并且提供了链式API调用、插件扩展等一系列能力用于进一步解决生产力。</p><ul><li>jquery并不能从根本上解决Dom操作量过大情况下前端一侧的压力；</li></ul></li><li><p>模板引擎方案，它更倾向于点对点解决繁琐DOM操作的问题，它在能力、定位上既不能够、也不打算替换掉jquery，两者和谐共存的。因此，并不存在模板引擎时期，只有模板引擎方案</p><ol><li>读取HTML模板并解析它，分离出其中的JS信息；</li><li>将解析出的内容拼接成字符串，动态生成JS代码</li><li>运行动态生成的JS代码，吐出“目标HTML&quot;</li><li>将目标HTML赋值给innerHtml，触发渲染流水线，完成真实DOM渲染</li></ol><ul><li>这种方案只需要关注：数据和数据变化本身，Dom层面的改变会帮我们做；</li><li>可惜的是：它实际应用场局限在，实现高效的字符串拼接这个点上而不能去做太复杂的事情。对真实Dom的修改过于大刀阔斧，也没有缓冲这些概念，存在糟糕的性能</li><li>他是虚拟DOM思想推广之前的一种方案。</li></ul></li><li><p>数据驱动视图：操作假DOM</p><p>传统时期、虚拟DOM时期的：</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122012152399.png" alt="image-20211122012152399" style="zoom: 20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122012205531.png" alt="image-20211122012205531" style="zoom:20%;" /></p><p>这里并不是一定是模板，比如reatc中使用的JSX。</p><ul><li><p>JSX本质不是模板，而是一种使用体验跟模板接近的JS语法糖，区别在于多出了一个虚拟DOm作为中间的缓冲层。缓冲层带来的优点是：当DOM操作频繁时，它会现将前后两次的Dom树记性对比，定位出具体需要更新的部分，生成补丁集，再将补丁打在需要更新的真实Dom上，实现精准更新</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122012306949.png" alt="image-20211122012306949" style="zoom:20%;" /></li></ul></li></ol><h3 id="3、用虚拟Dom是为了更好的性能吗">3、用虚拟Dom是为了更好的性能吗<a class="anchor" href="#3、用虚拟Dom是为了更好的性能吗">·</a></h3><ul><li>虚拟Dom是前端开发者为了追求更好的研发体验、研发效率而创造出来的高阶产物；</li><li>它也不是React的卖点。</li><li>性能问题是比较复杂的，在量化的时候要结合各阶段、各种要素来分情况讨论。</li></ul><h4 id="1、对比渲染步骤对比：">1、对比渲染步骤对比：<a class="anchor" href="#1、对比渲染步骤对比：">·</a></h4><ol><li>本质是字符换的拼接，对性能的消耗是有限的；</li><li>而虚拟DOm的构建、diff算法过程比较复杂，不可避免的涉及递归、遍历耗时操作；</li><li>这一步，都是更新的行为，因此模板渲染是全量更新、虚拟~是差量更新。</li></ol><ul><li>但是，当数据内容变化很大，二者差量计算相近，而虚拟~会有更多的性能消耗。</li><li>所以虚拟Dom的劣势主要在于<strong>JS计算耗时</strong>，而Dom操作的能耗、JS计算的能耗不再一个量级。少量的Dom操作就能抵大量的JS计算。</li><li>在实际场景中，setState修改少量的数据。</li></ul><h4 id="2、虚拟Dom的价值不在于性能，而在于别处">2、虚拟Dom的价值不在于性能，而在于别处<a class="anchor" href="#2、虚拟Dom的价值不在于性能，而在于别处">·</a></h4><p>它解决了什么问题呢？</p><ol><li><p>研发效率、研发体验的追求；</p><p>它的出现为数据驱动视图这一思想提供了落地的载体，对前端能够基于函数式的编程方式实现高效的声明式编程；</p></li><li><p>跨平台的问题</p><p>虚拟~是对真实内容的一种抽象，如果没有这一层抽象，那么视图层会和渲染平台紧密耦合在一起，为了描述同样的视图内容，需要在web端和native端写完全不同的两套、代码；</p><p>同一套虚拟Dom可以对接多套渲染平台，多端运行，这同样是提高开发效率的一种体现</p></li><li><p>性能方面的：批量更新</p><p>在通用虚拟Dom库里是由batch函数处理的,缓存每次生成的补丁集，再将最终的补丁集进行渲染到真实Dom</p></li></ol><h3 id="4、15栈调和–diff">4、15栈调和–diff<a class="anchor" href="#4、15栈调和–diff">·</a></h3><ul><li><p>调和：也叫协调。Virtual Dom是一种编程概念，在这个概念里，UI以一种理想化的或者说**“虚拟的”<strong>表现形式存在于内存中，并通过如ReactDom等类库使之与</strong>真实的Dom<strong>同步，这一过程叫做</strong>“调和”**。因此，调和也是把虚拟dom映射为真实Dom的过程。</p></li><li><p>React15的栈调和、React16的Fiber调和</p></li><li><p>**diff是找不同的过程，二者不是一个概念。**它是调和过程中的一环。</p></li><li><p>React将源码划分为了3部分：</p><p>core：</p><p>render：</p><p>reconciler：（调和器），这一路径中调和器所做的工作，包括组件的挂载、卸载、更新（涉及diff）过程等</p></li><li><p>diff是调和过程中重要的一环，因此很多人也将调和过程默认为diff过程</p></li></ul><h4 id="1、diff策略的设计思想">1、diff策略的设计思想<a class="anchor" href="#1、diff策略的设计思想">·</a></h4><p>要想找出两个树结构之间的不同：</p><ul><li><strong>传统的方法</strong>是通过循环递归进行树节点的一一对比。O(N^3)</li><li>为了将复杂度降低至o(N)，React确定了两个大前提：<ol><li>若组件属于同一类型，他们将拥有相同的Dom树形结构</li><li>处于同一层级的一组子节点，可用通过设置key作为唯一标识，从而维护各个节点在不同渲染过程中的稳定性</li><li>React实践的规律：Dom节点之间的跨层级操作并不多，同层级操作是主流</li></ol></li></ul><h4 id="2、Diff逻辑拆分解读">2、Diff逻辑拆分解读<a class="anchor" href="#2、Diff逻辑拆分解读">·</a></h4><ol><li><p>Diff算法性能突破的关键点在于“分层对比”</p><p>只需要完成从上到下的一次遍历，就可以完成对比，降低复杂度的重要量级对比</p><p>虽然栈调和将传统的树对比算法优化为了分层对比，但整个算法仍然是以递归的形式运转，分层递归也是递归，如果真的发生了跨层级操作，这种非主流操作，React并不能判断行为，要销毁+重建，因此react官方也要求开发者不要做跨层级的操作，尽量保持层级的稳定性。</p></li><li><p>类型一致的节点才有继续diff的必要性</p><p>一刀切。抓主要矛盾，只有确认类型相同，才会在更深层次做对比，减少diff过程中的冗余操作</p></li><li><p>key属性的设置，可以帮我们尽可能重用同一层级的节点</p><p>key是帮助react识别哪些内容被更改、添加或删除的。key需要写在用数组渲染出来的元素内部，并需要给其一个稳定的值。稳定很重要，因为如果key值发生了改变，React会触发UI重渲染</p></li></ol><h3 id="5、batch-批处理机制-—-setState">5、batch 批处理机制 — setState<a class="anchor" href="#5、batch-批处理机制-—-setState">·</a></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;increment setState前的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;increment setState后的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">//0 </span></span><br><span class="line">&#125;</span><br><span class="line">triple = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;triple setState前的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">//1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;triple setState后的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduce = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce setState前的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);<span class="comment">//2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce setState后的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">//1</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.increment&#125;</span>&gt;</span>点我增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.triple&#125;</span>&gt;</span>点我增加3倍<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.reduce&#125;</span>&gt;</span>点我减少<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、setState异步的动机和原理">1、setState异步的动机和原理<a class="anchor" href="#1、setState异步的动机和原理">·</a></h4><ul><li>state到底是哪个环节发生变化的呢？到底同步还是异步的呢？</li></ul><ol><li><p>一般的更新流程，render本身涉及dom操作，带来性能开销</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122133334696.png" alt="image-20211122133334696" style="zoom:25%;" /></li><li><p>假如每次setState都触发一次完整的更新流程，视图可能没刷新几次就卡死了</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122133348906.png" alt="image-20211122133348906" style="zoom:25%;" /></li></ol><p><strong>所以setState异步的动机就来源于 避免频繁的renrender</strong>：</p><ul><li>它的实现机制就类似于Vue中的nextTick和浏览器的EventLoop。每来一个setState。就把它塞入一个队列里<strong>攒起来</strong>，<strong>等时机成熟</strong>，再将攒起来的state结果做合并。最后只针对最新的State值走一次更新流程</li></ul><p>因此，即使100次，也之后增加入队次数，并不会带来频繁的renderer。当100次调用完毕之后，也只是100次任务队列的内容发生了变化，而count本身并不会立刻改变</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">test =<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;循环100次 setState前的count：&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">setState</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;循环100次 setState后的count：&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122133403091.png" alt="image-20211122133403091" style="zoom:25%;" /><h4 id="2、setState工作流-—-批量更新">2、setState工作流 — 批量更新<a class="anchor" href="#2、setState工作流-—-批量更新">·</a></h4><p>在setTimeout的保护下，它似乎有了同步的现象。为什么会这样呢？</p><p>并不是因为setTimeout改变了setState，<strong>而是setTimeout帮助setState逃脱了React对它的管控</strong>，只要是在React管控下的setState，一定是异步的。</p><p>源码分析（围绕15展开，关于16Fiber带来的改变后续再讲解）:读源码应该带着问题去读，主流程</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35dce2754bb844808bf65fcc12cd1b24~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 25%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122134505874.png" alt="image-20211122134505874" style="zoom: 25%;" /><h5 id="1、入口函数setState：">1、入口函数setState：<a class="anchor" href="#1、入口函数setState：">·</a></h5><p>充当分发的角色，根据入参的不同，将其分发到不同的函数中去。</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211122134838045.png" alt="image-20211122134838045" style="zoom:25%;" /><ol><li>假如传入的是对象：<strong>enqueueSetState做了两件事：</strong><ol><li>将新的state放入组件的状态队列里</li><li>用enqueueUpdate处理将要更新的实例对象</li></ol></li></ol><ul><li><p>获取组件实例：instance；</p></li><li><p>判断是否存在**_pendingStateQueue**</p><p>有—&gt; 将传入的partialState存储push进去，没有创建空数组，push进去;</p></li><li><p>如果存在callback就调用<strong>enqueueCallback</strong>将其存入一个**_pendingCallbacks**队列中存起来</p></li><li><p>调用<strong>enqueueUpdate</strong>，并传入当前组件实例；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">enqueueSetState</span>: <span class="keyword">function</span>(<span class="params">publicInstance, partialState</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据this拿到对应的组件实例</span></span><br><span class="line">  <span class="keyword">var</span> internalInstance = <span class="title function_">getInternalInstanceReadyForUpdate</span>(</span><br><span class="line">    publicInstance,</span><br><span class="line">    <span class="string">&#x27;setState&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// queue 对应一个组件实例的 state 数组</span></span><br><span class="line">  <span class="keyword">var</span> queue = internalInstance.<span class="property">_pendingStateQueue</span> || (internalInstance.<span class="property">_pendingStateQueue</span> = []);</span><br><span class="line">  queue.<span class="title function_">push</span>(partialState); <span class="comment">// 将 partialState 放入待更新 state 队列</span></span><br><span class="line">  <span class="comment">// 处理当前的组件实例</span></span><br><span class="line">  <span class="title function_">enqueueUpdate</span>(internalInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、enqueueUpdate的具体实现：直接决定了是等待还是直接走更新流程">2、enqueueUpdate的具体实现：<strong>直接决定了是等待还是直接走更新流程</strong><a class="anchor" href="#2、enqueueUpdate的具体实现：直接决定了是等待还是直接走更新流程">·</a></h5><ul><li><p>调用<strong>ensureInjected</strong>，对batchingStrategy进行赋值，</p></li><li><p>判断<strong>batchingStrategy.isBatchingUpdates</strong>，【注意】：开启事务前会将它设置为了true，事务结束会将它设为false</p><p>为true —&gt; 将当前组件实例添加到<strong>dirtyComponents</strong>数组中</p><p>为false ----&gt; 执行<strong>batchingStrategy</strong>的<strong>batchedUpdates</strong>方法，【注意】：事务开启的时候也会调用这个方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enqueueUpdate</span>(<span class="params">component</span>) &#123;</span><br><span class="line">  <span class="title function_">ensureInjected</span>() </span><br><span class="line">  <span class="comment">// isBatchingUpdates 标识着当前是否处于批量创建/更新组件过程</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.<span class="property">isBatchingUpdates</span>) &#123;</span><br><span class="line">    <span class="comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span></span><br><span class="line">    batchingStrategy.<span class="title function_">batchedUpdates</span>(enqueueUpdate, component)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要批量更新，则先把组件塞入 dirtyComponents 队列</span></span><br><span class="line">  dirtyComponents.<span class="title function_">push</span>(component)</span><br><span class="line">  <span class="keyword">if</span> (component.<span class="property">_updateBatchNumber</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    component.<span class="property">_updateBatchNumber</span> = updateBatchNumber + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3、batchingStrategy是什么-—锁管理器">3、batchingStrategy是什么 —锁管理器<a class="anchor" href="#3、batchingStrategy是什么-—锁管理器">·</a></h5><ul><li>从上面的流程可以看出： <code>batchingStrategy</code>该对象的<code>isBatchingUpdates</code>属性直接决定了是马上要走更新流程，还是应该进入队列等待；</li><li>所以大概可以得知<code>batchingStrategy</code>用于管控批量更新的对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0. transition是ReactDefaultBatchingStrategyTransaction的实例，它代表了其中一类事务的执行</span></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> <span class="title class_">ReactDefaultBatchingStrategyTransaction</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ReactDefaultBatchingStrategy</span> = &#123;</span><br><span class="line">  <span class="comment">// 1. 初始值为 false 表示当前并未进行任何批量更新操作：全局唯一的锁标识</span></span><br><span class="line">  <span class="attr">isBatchingUpdates</span>: <span class="literal">false</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 发起更新动作的方法batchedUpdates：</span></span><br><span class="line">      先把锁锁上，表明现在正处于批量更新过程中，此期间任何批量更新都只能暂时进入dirtyComponents排队等候下一次批量更新，而不能随意插队，这是一种任务锁的思想</span><br><span class="line">  <span class="attr">batchedUpdates</span>: <span class="keyword">function</span> (<span class="params">callback, a, b, c, d, e</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.1 第一次调用时，alreadyBatchingUpdates设置为false,就会执行perform</span></span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = <span class="title class_">ReactDefaultBatchingStrategy</span>.<span class="property">isBatchingUpdates</span>;</span><br><span class="line">    <span class="title class_">ReactDefaultBatchingStrategy</span>.<span class="property">isBatchingUpdates</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//2.2 perform启动事务，同时将 callback 放进事务里执行</span></span><br><span class="line">      <span class="keyword">return</span> transaction.<span class="title function_">perform</span>(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    进入事务transation，执行method方法，开启了组件的首次装载</span><br><span class="line"><span class="comment">// 3. 当组件装载完毕会调用componentDidMount(注意，此时还是在执行method方法，事务还没结束，事务只有在执行完method后执行一系列close才会结束)</span></span><br></pre></td></tr></table></figure><h5 id="4、transaction-perform-—-Transaction（事务）机制">4、transaction.perform — Transaction（事务）机制<a class="anchor" href="#4、transaction-perform-—-Transaction（事务）机制">·</a></h5><ul><li><h4 id="概念：-2">概念：<a class="anchor" href="#概念：-2">·</a></h4><ul><li>Transaction 是创建一个黑盒，该黑盒能够封装任何的方法，在React源码表现为一个核心类；</li><li>一个 Transaction 就是将需要执行的 method 使用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，再通过 Transaction 提供的 perform 方法执行</li><li>在React中就是调用perform方法进入一个事务，该方法中会传入一个method参数。执行perform时：<ul><li>先执行所有 wrapper 中的 initialize 方法，例如一些初始化操作</li><li>然后执行传入的method — perform真正</li><li>perform 完成之后（即 method 执行后）再执行所有的 close 方法，例如执行批量更新或者将isBatchingUpdates变回false等等</li></ul></li></ul></li></ul><h5 id="5、batchingStrategy-批量更新策略">5、batchingStrategy 批量更新策略<a class="anchor" href="#5、batchingStrategy-批量更新策略">·</a></h5><ul><li><p>ReactDefaultBatchingStrategy 这个对象，其实就是一个批量更新策略事务，它的 wrapper 有两个：<code>FLUSH_BATCHED_UPDATES</code> 和 <code>RESET_BATCHED_UPDATES</code></p></li><li><p>在<strong>perform</strong>中的method执行完毕后，会按照数组的顺序**[FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]<strong>依次调用其</strong>close**方法</p><ul><li><strong>FLUSH_BATCHED_UPDATES</strong>执行批量更新操作，会循环所有dirtyComponents，调用updateComponent执行所有的生命周期方法，实现组件的更新</li><li><strong>RESET_BATCHED_UPDATES</strong>将isBatchingUpdates变回false，即意味着事务结束</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">RESET_BATCHED_UPDATES</span> = &#123;</span><br><span class="line">  <span class="attr">initialize</span>: emptyFunction,</span><br><span class="line">  <span class="comment">//2 将isBatchingUpdates设置为false，代表本次事务结束。后续再调用setState就不会push到dirtyComponents里面</span></span><br><span class="line">  <span class="attr">close</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">ReactDefaultBatchingStrategy</span>.<span class="property">isBatchingUpdates</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flushBatchedUpdates 将所有的临时 state 合并并计算出最新的 props 及 state</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">FLUSH_BATCHED_UPDATES</span> = &#123;</span><br><span class="line">  <span class="attr">initialize</span>: emptyFunction,</span><br><span class="line">  <span class="comment">// 1 批量更新操作</span></span><br><span class="line">  <span class="attr">close</span>: <span class="title class_">ReactUpdates</span>.<span class="property">flushBatchedUpdates</span>.<span class="title function_">bind</span>(<span class="title class_">ReactUpdates</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">TRANSACTION_WRAPPERS</span> = [<span class="variable constant_">FLUSH_BATCHED_UPDATES</span>, <span class="variable constant_">RESET_BATCHED_UPDATES</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">reinitializeTransaction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、setState为何会表现为同步？">3、setState为何会表现为同步？<a class="anchor" href="#3、setState为何会表现为同步？">·</a></h4><p><code>batchedUpdates</code> 这个方法不仅仅会在setState之后才被调用，在首次渲染组件时执行内部会调用一次：</p><h5 id="1、componentDidMount：">1、componentDidMount：<a class="anchor" href="#1、componentDidMount：">·</a></h5><ol><li>实例化组件；</li><li>内部调用了一次 <code>batchedUpdates</code> 方法（将 isBatchingUpdates 设为 true）</li><li>在组件的渲染过程中，会按照顺序调用各个生命周期(钩子)函数。开发者可能在生命周期函数里面调用 setState，因此需要开启batch来确保所有的更新都能够进入 dirtyComponents 里去，进而确保初始初始渲染流程中，所有的state都是生效的</li></ol><h5 id="componentWillUpdate、componentDidUpdate">componentWillUpdate、componentDidUpdate<a class="anchor" href="#componentWillUpdate、componentDidUpdate">·</a></h5><ul><li>这两个生命周期中不能调用<code>setState</code>。在它们里面调用<code>setState</code>会造成死循环，导致程序崩溃</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line"><span class="attr">_renderNewRootComponent</span>: <span class="keyword">function</span>(<span class="params"> nextElement, container, shouldReuseMarkup, context </span>) &#123;</span><br><span class="line">  <span class="comment">// 实例化组件</span></span><br><span class="line">  <span class="keyword">var</span> componentInstance = <span class="title function_">instantiateReactComponent</span>(nextElement);</span><br><span class="line">  <span class="comment">// 调用 batchedUpdates 方法</span></span><br><span class="line">  <span class="title class_">ReactUpdates</span>.<span class="title function_">batchedUpdates</span>(</span><br><span class="line">    batchedMountComponentIntoNode,</span><br><span class="line">    componentInstance,</span><br><span class="line">    container,</span><br><span class="line">    shouldReuseMarkup,</span><br><span class="line">    context</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、事件：">2、事件：<a class="anchor" href="#2、事件：">·</a></h5><p>当我们在React绑定了事件后，事件中也有可能触发setState</p><ul><li>为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新</li><li><code>react</code>仍然处于他的更新机制中，这时<code>isBranchUpdate</code>为true；</li><li>这时无论调用多少次<code>setState</code>，都不会执行更新，而是将要更新的<code>state</code>存入<code>_pendingStateQueue</code>，将要更新的组件存入<code>dirtyComponent</code></li><li>事物结束后，会设置为false</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactEventListener.js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dispatchEvent</span>: <span class="keyword">function</span> (<span class="params">topLevelType, nativeEvent</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理事件：batchedUpdates会将 isBatchingUpdates设为true</span></span><br><span class="line">    <span class="title class_">ReactUpdates</span>.<span class="title function_">batchedUpdates</span>(handleTopLevelImpl, bookKeeping);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="title class_">TopLevelCallbackBookKeeping</span>.<span class="title function_">release</span>(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【总结】：<code>isBatchingUpdates</code> 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 改为 true，这时我们所做的 setState 操作自然不会立即生效</p><h4 id="4、回到之前的例子：">4、回到之前的例子：<a class="anchor" href="#4、回到之前的例子：">·</a></h4><ul><li>isBatchingUpdates对setTimeout内部的执行逻辑完全没有约束力，因为isBatchingUpdates是在同步代码变化，setTimeout是异步执行的，当this.setState真正运行时，isBatchingUpdates已经被重置为false了。</li><li>这就使得 setTimeout 里面的 setState 具备了立刻发起同步更新的能力。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// isBatchingUpdates = true; 先锁上</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;increment setState前的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;increment setState后的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">//0 </span></span><br><span class="line">   <span class="comment">// isBatchingUpdates = false;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduce = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// isBatchingUpdates = true;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce setState前的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);<span class="comment">//2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce setState后的count&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">//1</span></span><br><span class="line">     <span class="comment">// isBatchingUpdates = false;</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="5、总结">5、总结<a class="anchor" href="#5、总结">·</a></h4><p>setState 同步异步的表现会因调用场景的不同而不同：</p><ul><li>在 React 钩子函数及合成事件中，它表现为异步；</li><li>而在 setTimeout/setInterval 函数，DOM 原生事件中，它都表现为同步。这是由 React 事务机制和批量更新机制的工作方式来决定的</li></ul><p>【备注】：16以后，整个React核心算法被重写，setState也不可避免地被“Fiber”化，之后会展开讲</p><h4 id="6、整体执行流程">6、整体执行流程<a class="anchor" href="#6、整体执行流程">·</a></h4><ul><li>1.将setState传入的<code>partialState</code>参数存储在当前组件实例的state暂存队列中。</li><li>2.判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。</li><li>3.如果未处于批量更新状态，将批量更新状态标识设置为true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。</li><li>4.调用事务的<code>waper</code>方法，遍历待更新组件队列依次执行更新。</li><li>5.执行生命周期<code>componentWillReceiveProps</code>。</li><li>6.将组件的state暂存队列中的<code>state</code>进行合并，获得最终要更新的state对象，并将队列置为空。</li><li>7.执行生命周期<code>componentShouldUpdate</code>，根据返回值判断是否要继续更新。</li><li>8.执行生命周期<code>componentWillUpdate</code>。</li><li>9.执行真正的更新，<code>render</code>。</li><li>10.执行生命周期<code>componentDidUpdate</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的双向绑定</title>
      <link href="/posts/3598970227.html"/>
      <url>/posts/3598970227.html</url>
      
        <content type="html"><![CDATA[<p>总结：Vue 内部通过 <code>Object.defineProperty</code>方法属性拦截的方式，把 <code>data</code> 对象里每个数据的读写转化成 <code>getter</code>/<code>setter</code>，当数据变化时通知视图更新</p><img src="https://user-gold-cdn.xitu.io/2019/8/1/16c4a3ce0cc709da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="4.png" style="zoom:50%;" /><h2 id="一、什么是-MVVM-数据双向绑定">一、什么是 MVVM 数据双向绑定<a class="anchor" href="#一、什么是-MVVM-数据双向绑定">·</a></h2><p><code>MVVM</code> 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据</p><ul><li>输入框内容变化时，<code>Data</code> 中的数据同步变化。即 <code>View</code> =&gt; <code>Data</code> 的变化。  <strong>事件监听</strong></li><li><code>Data</code> 中的数据变化时，文本节点的内容同步变化。即 <code>Data</code> =&gt; <code>View</code> 的变化</li></ul><p>我们会通过实现以下 4 个步骤，来实现数据的双向绑定：</p><img src="https://user-gold-cdn.xitu.io/2019/8/1/16c4a3ce0bcb0d91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="3.png" style="zoom:50%;" /><p>1、实现一个监听器 <code>Observer</code> ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；</p><p>2、实现一个订阅器 <code>Dep</code>，用来收集订阅者，对监听器 <code>Observer</code> 和 订阅者 <code>Watcher</code> 进行统一管理；</p><p>3、实现一个订阅者 <code>Watcher</code>，可以收到属性的变化通知并执行相应的方法，从而更新视图；</p><p>4、实现一个解析器 <code>Compile</code>，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。</p><h2 id="二、监听器-Observer-实现">二、监听器 Observer 实现<a class="anchor" href="#二、监听器-Observer-实现">·</a></h2><p>监听器 <code>Observer</code> 的实现，主要是指让数据对象变得“可观测”，即每次数据读或写时，我们能感知到数据被读取了或数据被改写了。<code>Vue 2.0</code> 源码中用到 <code>Object.defineProperty()</code> 来劫持各个数据属性的 <code>setter / getter</code></p><h3 id="2-1、Object-defineProperty-语法">2.1、Object.defineProperty() 语法<a class="anchor" href="#2-1、Object-defineProperty-语法">·</a></h3><p><strong>（1）参数</strong></p><ul><li><code>obj</code>：要在其上定义属性的对象</li><li><code>prop</code>：要定义或修改的属性的名称</li><li><code>descriptor</code>：将被定义或修改的属性描述符</li></ul><p>**（2）返回值 ** 被传递给函数的对象</p><p><strong>（3）属性描述符</strong></p><p><code>Object.defineProperty()</code> 为对象定义属性，分 数据描述符 和 存取描述符 ，两种形式不能混用</p><p><strong>数据描述符和存取描述符均具有以下可选键值：</strong></p><ul><li><p><code>configurable</code>：当且仅当该属性的 <code>configurable</code> 为 <code>true</code> 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。<strong>默认为 false</strong></p></li><li><p><code>enumerable</code>：当且仅当该属性的 <code>enumerable</code> 为 <code>true</code> 时，该属性才能够出现在对象的枚举属性中。<strong>默认为 false</strong></p></li></ul><p><strong>数据描述符具有以下可选键值</strong>：</p><ul><li><p><code>value</code>：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<strong>默认为 undefined</strong></p></li><li><p><code>writable</code>：当且仅当该属性的 <code>writable</code> 为 <code>true</code> 时，<code>value</code>才能被赋值运算符改变。<strong>默认为 false</strong></p></li></ul><p><strong>存取描述符具有以下可选键值</strong>：</p><ul><li><p><code>get</code>：一个给属性提供 <code>getter</code> 的方法，如果没有 <code>getter</code> 则为 <code>undefined</code>。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入<code>this</code>对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。默认为 <code>undefined</code>。</p></li><li><p><code>set</code>：一个给属性提供 <code>setter</code> 的方法，如果没有 <code>setter</code> 则为 <code>undefined</code>。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 <code>undefined</code>。</p></li></ul><h3 id="2-2、监听器-Observer-实现">2.2、监听器 Observer 实现<a class="anchor" href="#2-2、监听器-Observer-实现">·</a></h3><ul><li><h4 id="梳理：">梳理：<a class="anchor" href="#梳理：">·</a></h4><p>完成了数据的’可观测’，即我们知道了数据在什么时候被读或写了，那么，我们就可以在数据被读或写的时候通知那些依赖该数据的视图更新了</p></li><li><p>**遍历+Object.defineProperty() **：让数据对象的所有属性都变得可观测：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环遍历数据对象的每个属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observable</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    keys.<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将对象的属性用 Object.defineProperty() 进行设置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被读取了...`</span>);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被修改了...`</span>);</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、订阅器-Dep-实现">三、订阅器 Dep 实现<a class="anchor" href="#三、订阅器-Dep-实现">·</a></h2><h3 id="1、梳理：">1、梳理：<a class="anchor" href="#1、梳理：">·</a></h3><ol><li><p>创建一个依赖收集容器，也就是消息订阅器 <code>Dep</code>，用来容纳所有的“订阅者”</p></li><li><p>当数据变化的时候后执行对应订阅者的更新函数</p></li></ol><h3 id="2、实现-2">2、实现<a class="anchor" href="#2、实现-2">·</a></h3><h4 id="Dep的构成">Dep的构成<a class="anchor" href="#Dep的构成">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dep</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dep</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">addSub</span>: <span class="keyword">function</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">notify</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">            sub.<span class="title function_">update</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li><h4 id="Dep添加的时机">Dep添加的时机<a class="anchor" href="#Dep添加的时机">·</a></h4></li></ul><p>再将 <strong><code>defineReactive</code> 函数进行改造一下，向其植入订阅器</strong>：</p><ul><li><p>设计了一个订阅器 <code>Dep</code> 类，该类里面定义了一些属性和方法</p></li><li><p>特别注意的是它有一个静态属性 <code>Dep.target</code>，这是一个全局唯一 的<code>Watcher</code>，因为在同一时间只能有一个全局的 <code>Watcher</code> 被计算，另外它的自身属性 <code>subs</code> 也是 <code>Watcher</code> 的数组</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">defineReactive</span>: <span class="keyword">function</span>(<span class="params">data, key, val</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">getter</span> () &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">setter</span> (newVal) &#123;</span><br><span class="line"><span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">val = newVal;</span><br><span class="line">dep.<span class="title function_">notify</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、订阅者-Watcher-实现">四、订阅者 Watcher 实现<a class="anchor" href="#四、订阅者-Watcher-实现">·</a></h2><ol><li><p>订阅者 <code>Watcher</code> 是一个 类，在它的构造函数中，定义了一些属性：</p><ul><li>**vm：**一个 Vue 的实例对象；</li><li>**exp：**是 <code>node</code> 节点的 <code>v-model</code> 等指令的属性值 或者插值符号中的属性。如 <code>v-model=&quot;name&quot;</code>，<code>exp</code> 就是<code>name</code>;</li><li>**cb：**是 <code>Watcher</code> 绑定的更新函数;</li></ul></li><li><p>运行过程：3个过程</p><ol><li><p>当我们去实例化一个渲染 <code>watcher</code> 的时候，首先进入 <code>watcher</code> 的构造函数逻辑，就会执行它的 <code>this.get()</code> 方法，进入 <code>get</code> 函数，实际上就是把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dep.target = this;  // 将自己赋值为全局的订阅者</span><br></pre></td></tr></table></figure></li><li><p>触发数据对象的 <code>getter</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let value = this.vm.data[this.exp]  // 强制执行监听器里的get函数</span><br></pre></td></tr></table></figure><p>每个对象值的 <code>getter</code> 都持有一个 <code>dep</code>，在触发 <code>getter</code> 的时候会调用 <code>dep.depend()</code> 方法，也就会执行<code>this.addSub(Dep.target)</code>，即把当前的 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>watchers</code> 中，至此完成了一个依赖收集的过程</p></li><li><p>完成依赖收集后，还需要把 <code>Dep.target</code> 恢复成上一个状态，即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dep.target = null; </span><br></pre></td></tr></table></figure></li></ol></li><li><p>而 <code>update()</code> 函数是用来当数据发生变化时调用 <code>Watcher</code> 自身的更新函数进行更新的操作。先通过 <code>let value = this.vm.data[this.exp];</code> 获取到最新的数据,然后将其与之前 <code>get()</code> 获得的旧数据进行比较，如果不一样，则调用更新函数 <code>cb</code> 进行更新。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Watcher</span>(<span class="params">vm, exp, cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">exp</span> = exp;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>();  <span class="comment">// 将自己添加到订阅器的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">update</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>];</span><br><span class="line">        <span class="keyword">var</span> oldVal = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">        <span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>; <span class="comment">// 全局变量 订阅者 赋值</span></span><br><span class="line">        <span class="keyword">var</span> value = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]  <span class="comment">// 强制执行监听器里的get函数</span></span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>; <span class="comment">// 全局变量 订阅者 释放</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="五、解析器-Compile-实现">五、解析器 Compile 实现<a class="anchor" href="#五、解析器-Compile-实现">·</a></h2><h3 id="1、梳理">1、梳理<a class="anchor" href="#1、梳理">·</a></h3><p>将来这个节点的这个数据改变了，你要执行这个函数</p><ol><li>解析模板指令，并替换模板数据，初始化视图</li><li>实例化watcher，将模板指令对应的节点绑定对应的更新函数</li></ol><h3 id="2、实现-3">2、实现<a class="anchor" href="#2、实现-3">·</a></h3><ul><li><p>下面对 ‘’ 这种形式的指令处理的关键代码进行分析，感受解析器 <code>Compile</code> 的处理逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">compileText</span>: <span class="keyword">function</span>(<span class="params">node, exp</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">var</span> initText = <span class="variable language_">this</span>.<span class="property">vm</span>[exp]; <span class="comment">// 获取属性值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">updateText</span>(node, initText); <span class="comment">// dom 更新节点文本值</span></span><br><span class="line">    <span class="comment">// 将这个指令初始化为一个订阅者，后续 exp 改变时，就会触发这个更新回调，从而更新视图</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, exp, <span class="keyword">function</span> (<span class="params">value</span>) &#123; </span><br><span class="line">self.<span class="title function_">updateText</span>(node, value);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="六、源码分析">六、源码分析<a class="anchor" href="#六、源码分析">·</a></h2><p>从 <code>Vue</code> 源码层面分析监听器 <code>Observer</code> 、订阅器 <code>Dep</code> 、订阅者 <code>Watcher</code> 的实现</p><h3 id="6-1、监听器-Observer-实现">6.1、监听器 Observer 实现<a class="anchor" href="#6-1、监听器-Observer-实现">·</a></h3><p>核心就是利用 <code>Object.defineProperty</code> 给数据添加了 <code>getter</code> 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑 。</p><h4 id="（1）initState">（1）initState<a class="anchor" href="#（1）initState">·</a></h4><ul><li><p>在 <code>Vue</code> 的初始化阶段，<code>_init</code> 方法执行的时候，会执行 <code>initState(vm)</code> 方法，它的定义在 <code>src/core/instance/state.js</code> 中，分别对<code>data</code>、<code>prop</code>、<code>computed</code>进行初始化，让其变成响应式</p></li><li><h4 id="过程：-2">过程：<a class="anchor" href="#过程：-2">·</a></h4><ul><li>初始化<code>props</code>：对所有<code>props</code>进行遍历，Observe调用<code>defineReactive</code>函数，将每个 prop 属性值变成响应式，然后将其挂载到<code>_props</code>中，然后通过代理，把<code>vm.xxx</code>代理到<code>vm._props.xxx</code>实例中</li><li>初始化<code>data</code>时：与<code>prop</code>相同，对所有<code>data</code>进行遍历，调用<code>defineReactive</code>函数，将每个 data 属性值变成响应式，然后将其挂载到<code>_data</code>中，然后通过代理，把<code>vm.xxx</code>代理到<code>vm._data.xxx</code>中</li><li>初始化<code>computed</code>，首先创建一个观察者对象<code>computed-watcher</code>，然后遍历<code>computed</code>的每一个属性，对每一个属性值调用<code>defineComputed</code>方法，使用<code>Object.defineProperty</code>将其变成响应式的同时，将其代理到组件实例上，即可通过<code>vm.xxx</code>访问到<code>xxx</code>计算属性</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）initData-2件事">（2）initData  2件事<a class="anchor" href="#（2）initData-2件事">·</a></h4><ol><li>对定义 <code>data</code> 函数返回对象的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上</li><li>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）observe"><strong>（3）observe</strong><a class="anchor" href="#（3）observe">·</a></h4><ul><li>**功能：**监测数据的变化，它的定义在 <code>src/core/observer/index.js</code> 中：</li><li>做法：给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span> (<span class="attr">value</span>: any, <span class="attr">asRootData</span>: ?boolean): <span class="title class_">Observer</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value) || value <span class="keyword">instanceof</span> <span class="title class_">VNode</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">ob</span>: <span class="title class_">Observer</span> | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) &#123;</span><br><span class="line">    ob = value.<span class="property">__ob__</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !<span class="title function_">isServerRendering</span>() &amp;&amp;</span><br><span class="line">    (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">    !value.<span class="property">_isVue</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.<span class="property">vmCount</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）Observer"><strong>（4）Observer</strong><a class="anchor" href="#（4）Observer">·</a></h4><ul><li><p>是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新：</p></li><li><p><code>Observer</code> 的构造函数逻辑：</p><ol><li><p>首先实例化 <code>Dep</code> 对象， <code>Dep</code> 对象</p></li><li><p>接下来会对 <code>value</code> 做判断：</p><p>对于<strong>数组</strong>会调用 <code>observeArray</code> 方法：遍历数组再次调用 <code>observe</code> 方法</p><p>对<strong>纯对象</strong>调用 <code>walk</code> 方法：遍历对象的 key 调用 <code>defineReactive</code> 方法</p></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xport <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: any;</span><br><span class="line">  <span class="attr">dep</span>: <span class="title class_">Dep</span>;</span><br><span class="line">  <span class="attr">vmCount</span>: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">value</span>: any) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vmCount</span> = <span class="number">0</span></span><br><span class="line">    <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="title function_">protoAugment</span>(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">copyAugment</span>(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (<span class="attr">obj</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observeArray (<span class="attr">items</span>: <span class="title class_">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（5）defineReactive">（5）defineReactive<a class="anchor" href="#（5）defineReactive">·</a></h4><ul><li>**功能：**定义一个响应式对象，给对象动态添加 <code>getter</code> 和 <code>setter</code>，它的定义在 <code>src/core/observer/index.js</code> 中：</li><li>**做法：**最开始初始化 <code>Dep</code> 对象的实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，这样就保证了无论 <code>obj</code> 层级多深，访问或修改 <code>obj</code> 中一个嵌套较深的属性，也能触发 getter 和 setter</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">val</span>: any,</span><br><span class="line">  customSetter?: ?<span class="title class_">Function</span>,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val)</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal)</span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2、订阅器-Dep-实现">6.2、订阅器 Dep 实现<a class="anchor" href="#6-2、订阅器-Dep-实现">·</a></h3><ul><li><p>订阅器<code>Dep</code> 是整个 <code>getter</code> 依赖收集的核心，它的定义在 <code>src/core/observer/dep.js</code> 中：</p></li><li><p>特别注意的是它有一个静态属性 <code>target</code>，这是一个全局唯一 <code>Watcher</code>，这是一个非常巧妙的设计，因为在同一时间只能有一个全局的 <code>Watcher</code> 被计算，</p></li><li><p>另外它的自身属性 <code>subs</code> 也是 <code>Watcher</code> 的数组。<code>Dep</code> 实际上就是对 <code>Watcher</code> 的一种管理，<code>Dep</code> 脱离 <code>Watcher</code> 单独存在是没有意义的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">target</span>: ?<span class="title class_">Watcher</span>;</span><br><span class="line">  <span class="attr">id</span>: number;</span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Watcher</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">      subs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3、订阅者-Watcher-实现">6.3、订阅者 Watcher 实现<a class="anchor" href="#6-3、订阅者-Watcher-实现">·</a></h3><ul><li><p>订阅者<code>Watcher</code> 的一些相关实现，它的定义在 <code>src/core/observer/watcher.js</code> 中</p></li><li><h4 id="实现过程：">实现过程：<a class="anchor" href="#实现过程：">·</a></h4><p><code>Watcher</code> 是一个 <code>Class</code>，在它的构造函数中，定义了一些和 <code>Dep</code> 相关的属性 ，其中，<code>this.deps</code> 和 <code>this.newDeps</code> 表示 <code>Watcher</code> 实例持有的 <code>Dep</code> 实例的数组；而 <code>this.depIds</code> 和 <code>this.newDepIds</code> 分别代表 <code>this.deps</code> 和 <code>this.newDeps</code> 的 <code>id</code> Set 。当我们去实例化一个渲染 <code>watcher</code> 的时候</p><ol><li><p>首先进入 <code>watcher</code> 的构造函数逻辑，然后会执行它的 <code>this.get()</code> 方法，进入 <code>get</code> 函数，首先会执行：把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code> 并压栈（为了恢复用）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushTarget(this)</span><br></pre></td></tr></table></figure></li><li><p>触发了数据对象的 <code>getter</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value = this.getter.call(vm, vm)</span><br></pre></td></tr></table></figure></li><li><p>每个对象值的 <code>getter</code> 都持有一个 <code>dep</code>，在触发 <code>getter</code> 的时候会调用 <code>dep.depend()</code> 方法，也就会执行 <code>Dep.target.addDep(this)</code>。这个时候 <code>Dep.target</code> 已经被赋值为渲染 <code>watcher</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  const id = dep.id</span><br><span class="line">  if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">    this.newDepIds.add(id)</span><br><span class="line">    this.newDeps.push(dep)</span><br><span class="line">    if (!this.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，那么就会执行 <code>this.subs.push(sub)</code></li><li>所以在 <code>vm._render()</code> 过程中，会触发所有数据的 <code>getter</code>，这样实际上已经完成了一个依赖收集的过程。</li></ul></li><li><p>当我们在组件中对响应的数据做了修改，就会触发 <code>setter</code> 的逻辑，最后调用 <code>watcher</code> 中的 <code>update</code> 方法：对于 <code>Watcher</code> 的不同状态，会执行不同的更新逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="3类watcher：">3类watcher：<a class="anchor" href="#3类watcher：">·</a></h4><ol><li><p><code>normal-watcher</code>：在组件钩子函数<code>watch</code>中定义，即监听的属性改变了，都会触发定义好的回调函数</p></li><li><p><code>computed-watcher</code>：在组件钩子函数<code>computed</code>中定义的，每一个<code>computed</code>属性，最后都会生成一个对应的<code>Watcher</code>对象</p><p>特点：当计算属性依赖的数据改变时，才会重新计算，即具备<code>lazy</code>（懒计算）特性</p></li><li><p><code>render-watcher</code>：每一个组件都会有一个<code>render-watcher</code>, 当<code>data/computed</code>中的属性改变的时候，会调用该<code>Watcher</code>来更新组件的视图。</p></li></ol><p>**执行顺序：**computed-render ---------&gt; normal-watcher ------&gt; render-watcher</p><ul><li>目的：尽可能的保证，在更新组件视图的时候，computed 属性已经是最新值了，如果 render-watcher 排在 computed-render 前面，就会导致页面更新的时候 computed 值为旧数据</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>;</span><br><span class="line">  <span class="attr">expression</span>: string;</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">Function</span>;</span><br><span class="line">  <span class="attr">id</span>: number;</span><br><span class="line">  <span class="attr">deep</span>: boolean;</span><br><span class="line">  <span class="attr">user</span>: boolean;</span><br><span class="line">  <span class="attr">lazy</span>: boolean;</span><br><span class="line">  <span class="attr">sync</span>: boolean;</span><br><span class="line">  <span class="attr">dirty</span>: boolean;</span><br><span class="line">  <span class="attr">active</span>: boolean;</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">newDeps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">depIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">  <span class="attr">newDepIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">  <span class="attr">before</span>: ?<span class="title class_">Function</span>;</span><br><span class="line">  <span class="attr">getter</span>: <span class="title class_">Function</span>;</span><br><span class="line">  <span class="attr">value</span>: any;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: ?<span class="title class_">Object</span>,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm.<span class="property">_watcher</span> = <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm.<span class="property">_watchers</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = !!options.<span class="property">deep</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sync</span> = !!options.<span class="property">sync</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">before</span> = options.<span class="property">before</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = <span class="variable language_">this</span>.<span class="property">user</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> = <span class="variable language_">this</span>.<span class="property">sync</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expression</span> = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      ? expOrFn.<span class="title function_">toString</span>()</span><br><span class="line">      : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = noop</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span></span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line">   。。。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的虚拟DOM</title>
      <link href="/posts/4285860800.html"/>
      <url>/posts/4285860800.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟DOM">虚拟DOM<a class="anchor" href="#虚拟DOM">·</a></h1><ul><li><h3 id="脉络：从初始化-Vue-到最终渲染的整个过程">脉络：从初始化 <code>Vue</code> 到最终渲染的整个过程<a class="anchor" href="#脉络：从初始化-Vue-到最终渲染的整个过程">·</a></h3><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e2486c7e0ed7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 67%;" /></li><li><p>什么是<code>Virtual DOM</code></p></li><li><p>为什么需要 <code>Virtual DOM</code></p></li><li><p>以及 <code>Virtual DOM</code>的具体实现</p></li></ul><h2 id="一、真实DOM和其解析流程">一、真实<code>DOM</code>和其解析流程<a class="anchor" href="#一、真实DOM和其解析流程">·</a></h2><p>下图为 <code>webkit</code> 渲染引擎工作流程图</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e10922325215?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>所有的浏览器渲染引擎工作流程大致分为5步：创建 <code>DOM</code> 树 —&gt; 创建 <code>Style Rules</code> -&gt; 构建 <code>Render</code> 树 —&gt; 布局 <code>Layout</code> -—&gt; 绘制 <code>Painting</code>。</p><ul><li>第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；</li><li>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；</li><li>第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；</li><li>第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；</li><li>第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。</li></ul><p><strong>注意点：</strong></p><p><strong>1、<code>DOM</code> 树的构建是文档加载完成开始的？</strong></p><p>​构建 <code>DOM</code> 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 <code>HTML</code> 文档解析完成之后才开始构建 <code>render</code> 树和布局。</p><p><strong>2、<code>Render</code> 树是 <code>DOM</code> 树和 <code>CSS</code> 样式表构建完毕后才开始构建的？</strong></p><p>​这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。</p><p><strong>3、<code>CSS</code> 的解析注意点？</strong></p><p>​<code>CSS</code> 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。</p><p><strong>4、<code>JS</code> 操作真实 <code>DOM</code> 的代价？</strong></p><ul><li>传统的开发模式：原生 <code>JS</code> 操作 <code>DOM</code> 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 <code>DOM</code> 节点，浏览器收到第一个 <code>DOM</code> 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。</li><li>例如，第一次计算完，紧接着下一个 <code>DOM</code> 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 <code>DOM</code> 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 <code>DOM</code> 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验</li></ul><h2 id="二、Virtual-DOM-基础">二、<code>Virtual-DOM</code> 基础<a class="anchor" href="#二、Virtual-DOM-基础">·</a></h2><h3 id="2-1、虚拟-DOM-的好处">2.1、虚拟 <code>DOM</code> 的好处<a class="anchor" href="#2-1、虚拟-DOM-的好处">·</a></h3><ul><li>为了解决浏览器性能问题而被设计出来的</li><li>若一次操作中有 10 次更新 <code>DOM</code> 的动作，虚拟 <code>DOM</code> 不会立即操作 <code>DOM</code>，而是将这 10 次更新的 <code>diff</code> 内容保存到本地一个 <code>JS</code> 对象中，最终将这个 <code>JS</code> 对象一次性 <code>attch</code> 到 <code>DOM</code> 树上，再进行后续操作，避免大量无谓的计算量</li><li>好处是，页面的更新可以先全部反映在 <code>JS</code> 对象(虚拟 <code>DOM</code> )上，操作内存中的 <code>JS</code> 对象的速度显然要更快，等更新完成后，再将最终的 <code>JS</code> 对象映射成真实的 <code>DOM</code>，交由浏览器去绘制。</li></ul><h3 id="2-2、算法实现">2.2、算法实现<a class="anchor" href="#2-2、算法实现">·</a></h3><h4 id="2-2-1、用-JS-对象模拟-DOM-树">2.2.1、用 <code>JS</code> 对象模拟 <code>DOM</code> 树<a class="anchor" href="#2-2-1、用-JS-对象模拟-DOM-树">·</a></h4><h5 id="（1）如何用-JS-对象模拟-DOM-树？"><strong>（1）如何用 <code>JS</code> 对象模拟 <code>DOM</code> 树？</strong><a class="anchor" href="#（1）如何用-JS-对象模拟-DOM-树？">·</a></h5><ul><li><p><strong>做法：<strong>调用</strong>createElement</strong>函数：内部实例化<strong>Element</strong>类，并在实例化时将参数传入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Element</span>(<span class="params">tagName, props, children</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tagName</span> = tagName</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span> = props</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(props.<span class="property">key</span>)&#123;  <span class="comment">// dom 元素的 key 值，用作唯一标识符</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">key</span> = props.<span class="property">key</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    children.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">child, i</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> <span class="title class_">Element</span>) &#123;</span><br><span class="line">            count += child.<span class="property">count</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            children[i] = <span class="string">&#x27;&#x27;</span> + child</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 子元素个数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tagName, props, children</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Element</span>(tagName, props, children);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = createElement;</span><br></pre></td></tr></table></figure></li><li><p>例如：一个真实的 <code>DOM</code> 节点如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;virtual-dom&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Virtual DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure><p>根据 <code>element</code> 对象的设定，则上面的 <code>DOM</code> 结构就可以简单表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">&quot;./element.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ul = <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="attr">id</span>:<span class="string">&#x27;virtual-dom&#x27;</span>&#125;,[</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;list&#x27;</span> &#125;, [</span><br><span class="line"><span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line"><span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line"><span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">]) </span><br></pre></td></tr></table></figure><p>现在 <code>ul</code> 就是我们用 <code>JavaScript</code> 对象表示的 <code>DOM</code> 结构，我们输出查看 <code>ul</code> 对应的数据结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e14fcff074f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><h5 id="（2）渲染用-JS-表示的-DOM-对象"><strong>（2）渲染用 <code>JS</code> 表示的 <code>DOM</code> 对象</strong><a class="anchor" href="#（2）渲染用-JS-表示的-DOM-对象">·</a></h5><p>此时页面上并没有这个结构，如何将 <code>ul</code> 渲染成页面上真实的 <code>DOM</code> 结构？</p><ul><li><p>**做法：**调用Element原型上面的render函数，会根据 <code>tagName</code> 构建一个真正的 <code>DOM</code> 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render 将virdual-dom 对象渲染为实际 DOM 元素</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>)</span><br><span class="line">    <span class="keyword">var</span> props = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">    <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="keyword">var</span> propValue = props[propName]</span><br><span class="line">        el.<span class="title function_">setAttribute</span>(propName, propValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> children = <span class="variable language_">this</span>.<span class="property">children</span> || []</span><br><span class="line">    children.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">child</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> childEl = (child <span class="keyword">instanceof</span> <span class="title class_">Element</span>)</span><br><span class="line">            ? child.<span class="title function_">render</span>() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">            : <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child) <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">        el.<span class="title function_">appendChild</span>(childEl)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>接上面的例子：将构建好的 <code>DOM</code> 结构添加到页面 <code>body</code> 上面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ulRoot = ul.<span class="title function_">render</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(ulRoot);</span><br></pre></td></tr></table></figure><p>这样，页面 <code>body</code> 里面就有真正的 <code>DOM</code> 结构，效果如下图所示：</p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e179a748d425?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /></li></ul><h4 id="2-2-2、比较两棵虚拟-DOM-树的差异-—-diff-算法">2.2.2、比较两棵虚拟 <code>DOM</code> 树的差异 — <code>diff</code> 算法<a class="anchor" href="#2-2-2、比较两棵虚拟-DOM-树的差异-—-diff-算法">·</a></h4><ul><li><p>复杂度：</p><ul><li><p>如果需要两棵树的完全比较，时间复杂度为<code>O(n^3)</code>。</p></li><li><p>但是在前端当中，你很少会跨越层级地移动 <code>DOM</code> 元素，所以 <code>Virtual DOM</code> 只会对同一个层级的元素进行对比</p></li><li><p>这样算法复杂度就可以达到 <code>O(n)</code>。</p></li></ul></li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e26a5ecf086e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 33%;" /><h5 id="（1）深度优先遍历，记录差异"><strong>（1）深度优先遍历，记录差异</strong><a class="anchor" href="#（1）深度优先遍历，记录差异">·</a></h5><ul><li>对<strong>新旧两棵树</strong>进行一个深度优先的遍历，每遍历到一个节点就把该节点和新的的树进行对比，如果有差异的话就记录到一个对象里面。这样每个节点都会有一个唯一的标记：</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2873e42b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dfs-walk" style="zoom: 33%;" /><ul><li><p><strong>diff函数 —&gt; dfsWalk函数：</strong></p><ol><li><p>判断新旧节点是否都是string类型：是，比较新旧文本内容是否相等？</p><ul><li>否：currentPatch数组中push一个对象，它内部标记为Text类型，实现替换文本内容</li></ul></li><li><p>否则，标签名+key值是否均相同：是，调用diffProps比较节点属性是否相等？</p><ul><li>否：currentPatch里push一个对象(将新节点的属性替换旧节点属性)</li><li>是（相等）：比较没有ignore属性的子节点：diffChildren，传入节点的children</li></ul></li><li><p>否则，如果新节点不为空：</p><p>currentPatch数组中push一个对象，类型为REPLACE，将来直接替换</p></li><li><p>函数最后：</p><p>将currentPatch数组赋值给patches对象上，patches这个对象就记录了所有节点的差异</p></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diff 函数，对比两棵树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">diff</span>(<span class="params">oldTree, newTree</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span> <span class="comment">// 当前节点的标志</span></span><br><span class="line">  <span class="keyword">var</span> patches = &#123;&#125; <span class="comment">// 用来记录每个节点差异的对象</span></span><br><span class="line">  <span class="title function_">dfsWalk</span>(oldTree, newTree, index, patches)</span><br><span class="line">  <span class="keyword">return</span> patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两棵树进行深度优先遍历</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dfsWalk</span>(<span class="params">oldNode, newNode, index, patches</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentPatch = []</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (oldNode) === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> (newNode) === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 文本内容改变</span></span><br><span class="line">    <span class="keyword">if</span> (newNode !== oldNode) &#123;</span><br><span class="line">      currentPatch.<span class="title function_">push</span>(&#123; <span class="attr">type</span>: patch.<span class="property">TEXT</span>, <span class="attr">content</span>: newNode &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode!=<span class="literal">null</span> &amp;&amp; oldNode.<span class="property">tagName</span> === newNode.<span class="property">tagName</span> &amp;&amp; oldNode.<span class="property">key</span> === newNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 节点相同，比较属性</span></span><br><span class="line">    <span class="keyword">var</span> propsPatches = <span class="title function_">diffProps</span>(oldNode, newNode)</span><br><span class="line">    <span class="keyword">if</span> (propsPatches) &#123;</span><br><span class="line">      currentPatch.<span class="title function_">push</span>(&#123; <span class="attr">type</span>: patch.<span class="property">PROPS</span>, <span class="attr">props</span>: propsPatches &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较子节点，如果子节点有&#x27;ignore&#x27;属性，则不需要比较</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isIgnoreChildren</span>(newNode)) &#123;</span><br><span class="line">      <span class="title function_">diffChildren</span>(</span><br><span class="line">        oldNode.<span class="property">children</span>,</span><br><span class="line">        newNode.<span class="property">children</span>,</span><br><span class="line">        index,</span><br><span class="line">        patches,</span><br><span class="line">        currentPatch</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(newNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 新节点和旧节点不同，用 replace 替换</span></span><br><span class="line">    currentPatch.<span class="title function_">push</span>(&#123; <span class="attr">type</span>: patch.<span class="property">REPLACE</span>, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatch.<span class="property">length</span>) &#123;</span><br><span class="line">    patches[index] = currentPatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从以上可以得出，<code>patches[1]</code> 表示 <code>p</code> ，<code>patches[3]</code> 表示 <code>ul</code> ，以此类推。</p><h5 id="（2）差异类型"><strong>（2）差异类型</strong><a class="anchor" href="#（2）差异类型">·</a></h5><p><code>DOM</code> 操作导致的差异类型包括以下几种：</p><ul><li>节点替换：节点改变了，例如将上面的 <code>div</code> 换成 <code>h1</code>;</li><li>顺序互换：移动、删除、新增子节点，例如上面 <code>div</code> 的子节点，把 <code>p</code> 和 <code>ul</code> 顺序互换；</li><li>属性更改：修改了节点的属性，例如把上面 <code>li</code> 的 <code>class</code> 样式类删除；</li><li>文本改变：改变文本节点的文本内容，例如将上面 <code>p</code> 节点的文本内容更改为 “<code>Real Dom</code>”；</li></ul><p>以上描述的几种差异类型在代码中定义如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var REPLACE = 0 // 替换原先的节点</span><br><span class="line">var REORDER = 1 // 重新排序</span><br><span class="line">var PROPS = 2 // 修改了节点的属性</span><br><span class="line">var TEXT = 3 // 文本内容改变 </span><br></pre></td></tr></table></figure><h5 id="（3）列表对比算法-不要主动提"><strong>（3）列表对比算法</strong>                   不要主动提<a class="anchor" href="#（3）列表对比算法-不要主动提">·</a></h5><ul><li><p>**问题：**同层级交换了位置，如何更高效的对比？</p><p>如果按照同层级的话，会全部被替换掉，开销大，实际只需要移动即可。</p><ul><li>将这个问题抽象出来其实就是<strong>字符串的最小编辑距离问题</strong>，最常见的解决方法是 <code>Levenshtein Distance</code> 。它是一个度量两个字符序列之间差异的字符串度量标准，通过<strong>动态规划</strong>求解，时间复杂度为 <code>O(M*N)</code></li></ul></li><li><p>具体求解过程：</p></li></ul><h5 id="（4）实例输出"><strong>（4）实例输出</strong><a class="anchor" href="#（4）实例输出">·</a></h5><ul><li>两个虚拟 <code>DOM</code> 对象如下图所示，其中 <code>ul1</code> 表示原有的虚拟 <code>DOM</code> 树，<code>ul2</code> 表示改变后的虚拟 <code>DOM</code> 树</li><li>通过差异对象patches，两个虚拟 <code>DOM</code> 对象之间进行了哪些变化，从而更改原先的真实 <code>DOM</code> 结构，从而将页面的 <code>DOM</code> 结构进行更改</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul1 = <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;virtual-dom&#x27;</span>&#125;,[</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;list&#x27;</span> &#125;, [</span><br><span class="line"><span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line"><span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line"><span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">]) </span><br><span class="line"><span class="keyword">var</span> ul2 = <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;virtual-dom&#x27;</span>&#125;,[</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;list&#x27;</span> &#125;, [</span><br><span class="line"><span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 21&#x27;</span>]),</span><br><span class="line"><span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 23&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">]) </span><br><span class="line"><span class="keyword">var</span> patches = <span class="title function_">diff</span>(ul1,ul2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;patches:&#x27;</span>,patches);</span><br></pre></td></tr></table></figure><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e1a5bff0b71a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /><h4 id="2-2-3、将两个虚拟-DOM-对象的差异应用到真正的-DOM-树">2.2.3、将两个虚拟 <code>DOM</code> 对象的差异应用到真正的 <code>DOM</code> 树<a class="anchor" href="#2-2-3、将两个虚拟-DOM-对象的差异应用到真正的-DOM-树">·</a></h4><h5 id="（1）深度优先遍历-DOM-树"><strong>（1）深度优先遍历 <code>DOM</code> 树</strong><a class="anchor" href="#（1）深度优先遍历-DOM-树">·</a></h5><p>​遍历的时候从步骤二生成的 <code>patches</code> 对象中找出当前遍历的节点差异，如下相关代码所示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span> (node, patches) &#123;</span><br><span class="line">  <span class="keyword">var</span> walker = &#123;<span class="attr">index</span>: <span class="number">0</span>&#125;</span><br><span class="line">  <span class="title function_">dfsWalk</span>(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dfsWalk</span> (node, walker, patches) &#123;</span><br><span class="line">  <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line">  <span class="keyword">var</span> currentPatches = patches[walker.<span class="property">index</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = node.<span class="property">childNodes</span></span><br><span class="line">    ? node.<span class="property">childNodes</span>.<span class="property">length</span></span><br><span class="line">    : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 深度遍历子节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = node.<span class="property">childNodes</span>[i]</span><br><span class="line">    walker.<span class="property">index</span>++</span><br><span class="line">    <span class="title function_">dfsWalk</span>(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">    <span class="title function_">applyPatches</span>(node, currentPatches)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="（2）对原有-DOM-树进行-DOM-操作"><strong>（2）对原有 <code>DOM</code> 树进行 <code>DOM</code> 操作</strong><a class="anchor" href="#（2）对原有-DOM-树进行-DOM-操作">·</a></h5><ul><li>根据不同类型的差异对当前节点进行不同的 <code>DOM</code> 操作</li><li>如果进行了节点替换，就进行节点替换 <code>DOM</code> 操作；如果节点文本发生了改变，则进行文本替换的 <code>DOM</code> 操作；以及子节点重排、属性改变等 <code>DOM</code> 操作</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyPatches</span> (node, currentPatches) &#123;</span><br><span class="line">  currentPatches.<span class="title function_">forEach</span>(<span class="function"><span class="params">currentPatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REPLACE</span>:</span><br><span class="line">        <span class="keyword">var</span> newNode = (<span class="keyword">typeof</span> currentPatch.<span class="property">node</span> === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">          ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(currentPatch.<span class="property">node</span>)</span><br><span class="line">          : currentPatch.<span class="property">node</span>.<span class="title function_">render</span>()</span><br><span class="line">        node.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(newNode, node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REORDER</span>:</span><br><span class="line">        <span class="title function_">reorderChildren</span>(node, currentPatch.<span class="property">moves</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="attr">PROPS</span>:</span><br><span class="line">        <span class="title function_">setProps</span>(node, currentPatch.<span class="property">props</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="attr">TEXT</span>:</span><br><span class="line">        node.<span class="property">textContent</span> = currentPatch.<span class="property">content</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unknown patch type &#x27;</span> + currentPatch.<span class="property">type</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="（3）DOM结构改变"><strong>（3）DOM结构改变</strong><a class="anchor" href="#（3）DOM结构改变">·</a></h5><ul><li>通过将第 2.2.2 得到的两个 <code>DOM</code> 对象之间的差异，应用到第一个（原先）<code>DOM</code> 结构中，我们可以看到 <code>DOM</code> 结构进行了预期的变化，如下图所示：</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e1ae714e9779?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 67%;" /><h3 id="2-3、总结流程">2.3、总结流程<a class="anchor" href="#2-3、总结流程">·</a></h3><p><code>Virtual DOM</code> 算法主要实现上面三个步骤来实现：</p><ul><li><p>用 <code>JS</code> 对象模拟 <code>DOM</code> 树 — <code>element.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;virtual-dom&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Virtual DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure></li><li><p>比较两棵虚拟 <code>DOM</code> 树的差异 — <code>diff.js</code></p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e1bb518a2951?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /></li><li><p>将两个虚拟 <code>DOM</code> 对象的差异应用到真正的 <code>DOM</code> 树 — <code>patch.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyPatches</span> (node, currentPatches) &#123;</span><br><span class="line">  currentPatches.<span class="title function_">forEach</span>(<span class="function"><span class="params">currentPatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REPLACE</span>:</span><br><span class="line">        <span class="keyword">var</span> newNode = (<span class="keyword">typeof</span> currentPatch.<span class="property">node</span> === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">          ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(currentPatch.<span class="property">node</span>)</span><br><span class="line">          : currentPatch.<span class="property">node</span>.<span class="title function_">render</span>()</span><br><span class="line">        node.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(newNode, node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REORDER</span>:</span><br><span class="line">        <span class="title function_">reorderChildren</span>(node, currentPatch.<span class="property">moves</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="attr">PROPS</span>:</span><br><span class="line">        <span class="title function_">setProps</span>(node, currentPatch.<span class="property">props</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="attr">TEXT</span>:</span><br><span class="line">        node.<span class="property">textContent</span> = currentPatch.<span class="property">content</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unknown patch type &#x27;</span> + currentPatch.<span class="property">type</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h2 id="三、Virtual-DOM-源码简析">三、<code>Virtual-DOM</code>  源码简析<a class="anchor" href="#三、Virtual-DOM-源码简析">·</a></h2><h3 id="3-1、VNode-模拟-DOM-树">3.1、<code>VNode</code> 模拟 <code>DOM</code> 树<a class="anchor" href="#3-1、VNode-模拟-DOM-树">·</a></h3><h4 id="3-1-1、VNode-类简析"><strong>3.1.1、<code>VNode</code> 类简析</strong><a class="anchor" href="#3-1-1、VNode-类简析">·</a></h4><ul><li><p>在 <code>Vue.js</code> 中，<code>Virtual DOM</code> 是用 <code>VNode</code> 这个 <code>Class</code> 去描述，它定义在 <code>src/core/vdom/vnode.js</code> 中</p></li><li><p>实际上 <code>Vue.js</code> 中 <code>Virtual DOM</code> 是借鉴了一个开源库  <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsnabbdom%2Fsnabbdom">snabbdom</a> 的实现，然后加入了一些 <code>Vue.js</code> 的一些特性。</p></li><li><h4 id="核心属性：">核心属性：<a class="anchor" href="#核心属性：">·</a></h4><ul><li><code>tag</code> 属性即这个<code>vnode</code>的标签属性</li><li><code>data</code> 属性包含了最后渲染成真实<code>dom</code>节点后，节点上的<code>class</code>，<code>attribute</code>，<code>style</code>以及绑定的事件</li><li><code>children</code> 属性是<code>vnode</code>的子节点</li><li><code>text</code> 属性是文本属性</li><li><code>elm</code> 属性为这个<code>vnode</code>对应的真实<code>dom</code>节点</li><li><code>key</code> 属性是<code>vnode</code>的标记，在<code>diff</code>过程中可以提高<code>diff</code>的效率</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="attr">tag</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">ns</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">key</span>: string | number | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态属性非常多，此处省略</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">    children?: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: <span class="title class_">Node</span>,</span><br><span class="line">    context?: <span class="title class_">Component</span>,</span><br><span class="line">    componentOptions?: <span class="title class_">VNodeComponentOptions</span>,</span><br><span class="line">    asyncFactory?: <span class="title class_">Function</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elm</span> = elm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnContext</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnOptions</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnScopeId</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = data &amp;&amp; data.<span class="property">key</span></span><br><span class="line">   <span class="comment">// 省略属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2、创建-VNode-过程">3.1.2、创建 <code>VNode</code> 过程<a class="anchor" href="#3-1-2、创建-VNode-过程">·</a></h4><h5 id="（1）初始化vue">（1）初始化vue<a class="anchor" href="#（1）初始化vue">·</a></h5><ul><li><code>new Vue( )</code> 时，实际上是执行 <code>src/core/instance/index.js</code> 中定义的 <code>Function</code> 函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内部调用 <code>this._init</code> 方法，该方法在 <code>src/core/instance/init.js</code> 中定义</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略一系列其它初始化的代码</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;vm.$options.el:&#x27;</span>,vm.<span class="property">$options</span>.<span class="property">el</span>);</span><br><span class="line">    vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）Vue-实例挂载"><strong>（2）<code>Vue</code> 实例挂载</strong><a class="anchor" href="#（2）Vue-实例挂载">·</a></h5><ul><li><code>Vue</code> 中是通过 <code>$mount</code> 实例方法去挂载 <code>dom</code> 的，下面我们通过分析 <code>compiler</code> 版本的 <code>mount</code> 实现，相关源码在目录 <code>src/platforms/web/entry-runtime-with-compiler.js</code> 文件中定义：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span></span><br><span class="line"><span class="comment">// 重写</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 省略一系列初始化以及逻辑判断代码  </span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现最终还是调用用原先原型上的 <code>$mount</code> 方法挂载 ，原先原型上的 <code>$mount</code> 方法在 <code>src/platforms/web/runtime/index.js</code> 中定义 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现<code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，这个方法定义在 <code>src/core/instance/lifecycle.js</code> 文件中：</p><ul><li><code>mountComponent</code> 核心就是先实例化一个渲染<code>Watcher</code>，在它的回调函数中会调用 <code>updateComponent</code> 方法</li><li>在此方法中调用 <code>vm._render</code> 方法先生成虚拟 Node，最终调用 <code>vm._update</code> 更新 <code>DOM</code>。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 省略一系列其它代码</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成虚拟 vnode   </span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="comment">// 更新 DOM</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  </span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）创建虚拟-Node"><strong>（3）创建虚拟 Node</strong><a class="anchor" href="#（3）创建虚拟-Node">·</a></h5><ul><li><code>Vue</code> 的 <code>_render</code> 方法是实例的一个私有方法，<strong>它用来把实例渲染成一个虚拟 <code>Node</code></strong>。它的定义在 <code>src/core/instance/render.js</code> 文件中：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span>;</span><br><span class="line">   <span class="keyword">let</span> vnode</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 省略一系列代码  </span></span><br><span class="line">     currentRenderingInstance = vm;</span><br><span class="line">     <span class="comment">// 调用 createElement 方法来返回 vnode</span></span><br><span class="line">     vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="title function_">handleError</span>(<span class="params">e, vm, <span class="string">`render`</span></span>)&#123;&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// set parent</span></span><br><span class="line">   vnode.<span class="property">parent</span> = _parentVnode;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vnode...:&quot;</span>,vnode);</span><br><span class="line">   <span class="keyword">return</span> vnode</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>Vue.js</code> 利用 <code>_createElement</code> 方法创建 <code>VNode</code>，它定义在 <code>src/core/vdom/create-elemenet.js</code> 中：<code>_createElement</code> 方法有 5 个参数:<ul><li><code>context</code> 表示 VNode 的上下文环境，它是 <code>Component</code> 类型；</li><li><code>tag</code>表示标签，它可以是一个字符串，也可以是一个 <code>Component</code>；</li><li><code>data</code> 表示 VNode 的数据，它是一个 <code>VNodeData</code> 类型，可以在 <code>flow/vnode.js</code> 中找到它的定义；</li><li><code>children</code> 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 <code>VNode</code> 数组；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  tag?: string | <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span>,</span><br><span class="line">  data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略一系列非主线代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (normalizationType === <span class="variable constant_">ALWAYS_NORMALIZE</span>) &#123;</span><br><span class="line">    <span class="comment">// 场景是 render 函数不是编译生成的</span></span><br><span class="line">    children = <span class="title function_">normalizeChildren</span>(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === <span class="variable constant_">SIMPLE_NORMALIZE</span>) &#123;</span><br><span class="line">    <span class="comment">// 场景是 render 函数是编译生成的</span></span><br><span class="line">    children = <span class="title function_">simpleNormalizeChildren</span>(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">    ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      <span class="comment">// 创建虚拟 vnode</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.<span class="property">pre</span>) &amp;&amp; <span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(ns)) <span class="title function_">applyNS</span>(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) <span class="title function_">registerDeepBindings</span>(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3、实例查看"><strong>3.1.3、实例查看</strong><a class="anchor" href="#3-1-3、实例查看">·</a></h4><ul><li><h5 id="例如，实例化一个-Vue-实例：">例如，实例化一个 <code>Vue</code> 实例：<a class="anchor" href="#例如，实例化一个-Vue-实例：">·</a></h5></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params">createElement</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">        <span class="attr">class</span>: <span class="string">&quot;class_box&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>我们打印出其对应的 <code>VNode</code> 表示：</p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e23b7481b16f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /></li></ul><h3 id="3-2、diff-过程">3.2、<code>diff</code> 过程<a class="anchor" href="#3-2、diff-过程">·</a></h3><h4 id="3-2-1、Vue-js-源码的-diff-调用逻辑">3.2.1、<code>Vue.js</code> 源码的 <code>diff</code> 调用逻辑<a class="anchor" href="#3-2-1、Vue-js-源码的-diff-调用逻辑">·</a></h4><ul><li><code>Vue.js</code> 源码实例化了一个 <code>watcher</code>，这个 ~ 被添加到了在模板当中所绑定变量的依赖当中，一旦 <code>model</code> 中的响应式的数据发生了变化，这些响应式的数据所维护的 <code>dep</code> 数组便会调用 <code>dep.notify()</code> 方法完成所有依赖遍历执行的工作，这包括视图的更新，即 <code>updateComponent</code> 方法的调用。</li><li><code>watcher</code> 和 <code>updateComponent</code>方法定义在  <code>src/core/instance/lifecycle.js</code> 文件中</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 省略一系列其它代码</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成虚拟 vnode   </span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="comment">// 更新 DOM</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  </span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完成视图的更新工作事实上就是调用了<code>vm._update</code>方法，这个方法接收的第一个参数是刚生成的<code>Vnode</code>，调用的<code>vm._update</code>方法定义在 <code>src/core/instance/lifecycle.js</code>中</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">  <span class="keyword">const</span> restoreActiveInstance = <span class="title function_">setActiveInstance</span>(vm)</span><br><span class="line">  vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// 第一个参数为真实的node节点，则为初始化</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果需要diff的prevVnode存在，那么对prevVnode和vnode进行diff</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">restoreActiveInstance</span>()</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.<span class="property">__vue__</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">    vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">    vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个方法当中最为关键的就是 <code>vm.__patch__</code> 方法，这也是整个 <code>virtual-dom</code> 当中最为核心的方法，定义在 <code>src/core/vdom/patch.js</code> 中</li><li>主要完成了<code>prevVnode</code> 和 <code>vnode</code> 的 <code>diff</code> 过程并根据需要操作的 <code>vdom</code> 节点打 <code>patch</code>，最后生成新的真实 <code>dom</code> 节点并完成视图的更新工作。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当oldVnode不存在时，创建新的节点</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      <span class="title function_">createElm</span>(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对oldVnode和vnode进行diff，并对oldVnode打patch  </span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">      &#125; </span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>patch</code> 方法中，我们看到会分为两种情况：<ol><li>当 <code>oldVnode</code> 不存在时，会创建新的节点；</li><li>已经存在 <code>oldVnode</code> ，那么会对 <code>oldVnode</code> 和 <code>vnode</code> 进行 <code>diff</code> 及 <code>patch</code> 的过程</li></ol></li><li><code>patch</code> 过程中会调用 <code>sameVnode</code> 方法来对对传入的2个 <code>vnode</code> 进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个<code>vnode</code> 只是局部发生了更新，然后才会对这2个 <code>vnode</code> 进行 <code>diff</code>，</li><li>如果2个 <code>vnode</code> 的基本属性存在不一致的情况，那么就会直接跳过 <code>diff</code> 的过程，进而依据 <code>vnode</code> 新建一个真实的 <code>dom</code>，同时删除老的 <code>dom</code>节点</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span> (a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp;</span><br><span class="line">    a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;</span><br><span class="line">    a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp;</span><br><span class="line">    <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp;</span><br><span class="line">    <span class="title function_">sameInputType</span>(a, b)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>diff</code> 过程中主要是通过调用 <code>patchVnode</code> 方法进行的:</p><h5 id="老的有，新的没有，直接干掉；老的没有。新的有，添加；老的新的都有，对比子">老的有，新的没有，直接干掉；老的没有。新的有，添加；老的新的都有，对比子<a class="anchor" href="#老的有，新的没有，直接干掉；老的没有。新的有，添加；老的新的都有，对比子">·</a></h5><p>分了好几种情况，<code>oldCh</code> 为 <code>oldVnode</code>的子节点，<code>ch</code> 为 <code>Vnode</code>的子节点：</p><ul><li>首先进行文本节点的判断，若 <code>oldVnode.text !== vnode.text</code>，那么就会直接进行文本节点的替换；</li><li>在<code>vnode</code> 没有文本节点的情况下，进入子节点的 <code>diff</code>；</li><li>当 <code>oldCh</code> 和 <code>ch</code> 都存在且不相同的情况下，调用 <code>updateChildren</code> 对子节点进行 <code>diff</code>；</li><li>若 <code>oldCh</code>不存在，<code>ch</code> 存在，首先清空 <code>oldVnode</code> 的文本节点，同时调用 <code>addVnodes</code> 方法将 <code>ch</code> 添加到<code>elm</code>真实 <code>dom</code> 节点当中；</li><li>若 <code>oldCh</code>存在，<code>ch</code>不存在，则删除 <code>elm</code> 真实节点下的 <code>oldCh</code> 子节点；</li><li>若 <code>oldVnode</code> 有文本节点，而 <code>vnode</code> 没有，那么就清空这个文本节点。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) &#123;</span><br><span class="line">  ...... </span><br><span class="line">  <span class="keyword">const</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> ch = vnode.<span class="property">children</span></span><br><span class="line">  <span class="comment">// 如果vnode没有文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode的children属性存在且vnode的children属性也存在  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="comment">// updateChildren，对子节点进行diff  </span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">checkDuplicateKeys</span>(ch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果oldVnode的text存在，那么首先清空text的内容,然后将vnode的children添加进去  </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 删除elm下的oldchildren</span></span><br><span class="line">      <span class="title function_">removeVnodes</span>(elm, oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) &#123;</span><br><span class="line">      <span class="comment">// oldVnode有子节点，而vnode没有，那么就清空这个节点  </span></span><br><span class="line">      nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素</span></span><br><span class="line">    nodeOps.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2、子节点-diff-流程分析">3.2.2、子节点 <code>diff</code> 流程分析<a class="anchor" href="#3-2-2、子节点-diff-流程分析">·</a></h4><h5 id="（1）Vue-js-源码"><strong>（1）<code>Vue.js</code> 源码</strong><a class="anchor" href="#（1）Vue-js-源码">·</a></h5><ul><li><code>updateChildren</code>方法，它也是整个 <code>diff</code> 过程中最重要的环节，以下为 <code>Vue.js</code> 的源码过程</li><li>**做法：**在开始遍历 <code>diff</code> 前，首先给 <code>oldCh</code>和 <code>newCh</code> 分别分配一个 <code>startIndex</code> 和 <code>endIndex</code> 来作为遍历的索引，当<code>oldCh</code> 或者 <code>newCh</code> 遍历完后(遍历完的条件就是 <code>oldCh</code> 或者 <code>newCh</code> 的 <code>startIndex &gt;= endIndex</code> )，就停止<code>oldCh</code> 和 <code>newCh</code> 的 <code>diff</code> 过程。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">  <span class="comment">// 为oldCh和newCh分别建立索引，为之后遍历的依据</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到oldCh或者newCh被遍历完后跳出循环</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">        : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = <span class="title function_">isUndef</span>(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].<span class="property">elm</span></span><br><span class="line">    <span class="title function_">addVnodes</span>(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    <span class="title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）无-key-的-diff-过程"><strong>（2）无 <code>key</code> 的 <code>diff</code> 过程</strong><a class="anchor" href="#（2）无-key-的-diff-过程">·</a></h5><ul><li>首先从第一个节点开始比较，不管是 <code>oldCh</code> 还是 <code>newCh</code> 的起始或者终止节点都不存在 <code>sameVnode</code> ，同时节点属性中是不带 <code>key</code>标记的，因此第一轮的 <code>diff</code> 完后，<code>newCh</code>的 <code>startVnode</code> 被添加到 <code>oldStartVnode</code>的前面，同时 <code>newStartIndex</code>前移一位；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2878c44dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /><ul><li>第二轮的 <code>diff</code>中，满足 <code>sameVnode(oldStartVnode, newStartVnode)</code>，因此对这2个 <code>vnode</code> 进行<code>diff</code>，最后将 <code>patch</code> 打到 <code>oldStartVnode</code> 上，同时 <code>oldStartVnode</code>和 <code>newStartIndex</code> 都向前移动一位 ；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e28889eaff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /><ul><li>第三轮的 <code>diff</code> 中，满足 <code>sameVnode(oldEndVnode, newStartVnode)</code>，那么首先对 <code>oldEndVnode</code>和<code>newStartVnode</code> 进行 <code>diff</code>，并对 <code>oldEndVnode</code>进行 <code>patch</code>，并完成 <code>oldEndVnode</code> 移位的操作，最后<code>newStartIndex</code>前移一位，<code>oldStartVnode</code> 后移一位；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e289a351b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 50%;" /><ul><li>第四轮的 <code>diff</code>中，过程同步骤3；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e289f9213e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><ul><li>第五轮的 <code>diff</code> 中，同过程1；</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e28aee99a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><ul><li>遍历的过程结束后，<code>newStartIdx &gt; newEndIdx</code>，说明此时 <code>oldCh</code> 存在多余的节点，那么最后就需要将这些多余的节点删除。</li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2ca893b49?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><h5 id="（3）有-key-的-diff-流程"><strong>（3）有 <code>key</code> 的 <code>diff</code> 流程</strong><a class="anchor" href="#（3）有-key-的-diff-流程">·</a></h5><ul><li><p>在 <code>vnode</code> 不带 <code>key</code> 的情况下，每一轮的 <code>diff</code> 过程当中都是<code>起始</code>和<code>结束</code>节点进行比较，直到 <code>oldCh</code> 或者<code>newCh</code> 被遍历完</p></li><li><p>当为 <code>vnode</code> 引入 <code>key</code> 属性后，在每一轮 <code>diff</code> 过程中，当<code>起始</code>和<code>结束</code>节点都没有找到<code>sameVnode</code> 时，然后判断在 <code>newStartVnode</code> 的属性中是否有 <code>key</code>，且是否在 <code>oldKeyToIndx</code> 中找到对应的节点：</p><ul><li>如果不存在这个 <code>key</code>，那么就将这个 <code>newStartVnode</code>作为新的节点创建且插入到原有的 <code>root</code> 的子节点中；</li><li>如果存在这个 <code>key</code>，那么就取出 <code>oldCh</code> 中的存在这个 <code>key</code> 的 <code>vnode</code>，然后再进行 <code>diff</code> 的过；</li></ul></li><li><p>所以：遍历 <code>diff</code> 的过程中，当<strong>起始点</strong>，<strong>结束点</strong>的<strong>搜寻</strong>及 <code>diff</code> 出现还是无法匹配的情况下时，就会用 <code>key</code> 来作为唯一标识，来进行 <code>diff</code>，这样就可以提高 <code>diff</code> 效率</p><p>带有 <code>Key</code>属性的 <code>vnode</code>的 <code>diff</code> 过程可见下图：</p><ol><li><p>首先从第一个节点开始比较，不管是 <code>oldCh</code> 还是 <code>newCh</code> 的起始或者终止节点都不存在 <code>sameVnode</code>，但节点属性中是带 <code>key</code> 标记的， 然后在 <code>oldKeyToIndx</code> 中找到对应的节点，这样第一轮 <code>diff</code> 过后 <code>oldCh</code> 上的<code>B节点</code>被删除了，但是 <code>newCh</code> 上的<code>B节点</code>上 <code>elm</code> 属性保持对 <code>oldCh</code> 上 <code>B节点</code> 的<code>elm</code>引用</p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2db1c4812?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /></li><li><p>第二轮的 <code>diff</code> 中，满足 <code>sameVnode(oldStartVnode, newStartVnode)</code>，因此对这2个 <code>vnode</code> 进行<code>diff</code>，最后将 <code>patch</code> 打到 <code>oldStartVnode</code>上，同时 <code>oldStartVnode</code> 和 <code>newStartIndex</code> 都向前移动一位 ；</p></li></ol></li></ul><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2d7df4fbf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /><p>​3. 第三轮的 <code>diff</code>中，满足 <code>sameVnode(oldEndVnode, newStartVnode)</code>，那么首先对 <code>oldEndVnode</code> 和<code>newStartVnode</code> 进行 <code>diff</code>，并对 <code>oldEndVnode</code> 进行 <code>patch</code>，并完成 <code>oldEndVnode</code> 移位的操作，最后<code>newStartIndex</code> 前移一位，<code>oldStartVnode</code>后移一位；</p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2e2a2835e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom:50%;" /><ol start="4"><li>第四轮的<code>diff</code>中，过程同步骤2；</li></ol><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e2e507aec0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><ol start="5"><li>第五轮的<code>diff</code>中，因为此时 <code>oldStartIndex</code> 已经大于 <code>oldEndIndex</code>，所以将剩余的 <code>Vnode</code> 队列插入队列最后。</li></ol><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e0e3178398fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="å¾çæè¿°" style="zoom: 33%;" /><h3 id="3-3、patch-过程">3.3、<code>patch</code> 过程<a class="anchor" href="#3-3、patch-过程">·</a></h3><p>通过3.2章节介绍的 <code>diff</code> 过程中，我们会看到 <code>nodeOps</code> 相关的方法对真实 <code>DOM</code> 结构进行操作，<code>nodeOps</code> 定义在 <code>src/platforms/web/runtime/node-ops.js</code> 中，其为基本 <code>DOM</code> 操作，这里就不在详细介绍。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElementNS</span> (<span class="attr">namespace</span>: string, <span class="attr">tagName</span>: string): <span class="title class_">Element</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createElementNS</span>(namespaceMap[namespace], tagName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createTextNode</span> (<span class="attr">text</span>: string): <span class="title class_">Text</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComment</span> (<span class="attr">text</span>: string): <span class="title class_">Comment</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createComment</span>(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">insertBefore</span> (<span class="attr">parentNode</span>: <span class="title class_">Node</span>, <span class="attr">newNode</span>: <span class="title class_">Node</span>, <span class="attr">referenceNode</span>: <span class="title class_">Node</span>) &#123;</span><br><span class="line">  parentNode.<span class="title function_">insertBefore</span>(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">removeChild</span> (<span class="attr">node</span>: <span class="title class_">Node</span>, <span class="attr">child</span>: <span class="title class_">Node</span>) &#123;</span><br><span class="line">  node.<span class="title function_">removeChild</span>(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目4:B实习：问题总结篇</title>
      <link href="/posts/265724518.html"/>
      <url>/posts/265724518.html</url>
      
        <content type="html"><![CDATA[<ul><li>这部分文档脱敏处理后再更新吧。。。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目3：购物街项目:问题总结</title>
      <link href="/posts/159855229.html"/>
      <url>/posts/159855229.html</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2020年11月-12月大概</li><li>项目背景： 给师姐做的（首页功能+购物车）</li><li>问题总结篇，比较啰嗦</li></ul><h3 id="1-吸顶效果">1. 吸顶效果<a class="anchor" href="#1-吸顶效果">·</a></h3><p>position属性的特性：5种定位方式</p><ul><li><p><strong>static：</strong>        默认值  正常文档流的位置（从上到下，从左到右）</p><ul><li>浏览器会按照源码的顺序，决定每个元素的位置，这称为&quot;正常的页面流&quot;（normal flow）。每个块级元素占据自己的区块（block），元素与元素之间不产生重叠，这个位置就是元素的默认位置。</li><li><code>static</code>定位所导致的元素位置，是浏览器自主决定的，所以这时<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性无效。</li></ul></li><li><p><strong>relative：</strong>     不脱标， 相对于原本占据的位置，且占用原位置</p></li><li><p><strong>absolute</strong>       脱标   相对于第一个不是static的父元素定位，如果没有，就以html元素为基准</p></li><li><p><strong>fixed：</strong>          脱标        相对于浏览器窗口</p></li><li><p><strong>sticky：</strong>  基于用户的滚动位置来定位，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换</p><ul><li>一般它的行为就像 <strong>position:relative</strong></li><li>而当页面滚动超出目标区域（跨越特定阈值top, right, bottom 或 left 之一）时，它的表现就像 **position:fixed;**它会固定在目标位置</li><li>指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同</li></ul><p>一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的<code>overflow</code> 是 <code>hidden</code>, <code>scroll</code>, <code>auto</code>, 或 <code>overlay</code>时），即便这个祖先不是最近的真实可滚动祖先</p></li></ul><h4 id="1-尝试1：">1. 尝试1：<a class="anchor" href="#1-尝试1：">·</a></h4><ul><li><p>**做法：**position属性为sticky，BScroll的出现让绝对定位失效</p></li><li><p>**失效原因：**bscroll容器内的fixed定位元素就全乱套了</p><ul><li><p>fixed固定定位的元素，如果父亲有transform样式，值不为none，那么fixed就会失效，比如：scale、translate等</p></li><li><p>Better-scroll在滚动中的过程中，会往content上加transform属性。其中Translate属性在滚动的过程中，会不断地改变，所以滚动是通过修改Translate实现的</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">element<span class="selector-class">.style</span> &#123;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">0ms</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>) <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">translateZ</span>(<span class="number">0px</span>);</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.165</span>, <span class="number">0.84</span>, <span class="number">0.44</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bscroll的滚动是用<code>transform</code>的<code>translate</code>来进行偏移，但是父元素设置了transform，所有子元素的position: fixed都不再相对于视口，而是相对于这个transform父元素！这不是什么bug，而是规范中规定。一直以为fixed定位霸道至极，没想到transform可以改变它的定位</p></li><li><p>三种可以修改fixed上文基准的样式属性：</p><ul><li>transform 属性不为 none 的元素perspective 的值不为 none 的元素在 will-change 中指定了任意 css 属性</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#home &#123;</span><br><span class="line">    <span class="comment">/* 如果这里没有44px,轮播图会跑到最上面，他的一部分就会被导航栏遮盖 */</span></span><br><span class="line">   padding-<span class="attr">top</span>: 44px;</span><br><span class="line">  &#125;</span><br><span class="line">  .<span class="property">home</span>-nav &#123;</span><br><span class="line">    <span class="comment">/* 首页上面的导航栏，向下滚动的时候他不要滚动。采用固定定位，一直在最上面 */</span></span><br><span class="line">    <span class="attr">position</span>: fixed;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">right</span>: <span class="number">0</span>;</span><br><span class="line">    z-<span class="attr">index</span>: <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .<span class="property">tab</span>-control &#123;</span><br><span class="line">    <span class="comment">/* 想实现的功能是：页面向下滑，滑到一定高度后，顶部固定 */</span></span><br><span class="line">    <span class="attr">position</span>: sticky;</span><br><span class="line">    <span class="comment">// 距离顶部44px的时候，会变成fixed定位</span></span><br><span class="line">    <span class="attr">top</span>: 44px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-得出总结：">2. 得出总结：<a class="anchor" href="#2-得出总结：">·</a></h4><p>只要组件仍在better-scroll内，就不能由定位实现吸顶</p><h4 id="3-尝试2：">3. 尝试2：<a class="anchor" href="#3-尝试2：">·</a></h4><ul><li><p>复制tab-control2组件，到scroll外面。并用isTabFixed控制这个组件的显隐（v-show），吸顶效果出现的时：true、其他false。<strong>至此吸顶效果实现</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tab-control :titles = &quot;titles&quot; </span><br><span class="line">              class=&quot;tab-control&quot; </span><br><span class="line">              @tabClick= &quot;tabClick&quot;</span><br><span class="line">              :class = &quot;&#123;fixed:isTabFixed&#125;&quot;</span><br><span class="line">              v-show = &quot;isTabFixed&quot;&gt;</span><br><span class="line">&lt;/tab-cotrol&gt;</span><br></pre></td></tr></table></figure></li><li><p>要解决的问题：</p><ol><li><p>如何获取组件2号出现的<strong>位置</strong>：<code>this.$refs.tabcontrol.$el.offsetTop</code></p></li><li><p><strong>何时获取这个数值？</strong></p><p>created不行，dom尚未挂载；mouted也不行，dom挂载但是网络请求的数据可能还没收到，所以要等所有图片数据都加载完毕再获取这个数值。在swiper加载完毕后，监听swiper组件emit的imgload事件，然后回调函数获取offsettop数据</p></li><li><p><strong>位置怎么计算？</strong></p><p>通过scroll组件的emit的scroll事件，回调函数判断position的y值，大于offsettop时，2号组件动态绑定class生效，显示出来</p></li></ol></li></ul><h3 id="2-Vuex管理购物车">2. <strong>Vuex</strong>管理购物车<a class="anchor" href="#2-Vuex管理购物车">·</a></h3><h4 id="1-加购逻辑：">1. 加购逻辑：<a class="anchor" href="#1-加购逻辑：">·</a></h4><ul><li>**用户点击后：**在回调函数中将点击商品的信息携带，并commit到mutation中</li><li><strong>在commit中：</strong><ul><li>取出state中的carList遍历，判断传入的product的iid是否已存在，<ul><li>存在：说明之前已经加购过，此时只需改变对应的数量</li><li>不存在：将这项product对象push到cartList数组中，且count属性赋值1，checked属性为true（这个用于全选购物车商品用，默认添加进购物车就被选中）</li></ul></li></ul></li></ul><h4 id="2-优化">2. 优化<a class="anchor" href="#2-优化">·</a></h4><ul><li><p>为了让mutations能够跟踪</p></li><li><p>为了逻辑不要混合在一起</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&#x27;addCart&#x27;,product)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">   AddCounter(state, payload) &#123;</span><br><span class="line">     payload.count++;</span><br><span class="line">   &#125;,</span><br><span class="line">   AddToCar(state, payload)&#123;</span><br><span class="line">     state.carList.push(payload)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    addCart(context, payload)&#123;</span><br><span class="line">      // 查找，传入参数是函数</span><br><span class="line">      let oldProduct = context.state.carList.find(function(item)&#123;</span><br><span class="line">        return item.iid === payload.iid</span><br><span class="line">      &#125;)</span><br><span class="line">      if (oldProduct) &#123;</span><br><span class="line">        context.commit(&#x27;AddCounter&#x27;, oldProduct)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        payload.count = 1</span><br><span class="line">        context.commit(&#x27;AddToCar&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>选中商品总价计算</strong></li></ul><ul><li><strong>价格：<strong>申明</strong>计算属性totalPrice</strong>，过滤cartList中所有checked属性为true的商品对象，对返回的数组调用reduce方法计算这些商品的总价，对总价数字调用toFixed方法保留两位数，然后‘¥’字符串拼<ul><li><strong>数量：<strong>申明</strong>checkLength计算属性</strong>，对cartList调用filter方法先筛选出checked属性为true的商品，返回的是数组取length属性就OK了</li></ul></li></ul><h3 id="3-图片滚动卡顿EventBus">3. 图片滚动卡顿EventBus<a class="anchor" href="#3-图片滚动卡顿EventBus">·</a></h3><h4 id="1-问题：">1. 问题：<a class="anchor" href="#1-问题：">·</a></h4><ul><li><p>**需求：**当滚到底的时候会发一次请求，新的图片会过来，可以继续向下滚动，不断展示新数据</p></li><li><p><strong>问题：</strong></p><ul><li>当100张图片的数据请求过来后，新的data会concat到data数组中，数据改变Vue页面自动会更新展示新的数据。</li><li>Vue中数据更新是异步的，在数据还没有加载完之前，BScroll是无法获取目标内容容器的高度的</li><li>但是Better-scroll插件并没有refresh，此时当前组件的可滚动区域content变长了，但better-scroll仍然按照原本的高度去计算，出现了滚动卡顿的现象</li></ul></li></ul><h4 id="2-解决过程：">2. 解决过程：<a class="anchor" href="#2-解决过程：">·</a></h4><ul><li><p>**所以根本原因：**BScroll的刷新时机问题，所以应该在图片加载完毕后去重新去refresh，内部重新计算高度</p></li><li><p>**解决：**监听图片加载完，回调函数中，拿到srcoll对象调用refresh方法进行刷新，此时真实可滚动高度   图片的load事件后，刷新</p></li><li><p>**问题：**如何50张图片加载完成与refresh对应起来？    节流</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//home组件：等组件创建完成之后就要监听你的图片是不是加载完成了</span></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 这里的refresh变量不会被销毁，因为被闭包引用</span></span><br><span class="line">   <span class="keyword">const</span> refresh = <span class="variable language_">this</span>.<span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">scroll</span>.<span class="property">refresh</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">//等组件创建完成之后就要监听你的图片是不是加载完成了</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;itemImageLoad&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">scroll</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">scroll</span>.<span class="title function_">refresh</span>();</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、优化点—并发解决">3、优化点—并发解决<a class="anchor" href="#3、优化点—并发解决">·</a></h4><p>这种判断方法过于依赖每个图片本身的加载情况，可以用promise来优化这个过程，通过promise.all来拿到这个加载完成的消息：</p><ul><li><p>在请求完成后，拿到这个数据，也就是url的数组。遍历图片数组，每个都用promise包裹。当图片加载完成，resolve这个promsie</p></li><li><p>在promise.all中拿到这个promise数组的结果</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;/static/img/123.png&quot;</span>,<span class="string">&quot;/static/img/123.png&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callBack</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加载完毕做点啥吧&quot;</span>)</span><br><span class="line">&#125;    </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">handleImgLoad</span>(arr, callBack)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加载图片事件</span></span><br><span class="line"><span class="title function_">handleImgLoad</span>(<span class="params">arr, callBack</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> brr = []</span><br><span class="line">   arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123;</span><br><span class="line">    brr[index] = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> imgReady = <span class="keyword">new</span> <span class="title class_">Image</span></span><br><span class="line">        imgReady.<span class="property">src</span> = item</span><br><span class="line">        imgReady.<span class="property">onload</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="title function_">resolve</span>(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(brr).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(result &amp;&amp; callBack) <span class="title function_">callBack</span>()</span><br><span class="line">   &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加载图片-----&quot;</span>, error)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、图片加载的方式单一">4、图片加载的方式单一<a class="anchor" href="#4、图片加载的方式单一">·</a></h4><ol><li>load事件</li><li>readystatechange事件</li><li>轮询不断监测img的complete属性，如果为true则表明图片已经加载完毕，停止轮询。该属性所有浏览器都支持</li></ol><h2 id="better-scroll的原理-☆☆☆☆">better-scroll的原理     ☆☆☆☆<a class="anchor" href="#better-scroll的原理-☆☆☆☆">·</a></h2><p>https://zhuanlan.zhihu.com/p/27407024</p><h4 id="1-基础">1. 基础<a class="anchor" href="#1-基础">·</a></h4><ul><li>**介绍：**重点解决移动端（已支持 PC）各种滚动场景需求的插件</li><li><strong>浏览器的滚动原理：</strong><ul><li>当页面内容的高度超过视口高度的时候，会出现纵向滚动条；</li><li>当页面内容的宽度超过视口宽度的时候，会出现横向滚动条。</li><li>也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。</li></ul></li></ul><h4 id="2-滚动原理："><strong>2. 滚动原理：</strong><a class="anchor" href="#2-滚动原理：">·</a></h4><img src="http://static.galileo.xiaojukeji.com/static/tms/shield/scroll-4.png" alt="布局" style="zoom:33%;" /><ul><li><p>绿色部分为 wrapper，也就是父容器，它会有<strong>固定的高度</strong>，并且溢出隐藏</p></li><li><p>黄色部分为 content，它是父容器的<strong>第一个子元素</strong>（其他的元素会被忽略，如果里面需要滚动的部分有好几部分。一定要拿一个元素把他包裹起来），它的高度会随着内容的大小而撑高</p></li><li><p>当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，就可以滚动内容区了</p></li><li><p>通过滑动的距离动态改变translate的值来实现，<strong>让它相对于父级移动</strong>，就有了一种滚动的效果，但是这里就又有了下一个坑</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">element<span class="selector-class">.style</span> &#123;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">0ms</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>) <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">translateZ</span>(<span class="number">0px</span>);</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.165</span>, <span class="number">0.84</span>, <span class="number">0.44</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-使用："><strong>3. 使用：</strong><a class="anchor" href="#3-使用：">·</a></h4><ul><li>better-scroll 提供了一个类，实例化的第一个参数是一个原生的 DOM 对象，如果传递的是一个字符串，better-scroll 内部会尝试调用 querySelector 去获取这个 DOM 对象，初始化只需要 new 一个类的实例即可</li><li><strong>better-scroll初始化的时机</strong>很重要：better-scroll 不能滚动的原因多半是初始化 better-scroll 的时机不对，或者是当 DOM 结构变化的时候并没有重新计算 better-scroll<ul><li>因为它在初始化的时候，会计算父元素和子元素的高度和宽度，来决定是否可以纵向和横向滚动</li><li>我们在初始化它的时候，必须确保父元素和子元素的内容已经正确渲染了。如果子元素或者父元素 DOM 结构发生改变的时候，必须重新调用</li><li>因此，scroll.refresh() 方法重新计算来确保滚动效果的正常</li></ul></li></ul><h4 id="4-应用场景">4. 应用场景<a class="anchor" href="#4-应用场景">·</a></h4><h5 id="场景1：基础列表滚动"><strong>场景1：基础列表滚动</strong><a class="anchor" href="#场景1：基础列表滚动">·</a></h5><ul><li><p><strong>vm.$refs</strong> 和<strong>this.$nextTick</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    mounted() &#123;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">1. this.$refs.wrapper拿到这个 DOM 对象</span><br><span class="line">2. 在 mounted钩子函数里，this.$nextTick 的回调函数中初始化 better-scroll</span><br><span class="line">3. 此时wrapper的最新DOM已渲染，可以正确计算它以及它内层 content 的高度，以确保滚动正常</span><br><span class="line">4. 也可以将this.$nextTick换成setTimeout(fn, 20) 也是可以的，每一个 Tick 约为 17 ms，对用户体验而言都是无感知的</span><br></pre></td></tr></table></figure></li></ul><h5 id="场景2：异步数据的处理"><strong>场景2：异步数据的处理</strong><a class="anchor" href="#场景2：异步数据的处理">·</a></h5><ul><li><p>实际工作中，列表的数据往往都是异步获取的，因此初始化 better-scroll 的时机需要在数据获取后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  requestData().then((res) =&gt; &#123;</span><br><span class="line">    this.data = res.data</span><br><span class="line">    this.$nextTick(() =&gt; &#123;</span><br><span class="line">      this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>获取到数据后，通过异步的方式再去初始化 better-scroll</p></li><li><p>因为 Vue 是数据驱动的， Vue 数据发生变化（this.data = res.data）到页面重新渲染是一个异步的过程，我们的初始化时机是要在 DOM 重新渲染后，所以这里用到了 this.$nextTick，当然替换成 setTimeout(fn, 20) 也是可以的</p></li><li><p>为什么这里在 created 这个钩子函数里请求数据而不是放到 mounted 的钩子函数里？</p><p>为 requestData 是发送一个网络请求，这是一个异步过程，当拿到响应数据的时候，Vue 的 DOM 早就已经渲染好了</p><p>但是数据改变 —&gt; DOM 重新渲染仍然是一个异步过程，所以即使在我们拿到数据后，也要异步初始化 better-scroll</p></li></ul></li></ul><h5 id="场景3：数据的动态更新"><strong>场景3：数据的动态更新</strong><a class="anchor" href="#场景3：数据的动态更新">·</a></h5><ul><li><p>实际开发中，除了数据异步获取，还有一些场景可以<strong>动态更新列表中的数据</strong>，比如常见的下拉加载，上拉刷新</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  this.loadData()</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  loadData() &#123;</span><br><span class="line">    requestData().then((res) =&gt; &#123;</span><br><span class="line">      this.data = res.data.concat(this.data)</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        if (!this.scroll) &#123;</span><br><span class="line">          this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span><br><span class="line">          this.scroll.on(&#x27;touchend&#x27;, (pos) =&gt; &#123;</span><br><span class="line">            // 下拉动作</span><br><span class="line">            if (pos.y &gt; 50) &#123;</span><br><span class="line">              this.loadData()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.scroll.refresh()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>滑动列表松开手指时，better-scroll 会对外派发一个 touchend 事件，我们监听了这个事件，并且判断了 pos.y &gt; 50（我们把这个行为定义成一次下拉的动作）</li><li>如果是下拉的话我们会重新请求数据，并且把新的数据和之前的 data 做一次 concat，也就更新了列表的数据，数据的改变就会映射到 DOM 的变化</li><li>这里我们对 this.scroll 做了判断，如果没有初始化过我们会通过 new BScroll 初始化，并且绑定一些事件，否则我们会调用 this.scroll.refresh 方法重新计算，来确保滚动效果的正常。</li></ul></li></ul><h4 id="5-封装">5. 封装<a class="anchor" href="#5-封装">·</a></h4><p>目的解耦合。每个组件都用，对这个框架依赖性太强了。所以先封装，需要的组件只需要引入封装就可以。框架改变时，只需要修改封装就可以，而不需要每个组件都修改。</p><ul><li><p>scroll 组件本质上就是一个可滚动的列表组件，至于列表的 DOM 结构，用什么标签，都不是 scroll 组件关心的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;slot&gt;   &lt;/slot&gt;         //插槽</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li>对 better-scroll 做一层 Vue 的封装，通过 props 的形式，把一些对 better-scroll 定制化的控制权交给父组件；</li><li>通过 methods 暴露的一些方法对 better-scroll 的方法做一层代理；</li><li>通过 watch 传入的 data，当 data 发生改变的时候，在适当的时机调用 refresh 方法重新计算 better-scroll 确保滚动效果正常；</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/ecmascript-6&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">BScroll</span> <span class="keyword">from</span> <span class="string">&#x27;better-scroll&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1 滚动的时候会派发scroll事件，会截流。</span></span><br><span class="line"><span class="comment">       * 2 滚动的时候实时派发scroll事件，不会截流。</span></span><br><span class="line"><span class="comment">       * 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">probeType</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 点击列表是否派发click事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">click</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否开启横向滚动</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">scrollX</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否派发滚动事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">listenScroll</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 列表的数据</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">null</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否派发滚动到底部的事件，用于上拉加载</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">pullup</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否派发顶部下拉的事件，用于下拉刷新</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">pulldown</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 是否派发列表滚动开始的事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">beforeScroll</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 当数据更新后，刷新scroll的延时。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="attr">refreshDelay</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 保证在DOM渲染完毕后初始化better-scroll</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_initScroll</span>()</span><br><span class="line">      &#125;, <span class="number">20</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">_initScroll</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">wrapper</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// better-scroll的初始化</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scroll</span> = <span class="keyword">new</span> <span class="title class_">BScroll</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">wrapper</span>, &#123;</span><br><span class="line">          <span class="attr">probeType</span>: <span class="variable language_">this</span>.<span class="property">probeType</span>,</span><br><span class="line">          <span class="attr">click</span>: <span class="variable language_">this</span>.<span class="property">click</span>,</span><br><span class="line">          <span class="attr">scrollX</span>: <span class="variable language_">this</span>.<span class="property">scrollX</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否派发滚动事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">listenScroll</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="title function_">on</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">(<span class="params">pos</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;scroll&#x27;</span>, pos)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否派发滚动到底部事件，用于上拉加载</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pullup</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="title function_">on</span>(<span class="string">&#x27;scrollEnd&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 滚动到底部</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="property">y</span> &lt;= (<span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="property">maxScrollY</span> + <span class="number">50</span>)) &#123;</span><br><span class="line">              <span class="variable language_">this</span>.$emit(<span class="string">&#x27;scrollToEnd&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否派发顶部下拉事件，用于下拉刷新</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pulldown</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="title function_">on</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="function">(<span class="params">pos</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 下拉动作</span></span><br><span class="line">            <span class="keyword">if</span> (pos.<span class="property">y</span> &gt; <span class="number">50</span>) &#123;</span><br><span class="line">              <span class="variable language_">this</span>.$emit(<span class="string">&#x27;pulldown&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否派发列表滚动开始的事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">beforeScroll</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="title function_">on</span>(<span class="string">&#x27;beforeScrollStart&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;beforeScroll&#x27;</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">refresh</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 代理better-scroll的refresh方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scroll</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="title function_">refresh</span>()</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">scrollTo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 代理better-scroll的scrollTo方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scroll</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="property">scrollTo</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">scroll</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">scrollToElement</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 代理better-scroll的scrollToElement方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scroll</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">scroll</span>.<span class="property">scrollToElement</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">scroll</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="comment">// 监听数据的变化，延时refreshDelay时间后调用refresh方法重新计算，保证滚动效果正常</span></span><br><span class="line">      <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">refresh</span>()</span><br><span class="line">        &#125;, <span class="variable language_">this</span>.<span class="property">refreshDelay</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>使用：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">scroll</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">:pulldown</span>=<span class="string">&quot;pulldown&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          @<span class="attr">pulldown</span>=<span class="string">&quot;loadData&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in data&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loading-wrapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">scroll</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">BScroll</span> <span class="keyword">from</span> <span class="string">&#x27;better-scroll&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>: [],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">pulldown</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">loadData</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">loadData</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">requestData</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">data</span> = res.<span class="property">data</span>.<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">data</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="toast插件封装">toast插件封装<a class="anchor" href="#toast插件封装">·</a></h2><h3 id="1-index-js定义">1. index.js定义<a class="anchor" href="#1-index-js定义">·</a></h3><ul><li>导入对应的组件</li><li>创建当前的插件对象</li><li>定义装载方法install</li><li>暴露插件对象</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//导入组件</span><br><span class="line">import Toast from &#x27;./Toast&#x27;</span><br><span class="line"></span><br><span class="line">const obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// install方法：main.js里面的Vue.use(toast)本质会来调用这里的install方法，执行这个函数</span><br><span class="line">obj.install = function(Vue) &#123;</span><br><span class="line">    // 1.创建组件构造器</span><br><span class="line">    const toastConstructor = Vue.extend(Toast)</span><br><span class="line"></span><br><span class="line">    // 2.new一个组件对象</span><br><span class="line">    const toast = new toastConstructor()</span><br><span class="line"></span><br><span class="line">    // 3.toast.$mount函数将组件对象手动挂载到某个元素上</span><br><span class="line">    toast.$mount(document.createElement(&#x27;div&#x27;))</span><br><span class="line"></span><br><span class="line">    // 4.将挂载了组件对象的元素添加到body，toast.$el对应的是div</span><br><span class="line">    document.body.appendChild(toast.$el)</span><br><span class="line"></span><br><span class="line">    // 5.将组件对象挂载到Vue的原型上</span><br><span class="line">    Vue.prototype.$toast = toast</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 暴露当前插件</span><br><span class="line">export default obj</span><br></pre></td></tr></table></figure><h3 id="2-main-js使用">2. main.js使用<a class="anchor" href="#2-main-js使用">·</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import toast from &#x27;./toast/index&#x27;</span><br><span class="line">Vue.use(toast)   // 会去执行index.js里面的install方法</span><br></pre></td></tr></table></figure><h3 id="3-toast组件">3. toast组件<a class="anchor" href="#3-toast组件">·</a></h3><ul><li><p>定义数据data：message：显示内容，isShow： 是否显示</p></li><li><p>定义方法：控制是否显示、显示持续时间。（延迟定时器,时间一到，清空message，isShow变为false）</p></li><li><p>定义样式：显示时候的样式，位置</p></li><li><p>使用的地方用：this.$toast.show(‘hahaha’, 2000)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目3：购物街项目:学习笔记</title>
      <link href="/posts/926905116.html"/>
      <url>/posts/926905116.html</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2020年11月-12月大概</li><li>项目背景： 给师姐做的（首页功能+购物车）</li><li>项目记录篇，比较啰嗦</li></ul><h2 id="项目首页Home笔记">项目首页Home笔记<a class="anchor" href="#项目首页Home笔记">·</a></h2><h3 id="项目相关配置：项目的目录结构划分（主要是Src）">项目相关配置：项目的目录结构划分（主要是Src）<a class="anchor" href="#项目相关配置：项目的目录结构划分（主要是Src）">·</a></h3><ul><li><p>去掉public里面的index.hml 的 favicon图标，去掉初始化的hellworld.vue</p></li><li><p>assets</p><ul><li>img<ul><li>cart</li><li>common</li><li>detail</li><li>home</li><li>profile</li><li>tabbar</li></ul></li><li>css<ul><li>normalize.css</li><li>base.css</li></ul></li></ul></li><li><p>components</p><ul><li>common （这里放不仅仅当前项目可以用的，完全抽离的，还可以在将来的组件中应用）<ul><li>tabbar 文件夹: TabBar.vue    TabBarItem.vue</li><li>navbar文件夹: NavBar.vue</li><li>scroll文件夹:    Scroll.vue</li><li>swiper文件夹 ：  index.js    Swiper.vue    SwiperItem.vue</li><li>toast文件夹 :        index.js    Toast.vue</li></ul></li><li>content（和业务相关的公共组件，只针对当前项目）<ul><li>maintabbar 文件夹:  MainTabBar.vue  （该组件实现了对底部4个模块的封装）</li><li>backTop文件夹:   BackTop.vue</li></ul></li><li>goods文件夹：    GoodsList.vue    GoodsListItem.vue<ul><li>tabcontrol文件夹：  TabControl.vue</li></ul></li></ul></li><li><p>views (我不希望把所有的组件全写在一起。整个页面业务相关的组件都放在这里)</p><ul><li><p>home文件夹： Home.vue   和  childComps文件夹childComps：</p><ul><li><p>FeatureView.vue</p></li><li><p>homeswiper.vue</p></li><li><p>RecommendView.vue</p></li></ul></li><li><p>cart文件夹:  Cart.vue 和   childComps文件夹childComps文件夹:</p><ul><li>CartBottomBar</li><li>CartList</li><li>CartListItem</li><li>CheckButton</li></ul></li><li><p>detail文件夹： Detail组件  +   childComps文件夹childComps文件夹：</p><ul><li>DetailImageInfo</li><li>DetailBaseInfo</li><li>DetailBottomBar</li><li>DetailCommentInfo</li><li>DetailGoodsInfo</li><li>DetailNavBar</li><li>DetailParamInfo</li><li>DetailShopInfo</li><li>DeatailSwiper</li></ul></li><li><p>category文件夹  (无)</p></li><li><p>profile文件夹    （无）</p></li></ul></li><li><p>router</p><ul><li>index.js   （这里存放的是路由配置信息）</li></ul></li><li><p>store</p><ul><li>index.js</li><li>mutation-type.js</li><li>actions.js</li><li>mutation.js</li><li>getters.js</li></ul></li><li><p>network   (网络请求的封装)</p><ul><li>request.js</li><li>home.js    这里封装了对首页数据的请求</li><li>detail.js</li></ul></li><li><p>common</p><ul><li>const.js   （抽出的常量）</li><li>util.js   （公共的方法或函数）</li><li>mixin.js    (混入)</li></ul></li></ul><h4 id="3-normalize-css和base-css">3.normalize.css和base.css<a class="anchor" href="#3-normalize-css和base-css">·</a></h4><ul><li>去github上面下载normalize.css</li><li>放入相应的文件夹中，在base.css中引入它</li><li>将base.css在app.vue中使用</li></ul><h4 id="4-vue-config-js文件和-editorconfig">4.vue.config.js文件和.editorconfig<a class="anchor" href="#4-vue-config-js文件和-editorconfig">·</a></h4><ul><li>目的是为了配置路径别名的问题  cli2中，自动生成的base.config里面可以尽心更改。但cli3中是没有的，我们在项目下新建 vue.config.js文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        &#x27;assets&#x27;: &#x27;@/assets&#x27;,</span><br><span class="line">        &#x27;common&#x27;: &#x27;@/common&#x27;,</span><br><span class="line">        &#x27;components&#x27;: &#x27;@/components&#x27;,</span><br><span class="line">        &#x27;network&#x27;: &#x27;@/network&#x27;,</span><br><span class="line">        &#x27;views&#x27;: &#x27;@/views&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cli2中，自动生成的.editorconfig里面可以尽行更改。这里主要对整个项目的代码风格的统一而cli3中没有的，我们可以把之前的拿过来。比如一个公司的不同项目代码风格基本是一致的</li></ul><h4 id="5-配置之前写好的MainBar组件">5.配置之前写好的MainBar组件<a class="anchor" href="#5-配置之前写好的MainBar组件">·</a></h4><ul><li>设置common里的文件tabbar 文件夹和maintabbar文件夹。并更改maintabbar里面的图片src</li><li>因为这是我们从上一个项目里拿出来的，所以路径是要注意匹配的，方式参考vue.config.js</li><li>将MainBar组件导入到App.vue里面</li></ul><h4 id="6-项目模块的划分与路由配置信息">6.项目模块的划分与路由配置信息<a class="anchor" href="#6-项目模块的划分与路由配置信息">·</a></h4><ul><li><p>在views文件夹下创建4个子文件夹，每个文件夹下的组件只与你当前的页面相关</p></li><li><p>router文件夹下的index.js里。。在main.js里面导入+注册</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">//路由的懒加载</span><br><span class="line">const Home = () =&gt; import(&#x27;views/home/Home&#x27;)</span><br><span class="line">const Profile = () =&gt; import(&#x27;views/profile/Profile&#x27;)</span><br><span class="line">const Cart = () =&gt; import(&#x27;views/cart/Cart&#x27;)</span><br><span class="line">const Category = () =&gt; import(&#x27;views/category/Category&#x27;)</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;&#x27;,</span><br><span class="line">    redirect: &#x27;/home&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/profile&#x27;,</span><br><span class="line">    component: Profile</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/cart&#x27;,</span><br><span class="line">    component: Cart</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/category&#x27;,</span><br><span class="line">    component: Category</span><br><span class="line">  &#125;]</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: &#x27;history&#x27;,</span><br><span class="line">&#125;)</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure></li><li><p>我在这里遇到了问题：在点击首页之后，相应的页面没有显示？</p><ul><li>因为我在App.vue里没有加router-view，导致每个按钮点击后相关的组件全显示不出来</li></ul></li></ul><p>购物车页面又显示不出来???</p><ul><li><p>模板里的每个标签绑定了一个to属性。它告诉子组件，我现在在这个路径，你去router的配置里面，找跟我路径匹配的路由对象，并把它在我的页面展示出来。</p><ul><li>to属性上的跟每个路由对象里的path是必须一致的。原来的/shopcart  而路由里面/cart。。他根本就没有建立联系，所以也不会显示内容</li></ul><p>第三个疑惑问题：为什么Home组件并没有在APP中进行引入，却可以在页面中显示呢？</p><ul><li>这其实跟上面的原理都是一致的。因为页面展示出来的内容是通过路由配置信息找到的组件，再由router-view将这部分组件的内容进行展示。路由相关知识总结：https://www.cnblogs.com/samweb/p/6610733.html</li></ul></li></ul><h3 id="1-导航栏开发">1. 导航栏开发<a class="anchor" href="#1-导航栏开发">·</a></h3><ul><li><p>显示效果<img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201202204147460.png" alt="image-20201202204147460"></p></li><li><p>NavBar组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;nav-bar&quot;&gt;</span><br><span class="line">    &lt;!-- 1.注意这里不要对slot进行直接布局，而是用div给他包起来，给div布局 --&gt;</span><br><span class="line">    &lt;!-- 2.插槽必须要有名字，这样我们插得时候才能对应起来，指定替换的是哪一个 --&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;&lt;slot name=&quot;center&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;NavBar&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  /* 为插槽设置样式，使用flex布局 */</span><br><span class="line">  .nav-bar &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    /* 导航栏的高度一般是44.如果是有导航栏高度是64 */</span><br><span class="line">    height: 44px;</span><br><span class="line">    line-height: 44px;</span><br><span class="line">    box-shadow: 0 1px 1px rgba(100, 100, 100, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  /* 一般左边插槽时固定的，右边也是，中间占用剩余的 */</span><br><span class="line">  .left,</span><br><span class="line">  .right &#123;</span><br><span class="line">    width: 60px;</span><br><span class="line">  &#125;</span><br><span class="line">  .center &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><pre><code>    &lt;nav-bar class=&quot;home-nav&quot;&gt;      &lt;div slot = &quot;center&quot;&gt;购物街&lt;/div&gt;    &lt;/nav-bar&gt;    导入+注册    &lt;style scoped&gt;      .home-nav &#123;        background-color: var(--color-tint);        color: #fff;      &#125;&lt;/style&gt;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 分析： </span><br><span class="line"></span><br><span class="line">  + 容易忘记在Home里面导入，最易犯错的是没有在components里面注册就使用</span><br><span class="line"></span><br><span class="line">  + 首先这个组件有左、中、右三部分。这三个位置设置了插槽，通过Home组件里v-slot，和子组件里的插槽name，我们可以随意指定哪一个位置的内容是什么。如果我们不想用哪个插槽，只要Home组件里没有与它对应的标签即可</span><br><span class="line">  + 插槽里面的内容如何实现定制呢？</span><br><span class="line">    在Home组件里，我们通过导入和注册的子组件里，把想插入的元素用div之类的包裹即可。注意slot名字要与子组件名字对应</span><br><span class="line"></span><br><span class="line">### 2.网络数据的请求封装 ###</span><br><span class="line"></span><br><span class="line">+ 网络请求文件是在network下面进行的。我们不要在每个子组件下都进行网络请求。一来，容易服务器拥挤</span><br><span class="line"></span><br><span class="line">  二来，当我有一天服务器借口进行改变时，所有的子组件都要进行更高。这对于项目开发来说是非常灾难的。所以不要这样做，不易维护</span><br><span class="line"></span><br><span class="line">+ 首先是request.js文件</span><br><span class="line"></span><br><span class="line">  ```vue</span><br><span class="line">  //首先要安装axios：npm install axios@0.18.0 --save    再导入axios</span><br><span class="line">  import axios from &#x27;axios&#x27;</span><br><span class="line">  export function request(config) &#123;</span><br><span class="line">    // 1.创建axios的实例</span><br><span class="line">    const instance = axios.create(&#123;</span><br><span class="line">      //换掉端口地址</span><br><span class="line">      baseURL: &#x27;http://152.136.185.210:8000/api/w6&#x27;,</span><br><span class="line">      timeout: 5000</span><br><span class="line">    &#125;)</span><br><span class="line">    // 2.axios的拦截器</span><br><span class="line">    // 2.1.请求拦截的作用</span><br><span class="line">    instance.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">      return config</span><br><span class="line">    &#125;, err =&gt; &#123;&#125;)</span><br><span class="line">    // 2.2.响应拦截</span><br><span class="line">    instance.interceptors.response.use(res =&gt; &#123;</span><br><span class="line">      return res.data</span><br><span class="line">    &#125;, err =&gt; &#123;&#125;)</span><br><span class="line">    // 3.发送真正的网络请求</span><br><span class="line">    return instance(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>home.js文件</p><ul><li>为什么还要进行一个封装？难道request不够吗？<ul><li>这种封装的意义在于，home组件面向home.js开发。home组件里所有需要获取的内容，你只需要调用这个函数，而不需要关心数据请求中url之类的配置.因为调用的封装函数已经设置过这些</li><li>当有一天借口发生了变化，我们只需要在这里进行修改，对应的home组件的数据自动发生相应的更新。如果我们去home组件里进行网络请求，则会造成，所有url的地方都需要修改。当项目组件很多的时候，这是很恐怖的</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对首页数据的封装请求写在这里。而不是在request中完成对所有数据的封装</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import &#123; request &#125; from &#x27;./request&#x27;</span><br><span class="line">//封装的是一个函数，他的名字叫getHomeMultidata</span><br><span class="line">export function getHomeMultidata () &#123;</span><br><span class="line">  //这里返回的是一个promise对象，在那边进行.then拿到结果</span><br><span class="line">  return request(&#123;</span><br><span class="line">    url: &#x27;/home/multidata&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Home组件：拿到了待会要用的数据，并进行了初次的保存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//因为那边没有default导出，所以不能去掉大括号！！！！</span><br><span class="line">import &#123;getHomeMultidata&#125; from &#x27;network/home&#x27;</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      result: null,</span><br><span class="line">      banners: [],</span><br><span class="line">      recommends: [],</span><br><span class="line">      keywords: [],</span><br><span class="line">      dKeywords: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //当首页组件创建完成之后，赶紧进行网络请求，待会要进行展示</span><br><span class="line">  created () &#123;</span><br><span class="line">    //1.请求多个数据    getHomeMultidata()调用函数，进行数据请求   .then()拿到请求后的结果</span><br><span class="line">    getHomeMultidata().then( res =&gt; &#123;</span><br><span class="line">      this.result = res;</span><br><span class="line">    //这个函数调用的时候会有函数执行栈，在调用结束后执行栈里面的数据会被全部销毁掉，所以我们要对他进行一个保存</span><br><span class="line">    </span><br><span class="line">    //垃圾回收机制：时间---等到没有引用指向他的时候进行垃圾回收。res指向的是一个对象，当执行完之后，</span><br><span class="line">    //会销毁掉变量res。此时rs指向的那个数据里面就没有被引用了，孤零零，最后垃圾回收机制会将它也销毁掉，</span><br><span class="line">    //result对res赋值，其实是内存地址。而此时的数据对象有了reult来引用他，所以这个数据不会被销毁掉</span><br><span class="line">    //其实这跟堆栈相关，以及执行上下文栈</span><br><span class="line">    //可以通过devtool插件里面的vue的HOME结构下看到result里面已经保存了数据</span><br><span class="line">    </span><br><span class="line">    //改进。从数据对象里面取出来每一项</span><br><span class="line">    this.banners = res.data.banner.list</span><br><span class="line">    this.recommends = res.data.recommend.list</span><br><span class="line">    //注意这里请求过来的数据里就是复数</span><br><span class="line">    this.keywords = res.data.keywords</span><br><span class="line">    this.dKeywords = res.data.dKeywords</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补充两个知识点：</p><ul><li><h5 id="模块的导入导出方式：">模块的导入导出方式：<a class="anchor" href="#模块的导入导出方式：">·</a></h5><ul><li><p>commandJs方式（导入导出对象）：modules.exports = {}    var aa = require(‘路径文件’)</p></li><li><p>ES6方式：</p><ul><li><p>直接导入变量：import  {a}  from ‘~~’ ，必须有花括号</p></li><li><p>统一全部导入：import  {a,b,c}  from ‘~~’ (函数，类，变量都可以)</p></li><li><p>导出函数/类：export function aa(){}       export class bb{}</p></li><li><p>默认导出：export default {}   只能有一个默认导出，在对这种进行导入的时候可以随意起名字例如：import  AA  from  ‘路径文件’</p></li></ul></li></ul></li><li><h5 id="Vue的生命周期"><strong>Vue的生命周期</strong><a class="anchor" href="#Vue的生命周期">·</a></h5><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p><p><strong>实例生命周期钩子</strong></p><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。对应的8个生命周期钩子函数：</p><ul><li><strong>beforeCreate、created</strong>、</li><li><strong>beforeMount、mounted</strong>、</li><li><strong>beforeUpdate、updated</strong>、</li><li><strong>beforeDestroy、destroyed</strong></li></ul><p><strong>Vue的生命周期图示（官方中文文档）</strong><img src="https://img-blog.csdnimg.cn/20200418104137666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX1RvZ2V0aGVy,size_16,color_FFFFFF,t_70" alt="官方图示" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20200418101911580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX1RvZ2V0aGVy,size_16,color_FFFFFF,t_70" alt="图片转自coderwhy老师" style="zoom: 50%;" /></p><p><strong>Vue的生命周期过程详解（主要以钩子函数为主线）</strong></p><p><strong>1、beforeCreate：</strong>实例组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行 beforeCreate 钩子函数，<strong>数据和 dom 都未初始化</strong>（取不到），一般不做任何操作。</p><p><strong>2、created：</strong><strong>挂载数据，绑定事件已完成</strong>，然后执行created函数，这个时候已经可以操作数据, 而且不会触发 updated 函数，一般在这里做初始数据的获取（相比在 beforeMount 获取数据页面渲染速度较快）。</p><p><strong>3、beforeMount：</strong>执行这个函数前，<strong>虚拟dom 创建完成，真实 dom未完成挂载</strong>。这里更改数据不会触发 updated ，在这里也可以做初始数据的获取。</p><p><strong>4、mounted：</strong>执行 mounted 钩子函数前，<strong>数据、真实dom都已经处理好了</strong>,事件也挂载好了，一般在这里初始化一些操作真实 dom 的方法。</p><p><strong>5、beforeUpdate：</strong>当组件或实例的数据更改，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。可以监听到 <strong>data 变化，但view层的数据还没有变化</strong>。一般不做任何操作。</p><p><strong>6、updated：</strong>view层的数据重新渲染完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</p><p><strong>7、beforeDestroy：</strong>当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、数据和事件的监听等。</p><p><strong>8、destroyed：</strong>组件的数据绑定、事件监听清除后只剩下dom空壳，这个时候，执行 destroyed 彻底销毁实例，如果在 beforeDestroy 没有做善后工作，在这里做善后工作也可以。</p><p><strong>注</strong>：掌握各个钩子函数执行时的环境，并在项目开发中正确使用显得尤为重要，能避免一些基础的bug。</p></li></ul></li></ul><h3 id="3-首页轮播图">3.首页轮播图<a class="anchor" href="#3-首页轮播图">·</a></h3><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201202204213590.png" alt="image-20201202204213590"></p><ul><li><p>Home组件</p><ul><li>轮播图是放在首页导航栏的下面的。但是这一部分我们不要直接在Home组件里写。Home组件下面还有要显示的内容，如果我们都写在这里最后，Home会越来越多。所以只要是个独立的一块，我们都要进行封装</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;home-swiper :banners = &quot;banners&quot;&gt;&lt;/home-swiper&gt;</span><br><span class="line">import HomeSwiper from &#x27;./homeswiper/HomeSwiper&#x27;</span><br></pre></td></tr></table></figure></li><li><p>在homeswiper下的HomeSwiper组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- home里面放主要的逻辑，组件里面怎么封装的，我并不关心。所以不要把swiper直接写在这里，抽离到home的新文件下，放他的子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;swiper&gt;</span><br><span class="line">    &lt;!-- 轮播的每一项用swiper-item  SwiperItem的组件里面预留了插槽，所以我们可以往里面插入我想插入的东西--&gt;</span><br><span class="line">    &lt;!-- 这里不要创建4个项，而是循环起来 从banners里面取出数据，取代插槽里面的内容--&gt;</span><br><span class="line">    &lt;swiper-item v-for=&quot;item in banners&quot; :key=&quot;item.index&quot;&gt;</span><br><span class="line">      &lt;!-- 因为图片是可以点击的，所以这里我们要给他包装一个标签a --&gt;</span><br><span class="line">      &lt;!-- 链接中href属性是获取数据banners里面有一个link --&gt;</span><br><span class="line">      &lt;a :href=&quot;item.link&quot;&gt;</span><br><span class="line">        &lt;!-- item.image是不对的，要动态绑定，所以要绑定到image里面的src上面--&gt;</span><br><span class="line">        &lt;img :src=&quot;item.image&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/swiper-item&gt;</span><br><span class="line">  &lt;/swiper&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//因为index.js文件对导出组件进行同一导出，所以这里我们不需要再一个一个地导入了</span><br><span class="line"> //因为那边没有default导出，所以不能去掉大括号！！！！</span><br><span class="line">import &#123;Swiper, SwiperItem&#125; from &#x27;components/common/swiper&#x27;</span><br><span class="line">    //等价于：// import Swiper from &#x27;components/common/swiper/Swiper&#x27;</span><br><span class="line">// import SwiperItem from &#x27;components/common/swiper/SwiperItem&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;HomeSwiper&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      banners: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Swiper,</span><br><span class="line">      SwiperItem</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>Swiper组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;hy-swiper&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;swiper&quot; @touchstart=&quot;touchStart&quot; @touchmove=&quot;touchMove&quot; @touchend=&quot;touchEnd&quot;&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;slot name=&quot;indicator&quot;&gt;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">      &lt;div class=&quot;indicator&quot;&gt;</span><br><span class="line">        &lt;slot name=&quot;indicator&quot; v-if=&quot;showIndicator &amp;&amp; slideCount&gt;1&quot;&gt;</span><br><span class="line">          &lt;div v-for=&quot;(item, index) in slideCount&quot; class=&quot;indi-item&quot; :class=&quot;&#123;active: index === currentIndex-1&#125;&quot; :key=&quot;index.id&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &quot;Swiper&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      interval: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">        default: 3000</span><br><span class="line">      &#125;,</span><br><span class="line">      animDuration: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">        default: 300</span><br><span class="line">      &#125;,</span><br><span class="line">      moveRatio: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 0.25</span><br><span class="line">      &#125;,</span><br><span class="line">      showIndicator: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">        slideCount: 0, // 元素个数</span><br><span class="line">        totalWidth: 0, // swiper的宽度</span><br><span class="line">        swiperStyle: &#123;&#125;, // swiper样式</span><br><span class="line">        currentIndex: 1, // 当前的index</span><br><span class="line">        scrolling: false, // 是否正在滚动</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: function () &#123;</span><br><span class="line">      // 1.操作DOM, 在前后添加Slide</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        this.handleDom();</span><br><span class="line"></span><br><span class="line">        // 2.开启定时器</span><br><span class="line">        this.startTimer();</span><br><span class="line">      &#125;, 100)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">  /*** 定时器操作*/</span><br><span class="line">      startTimer: function () &#123;</span><br><span class="line">    this.playTimer = window.setInterval(() =&gt; &#123;</span><br><span class="line">      this.currentIndex++;</span><br><span class="line">      this.scrollContent(-this.currentIndex * this.totalWidth);</span><br><span class="line">        &#125;, this.interval)</span><br><span class="line">      &#125;,</span><br><span class="line">      stopTimer: function () &#123;</span><br><span class="line">        window.clearInterval(this.playTimer);</span><br><span class="line">      &#125;,</span><br><span class="line">      /*** 滚动到正确的位置*/</span><br><span class="line">      scrollContent: function (currentPosition) &#123;</span><br><span class="line">        // 0.设置正在滚动</span><br><span class="line">        this.scrolling = true;// 1.开始滚动动画</span><br><span class="line">        this.swiperStyle.transition =&#x27;transform &#x27;+ this.animDuration + &#x27;ms&#x27;;</span><br><span class="line">        this.setTransform(currentPosition);</span><br><span class="line"></span><br><span class="line">        // 2.判断滚动到的位置</span><br><span class="line">        this.checkPosition();</span><br><span class="line"></span><br><span class="line">        // 4.滚动完成</span><br><span class="line">        this.scrolling = false</span><br><span class="line">      &#125;,</span><br><span class="line">      //校验正确的位置</span><br><span class="line">      checkPosition: function () &#123;</span><br><span class="line">        window.setTimeout(() =&gt; &#123;</span><br><span class="line">          // 1.校验正确的位置</span><br><span class="line">          this.swiperStyle.transition = &#x27;0ms&#x27;;</span><br><span class="line">          if (this.currentIndex &gt;= this.slideCount + 1) &#123;</span><br><span class="line">            this.currentIndex = 1;</span><br><span class="line">            this.setTransform(-this.currentIndex * this.totalWidth);</span><br><span class="line">          &#125; else if (this.currentIndex &lt;= 0) &#123;</span><br><span class="line">            this.currentIndex = this.slideCount;</span><br><span class="line">            this.setTransform(-this.currentIndex * this.totalWidth);</span><br><span class="line">          &#125;</span><br><span class="line">          // 2.结束移动后的回调</span><br><span class="line">          this.$emit(&#x27;transitionEnd&#x27;, this.currentIndex-1);</span><br><span class="line">        &#125;, this.animDuration)</span><br><span class="line">      &#125;,</span><br><span class="line">      //设置滚动的位置</span><br><span class="line">      </span><br><span class="line">      setTransform: function (position) &#123;</span><br><span class="line">        this.swiperStyle.transform = `translate3d($&#123;position&#125;px, 0, 0)`;</span><br><span class="line">        this.swiperStyle[&#x27;-webkit-transform&#x27;] = `translate3d($&#123;position&#125;px), 0, 0`;</span><br><span class="line">        this.swiperStyle[&#x27;-ms-transform&#x27;] = `translate3d($&#123;position&#125;px), 0, 0`;</span><br><span class="line">      &#125;,</span><br><span class="line">       //操作DOM, 在DOM前后添加Slide</span><br><span class="line">       </span><br><span class="line">  handleDom: function () &#123;</span><br><span class="line">        // 1.获取要操作的元素</span><br><span class="line">        let swiperEl = document.querySelector(&#x27;.swiper&#x27;);</span><br><span class="line">        let slidesEls = swiperEl.getElementsByClassName(&#x27;slide&#x27;);</span><br><span class="line">        // 2.保存个数</span><br><span class="line">        this.slideCount = slidesEls.length;</span><br><span class="line">        // 3.如果大于1个, 那么在前后分别添加一个slide</span><br><span class="line">        if (this.slideCount &gt; 1) &#123;</span><br><span class="line">          let cloneFirst = slidesEls[0].cloneNode(true);</span><br><span class="line">          let cloneLast = slidesEls[this.slideCount - 1].cloneNode(true);</span><br><span class="line">          swiperEl.insertBefore(cloneLast, slidesEls[0]);</span><br><span class="line">          swiperEl.appendChild(cloneFirst);</span><br><span class="line">          this.totalWidth = swiperEl.offsetWidth;</span><br><span class="line">          this.swiperStyle = swiperEl.style;</span><br><span class="line">        &#125;</span><br><span class="line">        // 4.让swiper元素, 显示第一个(目前是显示前面添加的最后一个元素)</span><br><span class="line">        this.setTransform(-this.totalWidth);</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 拖动事件的处理</span><br><span class="line">       */</span><br><span class="line">      touchStart: function (e) &#123;</span><br><span class="line">        // 1.如果正在滚动, 不可以拖动</span><br><span class="line">        if (this.scrolling) return;</span><br><span class="line">        // 2.停止定时器</span><br><span class="line">        this.stopTimer();</span><br><span class="line">        // 3.保存开始滚动的位置</span><br><span class="line">        this.startX = e.touches[0].pageX;</span><br><span class="line">      &#125;,</span><br><span class="line">      touchMove: function (e) &#123;</span><br><span class="line">        // 1.计算出用户拖动的距离</span><br><span class="line">        this.currentX = e.touches[0].pageX;</span><br><span class="line">        this.distance = this.currentX - this.startX;</span><br><span class="line">        let currentPosition = -this.currentIndex * this.totalWidth;</span><br><span class="line">        let moveDistance = this.distance + currentPosition;</span><br><span class="line">        // 2.设置当前的位置</span><br><span class="line">        this.setTransform(moveDistance);</span><br><span class="line">      &#125;,</span><br><span class="line">      touchEnd: function (e) &#123;</span><br><span class="line">        // 1.获取移动的距离</span><br><span class="line">        let currentMove = Math.abs(this.distance);</span><br><span class="line">        // 2.判断最终的距离</span><br><span class="line">        if (this.distance === 0) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125; else if (this.distance &gt; 0 &amp;&amp; currentMove &gt; this.totalWidth * this.moveRatio) &#123; // 右边移动超过0.5</span><br><span class="line">          this.currentIndex--</span><br><span class="line">        &#125; else if (this.distance &lt; 0 &amp;&amp; currentMove &gt; this.totalWidth * this.moveRatio) &#123; // 向左移动超过0.5</span><br><span class="line">          this.currentIndex++</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.移动到正确的位置</span><br><span class="line">        this.scrollContent(-this.currentIndex * this.totalWidth);</span><br><span class="line">        // 4.移动完成后重新开启定时器</span><br><span class="line">        this.startTimer();</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 控制上一个, 下一个</span><br><span class="line">       */</span><br><span class="line">      previous: function () &#123;</span><br><span class="line">        this.changeItem(-1);</span><br><span class="line">      &#125;,</span><br><span class="line">      next: function () &#123;</span><br><span class="line">        this.changeItem(1);</span><br><span class="line">      &#125;,</span><br><span class="line">      changeItem: function (num) &#123;</span><br><span class="line">        // 1.移除定时器</span><br><span class="line">        this.stopTimer();</span><br><span class="line">        // 2.修改index和位置</span><br><span class="line">        this.currentIndex += num;</span><br><span class="line">        this.scrollContent(-this.currentIndex * this.totalWidth);</span><br><span class="line">        // 3.添加定时器</span><br><span class="line">        this.startTimer();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  #hy-swiper &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .swiper &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .indicator &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 100%;</span><br><span class="line">    bottom: 8px;</span><br><span class="line">  &#125;</span><br><span class="line">  .indi-item &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    width: 8px;</span><br><span class="line">    height: 8px;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    line-height: 8px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    margin: 0 5px;</span><br><span class="line">  &#125;</span><br><span class="line">  .indi-item.active &#123;</span><br><span class="line">    background-color: rgba(212,62,46,1.0);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>SwiperItem组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;slide&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &quot;Slide&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .slide &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    flex-shrink: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  .slide img &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>这块的难点与任务：</p><ul><li><p>那么点这两个组件时如何完成封装的，你会写出原生封装吗？</p></li><li><p>学习一个插件：vue-awesome-swiper  踏实如何实现轮播效果的呢？？组件图的封装，github上进行了封装‘，这些库学习的时候不建议随便用UI库，而是自己封装，自己才能明白是怎么封装的。。。。。</p></li></ul></li></ul><h3 id="4-首页推荐信息">4.首页推荐信息<a class="anchor" href="#4-首页推荐信息">·</a></h3><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201202204250774.png" alt="image-20201202204250774"></p><ul><li><p>Home组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;home-recommend :recommends = &quot;recommends&quot;&gt;&lt;/home-recommend&gt;</span><br><span class="line">导入+注册</span><br></pre></td></tr></table></figure></li><li><p>HomeRecommend组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home-recommend&quot;&gt;</span><br><span class="line">    &lt;!-- 对轮播图里面的数据进行展示 --&gt;</span><br><span class="line">    &lt;div v-for=&quot;item in recommends&quot; </span><br><span class="line">        :key = &quot;item.index&quot;</span><br><span class="line">        class=&quot;recommend-item&quot;</span><br><span class="line">        &gt;</span><br><span class="line">      &lt;!-- 每个都是有标签的 ,数据中的link属性对应的就是每个图片点击后的超链接地址--&gt;</span><br><span class="line">      &lt;a :href=&quot;item.link&quot;&gt;</span><br><span class="line">        &lt;img :src=&quot;item.image&quot; alt=&quot;&quot; class=&quot;img&quot;&gt;</span><br><span class="line">        &lt;!-- 每个小图片有文字 --&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;item.title&#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;HomeRecommend&quot;,</span><br><span class="line">    //数据在首页里面，所以我们要接收，不然哪儿来的数据。而且父组件也要把数据传过来</span><br><span class="line">    //这两点总是爱忽略，遗漏</span><br><span class="line">    props: &#123;</span><br><span class="line">      recommends: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .home-recommend &#123;</span><br><span class="line">    /* 水平布局，flex，因为盒子全部在一列排列 */</span><br><span class="line">    display: flex;</span><br><span class="line">    width: 100%;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    /* 居中显示 */</span><br><span class="line">    text-align: center;</span><br><span class="line">    /* 让他与上面和下面拉开一点距离*/</span><br><span class="line">    padding: 10px 0 20px;</span><br><span class="line">    border-bottom: 8px solid #eee;</span><br><span class="line">  &#125;</span><br><span class="line">  .recommend-item &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">  &#125;</span><br><span class="line">  .recommend-item .img &#123;</span><br><span class="line">  /* 此时图片太大了。对图片进行限制 */</span><br><span class="line">  /* 与老师不同，我对这里的图片用的是百分比，不是定的px */</span><br><span class="line">    width: 80%;</span><br><span class="line">    height: 80%;</span><br><span class="line">    /* 图片和文字距离拉开 */</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-本周流行">5. 本周流行<a class="anchor" href="#5-本周流行">·</a></h3><ul><li><p>这块只有一个图片，虽然看起来像很多个小图标。但我们还是将它封装成一个组件Feature</p><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201203175355996.png" alt="image-20201203175355996"></p></li><li><p>FeatureView组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;feature&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;~assets/img/home/recommend_bg.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      //注意这里的src是有波浪线的</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;FeatureView&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.feature img&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>Home组件   导入+注册+使用该组件即可</p></li></ul><h3 id="6-控制栏">6.控制栏<a class="anchor" href="#6-控制栏">·</a></h3><ul><li><p>需求：点击这三个任一个，哪一个颜色改变，有下面的线，并展示相应的页面<img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201203180154105.png" alt="image-20201203180154105"></p><ul><li><p>分析：这种需求似乎跟之前的TabBar组件很像，但是这里我们并没有采用那种封装思想</p></li><li><p>TabBar的封装思想是：每一项都是文字+图标的形式，他们的展示形式也是一样的。将每一项抽离成一个组件进行封装，而组件里我们预留了插槽。我们将来用的时候，可以在插槽的位置填入想要定制化的内容。可以改变每次插入的文字，甚至可以改变个数，这时候就需要预留插槽</p></li><li><p>首先这个组件我是可以在第二页面进行复用的，他们都是一样的，只是文字不一样。如果这里我们也要这样做，带来的问题就是你用的时候组件里这样，他用的时候组件也这样。插槽的形式都是一样的，代码是重复的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不推荐 &lt;tab-bar&gt;&lt;span&gt;aa&lt;/span&gt;&lt;/tab-bar&gt;</span><br><span class="line">      &lt;tab-bar&gt;&lt;span&gt;bb&lt;/span&gt;&lt;/tab-bar&gt;</span><br><span class="line">      &lt;tab-bar&gt;&lt;span&gt;cc&lt;/span&gt;&lt;/tab-bar&gt;</span><br><span class="line">      &lt;tab-bar&gt;&lt;span&gt;dd&lt;/span&gt;&lt;/tab-bar&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>TabControl组件</p><ul><li><p>组件复用问题：</p><p>当我切换流行，时尚，详情时，组件页面并没有发生改变：</p><p>原因组件复用的问题。原来的图片。类似于之前的input复用问题。解决办法：绑定key</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;tab-control&quot;&gt;</span><br><span class="line">       &lt;!-- 点击哪一个，下面添加样式。样式的动态绑定 --&gt;</span><br><span class="line">       &lt;!-- 里面有几个span，是根据title有几项数据决定跟的 --&gt;</span><br><span class="line">     &lt;div v-for=&quot;(item, index) in titles&quot; </span><br><span class="line">          :key=&quot;(item, index)&quot;</span><br><span class="line">          class=&quot;tab-control-item&quot;</span><br><span class="line">          :class = &quot;&#123;active: index === currentIndex&#125;&quot;</span><br><span class="line">          @click = &quot;btnClick(index)&quot;&gt;</span><br><span class="line">      &lt;!-- 添加点击事件，点击哪一个，为其添加acive的class类 --&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;TabControl&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      //传进来title,告诉别人我用的时候你只需要给我传文字就可以了。</span><br><span class="line">      titles: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      //return 返回的是一个对象，不是函数！！！</span><br><span class="line">      return &#123;</span><br><span class="line">        currentIndex: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      btnClick(index) &#123;</span><br><span class="line">        this.currentIndex = index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .tab-control &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab-control .tab-control-item &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    height: 40px;</span><br><span class="line">    line-height: 40px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab-control-item span &#123;</span><br><span class="line">    /* 撑开一下便捷，左边和下边都会有一些距离 */</span><br><span class="line">    padding: 5px;</span><br><span class="line">  &#125;</span><br><span class="line">  .active &#123;</span><br><span class="line">    color: #ff5777;</span><br><span class="line">  &#125;</span><br><span class="line">  .active span &#123;</span><br><span class="line">    /* 不要整个部分全显示，而是现实span短横 */</span><br><span class="line">    border-bottom: 3px solid var(--color-tint);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>Home组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导入+注册</span><br><span class="line">   data里定义titles的内容： titles:[&#x27;流行&#x27;,&#x27;新款&#x27;,&#x27;精选&#x27;],</span><br><span class="line">   &lt;tab-control :titles = &quot;titles&quot; class=&quot;tab-control&quot;&gt;&lt;/tab-control&gt;</span><br><span class="line">   //这里为什么还有个class,跟下面的需求有关</span><br></pre></td></tr></table></figure></li><li><p>此时我们要实现一个需求：</p><ul><li>首页上面的导航栏，用户向下滚动的时候他不要跟着滚动，用定住最上面（固定定位），我这个组件也也同样固定在导航栏的下面（粘连定位）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.home-nav &#123;</span><br><span class="line">  background-color: var(--color-tint);</span><br><span class="line">  color: #fff;</span><br><span class="line">  /* 首页上面的导航栏，向下滚动的时候他不要滚动。采用固定定位，一直在最上面 */</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  z-index: 9;</span><br><span class="line">&#125;</span><br><span class="line">  #home &#123;</span><br><span class="line">  /* 如果这里没有44px,轮播图会跑到最上面，他的一部分就会被导航栏遮盖 */</span><br><span class="line"> padding-top: 44px;</span><br><span class="line">&#125;</span><br><span class="line">.tab-control &#123;</span><br><span class="line">  /* 想实现的功能是：页面向下滑，滑到一定高度后，顶部固定 */</span><br><span class="line">  /* 方法1：用定位做。方法2：后续用插件做 */</span><br><span class="line">  position: sticky;</span><br><span class="line">  // 距离顶部44px的时候，会变成fixed定位</span><br><span class="line">  top: 44px;</span><br><span class="line">  background-color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-控制栏点击之后的数据请求">7.控制栏点击之后的数据请求<a class="anchor" href="#7-控制栏点击之后的数据请求">·</a></h3><ul><li><p>分析：</p><p>我们对这部分封装在content里，与业务逻辑有关,不是完全独立，又可以应用在该项目其他页面的某些地方</p><p>点击之后请求过来的数据是什么形式的呢?我们又如何保存？</p><ul><li><p>我们需要一个变量，这个变量不仅存储着流行 新款 精选 的数据  当用户点击对应的某一项时，就展示那一项的数据。所以我们会一次把数据都请求过来。这种思想其实跟tabbar一样一样的。但有一个问题：</p><p>流行的数据有很多页。数据量很大。？？？怎么保存</p></li><li><p>数据保存模型：</p><ul><li><p>拿到整体的数据goods,保存着三类数据，每一类数据对应着一个对象。</p></li><li><p>list对象里面存放的展示数据。page因为要展示的图片很多，他会显示我们当前浏览到第几页了</p><p>流行页面已经浏览了第5页，此时我点击新款页面，他应该是第1页。page就是记录这个页</p></li><li><p>当我点击流行按钮的时候，就要把pop对象里面的数据请求过来，点击新款时，把news里面的数据请求过来点击详情时，把sell里面的数据请求过来，展示他里面的数据。取数据是通过key实现的。</p></li><li><p>如果用户产生了上拉加载更多的操作，我们还应该改page.还需要list展示已经展示了多少条数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> goods: &#123;</span><br><span class="line">    &#x27;pop&#x27;: &#123;page： 1， list： []&#125;，每个数据对象 默认page，还有key和value记录当前模型加载到第几页的</span><br><span class="line">‘news&#x27;: &#123;&#125;,</span><br><span class="line">    &#x27;sell&#x27;: &#123;&#125;</span><br><span class="line"> &#125;//这个数据模型会帮我们把请求的数据保存下来</span><br></pre></td></tr></table></figure></li><li><p>第二种保存数据的方法：Map数据结构，？？？学习一下？？</p></li></ul></li><li><h5 id="数据请求操作：">数据请求操作：<a class="anchor" href="#数据请求操作：">·</a></h5><p>同样我们要在network里面的home.js里完成请求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function getHomeGoods(type, page) &#123;</span><br><span class="line">  //这个函数跟上面不同，因为要针对不同的情况请求不同的数据，</span><br><span class="line">  //所以我们要传入参数一个时type，每一类你还要告诉我对应的页码，我有了页码采取请求对应的数据</span><br><span class="line">  return request (&#123;</span><br><span class="line">    url: &#x27;/home/data&#x27;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      type,</span><br><span class="line">      page</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Home组件里调用</p><ul><li>Level1   跟之前轮播图数据一样，在created里面调用home.js里的数据请求函数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//   getHomeGoods(type, 1).then(res =&gt; &#123;</span><br><span class="line">   //     console.log(res)</span><br><span class="line">   //   &#125;)</span><br></pre></td></tr></table></figure><p>但并不推荐这样做。因为避免created里面每个函数调用后我们在里面做较多的保存工作，我们要对这部分进一步封装在methods里面。至于created里面是怎么保存的我不关心。我只关心你的数据请求，所以最好只写主要逻辑</p><ul><li><p>把这部分功能放在methods里封装成函数，在created里面调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// getHomeGoods(type, page) &#123;</span><br><span class="line"> //   getHomeGoods(type, 1).then(res =&gt; &#123;</span><br><span class="line"> //     console.log(res)</span><br><span class="line"> //   &#125;)</span><br><span class="line"> // &#125;</span><br></pre></td></tr></table></figure></li><li><p>改进问题： 这样写page是死的，为了提升代码的复用性。当我浏览完第一个页面的第一页数据后，用户上拉加载更多，这时候要请求第二个数据了，但是我们将page固定位1，问题是我们还需要写新的函数来解决这个需求解决：通过传入的type，获取到page。page初始化为0，我们希望3个页面在开始的时候都是请求第一页</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  this.getHomeMultidata()</span><br><span class="line">  //我们希望3个页面在开始的时候都是请求第一页</span><br><span class="line">  this.getHomeGoods(&#x27;pop&#x27;)</span><br><span class="line">  this.getHomeGoods(&#x27;new&#x27;)</span><br><span class="line">  this.getHomeGoods(&#x27;sell&#x27;)</span><br><span class="line">//注意这两个地方的调用必须写this。如果不写this，其实还是在调用home.js里面的函数</span><br><span class="line">//而我们实际想要调用的是methods里面的.他里面对数据进行了保存</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   getHomeGoods(type) &#123;</span><br><span class="line">      const page = this.goods[type].page + 1</span><br><span class="line">      getHomeGoods(type, page).then(res =&gt; &#123;</span><br><span class="line">        //获取到请求结果res，得到res.data我们要进行一个保存。存储数据的模型是goods</span><br><span class="line">        //问题：如何将一个数组的所有数据保存在另一个数组里面？</span><br><span class="line">        //第一种对第2个数据每一项进行遍历，然后每一项push塞进第一个数组</span><br><span class="line">        //方法2： 使用push方法  num2.push(...num1)</span><br><span class="line">        //相当于也是一种解析，会将数组中每个元素解析出来放入数组2</span><br><span class="line">        //更深的理解：利用push函数，它可以传入可变参数，可以传入很多个</span><br><span class="line">        this.goods[type].list.push(...res.data.list)</span><br><span class="line">        //现在的pop类型多了一组数据，我们要将页码+1</span><br><span class="line">        this.goods[type].list.page +=1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//data里面的数据初始化</span><br><span class="line">      goods: &#123;</span><br><span class="line">        //现将数据设置好，然后去请求数据。将请求回来的数据在这里面放</span><br><span class="line">        &#x27;pop&#x27;: &#123;page: 0, list: []&#125;,</span><br><span class="line">        &#x27;new&#x27;: &#123;page: 0, list: []&#125;,</span><br><span class="line">        &#x27;sell&#x27;: &#123;page: 0, list: []&#125;,</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="8-商品数据展示">8. 商品数据展示<a class="anchor" href="#8-商品数据展示">·</a></h3><ul><li><h5 id="请求的数据保存后，如何显示在页面上呢？-组件GoodsItem和GoodsList">请求的数据保存后，如何显示在页面上呢？ 组件GoodsItem和GoodsList<a class="anchor" href="#请求的数据保存后，如何显示在页面上呢？-组件GoodsItem和GoodsList">·</a></h5><p>思路：Home组件将数据传给GoodsList，GoodsList进行遍历，然后将遍历出来的每一项传给他的GoodsListItem，它接收数据中，进行展示 -</p><p>Home组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;goods-list :goods = &quot;goods[&#x27;pop&#x27;].list&quot;&gt;&lt;/goods-list&gt;</span><br><span class="line">导入+注册</span><br></pre></td></tr></table></figure><p>GoodsList组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;goods-item&quot;&gt;</span><br><span class="line">    &lt;goods-list-item v-for = &#x27;item in goods&#x27; </span><br><span class="line">                    :key=&quot;item.index&quot;</span><br><span class="line">                    :goodsitem = &quot;item&quot;&gt;</span><br><span class="line">    &lt;!-- 将遍历出来的每一个对象，传到子组件中进行显示 --&gt;</span><br><span class="line">    &lt;/goods-list-item&gt;</span><br><span class="line">  &lt;!-- 每个小组件就是遍历的每个对象 --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import GoodsListItem from &#x27;./GoodsListItem&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;GoodsList&#x27;,</span><br><span class="line">    components: &#123; GoodsListItem &#125;,</span><br><span class="line">    //这个位置接受的就是穿过来的list，进行展示</span><br><span class="line">    props: &#123;</span><br><span class="line">      goods: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .goods-item &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    /* 目的是不要让图片占满一整行，注意子元素这是必须给宽度，否则，它会全往一行塞 */</span><br><span class="line">    /* 而且光给宽度还不行，flex-wrap会wrap进行换行，配合子元素的宽度，它会自动进行换行</span><br><span class="line">    默认是nowrap，是不换行的*/</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>GoodsListItem组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;goods-item&quot;&gt;</span><br><span class="line">    &lt;img :src = &quot;goodsitem.show.img&quot;/&gt;</span><br><span class="line">    &lt;!-- 图片下方还有一个标题+价格+收藏collect favorite --&gt;</span><br><span class="line">    &lt;div class=&quot;goods-info&quot;&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;goodsitem.title&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;span class=&quot;price&quot;&gt;&#123;&#123;goodsitem.price&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;collect&quot;&gt;&#123;&#123;goodsitem.cfav&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;GoodsListItem&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">    goodsitem: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        default() &#123;</span><br><span class="line">          return &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .goods-item &#123;</span><br><span class="line">    padding-bottom: 40px;</span><br><span class="line">    position: relative;</span><br><span class="line">    /* 父元素右flex这里要给宽度 */</span><br><span class="line">    width: 46%;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-item img &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info &#123;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 5px;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info p &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    margin-bottom: 3px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info .price &#123;</span><br><span class="line">    color: var(--color-high-text);</span><br><span class="line">    margin-right: 20px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info .collect &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-info .collect::before &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: -15px;</span><br><span class="line">    top: -1px;</span><br><span class="line">    width: 14px;</span><br><span class="line">    height: 14px;</span><br><span class="line">    background: url(&quot;~assets/img/common/collect.svg&quot;) 0 0/14px 14px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><p>遇到的问题1：如果子元素不给宽度的结果，全网一行塞<img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201203205335489.png" alt="image-20201203205335489"></p><p>为了不要让图片占满一整行，注意子元素必须给宽度，否则，它会全往一行塞 。而且光给宽度还不行，flex-wrap会wrap进行换行，配合子元素的宽度，它会自动进行换行默认是nowrap，是不换行的默认是nowrap，是不换行的*/flex-wrap: wrap;</p></li><li><p>问题2：一行的图片并不是均等分的  ： justify-content: space-around;</p><p>​<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203205855794.png" alt="image-20201203205855794" style="zoom:67%;" /></p></li><li><p>问题3：下滑的过程中，流行，新款的导航栏会被覆盖掉，</p><p>解决：去TabControl组件添加z-index：9</p></li></ul></li><li><h5 id="Home组件中如何实现数据动态传给子组件？？">Home组件中如何实现数据动态传给子组件？？<a class="anchor" href="#Home组件中如何实现数据动态传给子组件？？">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;goods-list :goods = &quot;goods[&#x27;pop&#x27;].list&quot;&gt;&lt;/goods-list&gt;</span><br><span class="line">这个传数据时，直接是写死的这样肯定是不行的。我们点击详情，新款时他就不能动态展示当前选择的类型里面的内容。</span><br></pre></td></tr></table></figure><p>实现的思路：在TabControl组件中的每一项被点击时，告诉Home组件当前被点击的是哪个index。Home组件根据index就知道了他应该切换为pop还是new还是sell里面的数据</p><p>在TabControl的方法中修改：</p><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201203230845680.png" alt="image-20201203230845680"></p><p>父组件监听这个自定义事件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;tab-control :titles = &quot;titles&quot; </span><br><span class="line">               class=&quot;tab-control&quot; </span><br><span class="line">               @tabClick=&quot;tabClick&quot;&gt;&lt;/tab-control&gt;   </span><br><span class="line"> //后续借助计算属性对这部分优化</span><br><span class="line"> &lt;goods-list :goods = &quot;goods[currentType].list&quot;&gt;&lt;/goods-list&gt;</span><br><span class="line">               </span><br><span class="line"> /*2.这是事件监听类的方法*/</span><br><span class="line">方法里： tabClick(index) &#123;</span><br><span class="line">   console.log(index)</span><br><span class="line">   console.log(&#x27;haha&#x27;);</span><br><span class="line">   </span><br><span class="line">   switch (index) &#123;</span><br><span class="line">     case 0: this.currentType = &#x27;pop&#x27;</span><br><span class="line">     break</span><br><span class="line">     case 1: this.currentType = &#x27;new&#x27;</span><br><span class="line">     break</span><br><span class="line">     case 2: this.currentType = &#x27;sell&#x27;</span><br><span class="line">     break</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> 数据里： 初始化类型</span><br><span class="line">   currentType: &#x27;pop&#x27;,</span><br></pre></td></tr></table></figure><ul><li><p>犯错1： @tabClick = &quot;tabClick(index)&quot;父组件中这个监听事件应该绑定到TabControl里面，不是goodlist上面</p></li><li><p>犯错2：这里@tabClick = &quot;tabClick(index)&quot;不要传参数，会导致index打印出是无效的，这是为什么呢？</p></li><li><p>遇到的问题：Home.vue?76f2:158 Uncaught (in promise) TypeError: Cannot read property ‘data’ of undefined at eval Error: timeout of 5000ms exceededat createError (createError.js?2d83:16)at XMLHttpRequest.handleTimeout (xhr.js?b50d:95)一直显示data没有定义，数据请求不过来解决：报错data没有定义,原因是我在request.js里面设置了5000ms，也就是超过5秒就超时，这时候还没有达到数据，我们用数据是有问题的。</p><p>我尝试了修改timeout的数值，发现控制台没有再报错，同时请求的3条数据也显示出来。不再像之前那样部分显示，部分报错</p></li><li><p>接上一个问题：另一个问题：为什么我只执行了一次打印，却会打印出三条请求数据的结果呢？</p><p>因为我们在上面的生命周期created里面调用了3种</p></li></ul></li><li><h5 id="Home中计算属性优化">Home中计算属性优化<a class="anchor" href="#Home中计算属性优化">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;goods-list :goods = &quot;goods[currentType].list&quot;&gt;&lt;/goods-list&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  showGoods() &#123;</span><br><span class="line">   return this.goods[this.currentType].list</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>犯错：注意return this.goods[this.currentType].list这里面是要加this的，在之前写在组件里不同加this，现在是写在下面，不加this，根本不认识它。没加会报错的！！！这个地方极容易犯错</li></ul></li></ul><h3 id="9-关于Better-scroll">9.关于Better-scroll<a class="anchor" href="#9-关于Better-scroll">·</a></h3><p>问题： 当前项目部署到服务器，只有用手机端请求网页，这个网页样式是没有问题的。我想往上滚，它是不会像PC浏览器里面自带的原生滚动一样  内容超过当前窗口的页面，可以自动滚动  。手机端会非常卡顿，还没有动态滚动效果的。</p><p><strong>解决：早期适配框架  iscroll 但这个框架已经不再维护了  有人参考了这个框架写了 better-scroll   有人维护，依赖于原生JS, 不依赖于其他框架</strong></p><ul><li><p>小技巧：开源框架的源码怎么找，</p><ul><li>如果官方网站没有下载，去github上面，找到tag版本进行下载，dist文件夹里esm.js里面。</li><li>直接用命令行。版本是1.13.2</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install better-scroll@1.13.2 --save</span><br></pre></td></tr></table></figure></li><li><h5 id="在Category组件里这样做（实验），局部区域滚动的原生做法">在Category组件里这样做（实验），局部区域滚动的原生做法<a class="anchor" href="#在Category组件里这样做（实验），局部区域滚动的原生做法">·</a></h5><ul><li>首先整体的原生滚动：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">此处用ul包裹100个li</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li><p>可以实现滚动的，这是原生的。如果我想实现局部区域滚动，应该怎么做？</p><ul><li>方法1：给父标签最外层的div一个高度，再让整个区域overflow-y: scroll;   此时超过height之后的内容隐藏了,并且高度之内的可以实行滚动，局部滚动实现 。但原生滚动非常卡顿，框架的滚动怎么做呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height: 100px;</span><br><span class="line">   background-color: red;</span><br><span class="line">   overflow-y: scroll;  </span><br></pre></td></tr></table></figure><ul><li>方法2：用框架来做<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204154344774.png" alt="image-20201204154344774" style="zoom: 50%;" /></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">//最外层需要包裹一个东西，并且有高度。之后往里面放入内容。但是content只能再放一个标签，一个！！</span><br><span class="line">  &lt;div class=&quot;wrapper&quot; ref = &quot;aaa&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">此处用ul包裹100个li</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .wrapper &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">    height: 200px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    //此处只是将溢出的地方进行隐藏</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import BScroll from &#x27;better-scroll&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Category&#x27;,</span><br><span class="line">  // created() &#123;</span><br><span class="line">  //   组件创建完之后调用，但是还没有进行模板的挂载，</span><br><span class="line">  //   所以这里的第一个参数是拿不到的。我们可以打印一下undifined/null</span><br><span class="line">  //   console.log(this.$refs.aaa)</span><br><span class="line">  //   console.log(document.querySelector(&#x27;.wrapper&#x27;))</span><br><span class="line">  //   this.scroll = new BScroll(&#x27;.wrapper&#x27;)</span><br><span class="line">  // &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      scroll: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>犯错1：</p><ul><li><p>我们加了一个wrapper的div。把之前的高度样式给wrapper。这样还是不行</p></li><li><p>导入安装的框架，并在created函数中new BSroll (参数1)，参数1是获取的dom节点。还是不行</p></li><li><p>在data里初始化scroll，用于对new出来的数据进行保存，还是不行。</p></li><li><p>wrapper的那个标签添加 ref = “aaa”，更改new Scroll</p></li></ul><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201204155650488.png" alt="image-20201204155650488"></p></li><li><p>犯错原因：在created里创建BScroll对象，这时拿不到dom节点，改在mounted里实现<img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201204155743073.png" alt="image-20201204155743073"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    // 改为在mounted函数里去实现</span><br><span class="line">    console.log(this.$refs.aaa)</span><br><span class="line">    //这里可以写.类名，也可以用获取dom节点，插件会自动找到的</span><br><span class="line">    console.log(document.querySelector(&#x27;.wrapper&#x27;))</span><br><span class="line">    this.scroll = new BScroll(&#x27;.wrapper&#x27;),&#123;&#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="Better-scroll的进一步拓展">Better-scroll的进一步拓展<a class="anchor" href="#Better-scroll的进一步拓展">·</a></h5><ul><li><p>拿到better-scroll下载打包之后的文件，使用它。也可以这样做，到node_modules里面的better-scoll 拿到dist文件夹下面的bscroll.js文件，粘贴过来</p></li><li><p>随便一个地方新建index.html,导入这个JS文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .content&#123;</span><br><span class="line">    height: 500px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script src = &#x27;./bscroll.js&#x27;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201204161344411.png" alt="image-20201204161344411"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">//这里也放100个li</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 里面有个叫做 BScroll  的类 ，打印结结果显示他是一个构造函数</span><br><span class="line">  // console.log(BScroll);</span><br><span class="line">  //哪个元素挂载上去实行滚动，就把他挂载上去。wrapper里面只能有一个元素。</span><br><span class="line">  const bscroll = new BScroll(document.querySelector(&#x27;.content&#x27;), &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>想要实时监听用户滚动到哪个位置了，滚动多少了？？怎么做，</p><ul><li>必须知道滚动到哪一个位置，详情，流行那个栏目才停留。拿到better-scoll对象后，通过on功能进行监听。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第一个参数是要监听的类型，第二个参数是function，可以用箭头函数，函数的参数是position</span><br><span class="line">bscroll.on(&#x27;scroll&#x27;, (position) =&gt; &#123;</span><br><span class="line">  //position 是实时位置</span><br><span class="line">  console.log(position)</span><br><span class="line">&#125;)</span><br><span class="line">//但是并没有打印出来，这是为什么呢？默认情况下，better-scroll是不可以实时监听滚动位置的。</span><br><span class="line">  //想要做到，在new一个BScroll时还要传参数。重要属性：probeType  </span><br></pre></td></tr></table></figure><p>解决：修改传入的参数2，属性probeType</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const bscroll = new BScroll(document.querySelector(&#x27;.content&#x27;), &#123;</span><br><span class="line">//要不要实时侦测  0或1--不侦测  </span><br><span class="line">//2--侦测 手指滚动的过程中个侦测，但手指离开后的惯性滚动不侦测，其他情况，手指离开的滚动也可监听到</span><br><span class="line">    probeType: 3,</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204163108700.png" alt="image-20201204163108700" style="zoom:50%;" /><ul><li><p>属性2： 在better-scroll里面的如果是button，无论Click是true还是false都是可以点击的，但div那些组件就必须设置true才能添加监听事件</p></li><li><p>上拉加载更多思路：属性3：pullUpLoad效果，我滚动到底，会进行打印</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const bscroll = new BScroll(document.querySelector(&#x27;.content&#x27;), &#123;</span><br><span class="line"> probeType: 3,</span><br><span class="line">   // 监听已经拉到第一页最低部了，我们要做上拉加载更多的功能pullUpLoad</span><br><span class="line">   pullUpLoad: true</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>但有一个问题：只能监听一次，只能加载一次，怎么办先去发送网络请求，请求更多页的数据。等你数据请求完成并且将新的数据存储在list里展示出来后调调用一个函数，告诉它这一次的上拉加载已经做完了。进行下一次的上拉加载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bscroll.on(&#x27;pullingUp&#x27;, () =&gt; &#123;</span><br><span class="line">  //这个函数没有参数，只是这里需要进行上拉加载更多了</span><br><span class="line">  console.log(&#x27;上啦加载更多&#x27;)</span><br><span class="line">  //为了不那么频繁进行下一次，设置一个定时器</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;我延迟了4秒&#x27;);</span><br><span class="line">    bscroll.finishPullUp()</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>我容易犯错的地方：这些属性的使用不够熟练，默写容易露着漏那</p></li></ul></li><li><h5 id="对Better-scrolld进一步封装">对Better-scrolld进一步封装<a class="anchor" href="#对Better-scrolld进一步封装">·</a></h5><ul><li><p>进一步的封装与抽离。首先将Scroll的功能封装在组件Scroll.vue里，目的解耦合。每个组件都用，对这个框架依赖性太强了。所以先封装，需要的组件只需要引入封装就可以。框架改变时，只需要修改封装就可以，而不需要每个组件都修改。这种公司向跟网络请求的封装也是一样的。</p><p>封装操作思想：  封装在components里面，因为它能在多个地方进行使用的。common里面scroll</p><p>文件夹，下一个项目中只要是滚动相关的项目，他也是可以拿来用的。Scroll.vue</p><ul><li><p>首先他也要有外层包裹，并满足包裹里面只能有一个；</p></li><li><p>在mounted里面不建议用document.querySelector('.wrapper)// 通过选择器拿到的，如果有重复类名，没有办法区分拿到的是哪一个，结果可能不准确，// 因此造成bug，Vue 也不建议去直接操作Dom。怎么办呢？绑定ref,传入this.$refs.wrapper ref如果是绑定在组件中的，通过$refs.名字拿到的是一个组件对象。</p><p>ref如果是绑定在普通标签中的，通过$refs.名字拿到的是一个元素对象。跟document.querySelector一样</p></li><li><p>此外为了其他子组件调用的时候可以自由决定要不要实时刷新功能、要不要上拉加载更多的功能。我们对BScroll对象里面要传入的参数不是像之前写死的。而是从父组件接收过来的数据来决定</p></li><li><p>在实时监听和上拉加载更多事件中，采用向外触发$emit事件，根据需要决定是否携带参数传出去。</p><p>告诉要监听的组件，以便他们进行需要的处理和信息</p></li><li><p>在methods里面，对我们创建的scroll对象里面自带的方法进行了封装，这样做是多此一举吗？1.封装思想；  2.为了简化父组件获取子组件中的scroll对象，再获取他的方法</p></li></ul></li><li><pre><code>&lt;template&gt;  &lt;div class=&quot;wrapper&quot; ref = &quot;wrapper&quot;&gt;    &lt;!-- 以前的ref 父组件获取某一个子组件 --&gt;    &lt;!-- 必须有包裹，因为better-scroll里面只能有一个 --&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;!-- 这里设置插槽的目的：方便首页 --&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import BScroll from 'better-scroll'  export default &#123;    name: 'Scroll',    data() &#123;      return &#123;        scroll: null      &#125;    &#125;,    props: &#123;      probeType: &#123;        type: Number,        default() &#123;          return 0        &#125;      &#125;,      pullUpLoad: &#123;        type: Boolean,        default() &#123;          return true        &#125;      &#125;    &#125;,    mounted()&#123;      //创建BScroll对象      this.scroll = new BScroll(this.$refs.wrapper, &#123;        //根据传入的来决定是否实时监听        probeType: this.probeType,        pullUpLoad: this.pullUpLoad,      &#125;)      this.scroll.on('scroll', (position) =&gt; &#123;        // 子组件向外发送位置信息，和事件        this.$emit('scroll', position)      &#125;)      this.scroll.on('pullingUp', () =&gt; &#123;        this.$emit('pullingUp')      &#125;)     &#125;,    methods: &#123;     scrollTo(x, y, time) &#123;       this.scroll.scrollTo(x, y, time)     &#125;,     //对完成上拉加载更多进行封装     finishPullUp() &#123;       this.scroll.finishPullUp();     &#125;    &#125;  &#125;&lt;/script&gt;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ Home组件中，滚动区域高度的确定，上面留44和下面高度留49</span><br><span class="line"></span><br></pre></td></tr></table></figure>  .content &#123;    height: 300px;    position: absolute;    top: 44px;    bottom: 49px;    right: 0;    left: 0;   &#125;    #home &#123;    /* 如果这里没有44px,轮播图会跑到最上面，他的一部分就会被导航栏遮盖 */    padding-top: 44px;    position: relative;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 遇到的问题： 图片被循环滚动？怎么解决、？？</span><br><span class="line">  &lt;img src=&quot;C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204215545273.png&quot; alt=&quot;image-20201204215545273&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  原因： 在Scroll.vue里面我用了4次插槽，这会导致将scroll包裹的东西重复了4次  &lt;template&gt;    &lt;div class=&quot;wrapper&quot; ref = &quot;wrapper&quot;&gt;      &lt;!-- 以前的ref 父组件获取某一个子组件 --&gt;      &lt;!-- 必须有包裹，因为better-scroll里面只能有一个 --&gt;      &lt;div class=&quot;content&quot;&gt;        &lt;!-- 这里设置插槽的目的：方便首页 --&gt;        &lt;slot&gt;&lt;/slot&gt;        &lt;slot&gt;&lt;/slot&gt;        &lt;slot&gt;&lt;/slot&gt;        &lt;slot&gt;&lt;/slot&gt;        &lt;slot&gt;&lt;/slot&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/template&gt;  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    + 新产生的问题： 就是TabControl组件的粘连定位效果已经失效了，为什么呢？怎么解决？</span><br><span class="line"></span><br><span class="line">      better-scroll在滚动的时候，系统没有办法检测现在滚到哪里了，所以sticky失效了。待解决</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">+ 需求1： 底部增加回到顶部的按钮，封装在components的content里面BackTop.vue</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204201503011.png&quot; alt=&quot;image-20201204201503011&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  ​    往下拉轮播图，为什么图标在没有布局时会跑到这里，因为从轮播图开始下面的东西是脱标的，图标就会被覆盖掉。而且我们顶部导航栏有一个padding-bottom  所以图标从下面导航栏下面开始占据位置。但我希望他在右下角，fixed布局。而且很多个页面这个图标都是在右下角这个位置，我们在这个组件里提前设置好</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><template><!-- 这里面封装的就是一个返回顶部的小图片 -->  <div class="backtop">    <img src="~assets/img/common/top.png" alt="" >  </div></template><script>  export default {    name: "BackTop",  }</script><style scoped>  .backtop {    position: fixed;    right: 6px;    bottom: 60px;  }  .backtop img {    width: 43px;    height: 43px;  }</style>><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 需求2：如何完成位置跳转：拿到Better-scroll对象，里面有一个scrollTo(x, y)方法，传入参数就可以跳转到我们想要的位置。在哪个组件里实现这个功能，</span><br><span class="line"></span><br><span class="line">  + 方案1：不要在图标组件里完成跳转到顶部，因为顶部是父组件Home里的，而图标组件和Scroll组件都是Home组件的子组件。此时需要图标组件触发，Home那边组件监听，再用methods想办法拿到Srcoll组件里的Bette-scroll对象，再去调用这个方法。这样做很麻烦</span><br><span class="line">  + 更好的做法： 直接监听Home里面的back-top组件的点击事件，这在普通标签上是当然可以的，但组件是否可以直接不通过子组件向外触发事件，父组件监听的方式，而是父组件直接监听呢？？</span><br><span class="line">    答案是：不可以直接监听点击，必须借助.native修饰符，才可以监听组件根元素的原生事件。如果不加，只能按照方案1，但是方案1比较麻烦</span><br><span class="line"></span><br><span class="line">+ 问题2： 如何获取到scroll对象，给scroll根组件绑定ref，再通过this.$refs.Scroll()拿到组件对象，再拿到组件对象的属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Home组件中：<scroll class="content" ref="scroll" :probe-type = "3" >&lt;back-top @click.native=“backTop” v-show = “isBackTop”&gt;</back-top>data里：isBackTop: false方法里：backTop() {// //拿到scroll组件上的scroll对象，调用他的scrollTo方法,第三个参数是多长时间回位置// this.$refs.scroll.scroll.scrollTo(0, 0, 500)// 这样写是拿到scroll组件，直接调用组件的方法，这个方法内部做了什么，在Scroll中已经定义了this.$refs.scroll.scrollTo(0, 0, 500)},</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 需求3：达到某个临界值时，图标显示，没到某个临界值，图片隐藏。所以我们需要实现监听图片滚动了多少，怎么监听呢？？？</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Home组件进一步修改：&lt;scroll class=“content” ref=“scroll” :probe-type = “3”@scroll = “contentScroll”&gt;方法里：<br>contentScroll(position) {//从position里取出y值，与1000对比，大于显示图标，小于隐藏图标//y默认是负值，要转换成正值，跟1000对比this.isBackTop = (-position.y) &gt; 1000 ?true: false<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 需求4： 上拉加载更多图片，此时我们需要再进行数据请求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 首页Better-scroll可滚动区域问题：</span><br><span class="line"></span><br><span class="line">现象：图片异步加载，每一项组件的高度被撑开了，可滚动区域突然变得更大了，但是这个插件并不知道，他还是按照没有图片时的可滚动区域。这时再往下滚就滚动。所以，我们要1.监听图片加载完，进行刷新。2.拿到srcoll对象调用refresh方法。一旦调用refresh就是真实可滚动高度</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">  打印new BScroll出来的 scroll对象，控制台查看里面有个属性叫scrollerHeight，根据放在better-scroll的cntent在子组件的高度决定当前有多少区域是可滚动的。这个高度没有计算加载图片的高度。所以我们滑到最后会有一片空白。图片异步加载，每一项组件的高度被撑开了，可滚动区域突然变得更大了，但是这个插件并不知道，他还是按照没有图片时的可滚动区域。这时再往下滚就滚动。所以，我们要</span><br><span class="line"></span><br><span class="line">+ 1.监听每张图片加载完，进行一次刷新。图片绑定加载事件，一旦图片加载完成就会执行这个函数</span><br><span class="line"></span><br><span class="line">问题怎么知道30张图片已经加载完成了呢？也就是如何图片加载完成与refresh对应起来</span><br><span class="line">![image-20201205185556938](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201205185556938.png)</span><br><span class="line"></span><br><span class="line">2.拿到srcoll对象调用refresh方法。一旦调用refresh就是真实可滚动高度。但是这个refresh是scroll对象的方法，现在在GoodListItem子组件里，是不能直接调用另一个组件的方法的。解决办法：GoodListItem先传给GoodList，再传给首页，首页再给Scroll组件。但这样很麻烦。</span><br><span class="line"></span><br><span class="line">方法2：搞一个Vuex,每次图片加载完之后，就改变Vuex里面的属性。再让首页引用这个属性并监听这个属性的改变。</span><br><span class="line"></span><br><span class="line">方法3：事件总线。与Vuex很像，但是他不是管理公共状态的，是用来管理事件的。this.$bus.$emit(&#x27;aa&#x27;),可以往Bus里面发送一个事件aa，之后在想要监听的位置写 this.$bus.$on(&#x27;aaa&#x27;, 函数)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>methods: {imageLoad() {this.$bus.$emit(‘itemImageLoad’)}}</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Home组件中监听：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>created () {this.getHomeMultidata()//我们希望3个页面在开始的时候都是请求第一页this.getHomeGoods(‘pop’)this.getHomeGoods(‘new’)this.getHomeGoods(‘sell’)</p><pre><code>//等组件创建完成之后就要监听你的图片是不是加载完成了this.$bus.$on('itemImageLoad', () =&gt; &#123;  console.log('我知道你的图片加载完成啦')&#125;)</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 但是会报错： 因为bus不存在。必须在原型里面加上。去main.js里面，给Vue原型方法上加上$bus</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//此时$bus就是事件总线Vue.prototype.$bus = new Vue()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">图片加载完后，给总线触发了事件，Home组件在created中监听。监听到后调用scroll组件里面的refres方法。但是scroll对象的创建在Scroll.vue组件里在mounted的时候创建的。这是后拿到的scroll可能是空的。对Scroll方法进行修改，</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code> scrollTo(x, y, time) &#123;   //在这里先做判断，scroll是不是有值  //  this.scroll &amp;&amp; this.scroll.scrollTo(a,y,time)  //  this.scroll.scrollTo(x, y, time) &#125;, refresh() &#123;   this.scroll &amp;&amp; this.scroll.refresh();  //  this.scroll.refresh();&#125;,</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在Home组件里也做同样修改。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mounted() {//等组件创建完成之后就要监听你的图片是不是加载完成了this.$bus.$on(‘itemImageLoad’, () =&gt; {this.$refs.scroll &amp;&amp; this.$refs.scroll.refresh();})},</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">防抖动/debounce：防抖函数，在用户输入一个值，等待50ms，看是否还输入值，若继续输入，将上一次准备像服务器发送的请求取消掉。将这两个东西收集起来，若500ms之后没有继续输入。这就防止了短时间内向服务器发送多次请求，缓解服务器的压力。</span><br><span class="line"></span><br><span class="line">这里每次加载图片都进行刷新refresh，所以也应该做防抖处理。这样加载一次要刷新30次。通过debounce函数将refresh函数传入到debounce中生成一个新的函数。</span><br><span class="line"></span><br><span class="line">this.debounce ()</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>debounce(func, time) &#123;  let timer = null;  //这里剩余参数，可以传多个参数  return function(...args) &#123;    if (timer) &#123;clearTimeout(timer)&#125;     timer = setTimeout(() =&gt; &#123;     //改变this指向，拿到当前函数的参数       func.apply(this, args)     &#125;)  &#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.判断是否有timer，第一次没有值，null。延迟500ms执行。但是图片加载调用很频繁。所以延迟的过程中第二次来到这个函数。此时timer不是空的了，看赋值表达式。所以会将timer1清空掉。再给timer重新赋值。到第29次一样。但是第30次之后，因为没有31次了，不会再来到这个函数里面了，定时器时间一到。拿到function了。执行函数里面的函数，applay拿到当前的所有传入参数</span><br><span class="line">为什么不传参数delay，也能试下防抖呢？</span><br><span class="line">事件循环机制：因为只要实现setTimeOUt是异步函数，即使没有延迟时间，会放到事件队列的尾部等到执行栈里执行完成之后才执行时间队列里的任务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mounted() {//传入的是函数，不是函数返回值// 这里的refresh变量不会被销毁，因为被闭包引用const refresh = this.debounce(this.$refs.scroll.refresh, 10)//等组件创建完成之后就要监听你的图片是不是加载完成了this.$bus.$on(‘itemImageLoad’, () =&gt; {this.$refs.scroll &amp;&amp; this.$refs.scroll.refresh();//在这里调用refresh的过程：})},</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">节流函数/throttle：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对节流函数封装在common文件夹中，起名字Utils.js，并导入Home组件，则使用时就不需要加this了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>export function debounce(func, time) {let timer = null;//这里剩余参数，可以传多个参数return function(…args) {if (timer) {clearTimeout(timer)}timer = setTimeout(() =&gt; {//改变this指向，拿到当前函数的参数func.apply(this, args)})}}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>import {debounce} from ‘common/Utils.js’</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ ##### 需求5：上拉加载更多 #####</span><br><span class="line"></span><br><span class="line">  + 监听什么时候滚到底部，scroll组件中的pullUpLOad属性值是外部决定的，让外界传入一个属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>      pullUpLoad: &#123;        type: Boolean,        default() &#123;          return false        &#125;      &#125;    &#125;,<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Home组件中对scrol添加绑定属性：</span><br><span class="line"></span><br></pre></td></tr></table></figure>    &lt;scroll class=&quot;content&quot; ref=&quot;scroll&quot; :probe-type = &quot;3&quot;  @scroll = &quot;contentScroll&quot;   :pull-up-load = &quot;true&quot;      &lt;/scroll&gt; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在mounted里面监听 </span><br><span class="line"></span><br></pre></td></tr></table></figure>      if (this.pullUpLoad)&#123;        this.scroll.on('pullingUp', () =&gt; &#123;        this.$emit('pullingUp')      &#125;)      &#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因为上拉到底时，我们首页要将即将加载的数据请求过来，所以首页Home组件要监听这个事件，并进行数据请求。currentType记录了当前选中的类型pop，根据pop取出pop当前页码。里面会将第二页数据拿到。放到list里面。并加页码</span><br><span class="line"></span><br></pre></td></tr></table></figure>    &lt;scroll class=&quot;content&quot; ref=&quot;scroll&quot; :probe-type = &quot;3&quot;             @scroll = &quot;contentScroll&quot;   :pull-up-load = &quot;true&quot;            @pullingUp = &quot;loadMore&quot;            &gt;methods里面：    loadMore() &#123;      //currentType记录了当前是哪一项。我们就获取哪一项的数据。取出当前的页码并加上1，      // 如果继续上拉加载更多，页码继续增多      console.log('首页知道你到达底部啦')      this.getHomeGoods(this.currentType)    &#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 问题：pullUpLoad默认只加载一次，还需要finish函数。在数据加载完之后，告诉他已经完成了上拉加载更多</span><br><span class="line"></span><br></pre></td></tr></table></figure>    getHomeGoods(type) &#123;      // 这个+1，这是告诉他要请求的是哪个页码的数据      const page = this.goods[type].page + 1      getHomeGoods(type, page).then(res =&gt; &#123;         console.log(res);        this.goods[type].list.push(...res.data.list);        // 而这个地方的+1，则是我们已经有两页数据了，当前页码应该更新到2了，而不是之前的1        this.goods[type].list.page +=1;        // //调用scroll里面的方法        this.$refs.scroll.finishPullUp();      &#125;)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>Scroll组件中，    //对完成上拉加载更多进行封装     finishPullUp() &#123;       this.scroll.finishPullUp();     &#125;,<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 9.TabControl的吸顶效果 ###</span><br><span class="line"></span><br><span class="line">#### 之前有sticky实现，但是在后面改需求后，又失效了。现在怎么解决呢？ ####</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201210195522021.png&quot; alt=&quot;image-20201210195522021&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">1.判断向上滚动的距离，如果大于某个距离，就开始吸顶（改布局fixed等）</span><br><span class="line"></span><br><span class="line">+ 怎么确定这个阈值呢？获取TabControl的offtop属性。一般情况下轮播图加载完了，他就拿到的是一个比较正确的值。</span><br><span class="line">  项目中经常需要监听图片是否加载完，否则他的加载会对你获取的数据有影响。</span><br><span class="line">  去HomeSwiper组件里，为图片绑定@load事件监听，，并向外$emit触发事件</span><br><span class="line"></span><br><span class="line">![image-20201206221918886](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201206221918886.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure> 绑定对HomeSwiper组件上的监听： swiperImageLoad swiperImageLoad() &#123;    //打印结果    // this.$refs.scroll &amp;&amp; this.$refs.scroll.refresh();    // 右侧拿到的是组件对象，组件有没有属性叫offsetTop呢？答案是没有    // 所以我们应该去拿组件里的模板，是元素里面才有这个属性    // 所有的组件都有一个属性叫$el，这个属性是用于获取组件中的元素的    // this.tabOffsetTop = this.$refs.tabControl;    this.tabOffsetTop = this.$refs.tabControl.$el.offsetTop;    // 但这样数值结果是不对的，因为mounted里挂载以为这组件都挂载上面了，    //但是图片未必都加载完了.等上面的图片都加载完毕再去拿这个offsetTop才是对的  &#125;</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">每张轮播图加载后都会取一次offsetTop，其实只需拿一次就可以拿到高度。我就知道高度了。你后面图片的加载就不要再发送这个事件告诉HOME组件了，因为有第一次的发送能拿到offsetTop。HomeSwiper修改：</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>  methods: &#123;    imageLoad() &#123;      //若图片还没有加载       if (!isLoad) &#123;         this.$emit('swiperImageLoad');        //  这样在第二次加载的时候他就不会来到这个函数里面了         this.isLoad = true       &#125;    &#125;  &#125;,添加：  data() &#123;    return &#123;      isLoad: false    &#125;  &#125;</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2.在Home组件里面contentScroll里，决定要不要吸顶</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>  contentScroll(position) &#123;    //从position里取出y值，与1000对比，大于显示图标，小于隐藏图标    //y默认是负值，要转换成正值，跟1000对比    this.isBackTop = (-position.y) &gt; 1000 ?true: false    //决定是否吸顶，当前滚动距离是否大于tabControl距离顶部的高度，就吸顶    this.isTabFixed = (-position.y) &gt; this.tabOffsetTop  &#125;,</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><pre><code>  帮上新属性class,动态决定要不要加一个fixed：      &lt;tab-control :titles = &quot;titles&quot;                     class=&quot;tab-control&quot;                     @tabClick=&quot;tabClick&quot;                    :class = &quot;&#123;fixed:isTabFixed&#125;&quot;&gt;      &lt;/tab-control&gt;.fixed &#123;  position: fixed;  top: 0;  right: 0;  left: 0;&#125;</code></pre>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 新问题： TabControl一下子往上面跑一下，因为它脱标了，所以下面的东西一下子跑上面去了。继续往下滑，这个栏目消失了。Better-scroll在滚动中的过程中，会往content上加很多属性。其中Translate属性在滚动的过程中，会不断地改变，所以滚动是通过修改Translate实现的。里面有一个fixed的东西是可以修改translate的。所以，Better-scroll里面的停留效果不好做，粘贴tab-control，到nav后面，scroll外面。并添加v-show = &quot;isTabFixed&quot;  isTabFixed默认值是false</span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">      &lt;tab-control :titles = &quot;titles&quot; </span><br><span class="line">                    class=&quot;tab-control&quot; </span><br><span class="line">                    @tabClick= &quot;tabClick&quot;</span><br><span class="line">                    :class = &quot;&#123;fixed:isTabFixed&#125;&quot;</span><br><span class="line">                    v-show = &quot;isTabFixed&quot;&gt;</span><br><span class="line">      &lt;/tab-cotrol&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，他是false的，当滚到要显示那个地方，他就出现。并将原有的覆盖。用户看起来好像停留在这里了。</p><ul><li><p>新问题：点击新款，并没有更新，说明这两个TabControl并没有保持一致我们只需要拿到tabControl，它里面的currentIndex记录了当前选中的是哪个类型。所以 两个tabControl设置不同的tabControl2。在监听点击的位置，等点击完成之后，this.$refs.tabControl1.currentIndex</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tabClick(index) &#123;</span><br><span class="line">  // console.log(index)</span><br><span class="line">  switch (index) &#123;</span><br><span class="line">    case 0: this.currentType = &#x27;pop&#x27;</span><br><span class="line">    break</span><br><span class="line">    case 1: this.currentType = &#x27;new&#x27;</span><br><span class="line">    break</span><br><span class="line">    case 2: this.currentType = &#x27;sell&#x27;</span><br><span class="line">    break</span><br><span class="line">  &#125;</span><br><span class="line">  //index 是最新点击的。更新index</span><br><span class="line">  this.$refs.tabControl1.currentIndex = index;</span><br><span class="line">  this.$refs.tabControl2.currentIndex = index;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>一直困扰我的问题：首次进入页面：轮播图没有效果。但切换其他页面再切换回来，又显示了？？？？</p></li><li><p>为什么加载底部会有大片空白？？为什么切换是，没有对应图片展示？？有时出现，大多数时候没</p></li><li><p>没有办法切换 流行，首页，数据，但是组件在scroll外面可以，里面就可以(原因是上面代码中两个index赋值都给了tabControl1，写错了)</p></li><li><h4 id="遇到的问题：当我们离开首页后，再回来，如果很快就回来，会保持离开时的浏览位置。但如果稍微慢一点，再进来就回到了最开始。">遇到的问题：当我们离开首页后，再回来，如果很快就回来，会保持离开时的浏览位置。但如果稍微慢一点，再进来就回到了最开始。<a class="anchor" href="#遇到的问题：当我们离开首页后，再回来，如果很快就回来，会保持离开时的浏览位置。但如果稍微慢一点，再进来就回到了最开始。">·</a></h4><ul><li><p>原因：这些组件都是通过路由来实现管理的，当跳转到分类页，首页就销毁了。所以我们再进入的时候Home又重新创建。解决：对App.vue里面的router-view包裹一层keep-alive。但还是有问题，</p><ul><li><p>1.虽然Home组件没有被销毁，但better-scroll内部的问题导致效果并没有生效（安卓手机生效了）。</p></li><li><p>2.我们要让Home中的内容保持原来滚动的位置。离开时保持一个位置信息，再进入的时候设置成之间的位置</p></li><li><p>3.监听什么时候离开，activated和deactivated。一个是在进来，一个是在拉开的时候调用。</p></li></ul></li><li><p>Home组件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  activated() &#123;</span><br><span class="line">  //进入的时候设置高度,x不需要滚动，也不需要几秒之内,应该是迅速回到原位置</span><br><span class="line">      this.$refs.scroll.scrollTo(0, this.saveY, 0)</span><br><span class="line">  //还要进行刷新，不然有时候会出问题。但我们在进来的时候滚动到原来的位置，并进行一次属性</span><br><span class="line">      this.$refs.scroll.refresh();</span><br><span class="line">&#125;,</span><br><span class="line">    deactivated() &#123;</span><br><span class="line">  // 离开的时候拿到高度进行保存</span><br><span class="line">      // this.saveY = this.$refs.scroll.scroll.y  对这个获取做一层封装</span><br><span class="line">  this.saveY = this.$refs.scroll.getScrollY() </span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>在scroll组件中：methods中封装函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getScrollY()&#123;</span><br><span class="line">   return this.scroll ? this.scroll.y : 0;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目2-去哪儿网：项目记录篇</title>
      <link href="/posts/2071449193.html"/>
      <url>/posts/2071449193.html</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2020年10月</li><li>项目背景： 慕课网的项目学习时做的笔记</li><li>项目记录篇，比较啰嗦</li></ul><h2 id="去哪儿项目记录梳理">去哪儿项目记录梳理<a class="anchor" href="#去哪儿项目记录梳理">·</a></h2><p>Axios–进行Ajax数据的获取</p><p>Vue Router–来做多页面之间的路由</p><p>Vuex–来做各个组件之间的数据共享</p><p>异步组件–来让我们代码上线，性能更优</p><p>Stylus–编写前端的样式</p><p>递归组件–实现组件调用自己的效果</p><p>插件–比Swiper插件来实现页面上的轮播效果</p><h3 id="6-1-Vue项目预热-环境配置">6-1  Vue项目预热-环境配置<a class="anchor" href="#6-1-Vue项目预热-环境配置">·</a></h3><ol><li><h5 id="cmd输入git-version报错解决办法：">cmd输入git --version报错解决办法：<a class="anchor" href="#cmd输入git-version报错解决办法：">·</a></h5></li></ol><p>①配置环境变量(分行已经是代表分号【;】间隔了)；</p><p>②安装的时候选择git和cmd一起的选项…(自动帮你配置好环境变量)</p><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="clipboard.png" style="zoom:50%;" /><ol start="2"><li><h5 id="打通线上-git码云-线下……SSH公钥：">打通线上(git码云)-线下……SSH公钥：<a class="anchor" href="#打通线上-git码云-线下……SSH公钥：">·</a></h5><ul><li><p>设置-&gt;SSH公钥-&gt;生成/添加SSH公钥</p></li><li><p>在Git Bash(在windows小型的Linux操作系统)运行Linux命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;2211016493@qq.com&quot; cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>生成公钥粘贴到网站上,[网站上有公钥，然后其实本地有一个私钥，公钥和私钥做匹配]</p></li></ul></li><li><h5 id="git码云克隆-下载-SSH复制">git码云克隆/下载-&gt;SSH复制<a class="anchor" href="#git码云克隆-下载-SSH复制">·</a></h5><ul><li>Git Bash：cd切换到想要把代码存放的地方</li><li>git clone SSH复制的内容</li></ul></li><li><h5 id="创建一个Vue项目">创建一个Vue项目<a class="anchor" href="#创建一个Vue项目">·</a></h5><ul><li><p>大型项目Vue.js是不够的，需要使用命令行工具(CLI)：</p></li><li><p>全局安装vue-cli</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --global vue-cli </span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个基于webpack模板的新项目(my-project是你的项目文件夹名字)</span><br><span class="line">vue init webpack my-project   （这是基于cli2的创建项目的做法）</span><br><span class="line">standardlone√，vue-router√，ESLint√，ESLint Standard√，unit×，e2e×，use NPM√</span><br><span class="line">cd my-project</span><br><span class="line"> npm run dev</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="6-3-Vue项目预热-项目代码介绍">6-3  Vue项目预热-项目代码介绍<a class="anchor" href="#6-3-Vue项目预热-项目代码介绍">·</a></h3><ul><li><p>路由的配置都放在router文件夹的index.js里面;路由就是根据网址的不同，返回不同的内容给用户</p></li><li><p>APP.vue是整个应用的根组件，在APP.vue里<router-view>显示的内容就是当前路由地址所对应的路由内容，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default new Router(</span><br><span class="line">&#123;  routes:[</span><br><span class="line">&#123;path: &#x27;/&#x27;,</span><br><span class="line"> name: &#x27;HelloWorld&#x27;, </span><br><span class="line"> component: HelloWorld   </span><br><span class="line">&#125;] </span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>路由内容在router文件夹的index.js配置项找到，当访问根路径的时候(path:‘/’)，展示的是HelloWorld单文件组件。</p></li><li><p>import Home from ‘@/pages/home/Home.vue’  @表示src目录下，Home.vue不写后缀.vue也会帮你去找到它</p></li></ul><h3 id="6-4-Vue项目预热-单文件组件与Vue中的路由">6-4  Vue项目预热-单文件组件与Vue中的路由<a class="anchor" href="#6-4-Vue项目预热-单文件组件与Vue中的路由">·</a></h3><ol start="5"><li><h5 id="Vue中做页面跳转一般不用a标签，用：">Vue中做页面跳转一般不用a标签，用：<a class="anchor" href="#Vue中做页面跳转一般不用a标签，用：">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/list&quot; class=&quot;home&quot;&gt;列表页&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="template模板只能向外暴露一个根标签">template模板只能向外暴露一个根标签<a class="anchor" href="#template模板只能向外暴露一个根标签">·</a></h5><p>所以里面的内容必须有一个div进行包裹</p></li><li><h5 id="【多页面应用】：页面跳转→返回HTML">【<strong>多页面应用</strong>】：页面跳转→返回HTML<a class="anchor" href="#【多页面应用】：页面跳转→返回HTML">·</a></h5><ul><li><p>特点：打开项目页面，点开控制台里的network，选择Doc,选择刷新页面。当访问首页的时候，会请求一个首页的html文件。进入列表页面，又会返回城市列表的页面html(没有home的html)。</p><p>每次页面跳转的时候，后台都会给我们返回一个新的html文档。这种类型的网站就叫做<strong>多页面应用</strong></p></li><li><p>优点：</p><ul><li><p>首屏时间快首屏时间：页面首个屏幕内容展现出来的时间，为什么会快呢？访问一个页面的时候，服务器返回一个html。然后页面就会被展示出来，这个过程只经历了一个http请求，请求回来了页面也就展示出来了，所以页面展示的速度非常的快)</p></li><li><p>SEO效果好搜索引擎在做网页排名的时候需要知道网页的内容，才能给网页权重来进行网页的排名，搜索引擎可以识别html的内容，而我们网页所有的内容都放在html之中，所以SEO效果好</p></li></ul></li><li><p>缺点：</p><ul><li>页面切换慢每一次页面切换都需要发送一个http请求，假设网速比较慢的时候，页面来回切换会出现明显的卡顿</li></ul></li></ul></li><li><h5 id="【单页面应用】：页面跳转→Js渲染">【<strong>单页面应用</strong>】：页面跳转→Js渲染<a class="anchor" href="#【单页面应用】：页面跳转→Js渲染">·</a></h5><ul><li><p>特点（前端路由渲染）</p><p>第一次进入页面home的时候会请求一个html文件，从home(http://localhost:8081/#/)跳转list(http://localhost:8081/#/list)并没有不请求html文件，如何做到不请求html文件但是页面会跟着变呢？原理：JS会感知到url的变化，js动态地把当前页面内容清除掉再把下一个页面的内容挂载到页面上(把新的页面的DOM结构渲染出来)，这个时候路由不是后端来做而是前端，判断是显示哪一个组件把以前的组件清除掉就可以。这时候就不会每次跳转，都去请求页面了</p></li><li><p>优点</p><ul><li>页面切换快：因为不请求→当页面之间做跳转不需要做html文件的请求，节约了很多http请求发送的时延，使页面切换的过程变得非常快</li></ul></li><li><p>缺点</p><ul><li>首屏时间稍慢单页首屏展示出来需要请求一次html，同时还需要发一个js的请求，2个请求都回来了首屏才会展示出来</li><li>SEO(搜索引擎优化)差搜索引擎认识html中的内容，不认识js的内容，单页页面所有内容都是靠JS渲染生成的，搜索引擎不识别这一块的内容，它就不给你的网页一个好的排名</li></ul></li></ul></li><li><h5 id="有缺点为什么要使用Vue开发单页应用？">有缺点为什么要使用Vue开发单页应用？<a class="anchor" href="#有缺点为什么要使用Vue开发单页应用？">·</a></h5><p>其实，Vue之中还提供了其他的技术(比如服务器端渲染这样的技术)，通过这些技术我们可以完美地解决单页应用的问题。解决了这些问题后，实际上单页应用对前端来说是一套非常完美的解决方案。</p></li></ol><h3 id="6-5-Vue项目预热-项目代码初始化">6-5  Vue项目预热-项目代码初始化<a class="anchor" href="#6-5-Vue项目预热-项目代码初始化">·</a></h3><ol start="11"><li><h5 id="添加第二行代码：在移动端的设备，用户用手指放大缩小是无效的，页面的比例始终是1-1">添加第二行代码：在移动端的设备，用户用手指放大缩小是无效的，页面的比例始终是1:1<a class="anchor" href="#添加第二行代码：在移动端的设备，用户用手指放大缩小是无效的，页面的比例始终是1-1">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="reset-css-重置页面的样式表">reset.css(重置页面的样式表)<a class="anchor" href="#reset-css-重置页面的样式表">·</a></h5><p>不同的手机浏览器上默认的样式是不统一的，把初始化样式作一个统一。</p></li><li><h5 id="border-css：该文件可以收藏起来以后直接用">border.css：该文件可以收藏起来以后直接用<a class="anchor" href="#border-css：该文件可以收藏起来以后直接用">·</a></h5><ul><li><p>解决移动端1像素边框问题border-bottom:1px solid green,指的是css像素。有的手机屏幕分辨率比较高，它是一个2倍屏或者3倍屏。在2倍屏实际上不是1个物理像素的高度，可能是2个或者3个物理像素的高度。为了解决多倍屏中一像素边框会被显示成多倍屏的问题。</p></li><li><p>项目入口文件main.js里面引入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#x27;./assets/styles/reset.css&#x27;</span><br><span class="line">import &#x27;./assets/styles/border.css&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="引入fastClick库，解决移动端300毫秒延迟的问题">引入fastClick库，解决移动端300毫秒延迟的问题<a class="anchor" href="#引入fastClick库，解决移动端300毫秒延迟的问题">·</a></h5><ul><li><p>在移动端开发中，某些机型某些浏览器上使用click事件时会延迟300ms才执行</p></li><li><p>把fastclick安装到项目的依赖中，（package.json中的&quot;dependencies&quot;）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install fastclick --save　</span><br><span class="line">save意思是不管在开发环境或者是打包生成线上版本的代码都需要使用fastclick</span><br></pre></td></tr></table></figure></li><li><p>在main.js里面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import fastClick from &#x27;fastclick&#x27;</span><br><span class="line">fastClick.attach(document.body)</span><br><span class="line">//attach是fastClick自带的方法 　</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="iconfont：创建一个项目-Travel项目图标">iconfont：创建一个项目-Travel项目图标<a class="anchor" href="#iconfont：创建一个项目-Travel项目图标">·</a></h5></li><li><h5 id="git的使用">git的使用<a class="anchor" href="#git的使用">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add.     //把本地的修改提交到git的缓存区</span><br><span class="line">git commit -m &#x27;project init&#x27; //把缓冲区的内容提交到本地仓库(线上的代码还没有任何改变)</span><br><span class="line">git push     //把本地仓库的代码推到线上去，git码云官网代码更新 </span><br></pre></td></tr></table></figure></li></ol><h3 id="7-1-Vue项目首页-header区域开发">7-1  Vue项目首页-header区域开发<a class="anchor" href="#7-1-Vue项目首页-header区域开发">·</a></h3><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image016.gif)</p><ol start="18"><li>【CSS 预处理器】定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用”。https://www.cnblogs.com/yanxiaoge/p/11078843.html</li></ol><p>CSS预处理器的出现大大的提高了前端开发的效率和逼格，它让CSS可编程化。LESS和Sass/SCSS/Stylus是为常见的预处理器。</p><ul><li><p>安装stylus依赖包 npm install  stylus --save  （0.54.5）</p></li><li><p>安装stylus-loader npm install stylus-loader --save  （3.0.1）</p></li><li><p>重新启动项目 npm run start</p><p>用stylus来写样式,scoped限制只对当前组件有效，在这个组件中写的样式不对其他组件产生影响：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><ol start="19"><li>移动端的布局一般采用rem的布局方式</li></ol><p>reset.css的html里font-size设置成了50px，rem是相对与50px的这个尺寸，设计师给的是2倍尺寸的图片，86px应该写成43px，1rem=html的font-size=50px，那么43px=.86rem。</p><h3 id="7-2-Vue项目首页-iconfont的使用和代码优化">7-2  Vue项目首页-iconfont的使用和代码优化<a class="anchor" href="#7-2-Vue项目首页-iconfont的使用和代码优化">·</a></h3><ol start="21"><li><p>定义一个伪类实现[倒三角形]：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     &lt;div class=&quot;nabla&quot;&gt;&lt;/div&gt;</span><br><span class="line">.nabla&#123; </span><br><span class="line">      width:0; height: 0px; </span><br><span class="line">      border-top:10px solid black; </span><br><span class="line">      border-left:10px solid white; </span><br><span class="line">      border-right:10px solid white; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)</p><ol start="22"><li>iconfont的使用</li></ol><p>①官网下载</p><p>②下载的文件压缩包中需要使用的文件</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif)</p><p>③修改iconfont.css文件</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif)</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image012.gif)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconfont.css最后位置有提供一些类，汉语拼音的形式的类，我们可以通过64位或者16进制的一个码来直接使用这些图标(官网上复制代码)  </span><br><span class="line">.icon-jiantou:before&#123;content:&quot;\e64a&quot;&#125;  </span><br><span class="line">.icon-fanhui  ..icon--sousou</span><br></pre></td></tr></table></figure><p>④main.js引入iconfont.css：import ‘./assets/styles/iconfont.css’</p><ol start="23"><li><p>代码的优化：</p><ul><li><p>varibles.styl。background:#00bcd4，整个网页地方很多用到这个颜色(主题颜色)，#00bcd4用一个变量来表示，如果以后想要改变网页的主题，只要改变那个变量，全局就可以跟着改变，可维护性可以得到非常大的提升。</p><ul><li>src/assets/styles下创建一个文件varibles.styl：$bgColor=#00bcd4</li><li>在style标签里引入：@import ‘…/…/…/assets/styles/varibles.styl’<br>background:$bgColor</li></ul></li><li><p>对 [ 多处import ‘…/…/…/assets/styles/varibles.styl’ ] 长路径的优化</p><ul><li><p>打开build目录&gt;-webpack.base.conf.js&gt;-添加对应的代码(@可以代替src使用的意思)<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image014.gif" alt="clipboard.png" style="zoom:67%;" /></p></li><li><p>此时，@import ‘~@/assets/styles/varibles.styl’，注意：</p><p>如果在CSS中引入其他的CSS，使用【@】符号需要在前面加【~】符号。Header.vue的<style></style>里示例：@import ‘~styles/varibles.styl’</p><p>main.js示例：import ‘styles/reset.css’</p></li></ul></li></ul></li></ol><h3 id="7-3-Vue项目首页-首页轮播图">7-3  Vue项目首页-首页轮播图<a class="anchor" href="#7-3-Vue项目首页-首页轮播图">·</a></h3><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image040.gif)</p><ol start="24"><li><h5 id="建立git分支–【index-swiper】">建立git分支–【index-swiper】<a class="anchor" href="#建立git分支–【index-swiper】">·</a></h5><p>在企业开发当中每创建一个新的功能需要新建一个git分支来进行代码的开发，代码开发完成把分支上的代码合并到master主分支上。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先切换目录至项目文件夹 cd xxx</span><br><span class="line">git码云网新建分支【index-swiper】</span><br><span class="line">把线上的分支拉到本地 git pull</span><br><span class="line">git checkout index-swiper    切换到index-swiper分支进行代码的开发 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status 命令用于显示工作目录和暂存区的状态.使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。</span><br><span class="line">git log.   git status不显示已经commit到项目历史中去的信息。看项目历史的信息要使用</span><br></pre></td></tr></table></figure></li><li><h5 id="制作轮播图借助第三方插件——vue-awesome-swiper（github搜索）">制作轮播图借助第三方插件——vue-awesome-swiper（github搜索）<a class="anchor" href="#制作轮播图借助第三方插件——vue-awesome-swiper（github搜索）">·</a></h5><ul><li><p>安装 ：npm install vue-awesome-swiper@2.6.7 --save</p></li><li><p>引入：入口文件main.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueAwesomeSwiper from &#x27;vue-awesome-swiper&#x27;</span><br><span class="line">Vue.use(VueAwesomeSwiper)</span><br><span class="line">import &#x27;swiper/dist/css/swiper.css&#x27;</span><br></pre></td></tr></table></figure></li><li><p>src/pages/home/components创建Swiper.vue……</p></li><li><p>Swiper.vue组件里（原本github上面的代码）<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image020.gif" alt="clipboard.png" style="zoom:67%;" /></p></li><li><p>在Swiper.vue组件里定义这个数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data () &#123;   </span><br><span class="line">  return &#123;    </span><br><span class="line">swiperOption: &#123;&#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Home组件中引入、注册、使用</p></li></ul></li></ol><ul><li><h5 id="根据需求，对Swiper组件作修改">根据需求，对Swiper组件作修改<a class="anchor" href="#根据需求，对Swiper组件作修改">·</a></h5><ul><li><p>删除轮播图的左右箭头div（swiper-button-prev和swiper-button-next）</p></li><li><p>删除灰色滚动条div（swiper-scrollbar）</p></li><li><p>删除文字、插入图片：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;swiper-slide&gt;</span><br><span class="line">  &lt;img class=&quot;swiper-img&quot; src=&quot;http://mp-piao-admincp.qunarzz.com/mp_piao_admin_mp_piao_admin/admin/20191/37a42ce34dc16cd43bad17570bf6ab31.jpg_750x200_65d24bd7.jpg&quot; /&gt;</span><br><span class="line">&lt;/swiper-slide&gt;   </span><br><span class="line">&lt;swiper-slide&gt;</span><br><span class="line">  &lt;img class=&quot;swiper-img&quot; src=&quot;http://img1.qunarzz.com/piao/fusion/1811/31/da037478f37cf202.jpg_750x200_fe28d396.jpg&quot; /&gt;</span><br><span class="line">&lt;/swiper-slide&gt;</span><br></pre></td></tr></table></figure></li><li><p>对图片宽高进行调整：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.swiper-img       width:100% </span><br></pre></td></tr></table></figure></li></ul></li><li><p>调整代码：Home.vue插入test的div</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">    &lt;div&gt;   </span><br><span class="line">    &lt;home-header&gt;&lt;/home-header&gt;   </span><br><span class="line">        &lt;home-swiper&gt;&lt;/home-swiper&gt;   </span><br><span class="line">    &lt;div&gt;test·······&lt;/div&gt; </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h5 id="F12的network改成fast-3G，刷新页面test文本有明显的抖动">F12的network改成fast 3G，刷新页面test文本有明显的抖动<a class="anchor" href="#F12的network改成fast-3G，刷新页面test文本有明显的抖动">·</a></h5><p>[原因]：图片没有加载的时候高度是0，test在图片位置。图片加载完了才把图片撑开，test才跑到图片下面</p><p>[解决]：<swiper></swiper>外层加一个div标签wrapper，设置样式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.wrapper   </span><br><span class="line">overflow:hidden   </span><br><span class="line">width:100%   </span><br><span class="line">height:0   </span><br><span class="line">padding-bottom:26.67%   </span><br><span class="line">background: #eee   //图片大小是375(W)×100(H)   //100/375≈26.67%</span><br><span class="line"> 注：height:26.67%是错的，相对的不是width的26.67%，而是父级元素的26.67%。</span><br><span class="line"></span><br><span class="line">也可以这样写(但可能有些浏览器的兼容性有问题)：</span><br><span class="line">.wrapper  width:100%  height:26.67vw</span><br></pre></td></tr></table></figure><p>解决后，test一直在那个位置，没有抖动</p></li><li><h5 id="添加轮播图的点">添加轮播图的点<a class="anchor" href="#添加轮播图的点">·</a></h5><ul><li><p>加一个配置项，传swiper-pagination进去![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image022.gif)</p></li><li><h5 id="把轮播图的点改成白色无效">把轮播图的点改成白色无效 ,<a class="anchor" href="#把轮播图的点改成白色无效">·</a></h5><p>（swiperOption 是传递给swiper组件的options里的，Swiper内部拿到这些数据，改变样式）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.swiper-pagination-bullet-active     </span><br><span class="line">background:#fff!important</span><br></pre></td></tr></table></figure></li><li><h5 id="解决办法：把轮播图的点改成白色有效-（样式穿透，不受scoped限制）">解决办法：把轮播图的点改成白色有效  （样式穿透，不受scoped限制）<a class="anchor" href="#解决办法：把轮播图的点改成白色有效-（样式穿透，不受scoped限制）">·</a></h5><p>.wrapper所有子组件只要出现.swiper-pagination-bullet-active  变成白色![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image024.gif)</p></li></ul></li></ul><p>☐ 思考：</p><p>用了<swiper></swiper>，可以理解成第三方组件，实际上是通过slot插槽的形式把页面具体的数据传给swiper</p><p>slot插槽：有的时候我们在用组件的时候，我们希望组件的一部分内容可以被父组件去定制的时候，采用slot形式往组件里传递可以被自己定制的内容</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image026.gif)</p><ul><li>修改代码使轮播图的图片循环输出：loop：true![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image028.gif)</li></ul><ol start="26"><li><p>Git的使用——分支内容提交&amp;合并</p><ul><li><p>把本地index-swiper分支的内容提交到了线上index-swiper分支      index-swiper -&gt; index-swiper![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image034.gif)</p></li><li><p>把index-swiper分支的内容合并到master分支：</p></li><li><p>切换到master分支：  git checkout master  ;</p></li><li><p>把index-swiper分支新增的内容合并到本地的master分支：  git merge origin/index-swiper</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)</p></li><li><p>最后git push把本地的master分支的内容提交到线上</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image038.gif)</p></li></ul></li></ol><h3 id="7-4-Vue项目首页-图标区域页面布局">7-4  Vue项目首页-图标区域页面布局<a class="anchor" href="#7-4-Vue项目首页-图标区域页面布局">·</a></h3><ol start="27"><li><h5 id="新建【index-icons分支】">新建【index-icons分支】<a class="anchor" href="#新建【index-icons分支】">·</a></h5></li><li><p>src/pages/home/components文件夹创建Icons.vue</p></li></ol><p>导出组件→Home引入、注册组件→<home-icons></home-icons>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image046.gif)</p><ol start="29"><li><h5 id="先实现一个小图标占位">先实现一个小图标占位<a class="anchor" href="#先实现一个小图标占位">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.icons   </span><br><span class="line">overflow:hidden   </span><br><span class="line">height:0   </span><br><span class="line">padding-bottom:50%   </span><br><span class="line">  .icon    </span><br><span class="line">float:left    </span><br><span class="line">width:25%    </span><br><span class="line">padding-bottom:25%</span><br></pre></td></tr></table></figure><ul><li><p>图标区域布局：</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image042.gif)</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    overflow:hidden      </span><br><span class="line">    height:0      </span><br><span class="line">    padding-bottom:50%  </span><br><span class="line">相当于：      </span><br><span class="line">overflow:hidden      </span><br><span class="line">width:100%      </span><br><span class="line">height:0      </span><br><span class="line">padding-bottom:50%</span><br></pre></td></tr></table></figure></li></ol><ul><li>小图标布局![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image044.gif)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.icon     </span><br><span class="line">float:left     </span><br><span class="line">width:25%     </span><br><span class="line">padding-bottom:25%</span><br></pre></td></tr></table></figure><ul><li>布局问题：<ul><li>图片放上去太大：.icon→overflow:hidden→给<img>一个div→.icon-image-content [ height:100% ]</li><li>img+p超过高度50%：.icon&gt;-height:0</li><li>图片居中：.icon-img-content [ display:block;margin:0 auto ]</li><li>间距：.icon-img [ box-sizing:border-box;padding:.1rem ]</li><li>box-sizing:border-box，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</li><li>字体颜色：$darkTextColor=#333→@import ‘~styles/varibles.styl’;</li></ul></li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image048.gif)</td><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image050.gif)</td></tr></tbody></table><h3 id="7-5-Vue项目首页-图标区域逻辑实现">7-5  Vue项目首页-图标区域逻辑实现<a class="anchor" href="#7-5-Vue项目首页-图标区域逻辑实现">·</a></h3><table><thead><tr><th>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image064.gif)</th><th>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image066.gif)</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><ol start="30"><li><h5 id="Swiper组件实现区域图标轮播：需求：两层图标只有上面一层轮播，实现上下两层图标都可以轮播">Swiper组件实现区域图标轮播：需求：两层图标只有上面一层轮播，实现上下两层图标都可以轮播<a class="anchor" href="#Swiper组件实现区域图标轮播：需求：两层图标只有上面一层轮播，实现上下两层图标都可以轮播">·</a></h5></li></ol><p>（原来icons的overflow:hidden去掉，因为swiper-container自带overflow）</p><p>.icons &gt;&gt;&gt; .swiper-container   height:0   padding-bottom:50%</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;    </span><br><span class="line">    &lt;div class=&quot;icons&quot;&gt;        </span><br><span class="line">        &lt;swiper&gt;         </span><br><span class="line">            &lt;swiper-slide&gt;             </span><br><span class="line">                &lt;div class=&quot;icon&quot; v-for=&quot;item of iconList&quot;  :key=&quot;item.id&quot;&gt; </span><br><span class="line">                &lt;div class=&#x27;icon-img&#x27;&gt;                 </span><br><span class="line">                &lt;img class=&#x27;icon-img-content&#x27; :src=&quot;item.imgUrl&quot; /&gt;</span><br><span class="line">                &lt;/div&gt;                 </span><br><span class="line">            &lt;p class=&quot;icon-desc&quot;&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt;             </span><br><span class="line">            &lt;/div&gt;         </span><br><span class="line">           &lt;/swiper-slide&gt;        </span><br><span class="line">        &lt;/swiper&gt;    </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ol start="31"><li><h5 id="实现图片循环写法">实现图片循环写法:<a class="anchor" href="#实现图片循环写法">·</a></h5></li></ol><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image052.gif" alt="clipboard.png" style="zoom:67%;" /><ol start="32"><li><h5 id="一个页面8个图标，实现第九个图标开始轮播">一个页面8个图标，实现第九个图标开始轮播<a class="anchor" href="#一个页面8个图标，实现第九个图标开始轮播">·</a></h5></li></ol><p>使用【计算属性computed】实现：</p><ul><li>不需要循环变更数据，key值可以写index，div循环的不是iconList了，是page![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image054.gif)</li><li>index=8时代表第九个图标(一个页面8个图标)，page=1，表示在第二页<br>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image056.gif)</li></ul><ol start="33"><li><h5 id="代码优化：当图标下面的文字过长显示省略号…">代码优化：当图标下面的文字过长显示省略号…<a class="anchor" href="#代码优化：当图标下面的文字过长显示省略号…">·</a></h5></li></ol><table><thead><tr><th>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image058.gif)</th><th>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image060.gif)</th></tr></thead><tbody><tr><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image062.gif)</td><td></td></tr></tbody></table><ol start="34"><li>Git—分支内容提交&amp;合并</li></ol><h3 id="7-6-Vue项目首页-热销推荐组件开发">7-6  Vue项目首页-热销推荐组件开发<a class="anchor" href="#7-6-Vue项目首页-热销推荐组件开发">·</a></h3><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image084.gif" alt="clipboard.png" style="zoom: 67%;" /><ol start="35"><li><p>新建[index-recommend分支]</p></li><li><p>新建recommend.vue文件→export导出→Home.vue引入import</p></li><li><p><img>宽和高定死的话不用外层包裹div</p></li><li><li></li>下面使用【1像素边框】：<p>li标签加上类：  border-bottom  （之前引入了scr/assets/styles/border.css）![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image068.gif)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &#x27;~styles/mixins.styl&#x27;;</span><br></pre></td></tr></table></figure><ul><li>省略号显示：光用ellipsis()还不行，接下面min-width:0技巧实现</li></ul></li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image076.gif)<br />![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image074.gif)</td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image078.gif" alt="clipboard.png" style="zoom:150%;" /></td></tr></tbody></table><ol start="39"><li>实现热销推荐三个<li></li>循环：</li></ol><table><thead><tr><th>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image080.gif)</th></tr></thead><tbody><tr><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image082.gif)</td></tr></tbody></table><h3 id="7-7-Vue项目首页-开发周末游组件">7-7  Vue项目首页-开发周末游组件<a class="anchor" href="#7-7-Vue项目首页-开发周末游组件">·</a></h3><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image088.gif)</p><ol start="41"><li>新建Weekend.vue</li></ol><p>l 复制Recommend.vue的内容进行修改→导出export→Home.vue引入</p><ol start="42"><li><p>修改： 要在<img />外面包裹一层div，不给图片具体的宽、高，而是width:100%</p><p>删除flex布局，删除查看详情按钮，相应的缩进修改</p></li><li><p>见<strong>7-3Vue****项目首页-首页轮播图</strong>的思考：slot插槽</p></li><li><p>不小心先push到了master分支解决办法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先在主分支上执行： git log  </span><br><span class="line">找到你想要同步的commit的ID，切换到分支以后执行</span><br><span class="line">git cherry-pick 56aec3410629347fefb5cfd918be32be6fb52e78</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch     查看所有分支</span><br><span class="line">git merge xxx   让新分支与xxx分支合并</span><br></pre></td></tr></table></figure></li></ol><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image086.gif)</p><h3 id="7-8-Vue项目首页-使用axios发送ajax请求">7-8  Vue项目首页-使用axios发送ajax请求<a class="anchor" href="#7-8-Vue项目首页-使用axios发送ajax请求">·</a></h3><ol start="45"><li><h5 id="创建【index-ajax分支】">创建【index-ajax分支】<a class="anchor" href="#创建【index-ajax分支】">·</a></h5></li><li><p>在Vue中发送ajax有很多工具可以供我们使用，浏览器自带的fetch函数、vue以前推荐的vue-resource，Vue官方推荐我们使用axios第三方模块，axios非常强大，可以实现跨平台的数据请求，比如你在浏览器端axios可以帮助你发送SHR的请求，在node服务器上可以帮助你发送http请求。</p></li><li><h5 id="安装axios-：npm-install-axios-save-（0-17-1）">安装axios  ：npm install axios --save  （0.17.1）<a class="anchor" href="#安装axios-：npm-install-axios-save-（0-17-1）">·</a></h5></li><li><p>整个首页发一个ajax请求，把ajax的代码写在Home.vue，可以把数据传给子组件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div&gt;   </span><br><span class="line">&lt;home-header&gt;&lt;/home-header&gt;   </span><br><span class="line">&lt;home-swiper&gt;&lt;/home-swiper&gt;   </span><br><span class="line">&lt;home-icons&gt;&lt;/home-icons&gt;   </span><br><span class="line">&lt;home-recommend&gt;&lt;/home-recommend&gt;   </span><br><span class="line">&lt;home-weekend&gt;&lt;/home-weekend&gt; </span><br><span class="line">  &lt;/div&gt; </span><br><span class="line">&lt;/template&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">import HomeHeader from &#x27;./components/Header&#x27; </span><br><span class="line">import HomeSwiper from &#x27;./components/Swiper&#x27; </span><br><span class="line">import HomeIcons from &#x27;./components/Icons&#x27; </span><br><span class="line">import HomeRecommend from &#x27;./components/Recommend&#x27; </span><br><span class="line">import HomeWeekend from &#x27;./components/Weekend&#x27; </span><br><span class="line">import axios from &#x27;axios&#x27; </span><br><span class="line">export default &#123;  </span><br><span class="line">name: &#x27;Home&#x27;,  </span><br><span class="line">components: &#123;   </span><br><span class="line">HomeHeader,   HomeSwiper,   HomeIcons,   HomeRecommend,   HomeWeekend  &#125;,  </span><br><span class="line">methods: &#123;   </span><br><span class="line">getHomeInfo()&#123;axios.get(&#x27;/static/mock/index.json&#x27;).then(this.getHomeInfoSucc)&#125;,   </span><br><span class="line">getHomeInfoSucc (res) &#123;console.log(res)&#125;&#125;,  </span><br><span class="line">mounted () &#123;this.getHomeInfo()&#125;&#125; </span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure><ul><li>axios返回的结果是一个promise对象，this.getHomeInfoSucc</li><li>mounted () { this.getHomeInfo() }：页面一挂载完成就请求ajax的数据，数据获取成功把数据打印出来</li></ul></li></ol><ul><li>static存放的是静态文件，创建一个mock文件夹，放index.json，把数据放到static是因为整个工程里面只有static目录下的内容可以被外部访问到</li></ul><table><thead><tr><th>↓↓可以访问↓↓</th><th>↓↓main.js不可以访问，会自动重新定位回到首↓↓</th></tr></thead><tbody><tr><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image090.gif)</td><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image092.gif)</td></tr></tbody></table><p>【本地开发的模拟数据】不提交到线上：</p><ul><li>.gitignore文件中添加：static/mock     static/mock这样这个文件夹就不会被提交的线上的git仓库，也不会提交到本地的git仓库![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image094.gif)</li></ul><p>【本地开发的模拟数据】</p><ul><li><p>问题：  /static/mock/index.json现在用的都是本地模拟接口地址，假如代码要上线，不能填成这样的地址，需要在上线之前把地址改成 ‘/api/index.json’ 这种格式，上线之前改动代码有风险，不建议这样操作。![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image096.gif)</p></li><li><p>解决：  如果有一个转发机制，它可以帮助我们把对api下所有json文件的请求转发到本地的static/mock文件夹下，这样就可以了。Vue有提供Proxy代理的功能，通过这个功能可以实现这个构想。![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image098.gif)</p></li><li><p>如图配置：  当我们请求api这个目录的时候，我们希望它去把请求转发到服务器8080端口，路径作一个替换：一旦请求的地址是以api开头的，那么就替换请求到本地/static/mock(在开发环境里，Vue的脚手架工具会自动帮助你把api进行替换，即作一个开发环境的转发)</p><ul><li>实际上这个功能不是Vue提供的，是webpack-dev-server这个工具提供的(了解即可)</li><li>改变了配置项文件需要重启服务器</li></ul></li></ul><p>【模拟数据的具体数据】： index.json![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image100.gif)</p><ul><li>“ret”: true  --服务器正确响应了你的请求</li><li>控制台有ajax返回值，ajax数据获取成功![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image102.gif)</li><li>**细节点：**写json文件的时候如果最后数据末尾多加逗号【,】，这有可能导致json格式解析失败![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image104.gif)</li></ul><h3 id="7-9-Vue项目首页-首页父子组组件间传值">7-9  Vue项目首页-首页父子组组件间传值<a class="anchor" href="#7-9-Vue项目首页-首页父子组组件间传值">·</a></h3><p>上一节从ajax的接口获取到了首页的数据，要把这些数据分别传给首页的各个组件：![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image108.gif)</p><p>删除原来直接写上去的数据，父组件将数据传过去</p><ol start="53"><li><h5 id="问题解决：Header轮播图默认显示的图片是最后一张">问题解决：Header轮播图默认显示的图片是最后一张<a class="anchor" href="#问题解决：Header轮播图默认显示的图片是最后一张">·</a></h5><ul><li><p>[原因]：使用swiper页面还没获取ajax的时候，这时props接收的数据是外部的空数组，swiperList最初创建的时候是通过空数组创建的，然后当ajax数据获取完成之后，swiperList变成真正的数据项，再传给home-swiper这个组件的时候它才获取到新的数据，然后重新渲染新数据对应的很多轮播的图片。</p></li><li><p>[解决]：swiper初次创建由完整的来创建而不是空数组来创建。(当传递过来的list是空数组，v-if的值是false，swiper不会被创建；真正数据过来了swiper才会被创建)![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image120.gif)</p></li><li><p>在模板里面尽量避免出现逻辑型的代码→computed属性：</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image124.gif)![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image122.gif)</p></li></ul></li></ol><ul><li><h5 id="需求改进：-Icons轮播图在页面自动左右滚动，使轮播图不自动滚动的实现如下：">需求改进： Icons轮播图在页面自动左右滚动，使轮播图不自动滚动的实现如下：<a class="anchor" href="#需求改进：-Icons轮播图在页面自动左右滚动，使轮播图不自动滚动的实现如下：">·</a></h5><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image126.gif)![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image128.gif)</p></li></ul><h3 id="8-1-Vue项目城市选择页-路由配置">8-1  Vue项目城市选择页-路由配置<a class="anchor" href="#8-1-Vue项目城市选择页-路由配置">·</a></h3><ol start="54"><li><p>新建新分支：【city-router】，配置路由index.js</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image130.gif)</p></li></ol><ul><li><p>创建city组件</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image132.gif)</p></li></ul><ol start="55"><li><p>路由跳转</p><ul><li>点击首页的[北京]可以跳转City.vue  (做页面跳转的内置组件router-link)</li></ul><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image134.gif)</p><ul><li>点击首页的[北京]跳转页面，北京变成了灰色，是因为默认点击后加a标签。  处理成字体的颜色是白色![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image136.gif)</li></ul></li><li><h5 id="做城市选择的Header-vue">做城市选择的Header.vue<a class="anchor" href="#做城市选择的Header-vue">·</a></h5><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image142.gif)</p><ul><li>创建 、City.vue中import→export default注册，使用</li><li>返回图标的制作：做一个[绝对定位]显示出来</li><li>点击实现回到首页(<router-link to="/"></router-link>)(回到根路径也就是首页)</li></ul></li></ol><ul><li>代码的优化</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &#x27;~styles/varibles.styl&#x27;  </span><br><span class="line">height:$headerHeight；</span><br><span class="line">line-height:$headerHeight  </span><br><span class="line">/home/components/Header里面的 height 和 line-height 也替换掉  </span><br><span class="line">好处：改动所有页面的页头跟着变</span><br></pre></td></tr></table></figure><ul><li>提交到git仓库</li></ul><h3 id="8-2-Vue项目城市选择页-搜索框布局">8-2  Vue项目城市选择页-搜索框布局<a class="anchor" href="#8-2-Vue项目城市选择页-搜索框布局">·</a></h3><p>新建git分支：【city-search】</p><p>做Search.vue，新建导入注册使用</p><ul><li><p>细节：让搜索框里面文字很长的时候文字不要紧贴搜索框两侧：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写padding要加box-sizing:border-box</span><br></pre></td></tr></table></figure><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image144.gif)</p></li><li><p>代码提交到git仓库</p></li></ul><h3 id="8-3-Vue项目城市选择页-列表布局">8-3  Vue项目城市选择页-列表布局<a class="anchor" href="#8-3-Vue项目城市选择页-列表布局">·</a></h3><ul><li><p>准备：</p><ul><li><p>新建git分支：【city-list】</p></li><li><p>/city创建组件List.vue(→组件起名name:CityList)</p></li><li><p>官网的列表是借助浏览器的自带的滚轮实现的列表，我们希望引入更高级的关于区块滚动的内容Better-scroll</p></li><li><p>div加上上下边框的class：border-topbottom，(border-topbottom是border.css里面的)</p></li><li><p>原来的上下边框颜色比较浅，修改样式【控制页面上显示的1像素边框的颜色】：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.border-topbottom   </span><br><span class="line">  &amp;:before    </span><br><span class="line"> border-color:#ccc   </span><br><span class="line">  &amp;:after    </span><br><span class="line"> border-color:#ccc</span><br><span class="line"> 意思是：border-topbottom这个类:before和:after伪元素的border-color都设成#ccc</span><br></pre></td></tr></table></figure></li><li><p>.button-list→.button-wrapper→.button（城市button外面还要有div,进行包裹）</p></li><li><p>这样城市button没有显示出来，因为  .button-wrapper设置了float，要给.button-list加上overflow:hidden触发它的BFC     https://blog.csdn.net/ty987654/article/details/77863473![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image146.gif)</p></li></ul></li><li><p>注意button-list右边留出padding给ABCDEFG…![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image148.gif)</p></li><li><p>Header和Search框不见了，因为没有设置overflow:hidden，多出去的高度会撑出去</p></li></ul><table><thead><tr><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image150.gif" alt="clipboard.png" style="zoom:150%;" /></th><th><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image152.gif" alt="clipboard.png" style="zoom:80%;" /></th></tr></thead><tbody><tr><td>●Header和Search出来了↓</td><td></td></tr><tr><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image154.gif)</td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image156.gif" alt="clipboard.png" style="zoom:80%;" /></td></tr><tr><td>●撑出来的部分是超过list区域的内容</td><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image158.gif)</td></tr><tr><td>●加上overflow:hidden，看起来没有问题了，但是不能往下拖，只能显示这样一部城市列表↓</td><td>下节课会对这个区域使用Better-scroll的插件，可以让这个区域的滚动很类似于原生APP的拖拽效果，会非常酷炫</td></tr><tr><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image160.gif" alt="clipboard.png" style="zoom:200%;" /></td><td><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image162.gif" alt="clipboard.png" style="zoom:67%;" /></td></tr></tbody></table><h3 id="8-4-Vue项目城市选择页-BetterScroll的使用和字母表布局">8-4  Vue项目城市选择页-BetterScroll的使用和字母表布局<a class="anchor" href="#8-4-Vue项目城市选择页-BetterScroll的使用和字母表布局">·</a></h3><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image174.gif" alt="clipboard.png" style="zoom:50%;" /><ul><li><p>准备：</p><ul><li><p>github搜索第三方的包–BetterScroll(iscroll的一个封装，BetterScroll使用起来更加友好)</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image164.gif)</p></li><li><p>安装 npm install better-scroll --save  （1.8.1）</p></li></ul></li><li><p>使用BetterScroll–制作完成可以往下拉列表，而且拉到尽头会有回弹的效果。官方文档使用说明：![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image166.gif)</p><ul><li>使用条件：需要符合上面这样的DOM结构：加多一个div把多个area内容包裹起来——list的div里面一个大的div</li></ul><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image168.gif)</p></li><li><p>使用方法：</p><ul><li><p>首先要引入Better Scroll，  然后创建一个BetterScroll的实例，  BetterScroll实例创建的时候要接收一个DOM元素或者一个DOM的选择器，ref可以帮助我们获取DOM![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image170.gif)</p></li><li><p>具体操作：导入，写一个生命周期函数：mounted会在页面挂载完毕执行， 创建一个scroll的实例属性=new  Bscroll(),同时把this.$refs.wrapper传入进去![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image172.gif)</p></li></ul></li><li><p>制作右侧字母表：</p><ul><li><p>在src/pages/city/components单独创建一个组件Alphabet.vue，导入注册使用</p></li><li><p>布局：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;ul class=&quot;list&quot;&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;   </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;A&lt;/li&gt;   </span><br><span class="line">  &lt;/ul&gt;  </span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;   </span><br><span class="line">@import &#x27;~styles/varibles.styl&#x27;   </span><br><span class="line">.list    </span><br><span class="line">    display:flex    </span><br><span class="line">    flex-direction:column    </span><br><span class="line">    justify-content:center    </span><br><span class="line">    position:absolute    </span><br><span class="line">    top:1.58rem    </span><br><span class="line">    right:0    </span><br><span class="line">    bottom:0    </span><br><span class="line">    width:.4rem    </span><br><span class="line">.item    </span><br><span class="line">    line-height:.4rem     </span><br><span class="line">    text-align:center     </span><br><span class="line">    color:$bgColor  </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>‘finish city css’，提交代码到git</p></li></ul></li></ul><h3 id="8-5-Vue项目城市选择页-页面的动态数据渲染">8-5  Vue项目城市选择页-页面的动态数据渲染<a class="anchor" href="#8-5-Vue项目城市选择页-页面的动态数据渲染">·</a></h3><img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image192.gif" alt="clipboard.png" style="zoom:50%;" /><ul><li><p>准备工作：</p><ul><li><p>新建git分支：【city-ajax】</p></li><li><p>准备好city.json文件放到static/mock目录</p></li><li><p>放在最外层组件—City.vue来做，一次ajax就可以获得这个页面所有组件的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">import axios from &#x27;axios&#x27; import CityHeader from &#x27;./components/Header&#x27; import CitySearch from &#x27;./components/Search&#x27; import CityList from &#x27;./components/List&#x27; import CityAlphabet from &#x27;./components/Alphabet&#x27; </span><br><span class="line">export default &#123;   </span><br><span class="line">    name: &#x27;City&#x27;,   </span><br><span class="line">    components: &#123;CityHeader,CitySearch,CityList,CityAlphabet&#125;,   </span><br><span class="line">    data () &#123;return &#123;cities: &#123;&#125;,hotCities: []&#125;&#125;,   </span><br><span class="line">    methods: &#123;     </span><br><span class="line">    getCityInfo () &#123; axios.get(&#x27;/api/city.json&#x27;)         .then(this.handleGetCityInfoSucc)&#125;,     </span><br><span class="line">            handleGetCityInfoSucc (res) &#123; </span><br><span class="line">            res = res.data </span><br><span class="line">            if (res.ret &amp;&amp; res.data) &#123;</span><br><span class="line">            const data = res.data </span><br><span class="line">            this.cities = data.cities</span><br><span class="line">            this.hotCities = data.hotCities&#125;&#125;&#125;,   </span><br><span class="line">    mounted () &#123;this.getCityInfo()&#125;&#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>可以先console.log(res)看页面控制台接收到的模拟数据的内容</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image178.gif)</p></li><li><p>接收到数据就可以来做动态数据的渲染了：写完之后就需要把根组件的数据传给子组件</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image180.gif)</p></li></ul><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image182.gif)</p></li></ul><ul><li><p>注意细节: ，ABCDE…Z</p><ul><li><p>cities不是一个数组，是一个对象 。这个对象比如键A，它的属性值是所有开头的城市的名字的集合。所以我们还要对他进行二次遍历。才能依次取出对应的城市</p></li><li><p>对象的v-for循环是：v-for=“(item,key) of cities ，不是v-for=”(item,index) of cities。代表ABCDE…Z  ，指的是键值对中的键</p></li><li><p>二次循环：v-for=“innerItem of item”。</p></li><li><p>双重循环的key值  父级的key值等于key就可以，因为key是ABCDE…Z，不会重名，用key比较安全；如果父级的key值和子级的key值重名了也没有关系，只要这一层级的key值不重复就可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;area&quot; v-for=&quot;(item,key) of cities&quot; :key=&quot;key&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;area&quot; v-for=&quot;(item,key) of cities&quot; :key=&quot;key&quot;&gt;      </span><br><span class="line">  &lt;div class=&quot;title border-topbottom&quot;&gt;&#123;&#123;key&#125;&#125;&lt;/div&gt;      </span><br><span class="line">  &lt;div class=&quot;item-list&quot;&gt;       </span><br><span class="line">     &lt;div class=&quot;item border-bottom&quot;v-for=&quot;innerItem of item&quot; :key=&quot;innerItem.id&quot; &gt;          &#123;&#123;innerItem.name&#125;&#125;       </span><br><span class="line">     &lt;/div&gt;      </span><br><span class="line">  &lt;/div&gt;     </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>右侧ABCDE…Z字母表：在Alphabet组件中，循环出来的是key，因为只要字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;   </span><br><span class="line">  &lt;ul class=&quot;list&quot;&gt;    </span><br><span class="line">    &lt;li class=&quot;item&quot; v-for=&quot;(item,key) of cities&quot; :key=&quot;key&quot;&gt;     </span><br><span class="line">       &#123;&#123;key&#125;&#125;    </span><br><span class="line">    &lt;/li&gt;   </span><br><span class="line">  &lt;/ul&gt;  </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>代码提交到git</p></li></ul><h3 id="8-6-Vue项目城市选择页-兄弟组件数据传递">8-6  Vue项目城市选择页-兄弟组件数据传递<a class="anchor" href="#8-6-Vue项目城市选择页-兄弟组件数据传递">·</a></h3><p>新建git分支：【city-components】</p><ul><li><h4 id="需求：希望点击右边的字母表，左侧的页面城市列表可以自动滚动到显示区域">需求：希望点击右边的字母表，左侧的页面城市列表可以自动滚动到显示区域<a class="anchor" href="#需求：希望点击右边的字母表，左侧的页面城市列表可以自动滚动到显示区域">·</a></h4></li><li><p>Alphabet.vue：绑定一个click事件，对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;    </span><br><span class="line">  handleLetterClick (e) &#123;     </span><br><span class="line">  this.$emit(&#x27;change&#x27;, e.target.innerText)    //e是事件对象</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>希望把这个字母传递给List.vue组件，然后List对应的区块显示出来：  需要做一个兄弟组件的传值（非父子组件，以前讲过bus总线的形式），因为非父子组件非常简单，它们就是兄弟组件，处理兄弟组件之间的传值也可以通过这种方式：  Alphabet.vue传递数据给City.vue组件→City.vue转发数据给List.vue</p></li><li><p>在父组件City.vue中监听：拿到这个字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@change=&quot;handleLetterChange&quot;       </span><br><span class="line">handleLetterChange (letter) </span><br><span class="line">  &#123; </span><br><span class="line">this.letter = letter    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>City.vue把letter转发给List.vue：  父传子通过属性的方式传递   。List组件拿到这个值，并且List.vue监听到letter有变化进行对应区块的展示：  借助【侦听器watch】！！！！（重要）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch: &#123;    </span><br><span class="line">  letter () &#123;     </span><br><span class="line">    if (this.letter) &#123;      </span><br><span class="line">      const element = this.$refs.[this.letter][0]  </span><br><span class="line">      this.scroll.scrollToElement(element)     </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//BetterScroll组件里面用到的参数必须是DOM元素或者DOM选择器</span><br><span class="line">(×)const element = this.$refs[this.letter]     </span><br><span class="line">(√)const element = this.$refs[this.letter][0]</span><br></pre></td></tr></table></figure><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image202.gif)</p></li></ul><h5 id="这个地方动态绑定ref非常关键：这是子组件能跳转到传过来字母所对应区域的关键一步，第二个关键点：才是跳转scrollToElement">这个地方动态绑定ref非常关键：这是子组件能跳转到传过来字母所对应区域的关键一步，第二个关键点：才是跳转scrollToElement<a class="anchor" href="#这个地方动态绑定ref非常关键：这是子组件能跳转到传过来字母所对应区域的关键一步，第二个关键点：才是跳转scrollToElement">·</a></h5><ul><li><h4 id="需求：实现在字母表作上下拖拽时对应城市列表自动上下滚动">需求：实现在字母表作上下拖拽时对应城市列表自动上下滚动<a class="anchor" href="#需求：实现在字母表作上下拖拽时对应城市列表自动上下滚动">·</a></h4><p>思路：  获得字母A距离顶部的高度ya，手指滑动的位置距离顶部的高度yb，作差即获得手指位置距离A的距离，再除以每个字母的高度就可以知道当前是第几个字母，然后取对应的字母触发事件给外部</p><ul><li><p>首先绑定touch相关事件3个，开始，移动，结束![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image206.gif)</p></li><li><p>希望handleTouchStart后再去做其他事情，在data定义一个标识类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data () &#123;    </span><br><span class="line">  return &#123;     </span><br><span class="line">touchStatus: false    </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要一个数组来存储第几个字母，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;    </span><br><span class="line">  letters () &#123;     </span><br><span class="line">    const letters = []  </span><br><span class="line">//cities是一个对象不是一个数组，将他的每一项存储为一个数组</span><br><span class="line">      for (let i in this.cities) &#123;      </span><br><span class="line">        letters.push(i)     </span><br><span class="line">      &#125;     </span><br><span class="line">    return letters    </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line">原来的v-for=&quot;(item,  key) of cities&quot;  </span><br><span class="line">改成：v-for=&quot;item of letters&quot;  ,我们不是循环cities的键了，而是letters了，</span><br><span class="line">因为letters里面刚好存的就是就是字母</span><br></pre></td></tr></table></figure></li><li><p>手指移动事件具体做的事：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleTouchStart () &#123;     </span><br><span class="line">  this.touchStatus = true    </span><br><span class="line">&#125;,    </span><br><span class="line">handleTouchMove (e) &#123;   </span><br><span class="line">// 在handleTouchMove里面做的事情：判断手指滑动的是哪个字母，然后跟点击字母事件一样，都向外触发change事件，由父组件监听这个事件。所以点击和滑动的区别在于，获取字母的方式不一样，但是目的都是一样的，就是向外触发同一事件，并携带字母出去。</span><br><span class="line">  if (this.touchStatus) &#123;      </span><br><span class="line">const startY = this.$refs[&#x27;A&#x27;][0].offsetTop  </span><br><span class="line">    // 事件对象里会有一个touches数组   -79是减掉header和搜索框的高度 </span><br><span class="line">const touchY = e.touches[0].clientY - 79      </span><br><span class="line">const index = Math.floor((touchY - startY) / 20)      </span><br><span class="line">if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123;       </span><br><span class="line">   this.$emit(&#x27;change&#x27;, this.letters[index])      </span><br><span class="line">&#125;     </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;,    </span><br><span class="line">handleTouchEnd () &#123;     </span><br><span class="line">this.touchStatus = false    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**为Alphabet.vue绑定ref，**作用：是为了计算字母A距离顶部的高度，拿到offsetTop值![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image208.gif)</p></li></ul></li></ul><h3 id="8-7-Vue项目城市选择页-列表性能优化">8-7  Vue项目城市选择页-列表性能优化<a class="anchor" href="#8-7-Vue项目城市选择页-列表性能优化">·</a></h3><ul><li><h4 id="优化startY">优化startY<a class="anchor" href="#优化startY">·</a></h4><ul><li>this.startY的值其实是固定的，但每次执行函数都要算一遍，耗费性能</li><li>在初次渲染Alaphabet组件的时候，cities的值还是空对象。当ajax数据获取后，往Alphabet传的数据发生变化，Alphabet这个组件就会重新渲染，</li><li>当Alphabet重新渲染之后，updated这个生命周期钩子就会被执行，这个时候页面中已经展示出了城市列表的所有内容，这个时候就去获取A这个字母所在的DOM对应的offsetTop的值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updated () &#123;</span><br><span class="line">  /* 当页面的数据完成了更新，并完成页面渲染后，执行这个钩子 */</span><br><span class="line">  this.startY = this.$refs[&#x27;A&#x27;][0].offsetTop</span><br><span class="line">  //this.startY </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><h4 id="函数节流优化：">函数节流优化：<a class="anchor" href="#函数节流优化：">·</a></h4><p>手指在字母表上移动，函数执行的频率是非常高的。限制函数执行的频率</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释节流函数：</span><br><span class="line">data里面定义一个timer，</span><br><span class="line"> 如果已经存在了就把this.timer去除掉：</span><br><span class="line">    if (this.timer) &#123;</span><br><span class="line">     clearTimeout(this.timer)</span><br><span class="line">   &#125;</span><br><span class="line"> 否则创建一个timer：this.timer = setTimeout()</span><br><span class="line">如果你正在做这样一件事情的时候，让它延迟16ms再去执行，如果在这16ms之间你又做了手指的滚动那么会把上一次你要做的操作清除掉、重新执行你这次要做的事情。</span><br><span class="line">通过函数节流的方式，可以大大节约handleTouchMove执行的频率，从而提高网页的性能</span><br><span class="line">肉眼察觉不到，实际上性能大大提高</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleTouchMove (e) &#123;</span><br><span class="line">      /* 当手指触摸的时候才去做的事 */</span><br><span class="line">      if (this.touchStatus) &#123;</span><br><span class="line">        if (this.timer) &#123;</span><br><span class="line">          clearTimeout(this.timer)</span><br><span class="line">        &#125;</span><br><span class="line">        this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">          const touchY = e.touches[0].clientY - 79</span><br><span class="line">          const index = Math.floor((touchY - this.startY) / 20)</span><br><span class="line">          if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123;</span><br><span class="line">            this.$emit(&#x27;change&#x27;, this.letters[index])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 16)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>代码提交到git，‘performance’</p></li></ul><h3 id="8-8-Vue项目城市选择页-搜索逻辑实现">8-8  Vue项目城市选择页-搜索逻辑实现<a class="anchor" href="#8-8-Vue项目城市选择页-搜索逻辑实现">·</a></h3><ul><li><h5 id="需求：实现搜索城市名字或拼音把对应的城市名字显示出来">需求：实现搜索城市名字或拼音把对应的城市名字显示出来<a class="anchor" href="#需求：实现搜索城市名字或拼音把对应的城市名字显示出来">·</a></h5></li><li><p>新建git分支：【city-search】</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class=&quot;search&quot;&gt;</span><br><span class="line">    &lt;input  class=&quot;search-input&quot; type=&quot;text&quot;</span><br><span class="line">            placeholder=&quot;输入城市名或拼音&quot;</span><br><span class="line">            v-model=&quot;keyword&quot;&gt;</span><br><span class="line">            //这个地方的双向绑定，实现了有输入值的时候，List组件隐藏</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;search-conent&quot;</span><br><span class="line">        ref=&quot;search&quot; //这个ref用于设置滚动效果</span><br><span class="line">        v-show=&quot;  keyword&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li class=&quot;search-item border-bottom&quot;</span><br><span class="line">          v-for=&quot;item of list&quot;</span><br><span class="line">          :key=&quot;item.id&quot;</span><br><span class="line">          @click=&quot;handleCityClick(item.name)&quot;</span><br><span class="line">      &gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;</span><br><span class="line">      &lt;li class=&quot;search-item border-bottom&quot;</span><br><span class="line">            v-show=&quot;hasNoData&quot;&gt;</span><br><span class="line">        没有找到匹配数据</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import Bscroll from &#x27;better-scroll&#x27;</span><br><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;CitySearch&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    cities: Object</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      keyword: &#x27;&#x27;,  //与搜素词做双向绑定</span><br><span class="line">      list: [],</span><br><span class="line">      timer: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    hasNoData () &#123;</span><br><span class="line">      return !this.list.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">  //侦听器侦听keyword的改变：</span><br><span class="line">    keyword () &#123;</span><br><span class="line">      if (this.timer) &#123;</span><br><span class="line">        clearTimeout(this.timer)</span><br><span class="line">      &#125;</span><br><span class="line">      if (!this.keyword) &#123;</span><br><span class="line">        this.list = []</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">    //当keyword发生改变的时候，隔100ms箭头函数会被执行，</span><br><span class="line">      this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        const result = []</span><br><span class="line">        for (let i in this.cities) &#123;</span><br><span class="line">   //json里面每一项都有spell(拼音)和name(中文)，有搜索到关键字对应城市名就添加到result之中</span><br><span class="line">          this.cities[i].forEach((value) =&gt; &#123;</span><br><span class="line">            if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123;</span><br><span class="line">              result.push(value)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        //所有匹配结果集合在result中，赋值给list，让他去显示</span><br><span class="line">        this.list = result</span><br><span class="line">      &#125;, 100)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  updated () &#123;</span><br><span class="line">  //需要你传入一个DOM元素或者选择器→传search-content这个元素对应的ref：search</span><br><span class="line">  //注意不需要整个全部滚动，只需要搜索结果滚动</span><br><span class="line">    this.scroll = new Bscroll(this.$refs.search)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleCityClick(city) &#123;</span><br><span class="line">      /* 此处组件可以直接调用commit方法 */</span><br><span class="line">      /* this.$store.commit(&#x27;changeCity&#x27;, city) */</span><br><span class="line">      this.changeCity(city)</span><br><span class="line">      this.$router.push(&#x27;/&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">    ...mapMutations([&#x27;changeCity&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>进一步修改样式：此时搜索框输入a，对应的内容很多，不能向下滚动看到所有匹配项，借助BetterScroll解决：<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image216.gif" alt="clipboard.png" style="zoom:50%;" /></p><ul><li><p>问题：把a取消掉城市列表还在，解决：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!this.keyword) &#123; </span><br><span class="line">this.list = []  return //没有输入关键字，就让显示为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当搜索框输入非匹配项，下面什么内容都没有，实现显示“没有找到匹配项”的文字：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个li标签：</span><br><span class="line">&lt;li class=&quot;search-item border-bottom&quot;&gt;没有找到匹配数据&lt;/li&gt;</span><br><span class="line">／／现在是无论找不找得到都显示”没有找到匹配数据“</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加上v-show来控制：</span><br><span class="line">&lt;li class=&quot;search-item border-bottom&quot; v-show=&quot;!length&quot;&gt;没有找到匹配数据&lt;/li&gt;</span><br><span class="line">length取反意思是如果list长度为0的时候才显示，</span><br><span class="line">现在是实现了找到的时候不显示+没找到显示+不搜索也显示,覆盖掉原来的所有城市列表</span><br><span class="line">search-content里面加上：v-show=&quot;keyword&quot;，意思是keyword有值的时候才会显示li标签</span><br><span class="line">二者是不同时存在的</span><br></pre></td></tr></table></figure><ul><li><p>模板里面尽量不要写逻辑运算，使用计算属性来优化(逻辑放到下面的js来完成)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li class=&quot;search-item border-bottom&quot; v-show=&quot;hasNoData&quot;&gt;没有找到匹配数据&lt;/li&gt;， </span><br><span class="line">computed: &#123;</span><br><span class="line">  hasNoData () &#123;return !this.list.length&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>'search finish’代码提交到git</p></li></ul><h3 id="8-9-Vue项目城市选择页-Vuex实现数据共享">8-9  Vue项目城市选择页-Vuex实现数据共享<a class="anchor" href="#8-9-Vue项目城市选择页-Vuex实现数据共享">·</a></h3><h4 id="需求1：实现在城市选择页点击城市，首页变为对应的城市">需求1：实现在城市选择页点击城市，首页变为对应的城市<a class="anchor" href="#需求1：实现在城市选择页点击城市，首页变为对应的城市">·</a></h4><ul><li><p>创建新的git分支：【city-vuex】</p></li><li><p>实现思路：City.vue和Home.vue没有公用的父级组件，这样就没有办法通过父级组件进行数据的中转，之前讲过bus总线的概念，在这里可以使用bus，但是使用bus依然比较麻烦，Vue的官方有提供一个工具——Vuex（Vue官方推荐的数据框架）。在Vue大型项目中，Vue只能承担视图层的主要内容，而当我们涉及大量数据之前传递时往往需要一个数据框架辅助，在Vue之中这个数据框架就是Vuex。</p><ul><li>当我们的一个项目之中各个页面或者多个组件之间进行复杂的数据传值很困难的时候，我们可以这样想，如果我们可以把这些数据放到公共的存储空间去存储，然后一个组件改变了这个公共的数据，其他的组件也能感知到，Vuex的设计理念是这样的</li></ul><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image218.gif)</p></li><li><p>解读：虚线部分的内容就是公共数据存储的区域，把这个区域理解成store仓库，这个仓库由几部分组成：</p><ul><li>【State】：所有的公用数据都存储在State之中，那如果组件想用一个公用的数据，直接去调用State就可以了。有的时候我们希望改变State里的数据，不能让组件直接改变而必须走一个流程</li><li>当有异步操作 或者一些比较多的逻辑操作，批量的同步操作时，放到Actions。组件先去调用Actions，Actions紧接着去调用Mutations，Mutations放的是一步一步对State的修改，当State存储的数据发生变化组件上显示的内容就会跟着变化了。</li><li>有的时候我们也可以略过Actions(这一步不是绝对的)，让组件直接去调用Mutations修改State里面的数据，这块需要额外注意的是：<ul><li>当组件调用Actions时，调用的是Dispatch方法来操作Actions</li><li>然后组件去调用Mutations或者Actions调用Mutations的时候，用commit方法来操作Mutations。</li></ul></li></ul></li><li><p>使用Vuex ：</p><ul><li><p>安装: npm install vuex --save</p></li><li><p>src目录新建store/index.js， 引入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;  </span><br><span class="line">import Vuex from &#x27;vuex&#x27;     </span><br><span class="line">Vue.use(Vuex)     </span><br><span class="line">export default new Vuex.Store(&#123;   </span><br><span class="line">state: &#123;city: &#x27;上海&#x27;&#125;,   //默认是上海</span><br><span class="line">mutations: &#123;</span><br><span class="line">  changeCity (state, city) &#123;     </span><br><span class="line">    state.city = city  &#125;   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>在main.js里面：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import store from &#x27;./store/index&#x27;</span><br><span class="line">引入了store，</span><br><span class="line">创建根Vue实例的时候把store:store传进去(键和值一样写一个东西就行)</span><br></pre></td></tr></table></figure><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image220.gif)</p></li></ul></li><li><p>组件(home的Header.vue)的城市使用这个公用的数据：以前Home.vue的Header的城市数据是通过ajax后端返回给我们的，现在希望city是前端存储的不需要后端告诉，所以把原来的city代码删除。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">home的Header.vue的&#123;&#123;city&#125;&#125;改成</span><br><span class="line">&#123;&#123;this.$store.state.city&#125;&#125;   //此时Header的城市显示默认的上海</span><br><span class="line">//因为在main.js根实例把store传递进去了，紧接着Vuex创建的store会派发到每个子组件里面，所以每个子组件都可以用this.$store获取store</span><br></pre></td></tr></table></figure></li><li><h4 id="需求2：城市选择页面中，点击热门城市的时候公用数据发生变化">需求2：城市选择页面中，点击热门城市的时候公用数据发生变化<a class="anchor" href="#需求2：城市选择页面中，点击热门城市的时候公用数据发生变化">·</a></h4></li><li><p>实现思路：</p></li><li><p>做法：</p><ul><li><p>为城市选择Citylist添加点击事件，当改变city的时候，派发changeCity这样一个Actions，把city作为第二个参数传过来。</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image222.gif)</p><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image224.gif)</p></li><li><p>创建store的时候只有一个state，并没有actions，所以要在写一个actions对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions: &#123; </span><br><span class="line">//这里对应的是那边dispatch的事件和参数</span><br><span class="line">  changeCity (ctx, city) &#123;     </span><br><span class="line"> ctx.commit(&#x27;changeCity&#x27;, city)  </span><br><span class="line">     //注意这里是context</span><br><span class="line">     //之所以actions里面第一个参数是ctx，作用是可以借助ctx帮我们拿到commit方法</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>actions里面已经接收到了传递过来的city，它需要调用Mutations去改变公用的数据，所以↓创建Mutations</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;    </span><br><span class="line">  changeCity (state, city) &#123;     </span><br><span class="line">  state.city = city    </span><br><span class="line">  &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>此时，通过Vuex实现首页和列表页的数据共享，点击热门城市，城市选择页的当前城市和首页的城市会显示对应的城市（但是要自行返回首页）</p></li><li><p>其实这个过程并没有异步操作，没必要调用Actions去做一个转发，直接调用commit也是可以的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组件里：</span><br><span class="line">methods: &#123;  </span><br><span class="line">  handleCityClick (city) &#123;     </span><br><span class="line">    this.$store.commit(&#x27;changeCity&#x27;, city)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store里：</span><br><span class="line">mutations: &#123;    </span><br><span class="line">  changeCity (state, city) &#123;     </span><br><span class="line">  state.city = city    </span><br><span class="line">  &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="需求3：实现点击列表的时候也实现城市的切换">需求3：实现点击列表的时候也实现城市的切换<a class="anchor" href="#需求3：实现点击列表的时候也实现城市的切换">·</a></h4><p>这跟需求1其实是类似的，监听、注意修改为innerItem.name，点击执行的都是一个方法![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image228.gif)</p></li><li><h4 id="需求4：实现搜索结果中点击城市也可以实现城市的切换：">需求4：实现搜索结果中点击城市也可以实现城市的切换：<a class="anchor" href="#需求4：实现搜索结果中点击城市也可以实现城市的切换：">·</a></h4><p>同样监听点击，然后执行的是同一个方法，只是不同的组件，传参名字不一样而已。这个地方需求1与需求3都是在list组件里，所以执行方法写一个就可以。Search组件没有，所以要赋值一下这个方法![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image230.gif)</p></li><li><h5 id="需求1、需求2、需求4-：都需要自行返回页面才能看见对应城市的显示，但是不会自行跳转页面">需求1、需求2、需求4 ：都需要自行返回页面才能看见对应城市的显示，但是不会自行跳转页面<a class="anchor" href="#需求1、需求2、需求4-：都需要自行返回页面才能看见对应城市的显示，但是不会自行跳转页面">·</a></h5><p>解决：【路由—编程式导航】在网页上做页面跳转，有2种方式：</p><ul><li><p>一种是通过a标签的形式实现跳转</p></li><li><p>另一种是通过js中， window location.href这种形式。</p></li><li><p>在Vue之中也一样，可以通过router-link这种标签的形式做页面的跳转，还可以通过js作js形式的跳转，js跳转不像window location.href这么简单，在vue-router里面用的是编程式的导航，编程式的导航提供给我们一个方法：$router.push(location, onComplete?, onAbort?)：</p></li><li><p>https://router.vuejs.org/zh/guide/essentials/navigation.html</p></li><li><p>每个组件里都有实例属性router(在main.js里面根实例传了router)：</p></li></ul></li><li><p>点击城市的时候首先改变城市的内容，然后实现页面的跳转    this.$router.push(‘/’)  '/'是首页地址![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image232.gif)</p></li></ul><h3 id="8-10-Vue项目城市选择页-Vuex的高级使用及localStorage">8-10  Vue项目城市选择页-Vuex的高级使用及localStorage<a class="anchor" href="#8-10-Vue项目城市选择页-Vuex的高级使用及localStorage">·</a></h3><h5 id="问题：点击三亚城市变为三亚，刷新一次页面城市又回到了默认的上海。">问题：点击三亚城市变为三亚，刷新一次页面城市又回到了默认的上海。<a class="anchor" href="#问题：点击三亚城市变为三亚，刷新一次页面城市又回到了默认的上海。">·</a></h5><h5 id="需求1：希望实现选中过一次城市，下一次再访问网站的时候显示的是上次选择的城市">需求1：希望实现选中过一次城市，下一次再访问网站的时候显示的是上次选择的城市<a class="anchor" href="#需求1：希望实现选中过一次城市，下一次再访问网站的时候显示的是上次选择的城市">·</a></h5><ul><li><p>【引入localStorageAPI】：localStorage，HTML5提供的一个新的API，可以帮助我们实现类似cookie的功能，做到本地存储，这个API比cookie简单。</p></li><li><p>更改：</p><ul><li><p>点击城市的时候不但把state.city改了，同时存一个 localStorage.city ，city的默认值是localStorage.city 或者 ‘上海’ (优先从localStorage.city取，取不到才用上海)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;   </span><br><span class="line">state: &#123;    city: localStorage.city || &#x27;上海&#x27;   &#125;,   </span><br><span class="line">mutations: &#123;    </span><br><span class="line">changeCity (state, city) &#123; </span><br><span class="line">state.city = city     </span><br><span class="line">localStorage.city = city    </span><br><span class="line">&#125;   </span><br><span class="line">&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>建议只要用localStorage，就在外层包裹一层try catch，因为在某些浏览器，如果用户关闭了本地存储这样的功能或者使用隐身模式，使用localStorage可能会使浏览器直接抛出异常，整个代码就运行不了了![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image234.gif)</p></li><li><p>对index.js进行抽离：![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image236.gif)![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image238.gif)![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image240.gif)</p></li><li><h5 id="小问题：点击阿拉善盟，向下的箭头icon移位了">小问题：点击阿拉善盟，向下的箭头icon移位了<a class="anchor" href="#小问题：点击阿拉善盟，向下的箭头icon移位了">·</a></h5><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image242.gif)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">home/Header.vue中：  (原来的width定死了)  原来：    </span><br><span class="line">.header-right     width:1.24rem     </span><br><span class="line">修改为：    </span><br><span class="line">.header-right     min-width:1.04rem     padding:0 .1rem    </span><br></pre></td></tr></table></figure><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image244.gif)</p></li></ul></li><li><h4 id="对Vuex的进一步优化：映射">对Vuex的进一步优化：映射<a class="anchor" href="#对Vuex的进一步优化：映射">·</a></h4><p>Vuex给了我们一个比较高级的API使得我们可以这样去写代码：</p><ul><li>…mapState里可以传递一个数组，也可以是一个对象，  意思是想把Vuex里的city公用数据映射到这个组件的计算属性里，映射过来的名字叫currentCity</li><li>…mapMutations     有一个Mutations叫changeCity，然后把这个mutation映射到组件里changeCity的方法里，     然后可以写成:this.changeCity(city)</li><li>…mapGetters   getter的作用类似于组件中的computed计算属性的作用，当需要根据state里面的数据算出新的数据的时候就可以借助getter来提供新的数据，这样可以避免数据的冗余.组件使用之前要在computed里面做映射![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image250.gif)![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image254.gif)</li></ul><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image252.gif)</p></li><li><p>【Module】当遇到非常复杂的业务场景，如管理后台系统的时候，经常有很多功能的数据在Vuex里进行存储，如果把mutations都放在mutations.js文件里，这个文件会慢慢变得非常庞大，难以维护，这个时候可以借助module对一个复杂的mutation state包括actions进行一个拆分。创建store的时候可以通过模块来创建，对各个模块的数据进行整合，通过module来写代码可以有更好的维护性。</p></li></ul><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image256.gif)</p><p>当然我们的项目中只有city一个公用数据，没必要使用module进行拆分。</p><ul><li>‘use vuex’代码提交带git</li></ul><h3 id="8-11-Vue项目城市选择页-使用keep-alive优化网页性能">8-11  Vue项目城市选择页-使用keep-alive优化网页性能<a class="anchor" href="#8-11-Vue项目城市选择页-使用keep-alive优化网页性能">·</a></h3><ul><li><p>新建git分支：【city-keepalive】</p></li><li><p>问题分析：</p></li></ul><table><thead><tr><th>1.换到城市选择页city.json请求了一次</th><th>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image258.gif)</th></tr></thead><tbody><tr><td>2.返回到首页index.json也请求了一次</td><td>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image260.gif)</td></tr><tr><td>再进入城市选择页city.json又被请求一次，每一次路由发生变化时ajax都会被重新发送</td><td>原因：  每一次切换，组件都会被重新渲染，如home/Home.vue中 mounted () {    this.getHomeInfo()   },  mounted钩子会被重新执行，ajax数据就会被重新获取    <br /> 问题：每一次都获取数据性能很低，希望实现获取一次就可以了：</td></tr></tbody></table><ul><li><p>问题解决：</p><ol><li><p>APP.vue中：  <router-view/>显示的是路由所对应的内容，外层包裹keep-alive标签(是Vue自带的一个标签)。  意思是：路由的内容被加载过一次后把内容放到内存之中，下一次再进这个路由的时候不用重新渲染这个组件去执行钩子函数，只需要你进入内存里把以前的内容拿出来显示在页面上。此时，再进入城市列表页不会重复city.json，回到首页也是不会在index.json此时，实际上逻辑上存在问题：当在桂林的时候首页显示的是桂林的内容，切换到北京的时候首页应该显示北京的内容，所以城市改变的时候，首页还是需要重新加载ajax请求<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image262.gif" alt="clipboard.png" style="zoom: 67%;" /></p></li><li><p>Home.vue中：请求接口时应带一个参数，等于Vuex里面存的当前的城市。所以，引入Vuex；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27;</span><br><span class="line">data () &#123;    </span><br><span class="line">    return &#123; </span><br><span class="line"></span><br><span class="line">    //data里面设置一个数据lastCity，一开始值为空</span><br><span class="line">    lastCity: &#x27;&#x27;,     </span><br><span class="line">    swiperList: [],     </span><br><span class="line">    iconList: [],     </span><br><span class="line">    recommendList: [],     </span><br><span class="line">    weekendList: []    </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;    ...mapState([&#x27;city&#x27;])   &#125;, //获取到对应城市的内容</span><br><span class="line">请求接口时应带一个参数：**（重要）**</span><br><span class="line">axios.get(&#x27;api/index.json?city=&#x27; + this.city) //发ajax时把city放在请求里面</span><br><span class="line">//此时，首次进入页面mounted和activated都执行，当切换城市后只有activated执行，</span><br><span class="line">//所以借助这个生命周期函数实现：切换城市首页内容换成切换的城市的内容</span><br><span class="line">mounted () &#123;  </span><br><span class="line">//当页面被挂载时，对第一次的城市做一个保存</span><br><span class="line">this.getHomeInfo()   </span><br><span class="line">this.lastCity = this.city</span><br><span class="line">&#125;, </span><br><span class="line">activated () &#123; </span><br><span class="line">//mounted被挂载的时候，页面初次加载时，会发ajax请求，页面重新显示时activated被重新执行，所以每次页面重新显示时判断页面和上次页面是否相同城市，如果城市不相等重新发一次ajax请求：</span><br><span class="line">  if (this.lastCity !== this.city) &#123; </span><br><span class="line">    this.lastCity = this.city   </span><br><span class="line">    //重新发一次ajax请求</span><br><span class="line">    this.getHomeInfo() </span><br><span class="line">  &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol></li><li><p>总结：</p><ul><li>通过keep-alive新增的一个生命周期函数activated，结合lastCity这个临时缓冲变量，实现网页性能优化的调整</li><li>首页再次→城市选择页不会二次请求city.json</li><li>城市没有发生变换返回首页不会二次index.json，城市变化返回首页才会二次index.json，同时数据参数是变化后的城市。</li></ul></li><li><p>‘finish page’代码提交到git分支。</p></li></ul><h3 id="9-1-Vue项目详情页-详情动态路由和banner布局">9-1  Vue项目详情页-详情动态路由和banner布局<a class="anchor" href="#9-1-Vue项目详情页-详情动态路由和banner布局">·</a></h3><ul><li><p>新建git分支：【detail-banner】</p></li><li><h4 id="需求1：点击跳转对应景点的详情页">需求1：点击跳转对应景点的详情页<a class="anchor" href="#需求1：点击跳转对应景点的详情页">·</a></h4><ul><li>代码： 注意将li标签改成router-link  添加to属性 为保持一致，修改tag属性为li</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#x27;/detail/&#x27; + item.id&quot;   tag=&quot;li&quot;&gt;  //配置路由信息   </span><br><span class="line">  &lt;li class=&quot;item border-bottom&quot; v-for=&quot;item of list&quot; :key=&quot;item.id&quot;&gt;       </span><br><span class="line">    &lt;img class=&quot;item-img&quot; :src=&quot;item.imgUrl&quot; /&gt;      </span><br><span class="line">    &lt;div class=&quot;item-info&quot;&gt;       </span><br><span class="line">        &lt;p class=&quot;item-title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt;       </span><br><span class="line">        &lt;p class=&quot;item-desc&quot;&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt;       </span><br><span class="line">        &lt;button class=&quot;item-button&quot;&gt;查看详情&lt;/button&gt;      </span><br><span class="line">    &lt;/div&gt;     </span><br><span class="line">  &lt;/li&gt;     </span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image276.gif)景点文字会变颜色(router-link默认是a标签的颜色)，需要重新改样式</p><ul><li><p>修改路由配置![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image282.gif)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:to=&quot;&#x27;/detail/&#x27; + item.id&quot;</span><br><span class="line"></span><br><span class="line">//路径后面还会跟id这样的内容</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建pages/detail/Detail.vue:</p><ul><li>使用iconfont下载的zip(包含之前的图标和现在的图标)替换掉(iconfont.eot，iconfont.svg，iconfont.ttf，iconfont.woff四个文件)</li><li>注意iconfont.css的的data修改成新的![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image284.gif)</li></ul></li><li><p>修改Detail组件样式：![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image292.gif)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.banner-img     width:100%  //使图片展示完全</span><br><span class="line">.banner-info     //实现渐变效果</span><br><span class="line">display:flex     </span><br><span class="line">position:absolute     </span><br><span class="line">left:0     </span><br><span class="line">right:0     </span><br><span class="line">bottom:0     </span><br><span class="line">line-height:.6rem     </span><br><span class="line">color:#fff     </span><br><span class="line">background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8))</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-Vue项目详情页-公用图片画廊组件拆分">9-2  Vue项目详情页-公用图片画廊组件拆分<a class="anchor" href="#9-2-Vue项目详情页-公用图片画廊组件拆分">·</a></h3><h4 id="需求：点击图片时展示图片轮播，下面显示图片轮播的页码">需求：点击图片时展示图片轮播，下面显示图片轮播的页码<a class="anchor" href="#需求：点击图片时展示图片轮播，下面显示图片轮播的页码">·</a></h4><ul><li><p>这种画廊组件在项目中可能不仅一个页面用到→变成一个公用的组件：创建common/gallary/Gallary.vue</p></li><li><h5 id="公用组件Gallary：">公用组件Gallary：<a class="anchor" href="#公用组件Gallary：">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot; @click = &quot;handleGallaryClick&quot;&gt;</span><br><span class="line">    &lt;!-- 对container绑定事件：希望点击轮播图，就会推出 --&gt;</span><br><span class="line">    &lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">      &lt;swiper :options = &quot;swiperOptions&quot;&gt;</span><br><span class="line">   &lt;!-- swiper里面的每一页应该循环一些图片。去电swiper-slide，src写死，不要循环，找一张图片 --&gt;</span><br><span class="line">        &lt;swiper-slide  v-for = &quot;(item, index) in imgs&quot; :key = index&gt;</span><br><span class="line">          &lt;img class=&quot;gallary-img&quot;   :src = &#x27;item&#x27;/&gt;</span><br><span class="line">        &lt;/swiper-slide&gt;</span><br><span class="line">        &lt;!-- 这样就有两张轮播图，是可以拖动的。但是下面还应该有反斜杠显示拖动的第第几张图片。</span><br><span class="line">        所以还要加pagination.怎么配置pagination呢? swiper里面的pagination,注意要在data里面定义swiperOptions--&gt;</span><br><span class="line">        &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/swiper&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;CommonGallary&#x27;,</span><br><span class="line">  // 图片是外面的数据传过来的</span><br><span class="line">  props: &#123;</span><br><span class="line">    imgs:&#123;</span><br><span class="line">      type: Array,</span><br><span class="line">      default() &#123;</span><br><span class="line">        return []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      swiperOptions:&#123;</span><br><span class="line">        // 在这里定义swiper里面的swiperOptions，没定义过是不能使用的</span><br><span class="line">        pagination: &#x27;.swiper-pagination&#x27;,</span><br><span class="line">        // 底层是借助Swiper实现的，想知道怎么实现，去baidu搜索Swiper3的pagination官网。</span><br><span class="line">        // 也可以查看Api官网,看左侧的pagination分页器。有一个paginationType.用第2种效果的fraction</span><br><span class="line">        paginationType: &quot;fraction&quot;,</span><br><span class="line">        // 解决点击后轮播图问题：加两个参数observeParents</span><br><span class="line">        // 意思是：Swiper插件只要监听到自己的元素或父级元素dom节点发生改变，就会自我刷新，就解决了宽度计算的问题</span><br><span class="line">        observeParents: true,</span><br><span class="line">        observer: true,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleGallaryClick() &#123;</span><br><span class="line">      // 点击后出发事件</span><br><span class="line">      this.$emit(&#x27;close&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style lang = stylus scoped&gt;</span><br><span class="line">/* 解决swiper的container里有overflow：hidden问题 */</span><br><span class="line">  .container &gt;&gt;&gt; .swiper-container</span><br><span class="line">    overflow: inherit</span><br><span class="line">  .container</span><br><span class="line">    display: flex</span><br><span class="line">    position: fixed</span><br><span class="line">    left: 0</span><br><span class="line">    right: 0</span><br><span class="line">    top: 0</span><br><span class="line">    bottom: 0</span><br><span class="line">    background: #000;</span><br><span class="line">    z-index: 99</span><br><span class="line">    flex-direction: column</span><br><span class="line">    justify-content: center</span><br><span class="line">    .wrapper</span><br><span class="line">      background: #fff</span><br><span class="line">      width: 100%   </span><br><span class="line">      /*不给高度，而是撑开一个 正方形的位置*/</span><br><span class="line">      height: 0</span><br><span class="line">      /* overflow: hidden */</span><br><span class="line">      padding-bottom: 100%</span><br><span class="line">      .gallary-img</span><br><span class="line">        width: 100%   解决图片太大的问题</span><br><span class="line">      .swiper-pagination</span><br><span class="line">      /* 让颜色是白色 */</span><br><span class="line">        color: red  </span><br><span class="line">        bottom: -1rem   </span><br><span class="line">        /* 这样会页面没有页码了。此时去掉wrapper的overflow 依然不行，*/</span><br><span class="line">        /* swiper-container上面默认是有overflow：hidden的内容，所以将高度限制死了 */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="Banner-vue使用Gallary-vue公用组件">Banner.vue使用Gallary.vue公用组件<a class="anchor" href="#Banner-vue使用Gallary-vue公用组件">·</a></h5><ul><li><p>common-gallary默认情况是隐藏的，点击画廊才显示出来。点击轮播，显示画廊</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;banner&quot; @click = &quot;handleBannerClick&quot; &gt;</span><br><span class="line">      &lt;img :src=&quot;bannerImg&quot;  alt=&quot;&quot; class=&quot;banner-img&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;banner-info&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;banner-title&quot;&gt;</span><br><span class="line">          &#123;&#123;this.sightName&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;banner-number&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;iconfont banner-icon&quot;&gt;&amp;#xe632;&lt;/span&gt;</span><br><span class="line">         &#123;&#123;this.gallaryImgs.length&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 我希望他的默认状态是隐藏的 --&gt;</span><br><span class="line">    &lt;common-gallary :imgs = &quot;gallaryImgs&quot; </span><br><span class="line">                  v-show = &quot;showGallary&quot;</span><br><span class="line">                  @close = &quot;handleGallaryClose&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/common-gallary&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import CommonGallary from &#x27;common/gallary/Gallary&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;DetailBanner&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    CommonGallary,</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    sightName: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">    &#125;,</span><br><span class="line">    bannerImg: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">    &#125;,</span><br><span class="line">    gallaryImgs: &#123;</span><br><span class="line">      type: Array,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      showGallary: false,</span><br><span class="line">    // 默认是false不显示，当你点击的时候，显示</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleBannerClick()&#123;</span><br><span class="line">      this.showGallary = true</span><br><span class="line">      // 此时点击显示轮播图。但是此时轮播图页码又出现问题了。</span><br><span class="line">      //原因：一开始让commonGallary隐藏，</span><br><span class="line">      // 当再次显示的时候Swiper计算宽度会有问题，导致轮播图无法正常滚动，</span><br><span class="line">      //解决：Gallary.vue的SwiperOptions参数设置。</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    handleGallaryClose() &#123;</span><br><span class="line">      this.showGallary = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang = &quot;stylus&quot; scoped&gt;</span><br><span class="line">  .banner</span><br><span class="line">    overflow: hidden</span><br><span class="line">    position: relative</span><br><span class="line">    height: 0</span><br><span class="line">    padding-bottom: 55%</span><br><span class="line">  .banner-img</span><br><span class="line">    width: 100%</span><br><span class="line">  .banner-info</span><br><span class="line">    display: flex</span><br><span class="line">    position: absolute</span><br><span class="line">    left:0</span><br><span class="line">    right: 0</span><br><span class="line">    bottom 0</span><br><span class="line">    line-height: .6rem</span><br><span class="line">    color: #fff</span><br><span class="line">    background-image: linear-gradient(top, rgba(0, 0, 0, .8))</span><br><span class="line">    .banner-title</span><br><span class="line">      flex:1</span><br><span class="line">      font-size: .32rem</span><br><span class="line">      padding: 0 .2rem</span><br><span class="line">    .banner-number</span><br><span class="line">      margin-top: .2rem</span><br><span class="line">      padding: 0 .4rem</span><br><span class="line">      height: .32rem</span><br><span class="line">      line-height: .32rem</span><br><span class="line">      border-radius: .2rem</span><br><span class="line">      background: rgba(0, 0, 0, .8)</span><br><span class="line">      font-size: .24rem</span><br><span class="line">      .banner-icon</span><br><span class="line">        font-size: .24rem</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="115"><li></li></ol><p>l 传imgs：</p><table><thead><tr><th>Banner.vue中：</th><th><common-gallary    :imgs="imgs"    >    </common-gallary></th></tr></thead><tbody><tr><td>data里面定义imgs</td><td>data () {    return {     imgs: [‘http://img1.qunarzz.com/sight/p0/1907/39/394802bd7fce909fa3.img.jpg_r_800x800_250e62f4.jpg’, ‘http://img1.qunarzz.com/sight/p0/1907/3d/3deee24945b577b3a3.img.jpg_r_800x800_46dee719.jpg’]    }   },</td></tr></tbody></table><ul><li>'banner finish’代码提交到git分支</li></ul><h3 id="9-3-Vue项目详情页-实现Header渐隐渐显效果">9-3  Vue项目详情页-实现Header渐隐渐显效果<a class="anchor" href="#9-3-Vue项目详情页-实现Header渐隐渐显效果">·</a></h3><ul><li><h4 id="需求：详情页左上方有返回按钮，往下滑返回回按钮消失、渐隐渐显Header区域">需求：详情页左上方有返回按钮，往下滑返回回按钮消失、渐隐渐显Header区域<a class="anchor" href="#需求：详情页左上方有返回按钮，往下滑返回回按钮消失、渐隐渐显Header区域">·</a></h4><ul><li>创建git分支：【detail-header】</li><li>pages/city/detail/components创建Header.vue</li><li>Detail.vue中：引入、注册、<detail-header></detail-header></li><li>页面需要足够长这样才可以滚动，∴Detail.vue中：写一个div帮助我们撑开页面的高度![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image316.gif)</li></ul></li><li><p>Header.vue中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-link class=&quot;header-abs&quot; </span><br><span class="line">                  to = &quot;/&quot; </span><br><span class="line">                  tag = div</span><br><span class="line">                  v-show = &quot;showAbs&quot;</span><br><span class="line">    &gt;</span><br><span class="line">       &lt;span class=&quot;iconfont header-abs-back&quot;&gt;&amp;#xe624;&lt;/span&gt;</span><br><span class="line">       &lt;!-- 点击区块，回到首页，router-link来实现。将div改成router-link --&gt;</span><br><span class="line">       &lt;!-- to回到根路径&quot;/&quot;，希望他会自动回到首页。如果写“.&quot;,他却后退到了detail页面，空白 --&gt;</span><br><span class="line">    &lt;/router-link&gt;</span><br><span class="line">    &lt;!-- 绑定style, 实现渐隐渐现的效果 --&gt;</span><br><span class="line">    &lt;div class=&quot;header-fixed&quot; v-show = &quot;!showAbs&quot; :style = &quot;opacityStyle&quot;&gt;</span><br><span class="line">      &lt;!-- 复制city页面的header进行修改 --&gt;</span><br><span class="line">      &lt;!-- 这时候页面详情会一直显示在顶部，这个箭头会覆盖上面的箭头 --&gt;</span><br><span class="line">      &lt;router-link to = &quot;/&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;iconfont header-fixed-back&quot;&gt;&amp;#xe624;&lt;/div&gt;</span><br><span class="line">      &lt;/router-link&gt;</span><br><span class="line">      景点详情</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;  </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;DetailHeader&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        showAbs: true,</span><br><span class="line">        // 这个变量定义了是否显示header-abs。而header-fixed取反，刚进页面他是不显示的，</span><br><span class="line">        // 只有当我滚动页面的时候，header-ads消失，他header-fixed才显示。所以监听scroll事件</span><br><span class="line">        opacityStyle: &#123;</span><br><span class="line">        opacity: 0</span><br><span class="line">        &#125;</span><br><span class="line">        // 默认等于0，当用户在60--140之间滚动的时候，有一个渐隐渐现的效果.给判断条件添加140</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      handleScroll()&#123;</span><br><span class="line">        const top = document.documentElement.scrollTop;</span><br><span class="line">//v-show实现刚进页面的时候显示返回按钮，Header区域景点详情不显示。什么时候显示Header区域景点详情呢？  往下滑到一定距离返回按钮隐藏、显示Header区域景点详情：通过对window的scroll事件进行监听</span><br><span class="line">        if (top &gt; 60) &#123;</span><br><span class="line">          this.showAbs =  false</span><br><span class="line">          // 此时不仅显示顶部，还要加动画</span><br><span class="line">          let opacity = top / 140  //这里要改用let来定义</span><br><span class="line">          opacity = opacity&gt;1 ? 1: opacity</span><br><span class="line">          this.opacityStyle = &#123;</span><br><span class="line">            // 对opacityStyle对象添加属性，键和值都相等</span><br><span class="line">            opacity: opacity</span><br><span class="line">          &#125;</span><br><span class="line">          // 此时渐隐渐现的下过已经有了，但一旦超过140，就会顶部不显示了,去掉&amp;&amp; top &lt; 140</span><br><span class="line">          // 对opacity进行判断:opacity?1: opacity,,这样就没有问题了</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.showAbs =  true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    activated()&#123;</span><br><span class="line">      // 在这个钩子里，用了keep-alive，所以当页面展示的时候他就会执行handleScroll方法</span><br><span class="line">      window.addEventListener(&#x27;scroll&#x27;, this.handleScroll)</span><br><span class="line">      // 这里addEventListener会带来问题：这是对window全局事件的监听，</span><br><span class="line">      // 这个事件不是对组件的绑定，而是绑定到了window的全局对象上面了</span><br><span class="line">      // Home组件也会收到影响，解决：deactived</span><br><span class="line">    &#125;,</span><br><span class="line">    deactivated() &#123;</span><br><span class="line">      // 所以我们要在离开组件的时候，移除对这一事件的监听</span><br><span class="line">      window.removeEventListener(&#x27;scroll&#x27;, this.handleScroll)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang = stylus scoped&gt;</span><br><span class="line">  @import &quot;~styles/varibles.styl&quot;</span><br><span class="line">  .header-abs</span><br><span class="line">    position: absolute</span><br><span class="line">    left: .2rem</span><br><span class="line">    top: .2rem</span><br><span class="line">    width: .8rem</span><br><span class="line">    height: .8rem</span><br><span class="line">    line-height: .8rem</span><br><span class="line">    border-radius: .4rem</span><br><span class="line">    background rgba(0, 0, 0, .8)</span><br><span class="line">    text-align: center</span><br><span class="line">    .header-abs-back</span><br><span class="line">      color: #fff</span><br><span class="line">      font-size: .4rem</span><br><span class="line">  .header-fixed</span><br><span class="line">    position fixed</span><br><span class="line">    top 0</span><br><span class="line">    left 0</span><br><span class="line">    right 0</span><br><span class="line">    height $headerHeight</span><br><span class="line">    line-height $headerHeight</span><br><span class="line">    text-align center</span><br><span class="line">    color #fff</span><br><span class="line">    background $bgColor</span><br><span class="line">    font-size .32rem</span><br><span class="line">    z-index 2 </span><br><span class="line">    /* 在详情页往下滑的时候，list前面的图标会浮出来，显示与顶部一起显示，z-index提高权重 */</span><br><span class="line">    .header-fixed-back</span><br><span class="line">      position absolute</span><br><span class="line">      top 0</span><br><span class="line">      left 0</span><br><span class="line">      width .64rem</span><br><span class="line">      text-align center</span><br><span class="line">      font-size .4rem</span><br><span class="line">      color #fff</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>'header animation’代码提交到git</p></li></ul><h3 id="9-4-Vue项目详情页-对全局事件的解绑">9-4  Vue项目详情页-对全局事件的解绑<a class="anchor" href="#9-4-Vue项目详情页-对全局事件的解绑">·</a></h3><p>很多初学者因为没有对全局事件进行解绑，造成代码出现大量的bug。</p><ul><li>如果在某个组件的标签上绑定这个事件(@click…)不会带来任何问题，因为这个事件绑定在组件的某个元素上所以只作用于这个组件的内部，不会影响外部的组件。</li><li>可是如果在这个组件上写的是window全局事件的绑定，那就有问题了。 因为事件并不是绑定在组件中，而是绑定在了全局的window对象上了，所以不仅对这个组件有效果，而且对其他的组件也产生了影响。</li></ul><p>解决：</p><ul><li><p>当对组件用了keep-alive，组件会多出activated生命周期函数，在每次页面展示时会执行。其实还提供一个生命周期函数deactivated，在页面即将被隐藏或者页面将被替换成新的页面时会被执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">页面展示的时候绑定scroll事件，而页面被隐藏时对scroll全局事件进行解绑</span><br><span class="line">activated () &#123;    </span><br><span class="line">window.addEventListener(&#x27;scroll&#x27;, this.handleScroll)   </span><br><span class="line">&#125;</span><br><span class="line">deactivated () &#123;    </span><br><span class="line">window.removeEventListener(&#x27;scroll&#x27;, this.handleScroll)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码提交到git之前的分支【detail-header】查看分支：git branch![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image336.gif)</p><ul><li><p>当前处于master主分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .，git commit -m &#x27;fix problem&#x27;，git push，</span><br><span class="line">（让之前的detai-header分支和master分支作合并：）</span><br><span class="line">git checkout detail-header，git merge master，git push</span><br></pre></td></tr></table></figure></li><li><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout detail-header，git add .，git commit -m &#x27;fix problem&#x27;，git push，</span><br><span class="line">git checkout master，git merge detail-header，git push</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="9-5-Vue项目详情页-使用递归组件实现详情页列表">9-5  Vue项目详情页-使用递归组件实现详情页列表<a class="anchor" href="#9-5-Vue项目详情页-使用递归组件实现详情页列表">·</a></h3><ul><li><p>新建git分支：【detail-list】pages/detail/components/创建List.vueDetail.vue引入这个组件DetailList、注册、使用</p></li><li><p>在List.vue做递归组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for = &quot;(item , index) in list&quot; :key = index</span><br><span class="line">        class=&quot;item&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;item-title&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;item-title-icon&quot;&gt;&lt;/span&gt;</span><br><span class="line">          &#123;&#123;item.title&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!-- 在组件的上一部分，循环了list数据的以及内容，递归组件怎么使用呢 --&gt;</span><br><span class="line">        &lt;!-- 他做了一个判断，如果item有children这个数据，说明他是一个多级菜单 --&gt;</span><br><span class="line">        &lt;div v-if = &quot;item.children&quot; class=&quot;item-children&quot;&gt;</span><br><span class="line">          &lt;!-- 在这里 :我们为一个组件起名字，他最大的用处就是在这里做递归组件的时候使用--&gt;</span><br><span class="line">          &lt;!-- 此时把children当做list，再传给自己 --&gt;</span><br><span class="line">          &lt;detail-list :list = &quot;item.children&quot;&gt;</span><br><span class="line">          &lt;/detail-list&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// class=&quot;item-children&quot;把样式调整至分级的形式显示在页面--给个padding左右（而不是让二级列表和一级标题一样对齐显示）</span><br></pre></td></tr></table></figure></li><li><p>作业：剩下部分的布局和逻辑实现（用户评论+列表样式+评论的页面）</p></li><li><p>'use recursive component’代码提交到git</p></li></ul><h3 id="9-6-Vue项目详情页-动态获取详情页面数据（使用Ajax获取动态数据）">9-6  Vue项目详情页-动态获取详情页面数据（使用Ajax获取动态数据）<a class="anchor" href="#9-6-Vue项目详情页-动态获取详情页面数据（使用Ajax获取动态数据）">·</a></h3><ul><li><p>新建git分支：【detail-ajax】</p></li><li><p>获取Ajax数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Detail.vue中：     </span><br><span class="line">//借助生命周期钩子mounted 发ajax请求，  </span><br><span class="line">methods:里定义getDetailInfo方法，  引入axios，      Ajax数据获取完毕就可以输出结果了then(this.handleGetDataSucc)        </span><br><span class="line">if (res.ret &amp;&amp; res.data) &#123;     </span><br><span class="line">const data = res.data        console.log(data)      &#125;可以输出数据        </span><br><span class="line">接下来把写死的数据换掉：  定义     sightName: &#x27;&#x27;,     bannerImg: &#x27;&#x27;,     gallaryImgs: [],     list: []  等于获取到的数据      this.sightName = data.sightName      this.bannerImg = data.bannerImg      this.gallaryImgs = data.gallaryImgs      this.list = data.categoryList                                                          |</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Detail.vue中： </span><br><span class="line">data () &#123;    </span><br><span class="line">return &#123; </span><br><span class="line">sightName: &#x27;&#x27;,     </span><br><span class="line">bannerImg: &#x27;&#x27;,    </span><br><span class="line">        gallaryImgs: [],     </span><br><span class="line">        list: []    &#125;   </span><br><span class="line">       &#125;,   </span><br><span class="line">methods: &#123;    </span><br><span class="line">  getDetailInfo () &#123;</span><br><span class="line">  // 每一次请求希望把id带给后端，这个id是动态路由的参数，获得动态路由的参数：router/index里有path: &#x27;/detail/:id&#x27;，router定义了动态路由会把对应的id存在id这个变量里，∴可以这样写：axios.get(&#x27;/api/detail.json&#x27; + this.$route.params.id)，但是这样拼接参数麻烦，可以写一个对象。</span><br><span class="line">    axios.get(&#x27;/api/detail.json&#x27;, &#123;</span><br><span class="line">        params: &#123;</span><br><span class="line">        id: this.$route.params.id</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;).then(this.handleGetDataSucc) &#125;,    </span><br><span class="line">  handleGetDataSucc (res) &#123;     </span><br><span class="line">  res = res.data     </span><br><span class="line">  if (res.ret &amp;&amp; res.data) &#123;      </span><br><span class="line">     const data = res.data      </span><br><span class="line">     this.sightName = data.sightName      </span><br><span class="line">     this.bannerImg = data.bannerImg      </span><br><span class="line">     this.gallaryImgs = data.gallaryImgs      </span><br><span class="line">     this.list = data.categoryList     </span><br><span class="line">  &#125;    </span><br><span class="line"> &#125; </span><br><span class="line">&#125;,   </span><br><span class="line">mounted () &#123;    this.getDetailInfo()   &#125;  &#125; </span><br></pre></td></tr></table></figure><ul><li>数据传子组件，替换</li></ul></li><li><h4 id="问题：第一次进详情页会拿到0001的数据，第二次进入0002详情页并没有重新获取0002的数据，还是0001的数据">问题：第一次进详情页会拿到0001的数据，第二次进入0002详情页并没有重新获取0002的数据，还是0001的数据<a class="anchor" href="#问题：第一次进详情页会拿到0001的数据，第二次进入0002详情页并没有重新获取0002的数据，还是0001的数据">·</a></h4><ul><li><p>原因：和之前首页原理一样）因为detail页面通过keep-alive作了缓存，mounted只会执行一次</p></li><li><p>解决：①如果想每次重新进页面都发一个ajax请求就需要使用activated生命周期钩子。</p><p>②exclude：Detail不被缓存，每一次进入详情页mounted钩子都会被重新执行，也就是重新获取数据![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image350.gif)</p></li></ul></li><li><h4 id="问题：首页被拖到下面，再进入详情页，详情页也是被拖到下面而不是从顶部开始">问题：首页被拖到下面，再进入详情页，详情页也是被拖到下面而不是从顶部开始<a class="anchor" href="#问题：首页被拖到下面，再进入详情页，详情页也是被拖到下面而不是从顶部开始">·</a></h4><ul><li>解决：Vue Router官网&gt;-进阶&gt;-滚动行为![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image356.gif)</li><li>复制到路由部分![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image358.gif)</li></ul></li><li><p>思考：每个组件里面的name的用途：</p><ol><li>递归组件</li><li>想对某个页面取消缓存时</li><li>Vue开发调试工具Devtools，组件叫什么名字取决于name给的是什么名字</li></ol></li><li><p>'ajax’代码提交到git</p></li></ul><h3 id="10-1-接口联调">10.1 接口联调<a class="anchor" href="#10-1-接口联调">·</a></h3><ul><li><p>在之前的static文文件夹下有一个mock文件夹，里面有json文件。当代码联调的时候，他们就没用了。而是切换为后端真实提供给我们的数据。http://localhost:80/api/index.json可以查看数据，不再请求本地mock文件夹的数据，删除之后，代码会有问题404。怎么做？config找到index.js。proxytable的代码意思开发环境下，如果你访问的是api路径，会将你对这个路径的请求转发到localhost8080端口上面。这个端口是前端服务器的端口，现在要更换后台服务器端口。这个端口还在本地，只是更改了地址。</p></li><li><p>实际中后端服务器并不在本地，这时候代理就不能写在localhost地址了，而是内网的ip地址。或者外网的一个域名。这样前端的api请求转发后后端服务器。如果项目使用的是vue这种，你就不需要再使用fiddler和charles这种抓包工具了。只需要使用proxytable这个配置项，就服务器的请求地址写在这里。</p></li></ul><h3 id="10-2-真机测试">10.2 真机测试<a class="anchor" href="#10-2-真机测试">·</a></h3><p>在windows系统中重新打开一个终端输入： ipconfig</p><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210102171115248.png" alt="image-20210102171115248"></p><p>iPv4就是内网ip地址，复制地址，在浏览器输入这个地址。这个地址的8080端口就是localhost80端口。但是他拒绝了我们的连接请求，为了确认，将8080换成80。前端项目是通过webpack-dev-server启动的，他默认不支持通过ip的方式进行页面的访问，需要将默认配置package.json向进行修改：我们每次运行npm run dev 本质运行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config             build/webpack.dev.conf.js&quot;,</span><br></pre></td></tr></table></figure><p>重启服务器</p><p>再通过ip地址进行访问就可以了</p><ul><li>让手机直接通过内网ip地址尽心访问：</li></ul><h3 id="10-课程总结与后续学习">10  课程总结与后续学习<a class="anchor" href="#10-课程总结与后续学习">·</a></h3><h5 id="学习方向：">学习方向：<a class="anchor" href="#学习方向：">·</a></h5><ul><li>Vue官方文档：大部分内容都涉及到了，还有比如插件、自定义指令等多多查阅、提升边缘知识点能力。</li><li>打开生态系统的vue-router插件，还有其他内容：命名路由、重定向、别名、守卫</li><li>Vuex：熟悉运用核心概念(State,Getter,Mutation,Action,Module)后，可以看一下在大型项目中创建比较复杂的Vuex数据架构时，项目结构怎么设计，或者如何使用Vuex相关的插件。</li><li>Vuex觉得没有太大的问题后：Vue服务器端渲染。搞明白意味着基本上对Node.js、Vue、前后端路由、前后端渲染有了极深的理解，前端的基础会得到很大的提升。如果时工作不满一年对前后端分得不是很清楚，这一部分内容可以延迟学习。</li></ul><h5 id="插件研究：">插件研究：<a class="anchor" href="#插件研究：">·</a></h5><ul><li>生态系统Vue资源：研究好用的插件的源码以及使用</li></ul><h5 id="全面了解Vue后：研究Vue的源码">全面了解Vue后：研究Vue的源码<a class="anchor" href="#全面了解Vue后：研究Vue的源码">·</a></h5>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目2：去哪儿网：问题总结篇</title>
      <link href="/posts/1460941642.html"/>
      <url>/posts/1460941642.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>项目时间： 2020年10月大概</p></li><li><p>项目背景： 慕课网的项目学习时做的笔记</p></li><li><p>问题总结篇： 总结一些之前的问题（简洁版）</p></li><li><p>概述：去哪儿网的移动端页面的实现，其中有3大模块:遇到的问题和优化点比较集中在搜索城市页面。主要包括：搜索城市的逻辑实现、手指滑动过程中的高度计算 和 更换城市过程中出现的一些问题。在解决这些问题的过程中，又产生了新的问题并进行了优化。</p></li></ul><h3 id="1-localStorage解决变更城市名后，首页无法更新的问题">1. localStorage解决变更城市名后，首页无法更新的问题<a class="anchor" href="#1-localStorage解决变更城市名后，首页无法更新的问题">·</a></h3><ul><li><p>**原本需求：**不选的时候有一个默认城市，展示该城市数据，实现选中一次，展示新的城市数据</p></li><li><p>**原本实现逻辑：**当用户每次进入页面，都在mounted钩子里会发ajax请求，并将Vuex中城市名的数据带过去</p></li><li><h4 id="出现的问题：刷新了页面，城市又回到了默认城市上海"><strong>出现的问题：刷新了页面，城市又回到了默认城市上海</strong><a class="anchor" href="#出现的问题：刷新了页面，城市又回到了默认城市上海">·</a></h4><ul><li><p>**原因：**由于store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值，就会使用state中默认保存的数据</p></li><li><p>**解决：**localStorage可以实现当有缓存值的时候用缓存值，没有才用默认值的功能，为什么选它？</p><ul><li>localStorage是永久存储在本地，除非你主动去删除;</li><li>sessionStorage是存储到当前页面关闭为止;</li><li>cookie则根据你设置的有效时间来存储，但缺点是不能储存大数据且不易读取。</li></ul></li><li><p><strong>新的问题：</strong></p><p>引入localStorage，当用户重新选择了城市时，Vuex会更新state里面的city变量，此时城市名已经变动，此时应该进行ajax请求的。</p><p>但同时由于对首页用了keep_alive，所以再次回到首页不会再执行mounted这个钩子了，进而无法在该钩子里做数据获取得操作，我们可以用activated</p></li><li><p><strong>网络请求优化：</strong></p><p>**原因：**每点一个城市都会数据请求，假如点击前后城市并没更新，其实没有必要重新请求：</p><p>**解决：**在首页activated新定义一个变量保存每次请求前的城市名，来对state里面的城市做if判断，只有二者不一致时才会去重新请求</p><p>**实现：**首次请求后不会再次请求的问题；城市名实际未变化，也不会再次请求的问题</p></li></ul></li></ul><h3 id="2-实现手指滑动时的更准确的高度计算并优化计算性能；">2. 实现手指滑动时的更准确的高度计算并优化计算性能；<a class="anchor" href="#2-实现手指滑动时的更准确的高度计算并优化计算性能；">·</a></h3><ul><li><p>需求：在右侧字母表上下拖拽时，左边对应的城市列表自动上下滚动</p></li><li><p>绑定touch相关的3个事件：touchstart、touchmove、touchend。设置标识位，在start里面将标识位更新为true，在move里判断标识位为true时才进行高度的计算。在touchend中将标识位false。</p></li><li><p>高度计算：</p><ul><li>获得字母A距离顶部的高度A ：·<code>this.$refs['A'][0].offsetTop</code>DOM元素距离顶部的距离 ，再拿到当前手指滑动个位置距离顶部的高度B ：通过事件对象里面的touche数组，e.touches[0].clientY，相减的高度差除以一个字母的高度20，就拿到了当前字母对应的索引，然后从存储字母的数组中取出来。</li></ul></li><li><p>优化：每次执行一次move，都要获取dom结构的offsetTOP属性进行一次计算。这是没有必要的且耗费性能的                                                  <strong>JS方面的优化</strong></p><ul><li>字母A距离顶部的高度A，在初次渲染这个组件的时候数据还是空的，而当ajax数据获取后，往这个组件传的数据改变，updated生命周期钩子就会执行，页面中显示出了列表的内容。这个时候去获取就能得到字母A所在的DOM对应的offsetTop的值不仅是准确的，还能解决耗费性能的问题</li><li>引入防抖操作，在touchmove中，如果标志位为true，就清空定时器，并且设置新的定时器，将高度计算的操作放在定时器里</li></ul></li></ul><h3 id="3-城市名搜索的逻辑实现">3. 城市名搜索的逻辑实现<a class="anchor" href="#3-城市名搜索的逻辑实现">·</a></h3><ul><li><p>需求：</p><ul><li>搜索框搜索城市名或拼音，显示对应的搜索结果，并引入防抖降低搜索过程中查找匹配函数的频率</li><li>当匹配不到城市时，显示无法匹配</li><li>匹配的城市可以滚动显示</li></ul></li><li><p>实现：</p></li><li><p>搜索框通过<strong>v-model双向绑定</strong>数据keyword，在<strong>侦听器watch</strong>中监听keyword的改变，当它发生改变时，代表用户正在输入。</p><ul><li>此时对cities对象进行遍历，cities里每一项都包含了indexof一个城市的名字name和拼音。只要输入的内容能匹配其中之一，就将匹配到的城市数据加入到list列表中。然后对list列表中的数据在li组件中循环显示出来。</li></ul></li><li><p>在循环列表末尾添加一项li，用于展示是否无法匹配，当匹配不到城市时，通过<strong>v-show</strong>控制，显示匹配不到该城市</p><ul><li>滚动：将这个组件绑定ref，在mounted阶段，通过<strong>refs拿到DOM元素</strong>，传入<strong>new BetterScroll</strong>中，然后实现局部滚动</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器运行机制</title>
      <link href="/posts/1322992885.html"/>
      <url>/posts/1322992885.html</url>
      
        <content type="html"><![CDATA[<p>待续</p>]]></content>
      
      
      <categories>
          
          <category> 3.2-浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染解析 </tag>
            
            <tag> 进程线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典国内外计算机基础课程</title>
      <link href="/posts/1720673220.html"/>
      <url>/posts/1720673220.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络">计算机网络<a class="anchor" href="#计算机网络">·</a></h2><p>斯坦福144：https://www.bilibili.com/video/BV137411Z7LR?from=search&amp;seid=5779448666653480680哈工大：https://www.bilibili.com/video/BV1Up411Z7hC</p><h2 id="数据结构与算法">数据结构与算法<a class="anchor" href="#数据结构与算法">·</a></h2><p>数据结构：https://www.bilibili.com/video/BV1Kb41127fTleetcode刷题笔记：https://mp.weixin.qq.com/s?__biz=MzI0NjAxMDU5NA==&amp;mid=328435125&amp;idx=1&amp;sn=3de887a586e8a6a08784036de466623e&amp;chksm=7f22e23848556b2e67fedbd30b1ca0fcdb46ed336279aa4cb0899a0f2ff44210e829d125ade6#rd</p><h2 id="操作系统：">操作系统：<a class="anchor" href="#操作系统：">·</a></h2><p>南大蒋岩岩：https://www.bilibili.com/video/BV1N741177F5?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1606808223&amp;unique_k=ns64dc</p><p>国外213： https://www.bilibili.com/video/BV1iW411d7hd?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1606782897&amp;unique_k=JeN7fa</p><h2 id="计算机组成原理">计算机组成原理<a class="anchor" href="#计算机组成原理">·</a></h2><p>哈工大：https://www.bilibili.com/video/BV1t4411e7LH/?spm_id_from=333.788.recommend_more_video.0</p>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目5：Node用户管理接口：学习记录篇</title>
      <link href="/posts/310999178.html"/>
      <url>/posts/310999178.html</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2021年2月</li><li>项目背景： 春节在家，只是想简单了解下接口、数据库的概念</li><li>学习记录篇：记录过程的，记忆丢失，嘤嘤嘤</li></ul><h2 id="项目实战">项目实战<a class="anchor" href="#项目实战">·</a></h2><h3 id="1-划分目录结构">1. 划分目录结构<a class="anchor" href="#1-划分目录结构">·</a></h3><ul><li><p>划分方式：</p><ul><li><p>按照功能模块划分；</p></li><li><p>按照业务模块划分；</p></li></ul></li><li><h4 id="项目配置文件信息：">项目配置文件信息：<a class="anchor" href="#项目配置文件信息：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;start&quot;</span>: <span class="string">&quot;nodemon ./src/main.js&quot;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="项目的入口文件：main-js">项目的入口文件：main.js<a class="anchor" href="#项目的入口文件：main-js">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app/index&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./app/config&#x27;</span>)</span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(config.<span class="property">APP_PORT</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器启动成功&#x27;</span>,config.<span class="property">APP_PORT</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><h4 id="创建服务器：index-js">创建服务器：index.js<a class="anchor" href="#创建服务器：index-js">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyParser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将app传入到userRouter函数里面是为什么？？？</span></span><br><span class="line"><span class="comment">// router文件夹下的index.js的作用：对router文件夹下的每个router.js文件遍历，</span></span><br><span class="line"><span class="comment">//免去每注册一个路由都要写一次app.use(router1.allowed())和app.use(router1.routes())</span></span><br><span class="line"><span class="comment">//传入app，是因为使用app.use()</span></span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="built_in">require</span>(<span class="string">&#x27;../router/index&#x27;</span>)</span><br><span class="line"><span class="title function_">useRoutes</span>(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errorHandle = <span class="built_in">require</span>(<span class="string">&#x27;./error-handle&#x27;</span>)</span><br><span class="line"><span class="comment">//监听错误事件</span></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, errorHandle)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app</span><br></pre></td></tr></table></figure></li><li><h4 id="加载配置的变量：config-js">加载配置的变量：config.js<a class="anchor" href="#加载配置的变量：config-js">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过dotenv内置模块</span></span><br><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">dotenv.<span class="title function_">config</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取公钥+私钥 </span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRIVATE_KEY</span> = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./keys/private.key&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PUBLIC_KEY</span> = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./keys/public.key&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="variable constant_">APP_PORT</span>,</span><br><span class="line">  <span class="variable constant_">MYSQL_HOST</span>,</span><br><span class="line">  <span class="variable constant_">MYSQL_PORT</span>,</span><br><span class="line">  <span class="variable constant_">MYSQL_USER</span>,</span><br><span class="line">  <span class="variable constant_">MYSQL_DATABASE</span>,</span><br><span class="line">  <span class="variable constant_">MYSQL_PASSWORD</span>,</span><br><span class="line">  <span class="variable constant_">LOCAL_HOST</span></span><br><span class="line">&#125; = process.<span class="property">env</span>;</span><br><span class="line"><span class="comment">//两种exports顺序不能换</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">PUBLIC_KEY</span> = <span class="variable constant_">PUBLIC_KEY</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">PRIVATE_KEY</span> = <span class="variable constant_">PRIVATE_KEY</span>;</span><br></pre></td></tr></table></figure></li><li><h4 id="编写-env文件">编写.env文件<a class="anchor" href="#编写-env文件">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">APP_PORT</span> = <span class="number">8000</span></span><br><span class="line"><span class="variable constant_">LOCAL_HOST</span> = <span class="string">&quot;http://localhost</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MYSQL_HOST = &quot;</span>localhost<span class="string">&quot;</span></span><br><span class="line"><span class="string">MYSQL_PORT = 3306</span></span><br><span class="line"><span class="string">MYSQL_USER = &quot;</span>root<span class="string">&quot;</span></span><br><span class="line"><span class="string">MYSQL_DATABASE = &quot;</span>coderhub<span class="string">&quot;</span></span><br><span class="line"><span class="string">MYSQL_PASSWORD = &quot;</span>56830908zml<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="错误类型模块：error-type-js">错误类型模块：error-type.js<a class="anchor" href="#错误类型模块：error-type-js">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">NAME_OR_PASSWORD_IS_REQUIRED</span> = <span class="string">&#x27;name_or_password_is_required&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">USER_ALREADY_EXISITS</span> =  <span class="string">&#x27;user_alreay_exisits&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">USER_DOES_NOT_EXISITS</span> = <span class="string">&#x27;user_does_not_exisits&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PASSWORD_IS_NOT_CORRECT</span> = <span class="string">&#x27;password_is_not_correct&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">NOT_AUTHORIZATION</span> = <span class="string">&#x27;not_authorization&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">NOT_PERMISSION</span> = <span class="string">&#x27;not_permission&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="variable constant_">NAME_OR_PASSWORD_IS_REQUIRED</span>,</span><br><span class="line">  <span class="variable constant_">USER_ALREADY_EXISITS</span>,</span><br><span class="line">  <span class="variable constant_">USER_DOES_NOT_EXISITS</span>,</span><br><span class="line">  <span class="variable constant_">PASSWORD_IS_NOT_CORRECT</span>,</span><br><span class="line">  <span class="variable constant_">NOT_AUTHORIZATION</span>,</span><br><span class="line">  <span class="variable constant_">NOT_PERMISSION</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="错误处理模块-：error-handle-js">错误处理模块 ：error-handle.js<a class="anchor" href="#错误处理模块-：error-handle-js">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">errorHandler</span> = (<span class="params">error, ctx</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(error.<span class="property">message</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;name_or_password_is_required&#x27;</span>: </span><br><span class="line">      status = <span class="number">400</span>;</span><br><span class="line">      message = <span class="string">&#x27;用户名/密码不能为空&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;user_alreay_exisits&#x27;</span>:</span><br><span class="line">      status = <span class="number">409</span>,<span class="comment">// 发生冲突conflict</span></span><br><span class="line">      message = <span class="string">&#x27;用户名已经使用&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;user_does_not_exisits&#x27;</span>:</span><br><span class="line">      status = <span class="number">400</span>,</span><br><span class="line">      message = <span class="string">&#x27;用户名不存在&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;password_is_not_correct&#x27;</span>:</span><br><span class="line">      status = <span class="number">400</span>, </span><br><span class="line">      message = <span class="string">&#x27;密码不正确&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;not_authorization&#x27;</span>: </span><br><span class="line">      status = <span class="number">401</span>  </span><br><span class="line">      message = <span class="string">&#x27;没有授权，token无效&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;not_permission&#x27;</span>: </span><br><span class="line">      status = <span class="number">401</span>  </span><br><span class="line">      message = <span class="string">&#x27;你没有操作权限&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">      status = <span class="number">404</span></span><br><span class="line">      message = <span class="string">&#x27;Not Found1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  ctx.<span class="property">status</span> = status</span><br><span class="line">  ctx.<span class="property">body</span> = message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = errorHandler</span><br></pre></td></tr></table></figure></li><li><h4 id="数据库连接：database-js">数据库连接：database.js<a class="anchor" href="#数据库连接：database-js">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connections = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: config.<span class="property">MYSQL_HOST</span>,</span><br><span class="line">  <span class="attr">port</span>: config.<span class="property">MYSQL_PORT</span>,</span><br><span class="line">  <span class="attr">user</span>: config.<span class="property">MYSQL_USER</span>,</span><br><span class="line">  <span class="attr">database</span>:config.<span class="property">MYSQL_DATABASE</span>,</span><br><span class="line">  <span class="attr">password</span>: config.<span class="property">MYSQL_PASSWORD</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">connections.<span class="title function_">getConnection</span>(<span class="function">(<span class="params">err, conn</span>) =&gt;</span> &#123;</span><br><span class="line">  conn.<span class="title function_">connect</span>( <span class="function"><span class="params">errr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接失败&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = connections.<span class="title function_">promise</span>()</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-用户注册接口">2. 用户注册接口<a class="anchor" href="#2-用户注册接口">·</a></h3><ul><li><p>用户注册接口编写流程：</p><ul><li><p>注册用户路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;verifyUser&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/user.middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;create&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/user.controller&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">new</span> <span class="title function_">router</span>(&#123;<span class="attr">prefix</span>: <span class="string">&#x27;/users&#x27;</span>&#125;)</span><br><span class="line">userRouter.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, verifyUser,create)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = userRouter;</span><br></pre></td></tr></table></figure></li></ul><h4 id="注册用户校验：verifyUser">注册用户校验：verifyUser<a class="anchor" href="#注册用户校验：verifyUser">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">verifyUser</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//1. 获取用户名和密码</span></span><br><span class="line">  <span class="keyword">const</span> &#123;name, password&#125; = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">  <span class="comment">// 如果没有传，name应该是undefined</span></span><br><span class="line">  <span class="comment">//2. 判断用户名/密码是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (!name || !password || name ===<span class="string">&#x27;&#x27;</span>|| password == <span class="string">&#x27;&#x27;</span> )&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">NAME_OR_PASSWORD_IS_REQUIRED</span>)</span><br><span class="line">    <span class="comment">//此时发送一个错误信息，另一个地方去获取这个错误信息</span></span><br><span class="line">    <span class="comment">//emit传事件类型，事件，参数</span></span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>,error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3. 判断用户名是否已经存在</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">getUserByName</span>(name)</span><br><span class="line">  <span class="keyword">if</span>(result.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">USER_ALREADY_EXISITS</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, error, ctx) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//必须调用next，等后面的中间件执行才返回结果</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  verifyUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询用户名是否被注册过：user.service.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&#x27;../app/database&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">userService</span>&#123;</span><br><span class="line">  <span class="comment">// 查询是否存在该用户</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getUserByName</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM users WHERE name = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [name])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">user</span>)&#123;</span><br><span class="line">    <span class="comment">//解构user</span></span><br><span class="line">    <span class="keyword">const</span> &#123;name, password&#125; = user;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO users (name, password) VALUES (?, ?)`</span>;</span><br><span class="line">    <span class="comment">//执行sql语句</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [name, password]);</span><br><span class="line">    <span class="comment">//将user存储到数据库中</span></span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">userService</span>();</span><br></pre></td></tr></table></figure><h4 id="注册用户操作：create-js">注册用户操作：create.js<a class="anchor" href="#注册用户操作：create-js">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 验证注册用户后的处理逻辑抽到user.<span class="property">controller</span>.<span class="property">js</span>里面</span><br><span class="line"><span class="keyword">const</span> service= <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">userController</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="comment">//这部分要做的事很多，所以对每一部分再抽取：</span></span><br><span class="line">    <span class="comment">//获取用户用于传递的参数</span></span><br><span class="line">    <span class="keyword">const</span> user = ctx.<span class="property">request</span>.<span class="property">body</span>   </span><br><span class="line">    <span class="comment">//查询数据 ----抽取到user.service.js</span></span><br><span class="line">    <span class="comment">//user是传入的参数</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">create</span>(user)  <span class="comment">// 见上面的user.service.js</span></span><br><span class="line">    <span class="comment">//返回数据</span></span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">userController</span>();</span><br></pre></td></tr></table></figure><h4 id="密码加密存储">密码加密存储<a class="anchor" href="#密码加密存储">·</a></h4><p>此时已经手动注册两个用户，可在数据库查看：<img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206144301822.png" alt="image-20210206144301822"></p></li></ul><p>但是账户密码是明文的形式保存的，如果数据库泄露了，那么密码会被别人拿到登录。更危险的是，很多人的其他账户密码全是一样的，所以我们拿到ctx.request.body里面的用户名+密码。然后加密。但是开发中并不是这样做。而是在verify之后做密码加密</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userRouter.post(&#x27;/&#x27;, verifyUser,**增加拦截中间件handlePassword***，create)</span><br></pre></td></tr></table></figure><p>加密中间件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> md5password = <span class="built_in">require</span>(<span class="string">&#x27;../utils/password-handle&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">verifyUser</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handlePassword</span> = <span class="keyword">async</span>(<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; password &#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">  <span class="comment">//通过加密函数，对password</span></span><br><span class="line">  ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> = <span class="title function_">md5password</span>(password) </span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  verifyUser,</span><br><span class="line">  handlePassword</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密的方式MD5，借助<strong>框架crypto</strong>，node自带的，有一个函数调用createHash()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">md5password</span> = (<span class="params">password</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 拿到的是一个对象</span></span><br><span class="line">  <span class="keyword">const</span> md5 = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>)</span><br><span class="line">  <span class="comment">// 返回还是一个对象,并转成16进制的结果,最终拿到字符串形式</span></span><br><span class="line">  <span class="keyword">const</span> result = md5.<span class="title function_">update</span>(password).<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = md5password</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206151111074.png" alt="image-20210206151111074"></p><p>数据库那边也已经显示的是加密后的密码</p><h3 id="3-登录接口">3. 登录接口<a class="anchor" href="#3-登录接口">·</a></h3><ul><li><p>登录路径是/login</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 新建路由配置auth.<span class="property">router</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> authRouter = <span class="keyword">new</span> <span class="title class_">Router</span>()</span><br><span class="line"><span class="keyword">const</span> &#123;login&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/auth.controller&#x27;</span>)</span><br><span class="line"></span><br><span class="line">authRouter.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, login)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 配置路由</span><br><span class="line">app.<span class="title function_">use</span>(authRouter.<span class="title function_">routes</span>())</span><br><span class="line">app.<span class="title function_">use</span>(authRouter.<span class="title function_">allowedMethods</span>())</span><br></pre></td></tr></table></figure><ul><li><h4 id="登录处理：login">登录处理：login<a class="anchor" href="#登录处理：login">·</a></h4></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AuthController</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">login</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">//拿到用户名</span></span><br><span class="line">    <span class="keyword">const</span> &#123;name&#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">`欢迎<span class="subst">$&#123;name&#125;</span>回来`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title class_">AuthController</span>();</span><br></pre></td></tr></table></figure></li><li><p>此时，用户随便输入密码账户都可以登录，并没有验证，在/login的post请求中插入中间件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">authRouter.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>,***中间件verifyLogin***, login)</span><br></pre></td></tr></table></figure><h4 id="密码验证：">密码验证：<a class="anchor" href="#密码验证：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> md5password = <span class="built_in">require</span>(<span class="string">&#x27;../utils/password-handle&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">verifyLogin</span> = <span class="keyword">async</span>(<span class="params">ctx, next</span>) =&gt;&#123;</span><br><span class="line"><span class="comment">//1.获取用户名+密码</span></span><br><span class="line">  <span class="keyword">const</span> &#123;name, password&#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//用户名/密码是否为空</span></span><br><span class="line"><span class="comment">//2. 判断用户名/密码是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (!name || !password)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">NAME_OR_PASSWORD_IS_REQUIRED</span>)</span><br><span class="line">    <span class="comment">//此时发送一个错误信息，另一个地方去获取这个错误信息</span></span><br><span class="line">    <span class="comment">//emit传事件类型，事件，参数</span></span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>,error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//3.用户名/密码是否存在</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">getUserByName</span>(name)</span><br><span class="line">  <span class="keyword">const</span> user = result[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">if</span>(!user)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">USER_DOES_NOT_EXISITS</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//4.用户名/密码是否一致(加密)</span></span><br><span class="line">  <span class="comment">//user.password是之前数据库中存储的密码，而且是已经加密了的</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title function_">md5password</span>(password) !== user.<span class="property">password</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">PASSWORD_IS_NOT_CORRECT</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//5.完成所有验证步骤后，再执行router后面的中间件</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = verifyLogin</span><br></pre></td></tr></table></figure></li><li><h4 id="优化路由注册，动态加载路由：">优化路由注册，动态加载路由：<a class="anchor" href="#优化路由注册，动态加载路由：">·</a></h4></li></ul><p>之前每监理一个路由都要进行一次注册，当路由越来越多，index.js里面的内容越来越多。对这部分代码简化</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># index.<span class="property">js</span>删除</span><br><span class="line">app.<span class="title function_">use</span>(userRouter.<span class="title function_">routes</span>())</span><br><span class="line">app.<span class="title function_">use</span>(userRouter.<span class="title function_">allowedMethods</span>())</span><br><span class="line">app.<span class="title function_">use</span>(authRouter.<span class="title function_">routes</span>())</span><br><span class="line">app.<span class="title function_">use</span>(authRouter.<span class="title function_">allowedMethods</span>())</span><br><span class="line"># 改为</span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="built_in">require</span>(<span class="string">&#x27;../router/index&#x27;</span>)</span><br><span class="line"><span class="title function_">useRoutes</span>(app)</span><br></pre></td></tr></table></figure><p>在router文件夹下，新增index.js</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useRoutes</span> = (<span class="params">app</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//读取当前文件所在的目录，返回的结果是数组</span></span><br><span class="line">  fs.<span class="title function_">readdirSync</span>(__dirname).<span class="title function_">forEach</span>(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//对当前目录下的所有文件遍历，除了index.js</span></span><br><span class="line">    <span class="keyword">if</span>(file === <span class="string">&#x27;index.js&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则对每个router.js文件进行导入</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;$&#123;file&#125;&#x27;</span>)</span><br><span class="line">    app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>())</span><br><span class="line">    app.<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>())</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = useRoutes</span><br></pre></td></tr></table></figure><h3 id="4-登录凭证：">4. 登录凭证：<a class="anchor" href="#4-登录凭证：">·</a></h3><ul><li><p>验证方式1：cookie+session；（正在被淘汰）</p><p>验证方式2：Token令牌；登录成功返回凭证：（未来更流行）</p></li><li><p>有关cookie、session、token的知识在14章节笔记：token采用了生成token时和验证token时使用同一密钥的方式</p></li></ul><h4 id="非对称加密">非对称加密<a class="anchor" href="#非对称加密">·</a></h4><ul><li><p>如果secretKey暴露是一件非常危险的事情，因为之后就可以模拟颁发token， 也可以解密token；所以HS256加密算法一单密钥暴露就是非常危险的事情。</p><ul><li><p>比如在分布式系统中，每一个子系统都需要获取到密钥；那么拿到这个密钥后这个子系统既可以发布另外，也可以验证令牌；</p></li><li><p>但是对于一些资源服务器来说，它们只需要有验证令牌的能力就可以了；这个时候我们可以使用非对称加密，RS256：<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210206220511367.png" alt="image-20210206220511367" style="zoom:67%;" /></p><ul><li>私钥（private key）：用于发布令牌</li><li>公钥（public key）：用于验证令牌，是通过私钥得到的</li></ul></li><li><p>可以使用openssl来生成一对私钥和公钥：Mac直接使用terminal终端即可；Windows默认的cmd终端是不能直接使用的，建议直接使用git bash终端；</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到公钥+私钥,拿到的是buffer，但是后面是可以传入buffer的</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRIVATE_KEY</span> = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./keys/private.key&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PUBLIC_KEY</span> = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./keys/public.key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//基于token实现：jwt，手里用私钥加密</span></span><br><span class="line">  <span class="keyword">const</span> user = &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>:<span class="string">&#x27;lily&#x27;</span>&#125;</span><br><span class="line">  <span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(user, <span class="variable constant_">PRIVATE_KEY</span>, &#123;</span><br><span class="line">    <span class="attr">expiresIn</span>: <span class="number">10</span>*<span class="number">100</span>,</span><br><span class="line">    <span class="comment">//加密算法</span></span><br><span class="line">    <span class="attr">algorithm</span>: <span class="string">&quot;RS256&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.<span class="property">body</span> = token</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/demo&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//取出token</span></span><br><span class="line">  <span class="keyword">const</span> authorization = ctx.<span class="property">headers</span>.<span class="property">authorization</span></span><br><span class="line">  <span class="keyword">const</span> token = authorization.<span class="title function_">replace</span>(<span class="string">&quot;Bearer &quot;</span>,<span class="string">&quot;&quot;</span> )</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//验证token，手里有公钥解密</span></span><br><span class="line">  <span class="keyword">const</span> result = jwt.<span class="title function_">verify</span>(token, <span class="variable constant_">PUBLIC_KEY</span>, &#123;</span><br><span class="line">    <span class="comment">//这里传入的是数组，而且复数，说明可以传很多</span></span><br><span class="line">    <span class="attr">algorithms</span>: [<span class="string">&quot;RS256&quot;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;token是无效的&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>())</span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>())</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;koa启动成功了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>补充：fs.readFileSync有时候可以传相对路径，绝对路径。但是有时又不可以。在项目中的任何地方，相对路径是相对于process的cwd，在哪个文件夹启动的项目就是process.cwd</li></ul></li><li><h4 id="颁发令牌-验证令牌（回到项目）">颁发令牌+验证令牌（回到项目）<a class="anchor" href="#颁发令牌-验证令牌（回到项目）">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取公钥+私钥 </span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRIVATE_KEY</span> = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./keys/private.key&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PUBLIC_KEY</span> = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./keys/public.key&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种exports顺序不能换</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">PUBLIC_KEY</span> = <span class="variable constant_">PUBLIC_KEY</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">PRIVATE_KEY</span> = <span class="variable constant_">PRIVATE_KEY</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># auth.<span class="property">controller</span>.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="variable constant_">PUBLIC_KEY</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../app/config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="variable constant_">PRIVATE_KEY</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../app/config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthController</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">login</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">//拿到用户名</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id, name&#125; = ctx.<span class="property">user</span> </span><br><span class="line">    <span class="comment">//颁发令牌</span></span><br><span class="line">    <span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(&#123;id, name&#125;, <span class="variable constant_">PRIVATE_KEY</span>, &#123;</span><br><span class="line">      <span class="attr">expiresIn</span>: <span class="number">10</span>*<span class="number">100</span>*<span class="number">60</span>,</span><br><span class="line">      <span class="attr">algorithm</span>: <span class="string">&#x27;RS256&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    ctx.<span class="property">body</span> = &#123;</span><br><span class="line">      id, token, name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title class_">AuthController</span>();</span><br></pre></td></tr></table></figure></li><li><h4 id="验证用户是否授权，颁发的签名是否有效">验证用户是否授权，颁发的签名是否有效<a class="anchor" href="#验证用户是否授权，颁发的签名是否有效">·</a></h4><p>比如当一个用户登录之后，发表动态，发表文章之前我们要验证该用户是否授权</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 验证的路径是/test,get请求</span><br><span class="line">authRouter.<span class="title function_">get</span>(<span class="string">&#x27;/test&#x27;</span>, verifyAuth, success)<span class="comment">//success只是显示验证成功的功能</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># auth.<span class="property">middleware</span>.<span class="property">js</span>  验证函数</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">verifyAuth</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;验证授权的middleware&#x27;</span>)</span><br><span class="line">  <span class="comment">// 注意这里发送请求时在postmen里记得把token复制，携带过去</span></span><br><span class="line">  <span class="keyword">const</span> authorization = ctx.<span class="property">headers</span>.<span class="property">authorization</span></span><br><span class="line">  <span class="comment">//如果我们在postman中携带错误的token传过来，</span></span><br><span class="line">  <span class="comment">//此时ctx.headers里面压根就没有authorization</span></span><br><span class="line">  <span class="comment">//所以要先验证一遍</span></span><br><span class="line">  <span class="keyword">if</span>(!authorization)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">NOT_AUTHORIZATION</span>)</span><br><span class="line">    <span class="comment">//这里必须是return,否则会卡在这里</span></span><br><span class="line">     <span class="keyword">return</span> ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> token = authorization.<span class="title function_">replace</span>(<span class="string">&#x27;Bearer &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 验证token</span></span><br><span class="line">    <span class="keyword">const</span> result = jwt.<span class="title function_">verify</span>(token, <span class="variable constant_">PUBLIC_KEY</span>, &#123;</span><br><span class="line">    <span class="attr">algorithms</span>: [<span class="string">&#x27;RS256&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">NOT_AUTHORIZATION</span>)</span><br><span class="line">    ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-1-发布-查询动态内容">5.1 发布/查询动态内容<a class="anchor" href="#5-1-发布-查询动态内容">·</a></h3><h4 id="1-发布动态内容">1. 发布动态内容<a class="anchor" href="#1-发布动态内容">·</a></h4><ul><li><p>新建moment.router.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;verifyAuth&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/auth.middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;create&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/moment.controller.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> momentRouter = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;<span class="attr">prefix</span>: <span class="string">&#x27;/moment&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">//发表评论之前要先验证登录，然后才是create创建评论</span></span><br><span class="line">momentRouter.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, verifyAuth, create)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = momentRouter </span><br></pre></td></tr></table></figure></li><li><p>创建新的表 moment</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">`moment`</span> (</span><br><span class="line">  <span class="comment">// 评论的id，表示哪条评论</span></span><br><span class="line">  id <span class="variable constant_">INT</span> <span class="variable constant_">PRIMARY</span> <span class="variable constant_">KEY</span> <span class="variable constant_">AUTO_INCREMENT</span>,</span><br><span class="line">  content <span class="title function_">VARCHAR</span>(<span class="number">1000</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">  <span class="comment">// 该评论对应的用户id</span></span><br><span class="line">  user_id <span class="variable constant_">INT</span> <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">  createAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updateAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="comment">// 引用外键约束，user_id是发表评论对应的用户的id，</span></span><br><span class="line">  <span class="comment">// users(id)是用户表中的用户的id，表示哪个用户，二者应该是联动的</span></span><br><span class="line">  <span class="comment">// 代表了哪条评论对应了哪个用户</span></span><br><span class="line">  <span class="variable constant_">FOREIGN</span> <span class="title function_">KEY</span>(user_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">users</span>(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>定义发布动态内容的接口</p><ul><li><p>验证用户登录:  verifyAuth直接导入使用</p></li><li><p>Controller和Service中处理内容</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> momentService = <span class="built_in">require</span>(<span class="string">&#x27;../service/moment.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">momentController</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">  <span class="comment">// 发表动态的逻辑:</span></span><br><span class="line">    <span class="comment">//1.拿到user_id, 动态内容，上一个中间件的ctx.user里面存着</span></span><br><span class="line">    <span class="keyword">const</span> user_id = ctx.<span class="property">user</span>.<span class="property">id</span>   <span class="comment">// 拿到用户id，是哪个用户</span></span><br><span class="line">    <span class="keyword">const</span> content = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">content</span>  <span class="comment">// 是什么动态内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 将数据插入到数据库中</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.<span class="title function_">create</span>(user_id, content)</span><br><span class="line">    ctx.<span class="property">body</span> =  result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">momentController</span>();</span><br></pre></td></tr></table></figure></li><li><p>moment.service.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const connection = require(&#x27;../app/database&#x27;)</span><br><span class="line">class momentService&#123;</span><br><span class="line">  async create(user_id, content)&#123;</span><br><span class="line">    const statement = `INSERT INTO moment (content, user_id) VALUES (?, ?)`</span><br><span class="line">    const result = connection.execute(statement, [content, user_id])</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = new momentService();</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210207173925587.png" alt="image-20210207173925587"></p></li></ul></li></ul><h4 id="2-查询动态内容">2.查询动态内容<a class="anchor" href="#2-查询动态内容">·</a></h4><ul><li><p>定义查询单个内容的接口</p><ul><li><p>根据momentId查询接口内容；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 路由</span><br><span class="line"><span class="comment">// 查看评论,不需要登录,需要知道评论对应的id</span></span><br><span class="line">momentRouter.<span class="title function_">get</span>(<span class="string">&#x27;/:momentId&#x27;</span>, momentDetail)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">momentDetail</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 从数据库中获取评论信息，需要id,</span></span><br><span class="line">    <span class="comment">//1. id是请求接口params里面携带的momentId</span></span><br><span class="line">    <span class="keyword">const</span> momentId = ctx.<span class="property">params</span>.<span class="property">momentId</span></span><br><span class="line">    <span class="comment">//2.拿到id去数据库查询评论信息,让service做</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.<span class="title function_">getMomentById</span>(momentId)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 去数据库查询内容</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getMomentById</span>(<span class="params">id</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT </span></span><br><span class="line"><span class="string">      m.id id, m.content content, </span></span><br><span class="line"><span class="string">      m.createAt createTime, m.updateAt updateTime, </span></span><br><span class="line"><span class="string">      JSON_OBJECT(&#x27;id&#x27;, u.id, &#x27;name&#x27;, u.name) author</span></span><br><span class="line"><span class="string">      FROM moment m</span></span><br><span class="line"><span class="string">      LEFT JOIN users u ON m.user_id = u.id </span></span><br><span class="line"><span class="string">      WHERE m.id =?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [id])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义查询多条内容的接口</p><ul><li><p>查询所有moment接口内容（根据offset和size决定查询数量）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 路由</span><br><span class="line"><span class="comment">// 查看多条动态</span></span><br><span class="line">momentRouter.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, list)</span><br></pre></td></tr></table></figure><p>在实际中，数据很多的，不能一次性把所有数据查完而是分页查询，所以你请求路径后面还要跟上偏移offset+size，从哪儿查，一次查多少</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">list</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 获取查询参数</span></span><br><span class="line">    <span class="keyword">const</span> &#123;offset, size&#125; = ctx.<span class="property">request</span>.<span class="property">query</span></span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.<span class="title function_">getMomentList</span>(offset, size)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 查询多条内容</span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">getMomentList</span>(<span class="params">offset, size</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT </span></span><br><span class="line"><span class="string">      m.id id, m.content content, </span></span><br><span class="line"><span class="string">      m.createAt createTime, m.updateAt updateTime, </span></span><br><span class="line"><span class="string">      JSON_OBJECT(&#x27;id&#x27;, u.id, &#x27;name&#x27;, u.name) author</span></span><br><span class="line"><span class="string">      FROM moment m</span></span><br><span class="line"><span class="string">      LEFT JOIN users u ON m.user_id = u.id </span></span><br><span class="line"><span class="string">      LIMIT ?, ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [offset, size])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>代码优化：sql语句有很多相似的地方，可以抽出来 ，简化代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sqlFragment = <span class="string">`SELECT </span></span><br><span class="line"><span class="string">  m.id id, m.content content, </span></span><br><span class="line"><span class="string">  m.createAt createTime, m.updateAt updateTime, </span></span><br><span class="line"><span class="string">  JSON_OBJECT(&#x27;id&#x27;, u.id, &#x27;name&#x27;, u.name) author</span></span><br><span class="line"><span class="string">  FROM moment m</span></span><br><span class="line"><span class="string">  LEFT JOIN users u ON m.user_id = u.id `</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> statement = <span class="string">`</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;sqlFragment&#125;</span></span></span><br><span class="line"><span class="string">WHERE m.id =?`</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-2-修改-删除动态内容">5.2 修改/删除动态内容<a class="anchor" href="#5-2-修改-删除动态内容">·</a></h3><h4 id="1-定义修改动态内容的接口">1.  定义修改动态内容的接口<a class="anchor" href="#1-定义修改动态内容的接口">·</a></h4><p>​用户必须已经登录验证; 只能修改自己发表的内容，而不能修改别人的内容，是否有权限</p><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改动态 </span></span><br><span class="line">momentRouter.<span class="title function_">patch</span>(<span class="string">&#x27;/:momentId&#x27;</span>,verifyAuth, verifyPermission, update)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：省略</p></li><li><p>验证用户的权限</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">middleware</span>.<span class="property">js</span>的中间件</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">verifyPermission</span> = <span class="keyword">async</span>(<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 验证已经登陆的用户与要修改的评论是否有权限</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;验证是否有修改权限&#x27;</span>)</span><br><span class="line"><span class="comment">// 1.获取参数</span></span><br><span class="line">  <span class="comment">// momentId 是要修改的动态id</span></span><br><span class="line">  <span class="keyword">const</span> &#123;momentId&#125; = ctx.<span class="property">request</span>.<span class="property">params</span></span><br><span class="line">  <span class="comment">// 拿到当前登录用户的id，也就是谁登陆的</span></span><br><span class="line">  <span class="comment">//在update前面的中间件auth.verify中将ctx.user = result</span></span><br><span class="line">  <span class="comment">//当前登录信息结果保存在user里面</span></span><br><span class="line">  <span class="keyword">const</span> &#123;id&#125; = ctx.<span class="property">user</span></span><br><span class="line"><span class="comment">// 2. 查询是否具备权限并处理</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isPermission = <span class="keyword">await</span> authService.<span class="title function_">checkMoment</span>(momentId, id)</span><br><span class="line">    <span class="keyword">if</span>(!isPermission)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>()<span class="comment">//这个错误会在catch捕获</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">NOT_PERMISSION</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="单独封装权限查询的函数，这是为了后续各种需要权限的操作时，不用再重复写">单独封装权限查询的函数，这是为了后续各种需要权限的操作时，不用再重复写<a class="anchor" href="#单独封装权限查询的函数，这是为了后续各种需要权限的操作时，不用再重复写">·</a></h4><p>验证权限的中间件很重要：</p><ol><li>很多功能都需要权限验证</li><li>业务接口，一般只需要验证当前登录的这个人与修改评论即可。但在后台管理系统中，权限验证是非常重要的，它是有一对一的关系：后台管理系统中用户有角色，还有权限表，是多对多的关系。角色是否具备某个权限，到时候可以去查询就可以了。</li><li>开发业务接口和后台管理系统一般是两个系统，而且可能部署到不同的服务器，一般不会放在一起开发。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># auth.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&#x27;../app/database&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">authService</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">checkMoment</span>(<span class="params">momentId, userId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM moment WHERE id =? AND user_id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [momentId, userId])</span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">length</span> === <span class="number">0</span>? <span class="attr">false</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">authService</span>()</span><br></pre></td></tr></table></figure></li><li><p>Controller和Service中的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">update</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// momentId 是要修改的动态id</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId&#125; = ctx.<span class="property">request</span>.<span class="property">params</span></span><br><span class="line">    <span class="keyword">const</span> &#123;content&#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">    <span class="comment">// 修改动态</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.<span class="title function_">update</span>(content, momentId)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">update</span>(<span class="params">content, id</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`UPDATE moment SET content =? WHERE id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [content, id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-定义删除内容的接口">2. 定义删除内容的接口<a class="anchor" href="#2-定义删除内容的接口">·</a></h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除动态</span></span><br><span class="line">momentRouter.<span class="title function_">delete</span>(<span class="string">&#x27;/:momentId&#x27;</span>,verifyAuth, verifyPermission, remove)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：省略</p></li><li><p>验证用户权限： 省略</p></li><li><p>Controller和Service的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">remove</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">  <span class="comment">// 拿到要输出动态的id</span></span><br><span class="line">  <span class="keyword">const</span> id = ctx.<span class="property">params</span>.<span class="property">momentId</span></span><br><span class="line">  <span class="comment">// 删除内容</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> momentService.<span class="title function_">remove</span>(id)</span><br><span class="line">  ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">remove</span>(<span class="params">id</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`DELETE FROM moment WHERE id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-发表-修改评论内容">6.1 发表/修改评论内容<a class="anchor" href="#6-1-发表-修改评论内容">·</a></h3><ul><li><p>创建新的表 comment</p><p>需要记录是对当前动态做的评论，还是对评论做了评论，但他们都属于当前这条动态下的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">`comment`</span>(</span><br><span class="line">  # 评论唯一的主键</span><br><span class="line">  id <span class="variable constant_">INT</span> <span class="variable constant_">PRIMARY</span> <span class="variable constant_">KEY</span> <span class="variable constant_">AUTO_INCREMENT</span>,</span><br><span class="line">  # 评论的内容</span><br><span class="line">  content <span class="title function_">VARCHAR</span>(<span class="number">1000</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">  # 对哪个动态做的评论</span><br><span class="line">  moment_id <span class="variable constant_">INT</span> <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">  # 哪个用户做的评论</span><br><span class="line">  user_id <span class="variable constant_">INT</span> <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">  # 这个评论是对哪个评论做的评论</span><br><span class="line">  comment_id <span class="variable constant_">INT</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">  createAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updateAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line"></span><br><span class="line">  <span class="variable constant_">FOREIGN</span> <span class="variable constant_">KEY</span> (moment_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">moment</span>(id) <span class="variable constant_">ON</span> <span class="variable constant_">DELETE</span> <span class="variable constant_">CASCADE</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CASCADE</span>,</span><br><span class="line">  <span class="variable constant_">FOREIGN</span> <span class="variable constant_">KEY</span> (user_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">users</span>(id) <span class="variable constant_">ON</span> <span class="variable constant_">DELETE</span> <span class="variable constant_">CASCADE</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CASCADE</span>,</span><br><span class="line">  <span class="variable constant_">FOREIGN</span> <span class="variable constant_">KEY</span> (comment_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">comment</span>(id) <span class="variable constant_">ON</span> <span class="variable constant_">DELETE</span> <span class="variable constant_">CASCADE</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CASCADE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-定义发布评论内容的接口">1. 定义发布评论内容的接口<a class="anchor" href="#1-定义发布评论内容的接口">·</a></h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;create&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/comment.controller&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;verifyAuth&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/auth.middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commentRouter = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;<span class="attr">prefix</span>: <span class="string">&quot;/comment&quot;</span>&#125;)</span><br><span class="line">commentRouter.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, verifyAuth, create)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = commentRouter</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录： verifyAuth省略</p></li><li><p>Controller和Service中处理内容</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/comment.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">momentController</span>&#123;</span><br><span class="line">  <span class="comment">// 创建评论</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 在请求体里对哪个动态(动态id)拿到评论的内容(content)</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId, content&#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">    <span class="comment">// 谁发布的评论，在上一个中间件认证中已经知道</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.<span class="property">user</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">create</span>(momentId, content, id)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">momentController</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&#x27;../app/database&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">momentService</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">momentId, content, user_id</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO comment (content, moment_id, user_id) </span></span><br><span class="line"><span class="string">    VALUES (?, ?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, </span><br><span class="line">    [content, momentId, user_id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">momentService</span>()</span><br></pre></td></tr></table></figure><ul><li>在这里犯了错：写sql语句的时候一定要记得对照数据库里面的称呼名字，传参时对应就可以，但写语句时必须严格一样</li></ul></li></ul><h4 id="2-定义回复评论内容的接口">2. 定义回复评论内容的接口<a class="anchor" href="#2-定义回复评论内容的接口">·</a></h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">commentRouter.<span class="title function_">post</span>(<span class="string">&#x27;/:commentId/reply&#x27;</span>, verifyAuth, reply)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录： verifyAuth</p></li><li><p>Controller和Service中的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">reply</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 拿到传的参数commentId</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId, content&#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">    <span class="keyword">const</span> &#123;commentId&#125; = ctx.<span class="property">params</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.<span class="property">user</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">reply</span>(commentId, momentId, content, id)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">reply</span>(<span class="params">commentId, momentId, content, id</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO comment (content, moment_id, user_id, comment_id) VALUES (?, ?, ?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, </span><br><span class="line">    [content, momentId, id, commentId])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-定义修改评论内容的接口">3. 定义修改评论内容的接口<a class="anchor" href="#3-定义修改评论内容的接口">·</a></h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改评论,你只能修改自己发表的评论，而不能修改别人发表的评论</span></span><br><span class="line">commentRouter.<span class="title function_">patch</span>(<span class="string">&#x27;/:commentId&#x27;</span>, verifyAuth, verifyPermission, update)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录: verifyAuth</p></li><li><p>验证用户的权限</p><ul><li>之前的权限是验证是否具备发表动态的权限，而这里是验证是否有修改评论的权限，是不可以继续用以前的那个权限的</li><li>一种思路是按之前验证动态权限一样，再去写一个函数verifyPermission来验证，但是随着越来越多的业务都需要验证时，此时代码量会越来越多。</li><li>另一种解决办法是：写一个函数既具备验证动态，也具备验证评论。但是如果你只是调用checkmoment，里面的const statement = <code>SELECT * FROM moment WHERE id =? AND user_id = ?</code>是写死的，你只能验证动态。所以让这个验证权限的函数具备多种验证功能的方法是：动态的改变statement，让他查询的东西随权限的不同而变化。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 对auth.<span class="property">middleware</span>.<span class="property">js</span>重新修改  verifyPermission函数</span><br><span class="line"># 更改了checkmoment为checkResource，并对参数做了改变</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">verifyPermission</span> = <span class="keyword">async</span>(<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 验证已经登陆的用户与要修改的动态是否有权限</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;验证是否有修改权限&#x27;</span>)</span><br><span class="line"><span class="comment">// 1.获取参数</span></span><br><span class="line">  <span class="comment">// momentId 是要修改的动态id</span></span><br><span class="line">  <span class="comment">// const &#123;momentId&#125; = ctx.request.params</span></span><br><span class="line">  <span class="comment">// 拿到当前登录用户的id，也就是谁登陆的</span></span><br><span class="line">  <span class="comment">//在update前面的中间件auth.verify中将ctx.user = result</span></span><br><span class="line">  <span class="comment">//当前登录信息结果保存在user里面</span></span><br><span class="line">    <span class="comment">// 获取tablename:</span></span><br><span class="line">    <span class="comment">//思路1：</span></span><br><span class="line">    <span class="comment">//思路2：如果路径是restful风格，可以从里面取出tableNmae</span></span><br><span class="line">    <span class="keyword">const</span> [resourceKey] = <span class="title class_">Object</span>.<span class="title function_">keys</span>(ctx.<span class="property">params</span>)</span><br><span class="line">    <span class="keyword">const</span> tableName = resourceKey.<span class="title function_">replace</span>(<span class="string">&#x27;Id&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">//resourceId是想修改的那个评论在table中所处的id号</span></span><br><span class="line">    <span class="keyword">const</span> resourceId = ctx.<span class="property">params</span>[resourceKey]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.<span class="property">user</span></span><br><span class="line"><span class="comment">// 2. 查询是否具备权限并处理</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isPermission = <span class="keyword">await</span> authService.<span class="title function_">checkResource</span>(tableName,resourceId, id)</span><br><span class="line">    <span class="keyword">if</span>(!isPermission)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>()<span class="comment">//这个错误会在catch捕获</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须加await，否则会出问题，为什么</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(errorType.<span class="property">NOT_PERMISSION</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># auth.<span class="property">service</span>.<span class="property">js</span>修改后</span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&#x27;../app/database&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">authService</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">checkResource</span>(<span class="params">tableNmae, id, userId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM <span class="subst">$&#123;tableNmae&#125;</span> WHERE id =? AND user_id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [id, userId])</span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">length</span> === <span class="number">0</span>? <span class="attr">false</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">authService</span>()</span><br></pre></td></tr></table></figure><ul><li><p>Controller和Service中的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">update</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;content&#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">    <span class="keyword">const</span> &#123;commentId&#125; = ctx.<span class="property">params</span></span><br><span class="line">    <span class="comment">// 修改评论</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">update</span>(content, commentId)</span><br><span class="line">    ctx.<span class="property">body</span> = content+commentId+result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">update</span>(<span class="params">content, commentId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`UPDATE comment SET content=? WHERE comment_id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [content, commentId])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-删除-查询评论内容">6.2  删除/查询评论内容<a class="anchor" href="#6-2-删除-查询评论内容">·</a></h3><h4 id="1-定义删除评论内容的接口">1. 定义删除评论内容的接口<a class="anchor" href="#1-定义删除评论内容的接口">·</a></h4><ul><li><p>定义路由接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除评论</span></span><br><span class="line">commentRouter.<span class="title function_">delete</span>(<span class="string">&#x27;/:commentId&#x27;</span>, verifyAuth, verifyPermission, remove)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：verifyAuth</p></li><li><p>验证用户权限：verifyPermission</p></li><li><p>Controller和Service的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">remove</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 删除评论需要这个评论的id即可</span></span><br><span class="line">    <span class="keyword">const</span> &#123;commentId&#125; = ctx.<span class="property">params</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">delete</span>(commentId)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">delete</span>(<span class="params">commentId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`DELETE FROM comment WHERE id=? `</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [commentId])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-查询动态">2. 查询动态<a class="anchor" href="#2-查询动态">·</a></h4><ul><li><p>需求：</p><ul><li><p>查询一个动态详情时，既要看动态信息，还要看用户信息，评论的列表。需要回头修改moment.user.需要修改sql语句</p></li><li><p>查询动态列表时，有一个commentCount，也就是对应着你这条动态下有多少条评论计数。</p></li></ul></li><li><p>查询多个动态时，<strong>显示评论的个数</strong></p><p>在原有的查看动态getMomentList下的基础上，对sql语句进行了修改，添加查询字段，并增添了评论数量</p><p>在此基础上添加查询字段，子查询字段。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">SELECT</span> </span><br><span class="line">  m.<span class="property">id</span> id, m.<span class="property">content</span> content, </span><br><span class="line">  m.<span class="property">createAt</span> createTime, m.<span class="property">updateAt</span> updateTime, </span><br><span class="line">  <span class="title class_">JSON</span>_OBJECT(<span class="string">&#x27;id&#x27;</span>, u.<span class="property">id</span>, <span class="string">&#x27;name&#x27;</span>, u.<span class="property">name</span>) author,</span><br><span class="line">(<span class="variable constant_">SELECT</span> <span class="title function_">COUNT</span>(*) <span class="variable constant_">FROM</span> comment c <span class="variable constant_">WHERE</span> c.<span class="property">moment_id</span> = m.<span class="property">id</span>) commentCount</span><br><span class="line">  <span class="variable constant_">FROM</span> moment m</span><br><span class="line">  <span class="variable constant_">LEFT</span> <span class="variable constant_">JOIN</span> users u <span class="variable constant_">ON</span> m.<span class="property">user_id</span> = u.<span class="property">id</span></span><br><span class="line"><span class="variable constant_">LIMIT</span> ?, ?;</span><br></pre></td></tr></table></figure><ul><li><p>进行请求：<img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210208223358740.png" alt="image-20210208223358740"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;评论动态的内容&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="string">&quot;2021-02-07T09:33:56.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updateTime&quot;</span>: <span class="string">&quot;2021-02-07T09:33:56.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lucy&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;commentCount&quot;</span>: <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;评论动态的内容&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span>: <span class="string">&quot;2021-02-07T09:34:48.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updateTime&quot;</span>: <span class="string">&quot;2021-02-07T09:34:48.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lucy&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;commentCount&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>数据库中显示查询结果：<img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210208223616477.png" alt="image-20210208223616477"></p></li></ul></li><li><p>查询单个动态时，显示评论的列表</p><p>当用户点击动态后，会进入动态详情页。如何获取评论的列表，之前是评论数量</p><ul><li>思路1：动态的接口与评论接口分开，分别用不同的接口获得不同的需求</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">router</span>.<span class="property">js</span></span><br><span class="line"><span class="comment">// 获取评论列表：不需要验证登录、权限</span></span><br><span class="line">commentRouter.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, list)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">list</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 拿到要获取comment的动态id：momentId</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId&#125; = ctx.<span class="property">query</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">getCommentsBymomentId</span>(momentId)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># comment.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getCommentsBymomentId</span>(<span class="params">momentId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM comment  WHERE moment_id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">exexute</span>(statement, [momentId])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210208231911140.png" alt="image-20210208231911140"></p><ul><li>思路2：直接在请求动态的接口时候，就会携带评论相关的信息，嵌入动态信息里面。缺点：sql语句复杂，容易写错；如果信息很多，一次性请求过多的信息，网速慢，用户体验不好，可以把用户的动态先请求过来。省略</li><li>点赞功能：用户之间的多对多的关系，一个动态可以被多个用户点赞，一个用户也可以点赞多个用户。动态表中有很多动态，用户表也有很多用户，在这两个之间建立关系表，把动态相关的id+user_id结合在一起网这个表插入进去。</li></ul></li></ul><h3 id="7-标签接口开发（多对多）">7. 标签接口开发（多对多）<a class="anchor" href="#7-标签接口开发（多对多）">·</a></h3><p>标签是给动态加标签，每个动态都有对应着。所以需要标签表记录标签id，标签名等。一个动态可以有多个标签，一个标签可以属于多个动态。多对多的关系，所以当给一条动态添加一个标签以后，先判断是否存在这个标签，没有要先创建，有了再添加。</p><ul><li><p>创建标签的表</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">`label`</span>(</span><br><span class="line"> # id是主键</span><br><span class="line">id <span class="variable constant_">INT</span> <span class="variable constant_">PRIMARY</span> <span class="variable constant_">KEY</span> <span class="variable constant_">AUTO_INCREMENT</span>,</span><br><span class="line"># 标签名 是不能重复的，没意义</span><br><span class="line">name <span class="title function_">VARCHAR</span>(<span class="number">10</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">UNIQUE</span>,</span><br><span class="line">createAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updateAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span> </span><br><span class="line"> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-创建标签接口">1. 创建标签接口<a class="anchor" href="#1-创建标签接口">·</a></h4><ul><li><p>路由配置Router</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; verifyAuth &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/auth.middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;create&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/label.controller&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> labelRouter = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;<span class="attr">prefix</span>: <span class="string">&#x27;/label&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建标签时会先验证登录，</span></span><br><span class="line">labelRouter.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, verifyAuth,create)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = labelRouter</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：verifyAuth</p></li><li><p>Controller和Service的处理：创建标签</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.<span class="property">controller</span></span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/label.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">laberController</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 拿到要添加的标签</span></span><br><span class="line">    <span class="keyword">const</span> &#123;name&#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">create</span>(name)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">laberController</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.<span class="property">service</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&quot;../app/database&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">labelService</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO label (name) VALUES (?);`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [name])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">labelService</span>()</span><br></pre></td></tr></table></figure></li><li><p>创建标签和动态关系表</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">`moment_label`</span>(</span><br><span class="line">moment_id <span class="variable constant_">INT</span> <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">label_id <span class="variable constant_">INT</span> <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line">createAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updateAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="comment">// 让二者成为联合主键，与复合主键是一个概念</span></span><br><span class="line"><span class="variable constant_">PRIMARY</span> <span class="variable constant_">KEY</span> (moment_id, label_id),</span><br><span class="line"><span class="comment">// 这里的联动效果是：这条动态删掉了，关系表里的记录会删掉，但是标签name并不会被删掉,</span></span><br><span class="line"><span class="variable constant_">FOREIGN</span> <span class="variable constant_">KEY</span> (moment_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">moment</span>(id) <span class="variable constant_">ON</span> <span class="variable constant_">DELETE</span> <span class="variable constant_">CASCADE</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CASCADE</span>,</span><br><span class="line"><span class="variable constant_">FOREIGN</span> <span class="variable constant_">KEY</span> (label_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">label</span>(id) <span class="variable constant_">ON</span> <span class="variable constant_">DELETE</span> <span class="variable constant_">CASCADE</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CASCADE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-给动态添加标签">2. 给动态添加标签<a class="anchor" href="#2-给动态添加标签">·</a></h4><ul><li><p>给<strong>动态</strong>添加新的接口： /moment/1/labels</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">router</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> &#123;verifyLabelExist&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/label.middleware&#x27;</span>)</span><br><span class="line"><span class="comment">// 给动态添加标签</span></span><br><span class="line">momentRouter.<span class="title function_">post</span>(<span class="string">&#x27;/:momentId/labels&#x27;</span>, verifyAuth, verifyPermission,</span><br><span class="line">                    verifyLabelExist,addLabels)</span><br></pre></td></tr></table></figure></li><li><p>验证用户登录：verifyAuth</p></li><li><p>验证用户权限：verifyPermission</p></li><li><p>验证标签是否存在：Controller和Service的处理</p><p>如果标签不存在，添加到label表中，也就是为label创建新标签。而下面的创建标签是在关系表中添加标签</p><ul><li>这里是不可以直接将标签与动态联系在一起的，标签的名字有可能在标签的表里是不存在的，此时是没有对应的id，此时联系表label_id就不存在</li><li>所以当用户调用接口时，判断是否存在这个标签，如果不存在先创建这个标签，再往关系表里面插入数据。</li><li>所以路由中间还应该有一个中间件labelmiddleware,里面有函数varifyLabelExists，验证标签是否存在</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.<span class="property">middleware</span>.<span class="property">js</span></span><br><span class="line"><span class="comment">// 验证要添加的标签是否已经存在与标签表</span></span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/label.service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">verifyLabelExist</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//取出要添加的所有标签</span></span><br><span class="line">  <span class="keyword">const</span> &#123;labels&#125; = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">  <span class="keyword">const</span> newLabels = []</span><br><span class="line">  <span class="comment">// 判断每个标签是否存在于标签表，遍历</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> name <span class="keyword">of</span> labels)&#123;</span><br><span class="line">    <span class="comment">// 如果该标签不存在，返回结果是result[0]，为undefined</span></span><br><span class="line">    <span class="comment">// 如果存在：结果是:BinaryRow &#123;</span></span><br><span class="line">    <span class="comment">//   id: 2,</span></span><br><span class="line">    <span class="comment">//   name: &#x27;游戏&#x27;,</span></span><br><span class="line">    <span class="comment">//   createAt: 2021-02-09T10:00:56.000Z,</span></span><br><span class="line">    <span class="comment">//   updateAt: 2021-02-09T10:00:56.000Z</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">const</span> labelResult = <span class="keyword">await</span> service.<span class="title function_">getLabelByName</span>(name) <span class="comment">//  label.service.js</span></span><br><span class="line">    <span class="keyword">const</span> label = &#123;name&#125;</span><br><span class="line">    <span class="comment">// 如果不存在,就添加标签</span></span><br><span class="line">    <span class="keyword">if</span>(!labelResult)&#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">create</span>(name)   <span class="comment">//  label.service.js</span></span><br><span class="line">      label.<span class="property">id</span> = result.<span class="property">insertId</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      label.<span class="property">id</span> = labelResult.<span class="property">id</span></span><br><span class="line">    &#125;</span><br><span class="line">    newLabels.<span class="title function_">push</span>(label)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环结束，完成所有不存在标签的添加到label表</span></span><br><span class="line">  ctx.<span class="property">body</span> = newLabels</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  verifyLabelExist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&quot;../app/database&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">labelService</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO label (name) VALUES (?);`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [name])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断标签是否存在的情况</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getLabelByName</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM label WHERE name = ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [name])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">labelService</span>()</span><br></pre></td></tr></table></figure></li><li><p>在关系表中添加标签：Controller和Service的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">controller</span>.<span class="property">js</span> </span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">addLabels</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">//1. 给哪条动态上加什么标签</span></span><br><span class="line">    <span class="keyword">const</span> &#123;labels&#125; = ctx</span><br><span class="line">    <span class="keyword">const</span> &#123;momentId&#125; = ctx.<span class="property">params</span></span><br><span class="line">    <span class="comment">//2. 判断：如果添加标签是否已存在关系表</span></span><br><span class="line">      <span class="comment">// 2.1 在关系表中是否关于这个moment的标签已经有了</span></span><br><span class="line">      <span class="comment">// 标签表、关系表中标签都应该是唯一的</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> label <span class="keyword">of</span> labels)&#123;</span><br><span class="line">        <span class="keyword">const</span> isExist = <span class="keyword">await</span> momentService.<span class="title function_">hasLabel</span>(momentId, label.<span class="property">id</span>)</span><br><span class="line">        <span class="keyword">if</span>(!isExist)&#123;</span><br><span class="line">         <span class="keyword">await</span> momentService.<span class="title function_">addLabels</span>(label.<span class="property">id</span>, momentId)</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;在关系表中添加标签&#x27;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># moment.<span class="property">service</span>.<span class="property">js</span> </span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">hasLabel</span>(<span class="params">momentId, labelId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM moment_label WHERE moment_id=? AND label_id=?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [momentId, labelId])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]? <span class="attr">true</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">addLabels</span>(<span class="params">label_id, momentId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO moment_label (moment_id, label_id) VALUES (?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [momentId, label_id])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-展示标签">3. 展示标签<a class="anchor" href="#3-展示标签">·</a></h4><ul><li><p>展示标签的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询标签列表</span></span><br><span class="line">labelRouter.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, list)</span><br></pre></td></tr></table></figure></li><li><p><strong>查询动态列表</strong>，展示<strong>标签数量</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">list</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;offset, limit&#125; = ctx.<span class="property">query</span></span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">getLabels</span>(offset, limit)</span><br><span class="line">   ctx.<span class="property">body</span> = result</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># label.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getLabels</span>(<span class="params">offset, limit</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM label LIMIT ?, ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [offset, limit])</span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改标签接口：一般标签创建后一般不会做修改和删除操作</p></li><li><p>查询<strong>动态详情</strong>，展示<strong>标签列表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql语句太复杂了，暂时先不写这块</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210209225206649.png" alt="image-20210209225206649"></p></li></ul><h3 id="8-上传图片">8. 上传图片<a class="anchor" href="#8-上传图片">·</a></h3><h4 id="分析实现思路：">分析实现思路：<a class="anchor" href="#分析实现思路：">·</a></h4><ul><li><p>图片（文件）上传 /upload/avatar</p><ul><li>图片上传就是文件上传的一种，服务器端可以保存一张图片</li></ul></li><li><p>提供一个接口，可以让用户获取图片</p><ul><li><p>如果有一天浏览器请求这个图片时，要在img标签里展示出来图片。必须提供一个接口提供给用户获取这个接口，而不是让用户下载这个图片文件。</p></li><li><p>找到图片，读取图片，设置content-type，告诉浏览器类型，而不是将二进制流直接给他。这样浏览器才知道是一图片的形式展示出去</p></li><li><p>avatar -&gt; 找到图片\读取图片\content-type: image/jpeg\返回图像的信息</p></li></ul></li><li><p>将URL存储到用户信息中</p><ul><li><p>将url存储到用户信息中，用户信息中有一个字段： avatar字段，直接给用户头像的地址</p></li><li><p>avatarURL: 头像的地址</p></li></ul></li><li><p>获取信息时，获取用户的头像</p></li></ul><h4 id="1-上传头像">1. 上传头像<a class="anchor" href="#1-上传头像">·</a></h4><ul><li>定义所有关于上传头像的接口</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.<span class="property">router</span>.<span class="property">js</span>   希望在这个路由里定义所有关于图片上传的路由</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;verifyAuth&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/auth.middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;uploadHandle&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleWare/file.middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileRouter = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;<span class="attr">prefix</span>: <span class="string">&quot;/upload&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 上传图片：中间件定义图片保存在哪里，保存在服务器里；</span></span><br><span class="line"><span class="comment">// 关于图片的信息：类型，大小，controller.js里</span></span><br><span class="line"><span class="comment">// 上传头像必须要登录的，verifyAuth, 验证登录</span></span><br><span class="line">fileRouter.<span class="title function_">post</span>(<span class="string">&#x27;/avatar&#x27;</span>, verifyAuth, uploadHandle,saveAvatarInfo)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = fileRouter</span><br></pre></td></tr></table></figure>  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210153519583.png" alt="image-20210210153519583" style="zoom:50%;" />  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.<span class="property">middleware</span>.<span class="property">js</span>   借助插件koa-multer来实现文件上传</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Multer</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-multer&#x27;</span>)</span><br><span class="line"><span class="comment">// 在本地的process.cwd路径下创建路径./uploads/avatar下的文件夹</span></span><br><span class="line"><span class="keyword">const</span> uploadAvatar = <span class="title class_">Multer</span>(&#123;</span><br><span class="line">  <span class="attr">dest</span>: <span class="string">&#x27;./uploads/avatar&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 找到在postman那边上传的avatar字段,single只找一个文件</span></span><br><span class="line"><span class="comment">// 然后放入后面的路由后面，登陆之后会对上传文件进行处理</span></span><br><span class="line"><span class="keyword">const</span> uploadHandle = uploadAvatar.<span class="title function_">single</span>(<span class="string">&#x27;avatar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  uploadHandle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时文件夹已经有上传过来的图片了</p>  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210153559449.png" alt="image-20210210153559449" style="zoom:50%;" /><ul><li><p>对上传图片信息保存</p><ul><li><p>新建表avatar</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">`avatar`</span>(</span><br><span class="line">id <span class="variable constant_">INT</span> <span class="variable constant_">PRIMARY</span> <span class="variable constant_">KEY</span> <span class="variable constant_">AUTO_INCREMENT</span>,</span><br><span class="line">filename <span class="title function_">VARCHAR</span>(<span class="number">255</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">UNIQUE</span>,</span><br><span class="line">mimetype <span class="title function_">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">size <span class="variable constant_">INT</span>,</span><br><span class="line">user_id <span class="variable constant_">INT</span>,</span><br><span class="line">createAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="variable constant_">FOREIGN</span> <span class="variable constant_">KEY</span> (user_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">users</span>(id) <span class="variable constant_">ON</span> <span class="variable constant_">DELETE</span> <span class="variable constant_">CASCADE</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CASCADE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>图像信息保存：saveAvatarInfo中间件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/file.service&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fileController</span>&#123;</span><br><span class="line">  <span class="comment">// 上传图片时不仅要传图片，还要对图片信息相关进行保存</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">saveAvatarInfo</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 拿到图片信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123;filename, mimetype, size&#125; = ctx.<span class="property">req</span>.<span class="property">file</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.<span class="property">user</span></span><br><span class="line">    <span class="comment">// 将图片保存到数据库中，所以需要单独创建表</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">createAvatar</span>(filename, mimetype, size, id)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">fileController</span>()</span><br></pre></td></tr></table></figure><p>ctx.req.file里面保存的信息：<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210154139788.png" alt="image-20210210154139788" style="zoom:50%;" /></p></li><li><p>service的操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connection = <span class="built_in">require</span>(<span class="string">&quot;../app/database&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fileService</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">createAvatar</span>(<span class="params">filename, mimetype, size, user_id</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO avatar (filename, mimetype, size, user_id) VALUES (?, ?, ?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [filename, mimetype, size, user_id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">fileService</span>()</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210210162609117.png" alt="image-20210210162609117"></p></li></ul></li></ul><h4 id="2-获取头像">2. 获取头像<a class="anchor" href="#2-获取头像">·</a></h4><ul><li>定义获取图像的接口</li></ul><p>输入浏览器的头像，希望直接展示出来。此时必须单独写个接口，给用户返回头像</p><p>获取用户信息的时候，可以直接看到用户的头像。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># user.router.js</span><br><span class="line">userRouter.get(&#x27;/:userId/avatar&#x27;, avatarInfo)</span><br></pre></td></tr></table></figure><ul><li>请求用户信息时，获取头像</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># user.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">avatarInfo</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 用户获取的文件id</span></span><br><span class="line">    <span class="keyword">const</span> &#123;userId&#125; = ctx.<span class="property">params</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> fileService.<span class="title function_">getAvatarByUserId</span>(userId) # file.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getAvatarByUserId</span>(<span class="params">userId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`SELECT * FROM avatar WHERE id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [userId])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时返回的数据：<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210210171048347.png" alt="image-20210210171048347" style="zoom:50%;" /></p><p>要想将图片信息展示出来：ctx.body = result需要修改。</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">avatarInfo</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">  <span class="comment">// 用户获取的文件id</span></span><br><span class="line">  <span class="keyword">const</span> &#123;userId&#125; = ctx.<span class="property">params</span></span><br><span class="line">  <span class="keyword">const</span> avatarInfo = <span class="keyword">await</span> fileService.<span class="title function_">getAvatarByUserId</span>(userId)</span><br><span class="line">  ctx.<span class="property">body</span> = fs.<span class="title function_">createReadStream</span>(<span class="string">`<span class="subst">$&#123;AVATAR_PATH&#125;</span>/<span class="subst">$&#123;avatarInfo.filename&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"># <span class="variable constant_">AVATAR_PATH</span>是导入的路径常量：./upload/avatar  <span class="comment">// 在constants/file-path.js里</span></span><br></pre></td></tr></table></figure><p>此时图片再进行请求，浏览器自动下载文件，并不会展示图片，因为他不知道是图片还是文件。这种做法是只适合普通的图片。现在我们要设置reponse， 拿到响应对象</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="property">response</span>.<span class="title function_">set</span>(<span class="string">&#x27;content-type&#x27;</span>, avatarInfo.<span class="property">mimetype</span>)</span><br><span class="line">ctx.<span class="property">body</span> = fs.<span class="title function_">createReadStream</span>(<span class="string">`<span class="subst">$&#123;AVATAR_PATH&#125;</span>/<span class="subst">$&#123;avatarInfo.filename&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><ul><li><p>对user表添加一段avatar，用来保存用户头像的url</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">ALTER</span> <span class="variable constant_">TABLE</span> <span class="string">`users`</span> <span class="variable constant_">ADD</span> <span class="string">`avatar_url`</span> <span class="title function_">VARCHAR</span>(<span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>希望用户在上传图像成功后，就保存这个url。在fileController中，上传后将用户数据保存到users表中。修改之前上传头像的接口：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">saveAvatarInfo</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 拿到图片信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123;filename, mimetype, size&#125; = ctx.<span class="property">req</span>.<span class="property">file</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.<span class="property">user</span></span><br><span class="line">    <span class="comment">// 将图片保存到数据库中，所以需要单独创建表</span></span><br><span class="line">   <span class="keyword">const</span> res =  <span class="keyword">await</span> service.<span class="title function_">createAvatar</span>(filename, mimetype, size, id)</span><br><span class="line">  <span class="comment">// 保存图片地址在users表里</span></span><br><span class="line">    <span class="comment">// 拿到图片路径</span></span><br><span class="line">    <span class="keyword">const</span> avatarUrl = <span class="string">`<span class="subst">$&#123;AVATAR_PATH&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span></span><br><span class="line">    <span class="comment">//更改users表</span></span><br><span class="line">    <span class="keyword">await</span> userService.<span class="title function_">updateAvatarUrlById</span>(avatarUrl, id)</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;用户头像上传头像&#x27;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">createAvatar</span>(<span class="params">filename, mimetype, size, user_id</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO avatar </span></span><br><span class="line"><span class="string">    (filename, mimetype, size, user_id) VALUES (?, ?, ?, ?)`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, </span><br><span class="line">    [filename, mimetype, size, user_id])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># user.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">updateAvatarUrlById</span>(<span class="params">avatarUrl, id</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`UPDATE users SET avatar_url = ? WHERE id = ?`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [avatarUrl, id])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时上传头像，users里就有url字段存储着地址<img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210210195615751.png" alt="image-20210210195615751"></p><p>但这个地址是相对路径，更改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 更改env</span><br><span class="line"><span class="variable constant_">APP_PORT</span> = <span class="number">8000</span></span><br><span class="line"><span class="variable constant_">LOCAL_HOST</span> = <span class="string">&quot;localhost</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># config.<span class="property">js</span></span><br><span class="line">导出增加这一项</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> avatarUrl = <span class="string">`<span class="subst">$&#123;AVATAR_PATH&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span></span><br><span class="line">更改为：</span><br><span class="line"><span class="keyword">const</span> avatarUrl = <span class="string">`<span class="subst">$&#123;LOCAL_HOST&#125;</span>:<span class="subst">$&#123;APP_PORT&#125;</span>/<span class="subst">$&#123;id&#125;</span>/avatar`</span></span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210210201631018.png" alt="image-20210210201631018"></p></li></ul><h4 id="3-上传动态的配图">3. 上传动态的配图<a class="anchor" href="#3-上传动态的配图">·</a></h4><ul><li><p>定义上传动态配图的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.<span class="property">router</span>.<span class="property">js</span></span><br><span class="line">fileRouter.<span class="title function_">post</span>(<span class="string">&#x27;/picture&#x27;</span>, verifyAuth, pictureHandle)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># fie.<span class="property">middleware</span>.<span class="property">js</span></span><br><span class="line"><span class="comment">// 上传动态图</span></span><br><span class="line"><span class="keyword">const</span> uploadPicture = <span class="title class_">Multer</span>(&#123;</span><br><span class="line">  <span class="attr">dest</span>: <span class="variable constant_">PICTURE_PATH</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> pictureHandle = uploadPicture.<span class="title function_">array</span>(<span class="string">&#x27;picture&#x27;</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure></li><li><p>创建表file存储上传的动态配图</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">`file`</span>(</span><br><span class="line">id <span class="variable constant_">INT</span> <span class="variable constant_">PRIMARY</span> <span class="variable constant_">KEY</span> <span class="variable constant_">AUTO_INCREMENT</span>,</span><br><span class="line">filename <span class="title function_">VARCHAR</span>(<span class="number">100</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">UNIQUE</span>,</span><br><span class="line">mimetype <span class="title function_">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">size <span class="variable constant_">INT</span>,</span><br><span class="line">moment_id <span class="variable constant_">INT</span>,</span><br><span class="line">user_id <span class="variable constant_">INT</span>,</span><br><span class="line">createAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updateAt <span class="variable constant_">TIMESTAMP</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CURRENT_TIMESTAMP</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="variable constant_">FOREIGN</span> <span class="variable constant_">KEY</span> (user_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">users</span>(id) <span class="variable constant_">ON</span> <span class="variable constant_">DELETE</span> <span class="variable constant_">CASCADE</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CASCADE</span>,</span><br><span class="line"><span class="variable constant_">FOREIGN</span> <span class="variable constant_">KEY</span> (moment_id) <span class="variable constant_">REFERENCES</span> <span class="title function_">moment</span>(id) <span class="variable constant_">ON</span> <span class="variable constant_">DELETE</span> <span class="variable constant_">CASCADE</span> <span class="variable constant_">ON</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">CASCADE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>我希望上传时，把query参数一起传过来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># # file.<span class="property">router</span>.<span class="property">js</span></span><br><span class="line">fileRouter.<span class="title function_">post</span>(<span class="string">&#x27;/picture&#x27;</span>, verifyAuth, pictureHandle, savePictureInfo)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.<span class="property">controller</span>.<span class="property">js</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">savePictureInfo</span>(<span class="params">ctx, next</span>)&#123;</span><br><span class="line">    <span class="comment">// 获取头像信息</span></span><br><span class="line">    <span class="keyword">const</span> files = ctx.<span class="property">req</span>.<span class="property">files</span></span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = ctx.<span class="property">user</span></span><br><span class="line">    <span class="keyword">const</span> &#123;momentId&#125; = ctx.<span class="property">query</span></span><br><span class="line">    <span class="comment">// 将所有的文件信息保存到数据库中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> file <span class="keyword">of</span> files)&#123;</span><br><span class="line">      <span class="comment">// 拿到图片信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123;originalname, mimetype, size&#125; = file</span><br><span class="line">    <span class="comment">// 拿user_id</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.<span class="title function_">createPicture</span>(</span><br><span class="line">       originalname, mimetype, size, momentId, id)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># file.<span class="property">service</span>.<span class="property">js</span></span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">createPicture</span>(<span class="params">originalname, mimetype, size, momentId, userId</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> statement = <span class="string">`INSERT INTO file (filename, mimetype, size, moment_id, user_id) </span></span><br><span class="line"><span class="string">                       VALUES (?, ?, ?, ?, ?);`</span></span><br><span class="line">    <span class="keyword">const</span> [result] = <span class="keyword">await</span> connection.<span class="title function_">execute</span>(statement, [originalname, mimetype, size, momentId, userId,])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210210213006041.png" alt="image-20210210213006041"></p><p>从服务器拿到的图片是原图，服务器会对上传的图片进行一些处理，举例一张图像变成3张（1280、640、320）。当我们在列表中展示图片的时候，可以提供不同类型的图片，这是就需要对用户上传过来的图片进行专门的处理。</p>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node、MySQL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目5：Node用户管理接口：项目梳理篇</title>
      <link href="/posts/3253305718.html"/>
      <url>/posts/3253305718.html</url>
      
        <content type="html"><![CDATA[<ul><li>项目时间： 2021年2月</li><li>项目背景： 春节在家，只是想简单了解下接口、数据库的概念</li><li>梳理篇：大概梳理了哪些功能，实现思路。。吧，记忆丢失，嘤嘤嘤</li></ul><h2 id="用户管理系统逻辑">用户管理系统逻辑<a class="anchor" href="#用户管理系统逻辑">·</a></h2><h4 id="1-用户注册">1. 用户注册<a class="anchor" href="#1-用户注册">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用户注册</span><br><span class="line">userRouter.post(&#x27;/&#x27;, verifyUser, handlePassword, create)</span><br></pre></td></tr></table></figure><ol><li><p>验证是否已有该账户： verifyUser查询数据库，结果是否为空</p></li><li><p>对用户信息加密：handlePassWord，目的：避免存在数据库中的用户信息是明文的</p><p>借助框架crypto的createHash（），MD5的加密方式</p></li><li><p>创建新用户：create</p><p>对users表插入数据</p></li></ol><h4 id="2-用户登录">2. 用户登录<a class="anchor" href="#2-用户登录">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用户登录</span><br><span class="line">authRouter.post(&#x27;/login&#x27;, verifyLogin, login)</span><br><span class="line">// 验证是否授权的一个接口</span><br><span class="line">authRouter.get(&#x27;/test&#x27;, verifyAuth, success)</span><br></pre></td></tr></table></figure><ol><li>验证账户密码正确：verifyLogin<ul><li>拿到请求中的账户密码，是否为空、是否存在该用户</li><li>对登录的密码进行MD5的加密，去数据库查询是否匹配</li></ul></li><li>登录：login<ul><li>从ctx.user中拿到id和name，通过jwt.sign({})，设置过期时间+私钥的加密算法，生成token。</li></ul></li></ol><h4 id="3-用户动态">3. 用户动态<a class="anchor" href="#3-用户动态">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//发表动态之前要先验证登录，然后才是create创建动态</span><br><span class="line">momentRouter.post(&#x27;/&#x27;, verifyAuth, create)</span><br><span class="line">// 查看动态,不需要登录,需要知道动态对应的id</span><br><span class="line">momentRouter.get(&#x27;/:momentId&#x27;, momentDetail)</span><br><span class="line"></span><br><span class="line">// 修改动态 </span><br><span class="line">momentRouter.patch(&#x27;/:momentId&#x27;,verifyAuth, verifyPermission, update)</span><br><span class="line">// 删除动态</span><br><span class="line">momentRouter.delete(&#x27;/:momentId&#x27;,verifyAuth, verifyPermission, remove)</span><br><span class="line">// 给动态添加标签</span><br><span class="line">momentRouter.post(&#x27;/:momentId/labels&#x27;, verifyAuth, verifyPermission,</span><br><span class="line">                    verifyLabelExist,addLabels)</span><br></pre></td></tr></table></figure><ol><li><p>验证登录：verifyAuth，作用：验证用户授权与否、颁发签名是否有效</p><p>在验证时：</p><ul><li>通过ctx.headers.authorization拿到authorization，处理（去掉Bearer ），得到token</li><li>通过jwt.verify(token, 公钥，{解密算法})拿到解密后的信息。</li><li>通过try.catch块包裹，如果有错误会抛出。否则进入下一个中间件</li></ul></li><li><p>创建动态：create</p><ul><li>在上一中间件中ctx.user，进行解构拿到id（哪个用户），拿到content内容（请求体），插入数据库moment表中</li></ul></li><li><p>查询动态:</p><ul><li>单条：由params拿到要查询的动态id，再去数据库moment表中查询（左连接）</li><li>多条：offset和size在query中拿到，在评论的功能汇总添加的动态的评论数量。这是通过修改sql语句，增加字段</li></ul></li><li><p>修改动态</p><ul><li><p>验证登录verifyAuth</p></li><li><p>验证是否具备修改权限verifyPermission拿到要删除的动态id（params中得到），登录用户的id，查询结果是否为空，判断是否具有权限</p></li><li><p>更改</p><p>对moment表中id为xxx的content设置新的值</p></li></ul></li><li><p>删除动态</p><ul><li>验证登录</li><li>验证权限</li><li>删除remove：从params中拿到要删除的动态id，Delete删除</li></ul></li></ol><h4 id="4-用户评论：comment">4. 用户评论：comment<a class="anchor" href="#4-用户评论：comment">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commentRouter.post(&#x27;/&#x27;, verifyAuth, create)</span><br><span class="line">commentRouter.post(&#x27;/:commentId/reply&#x27;, verifyAuth, reply)</span><br><span class="line">// 修改评论,你只能修改自己发表的评论，而不能修改别人发表的评论</span><br><span class="line">commentRouter.patch(&#x27;/:commentId&#x27;, verifyAuth,verifyPermission, update)</span><br><span class="line">// 删除评论</span><br><span class="line">commentRouter.delete(&#x27;/:commentId&#x27;, verifyAuth, verifyPermission, remove)</span><br><span class="line">// 获取评论列表：不需要验证登录、权限</span><br><span class="line">commentRouter.get(&#x27;/&#x27;, list)</span><br></pre></td></tr></table></figure><ol><li><p>发布评论</p><ul><li>验证登录</li><li>创建评论从请求体里拿到动态id，内容content、用户id。也就是哪个用户对哪条动态做了怎样的评论</li></ul></li><li><p>回复评论</p><ul><li>验证登录</li><li>回复：从请求体里拿到动态id，内容content、用户id，再拿到要评论的id（params），去操作moment表</li></ul></li><li><p>修改评论</p><ul><li><p>验证登录</p></li><li><p>验证权限：varifyPermission，只能修改自己的评论</p><p>对varifyPermission做了修改，通过遍历ctx.params属性拿到表名，从而动态的修改statement中的表名，使其作为一个参数传入进去，这样每次查询的是否，根据传入参数tablename的不同，查询的不同权限，使其既具备验证动态权限处理又可验证评论权限</p></li><li><p>update</p></li></ul></li><li><p>删除评论</p><ul><li>验证登录</li><li>验证权限</li><li>remove</li></ul></li><li><p>查询动态，显示评论</p><ul><li>单条：显示评论列表</li><li>多条：修改sql语句，增加commentCount字段</li></ul></li></ol><h4 id="5-标签功能">5. 标签功能<a class="anchor" href="#5-标签功能">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建标签时会先验证登录，</span><br><span class="line">labelRouter.post(&#x27;/&#x27;, verifyAuth,create)</span><br><span class="line"></span><br><span class="line">// 查询标签列表</span><br><span class="line">labelRouter.get(&#x27;/&#x27;, list)</span><br></pre></td></tr></table></figure><h5 id="添加标签的过程">添加标签的过程<a class="anchor" href="#添加标签的过程">·</a></h5><ol><li><p>验证登录  √</p></li><li><p>验证用户权限  √</p></li><li><p>验证要添加的标签是否存在 （verifyLabelsExists）</p><ul><li><p>从params中拿到动态id，再拿到所有的标签，进行遍历，getLabelByName判断label表中，是否有标签id</p><p>如果没有标签id，通过create在label表中添加，此时数据库的操作返回结果result.insertId就有了该id</p><p>如果已有标签id，通过getLabelByName查询的结果 labelResult.id中，可以拿到id</p></li><li><p>补充如何添加标签：创建标签表、验证登录、从请求体拿到标签名，通过create插入label中</p></li></ul></li><li><p>再给某条动态添加标签（在关系表中）</p><p>此时已有commentId、标签id，以及标签。在添加标签之前，hasLabel判断该动态是否已存在该标签，对没有某些标签的那个动态，再通过addLabels去添加标签。在关系表中添加</p></li></ol><h5 id="展示标签">展示标签<a class="anchor" href="#展示标签">·</a></h5><ul><li>从query中取出offset和size，去label表中查询结果</li></ul><h4 id="6-图片上传">6. 图片上传<a class="anchor" href="#6-图片上传">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用户上传头像</span><br><span class="line">userRouter.get(&#x27;/:userId/avatar&#x27;, avatarInfo)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fileRouter.post(&#x27;/avatar&#x27;, verifyAuth, uploadHandle,saveAvatarInfo)</span><br><span class="line">fileRouter.post(&#x27;/picture&#x27;, verifyAuth, pictureHandle,pictureResize, savePictureInfo)</span><br></pre></td></tr></table></figure><ol><li>头像上传<ul><li>验证登录：VerifyAuth</li><li>uploadHandle：借助koa-multer，实现上传功能，单张图片用single的方法</li><li>图像信息保存：saveAvatarInfo，从ctx.req.file中拿到filename,mimetype,size，再去数据库中插入数据</li></ul></li><li>头像获取<ul><li>拿到用户id（从params中），再去数据库中查询，拿到查询结果</li></ul></li><li>展示头像<ul><li>ctx.body = result，不能直接去那个接口请求，会下载下来。而是先设置ctx.response.set()设置content-type为头像的mimetype。</li><li>再修改ctx.body =为fs读取文件流的结果，读取的地址是http：//localhost:8000/…等接口下的某路径。但是这个地方不能写死了，所以可以将端口主机等修改为导入的量。</li><li>为表users添加字段avatar_url，保存请求地址，此时修改获取头像时，只需要传入avatar_url和用户的id，就可以在users中查找到对应的头像</li></ul></li><li>上传动态的配图（多张）<ul><li>登录验证</li><li>savePictureInfo<ul><li>上传文件，使用multer，并用array的方法</li><li>拿到文件信息，用户id，momentId（query中），遍历每个文件，都进行插入数据库的表file中，</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 2.4-项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node、MySQL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git-协同开发</title>
      <link href="/posts/372934289.html"/>
      <url>/posts/372934289.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、本地仓库">一、本地仓库<a class="anchor" href="#一、本地仓库">·</a></h2><h3 id="1、初始化、操作命令">1、初始化、操作命令<a class="anchor" href="#1、初始化、操作命令">·</a></h3><h4 id="1、Linux命令">1、Linux命令<a class="anchor" href="#1、Linux命令">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ll：显示目录中全部文件信息</span><br><span class="line">ls -la:带隐藏资源</span><br><span class="line">pwd：用于显示工作目录</span><br><span class="line">cd ~：进入家目录</span><br><span class="line">如果显示: 说明内容一页放不完，按空格进入下一页</span><br><span class="line">vim编辑器</span><br><span class="line"></span><br><span class="line">:wq 保存退出</span><br><span class="line">esc 退出编辑模式</span><br><span class="line">显示行号:set nu</span><br></pre></td></tr></table></figure><p>多屏显示控制方式：</p><ul><li>空格向下翻页</li><li>b 向上翻页</li><li>q 退出</li></ul><h4 id="2、创建版本库：">2、创建版本库：<a class="anchor" href="#2、创建版本库：">·</a></h4><ul><li><code>git init</code>把这个目录变成Git管理的仓库：<ul><li>当前目录下多了一个<code>.git</code>的目录，是Git来跟踪管理版本库的，不要随意修改这个文件夹</li><li>如果没有<code>.git</code>目录，用<code>ls -ah</code>命令（list file）可看见，因为默认隐藏了</li></ul></li><li>版本控制系统只能跟踪<strong>文本文件</strong>的改动，而不能追踪Microsoft的Word、图片、视频这些<strong>二进制文件</strong>，无法知道这些文件具体改了啥</li></ul><h4 id="3、签名">3、签名<a class="anchor" href="#3、签名">·</a></h4><ul><li><h4 id="项目级别-仓库级别：仅在当前本地库（如MyBooBPMS）范围内有效">项目级别/仓库级别：仅在当前本地库（如MyBooBPMS）范围内有效<a class="anchor" href="#项目级别-仓库级别：仅在当前本地库（如MyBooBPMS）范围内有效">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name wuyunzhi_pro</span><br><span class="line">git config user.email hangOn_pro@zz</span><br><span class="line">信息保存位置：./.git/config文件</span><br><span class="line">查看签名命令 cat .git/config</span><br></pre></td></tr></table></figure></li><li><h4 id="系统用户级别：登录当前操作系统的用户范围">系统用户级别：登录当前操作系统的用户范围<a class="anchor" href="#系统用户级别：登录当前操作系统的用户范围">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name tom_glb</span><br><span class="line">git config --global goodMorning@atguigu.com</span><br><span class="line">信息保存位置：~/.gitconfig 文件</span><br><span class="line">查看签名命令 cat ~/.gitconfig</span><br></pre></td></tr></table></figure></li><li><h4 id="级别优先级">级别优先级<a class="anchor" href="#级别优先级">·</a></h4><p>就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别的签名如果只有系统用户级别的签名，就以系统用户级别的签名为准二者都没有不允许</p></li></ul><h3 id="2、基本操作">2、基本操作<a class="anchor" href="#2、基本操作">·</a></h3><h4 id="0、工作区、暂存区概念">0、工作区、暂存区概念<a class="anchor" href="#0、工作区、暂存区概念">·</a></h4><ul><li>**工作区：**在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区</li><li>**版本库：**工作区有一个隐藏目录<code>.git</code>，它里面存了很多东西，其中：<ul><li>**暂存区：**最重要的，也叫stage（或者叫index）</li><li><strong><code>master</code>分支</strong>：Git自动创建的</li><li>**HEAD指针：**指向<code>master</code>的一个指针</li></ul></li></ul><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo"></p><h4 id="1、命令理解：">1、命令理解：<a class="anchor" href="#1、命令理解：">·</a></h4><ul><li><p><code>git add</code>：把文件修改添加到暂存区；</p><p>没有git add的文件时，<code>git status</code>查看文件的状态是<code>Untracked</code>；</p><p>add 之后的状态是：changes to be commited，并且实际状态变成如下：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020074026336/0" alt="git-stage"></p></li><li><p><code>git commit</code>：一次性把暂存区的所有修改提交到当前分支</p></li><li><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><img src="https://www.liaoxuefeng.com/files/attachments/919020100829536/0" alt="git-stage-after-commit" style="zoom:80%;" /></li></ul><h4 id="2、查看、改变状态">2、查看、改变状态<a class="anchor" href="#2、查看、改变状态">·</a></h4><ul><li><code>git status</code>：可以时刻掌握仓库当前的状态，可以知道哪些文件被修改了</li><li><code>git diff</code>：可以知道相比于上次的修改内容</li><li><code>git add readme.txt</code>：把文件添加到仓库</li><li><code>commit</code>：把文件提交到仓库：git commit --m “文件说明”<ul><li>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，再一次性提交</li></ul></li></ul><h4 id="3、日志">3、日志<a class="anchor" href="#3、日志">·</a></h4><ul><li><p><code>git log</code>：显示从最近到最远的提交日志</p><ul><li>一大串数字是版本号commit id</li><li>每提交一个新版本Git就会把它们自动串成一条时间线，如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线</li></ul></li><li><p><code>git log--pretty=oneline</code>：每个记录一行显示</p></li><li><p><code>git reflog</code>：有距离本次的HEAD回退次数：</p><ul><li>在Git中，用<code>HEAD</code>表示当前版本，是最新提交</li><li>上一个版本是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本<code>HEAD~100</code></li></ul><p><img src="C:%5CUsers%5C%E5%B0%8F%E8%99%8E%E7%89%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210101204117305.png" alt="image-20210101204117305"></p><p>回退到上一个版本：可以使用<code>git reset</code>命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>此时，如果想回未来的某个版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 1094a       //版本号没必要写全，前几位就可以了，Git会自动去找</span><br></pre></td></tr></table></figure><p>【注意】：这里的id是提交时候的那个id</p></li></ul><h3 id="3、-文件删除、找回">3、 文件删除、找回<a class="anchor" href="#3、-文件删除、找回">·</a></h3><h5 id="1、文件删除">1、文件删除<a class="anchor" href="#1、文件删除">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm test.txt     // 或者文件管理器删除</span><br><span class="line">// 删除工作区文件后，工作区和版本库就不一致了，`git status`命令会告诉你哪些文件被删除了</span><br><span class="line"></span><br><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$git reset --hard commitId</span><br></pre></td></tr></table></figure><h5 id="2、删除文件找回">2、删除文件找回<a class="anchor" href="#2、删除文件找回">·</a></h5><p>【前提】：删除前，文件存在的状态被提交到了版本库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- test.txt   // 丢弃掉本次修改，无论工作区是修改还是删除，都可以“一键还原”</span><br></pre></td></tr></table></figure><h3 id="4、版本回退reset">4、版本回退reset<a class="anchor" href="#4、版本回退reset">·</a></h3><h4 id="1、版本回退原理：">1、版本回退原理：<a class="anchor" href="#1、版本回退原理：">·</a></h4><ul><li>Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本<code>append GPL</code>的时候，Git仅仅是把HEAD从指向你回退的那个地方，并把工作区的文件更新：</li></ul><h4 id="2、直接操作HEAD指针">2、直接操作HEAD指针<a class="anchor" href="#2、直接操作HEAD指针">·</a></h4><ul><li><p>基于commitID操作：推荐</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 1094a </span><br></pre></td></tr></table></figure></li><li><p>基于符号^操作：只能后退</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li><li><p>基于符号~来操作：只能后退</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~N</span><br></pre></td></tr></table></figure></li></ul><img src="https:////upload-images.jianshu.io/upload_images/4428238-fcad08ebe26933a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp" alt="img" style="zoom:67%;" /><h4 id="3、git-checkout">3、git checkout<a class="anchor" href="#3、git-checkout">·</a></h4><p>撤销工作区的修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- readme.txt //把`readme.txt`文件在工作区的修改全部撤销</span><br></pre></td></tr></table></figure><h4 id="4、reset的参数-hard">4、reset的参数 --hard<a class="anchor" href="#4、reset的参数-hard">·</a></h4><h5 id="1、作用：">1、作用：<a class="anchor" href="#1、作用：">·</a></h5><ol><li>在本地库移动HEAD指针、<strong>branch</strong></li><li>重置暂存区</li><li>重置工作区</li></ol><h5 id="2、效果：">2、效果：<a class="anchor" href="#2、效果：">·</a></h5><ol><li><strong>HEAD 和当前 branch</strong> 切到了上一条<strong>commit</strong>的位置</li><li>暂存区、工作区的内容变成了和<strong>HEAD</strong>的新位置相同的内容，之前你没有commit的内容会全部丢失</li></ol><h5 id="3、原理">3、原理<a class="anchor" href="#3、原理">·</a></h5><p>撤销 <strong>commit</strong> 的效果在于：</p><ul><li>它把 <strong>HEAD</strong> 和它所指向的 branch 一起移动到了当前 <strong>commit</strong> 的父 <strong>commit</strong> 上，从而起到了「撤销」的效果：</li></ul><img src="https:////upload-images.jianshu.io/upload_images/4428238-6dbab74ae9ad2e1f?imageMogr2/auto-orient/strip|imageView2/2/w/466/format/webp" alt="img" style="zoom:50%;" /><h5 id="4、使用场景">4、使用场景<a class="anchor" href="#4、使用场景">·</a></h5><ol><li><p><strong>要放弃目前本地的所有改变</strong>：强制恢复git管理的文件夹的內容及状态</p></li><li><p>**想抛弃某节点后的所有commit，：**可能觉得目标节点到原节点之间的commit提交都是错了，之前所有的commit有问题</p></li><li><p>移动到任何你想去的分支：</p><img src="https:////upload-images.jianshu.io/upload_images/4428238-71f7141a3878da7e?imageMogr2/auto-orient/strip|imageView2/2/w/434/format/webp" alt="img" style="zoom: 33%;" /></li></ol><h4 id="5、reset的3个参数–mixed">5、reset的3个参数–mixed<a class="anchor" href="#5、reset的3个参数–mixed">·</a></h4><p>git reset 不加参数</p><h5 id="1、作用">1、作用<a class="anchor" href="#1、作用">·</a></h5><ol><li>在本地库移动HEAD指针、<strong>branch</strong></li><li>保留工作目录，并重置暂存区</li></ol><h5 id="2、效果">2、效果<a class="anchor" href="#2、效果">·</a></h5><ol><li>工作区的修改、暂存区的内容以及由 <strong>reset</strong> 所导致的新的文件差异，都会被放进工作区</li><li>一样可以达到合并<strong>commit</strong>节点的效果</li></ol><h5 id="3、使用场景">3、使用场景<a class="anchor" href="#3、使用场景">·</a></h5><ol><li><p>发现add错文件到暂存区</p></li><li><p>合并提交节点：</p><ul><li><p><strong>commit</strong>提交某些错误代码，不想再修改错误再<strong>commit</strong>，因为会留下一个错误<strong>commit</strong>点</p></li><li><p>可以回退到正确的<strong>commit</strong>点上，然后所有原节点和<strong>reset</strong>节点之间差异会在工作区，错误的文件修改后，再<strong>commit</strong>上去就OK了</p></li></ul></li></ol><h4 id="6、reset的3个参数-soft">6、reset的3个参数 --soft<a class="anchor" href="#6、reset的3个参数-soft">·</a></h4><h5 id="1、作用-2">1、作用<a class="anchor" href="#1、作用-2">·</a></h5><ul><li>仅在本地库移动HEAD指针、<strong>branch</strong></li></ul><h5 id="2、效果-2">2、效果<a class="anchor" href="#2、效果-2">·</a></h5><ul><li>重置 <strong>HEAD</strong> 和 <strong>branch</strong></li><li><strong>保留工作区和暂存区</strong>中的内容，此时暂存区里是最新的变动内容</li></ul><h5 id="3、使用场景-2">3、使用场景<a class="anchor" href="#3、使用场景-2">·</a></h5><p>想合并「当前节点」与「reset目标节点」之间不具太大意义的 <strong>commit</strong> 记录时</p><ul><li>比如：开发一个功能，改或增一个文件就<strong>commit</strong>，<strong>这样导致一个完整的功能会多个commit点</strong></li><li>而你又想把这些<strong>commit</strong>整合成一个<strong>commit</strong>时，可以使用<strong>reset  --soft</strong>，再 <strong>git commit</strong> 將 index暂存区中的內容提交至 <strong>repository</strong> 中</li></ul><h2 id="二、远程仓库">二、远程仓库<a class="anchor" href="#二、远程仓库">·</a></h2><h3 id="1、仓库配置">1、仓库配置<a class="anchor" href="#1、仓库配置">·</a></h3><h4 id="1、创建SSH-Key">1、创建SSH Key<a class="anchor" href="#1、创建SSH-Key">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line">// 一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码</span><br></pre></td></tr></table></figure><ul><li>在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥</li><li>登录远程仓库，比如github，找到添加“SSH Keys”页面，粘贴<code>id_rsa.pub</code>文件的内容</li></ul><h4 id="2、为什么远程需要SSH-Key？">2、为什么远程需要SSH Key？<a class="anchor" href="#2、为什么远程需要SSH-Key？">·</a></h4><ol><li>GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的</li><li>Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送</li><li>GitHub允许添加多个Key，多设备提交</li></ol><h4 id="3、建立关联">3、建立关联<a class="anchor" href="#3、建立关联">·</a></h4><ul><li><p>把一个已有的本地仓库与之<strong>关联</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git；</span><br><span class="line"></span><br><span class="line">$ git remote add origin git@github.com:claire-woodsen/cangku1.git</span><br></pre></td></tr></table></figure><p>origin：远程库的名字，是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>claire-woodsen：邮箱名</p><p>cangku1.git：<strong>远程版本库</strong>的名字</p></li></ul><h3 id="2、删除远程库">2、删除远程库<a class="anchor" href="#2、删除远程库">·</a></h3><ol><li><p>先用<code>git remote -v</code>查看远程库信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure></li><li><p>然后根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure></li></ol><p>【注意】：</p><ol><li>删除，指的是解除了本地和远程的绑定关系，远程库本身并没有删除</li><li>真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮</li></ol><h3 id="3、克隆远程库">3、克隆远程库<a class="anchor" href="#3、克隆远程库">·</a></h3><ul><li><p>找到合适路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:claire-woodsen/cangku2.git</span><br></pre></td></tr></table></figure></li></ul><ul><li>Git支持多种协议，默认的<code>git://</code>使用ssh，<code>ssh</code>协议速度最快</li><li>也可以用<code>https</code>等其他协议，<code>https</code>除了速度慢以外，每次推送都必须输入口令</li></ul><h3 id="4、推送远程仓库">4、推送远程仓库<a class="anchor" href="#4、推送远程仓库">·</a></h3><ul><li><p>把本地仓库的内容<strong>推送</strong>到GitHub仓库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master   //实际是将当前分支推送到远程</span><br></pre></td></tr></table></figure><ul><li><code>-u</code>参数：<ol><li>不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支</li><li>把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来</li></ol></li></ul></li></ul><h4 id="安装警告">安装警告<a class="anchor" href="#安装警告">·</a></h4><ul><li><p>【注意】：第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><ol><li>输入<code>yes</code>回车即可，后面的操作就不会有任何警告了</li><li>Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器</li></ol></li></ul><h2 id="三、分支管理">三、分支管理<a class="anchor" href="#三、分支管理">·</a></h2><h3 id="1、分支关系、命令">1、分支关系、命令<a class="anchor" href="#1、分支关系、命令">·</a></h3><h4 id="1、分支命令">1、分支命令<a class="anchor" href="#1、分支命令">·</a></h4><ul><li><p><code>git switch </code>：切换分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master   // 切换到已有的master分支</span><br><span class="line">$ git switch -c dev  //创建并切换到新的`dev`分支</span><br></pre></td></tr></table></figure></li><li><p><code>git checkout</code>：切换分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- file.txt    撤销工作区的修改</span><br><span class="line">git checkout master   // 切换到已有的master分支</span><br><span class="line">git checkout -b dev  //创建并切换到新的`dev`分支</span><br></pre></td></tr></table></figure></li><li><p><code>git merge </code>：合并某分支到当前分支</p></li><li><p><code>git branch -d </code>：删除分支</p></li><li><p><code>git branch</code>：查看分支</p></li></ul><h4 id="2、分支关系">2、分支关系<a class="anchor" href="#2、分支关系">·</a></h4><ol><li><p><strong>主分支：</strong></p><p>在Git里，每次提交它们会串成一条时间线主分支，即<code>master</code>分支，<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<strong><code>master</code>才是指向提交的</strong></p><img src="https://www.liaoxuefeng.com/files/attachments/919022325462368/0" alt="git-br-initial" style="zoom:67%;" /></li><li><p><strong>新建分支：</strong></p><p>当前分支在<code>dev</code>上：指的是，新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code></p><img src="https://www.liaoxuefeng.com/files/attachments/919022363210080/l" alt="git-br-create" style="zoom: 67%;" /></li><li><p><strong>提交分支</strong>：</p><p>新分支提交后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><img src="https://www.liaoxuefeng.com/files/attachments/919022387118368/l" alt="git-br-dev-fd" style="zoom:50%;" /></li><li><p><strong>合并分支：</strong></p><p>把<code>dev</code>合并到<code>master</code>上。最简单的方法，直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge" style="zoom:50%;" /></li><li><p><strong>删除分支：</strong></p><p>合并完分支后，删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，就剩下了一条<code>master</code>分支：</p><img src="https://www.liaoxuefeng.com/files/attachments/919022479428512/0" alt="git-br-rm" style="zoom:50%;" /></li></ol><h3 id="2、分支合并模式">2、分支合并模式<a class="anchor" href="#2、分支合并模式">·</a></h3><p>分支合并有两种方式，“快速合并”模式、no-diff模式</p><h4 id="1、Fast-forward模式">1、<code>Fast forward</code>模式<a class="anchor" href="#1、Fast-forward模式">·</a></h4><ul><li><p>新建了dev 的分支，并在其上进行一系列提交，完成时，回到 master 分支，此时，master 分支在创建 dev 分支之后并未产生任何新的 commit。此时的合并就会直接移动文件指针，就叫 <code>fast forward</code></p></li><li><p>这种模式下，删除分支后，会丢掉分支信息，看不出来曾经做过合并</p></li></ul><h4 id="2、-no-ff-方式">2、<code>--no-ff</code> 方式<a class="anchor" href="#2、-no-ff-方式">·</a></h4><ul><li><p>指的是：强制禁用 <code>Fast forward</code> 模式（<code>--no-ff</code> 方式）的 <code>git merge</code></p></li><li><p>Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息</p></li><li><p>操作流程：</p><ol><li>修改 <code>readme.md</code> 文件，并提交一个新的 commit：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -am &quot;update readme&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>切换回 master，合并 dev 分支，请注意 <code>--no-ff</code> 参数，表示禁用 <code>Fast forward</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README.md                                          |   4 +-</span><br><span class="line"> ...5\217\344\275\234\346\226\207\346\241\243.docx&quot; | Bin 278553 -&gt; 279350 bytes</span><br><span class="line"> ...234\200\345\212\240\345\210\206\357\274\237.md&quot; |  62 +++++++++++++++++++++</span><br><span class="line"> 3 files changed, 65 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 &quot;\346\225\260\346\215\256\345\210\206\346\236\220\351\235\242\350\257\225-\344\270\273\350\247\202\351\242\230/\345\275\223\351\235\242\350\257\225\345\256\230\350\257\264\357\274\214\342\200\234\344\275\240\346\234\211\344\273\200\344\271\210\350\246\201\351\227\256\346\210\221\357\274\237\342\200\235\346\200\216\346\240\267\345\233\236\347\255\224\346\234\200\345\212\240\345\210\206\357\274\237.md&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>合并后，用 <code>git log</code> 看分支历史：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   1d78e1a merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 237907d update readme</span><br><span class="line">| * 75a4fbc update 主观题</span><br><span class="line">| * 9669636 update 协作文档</span><br><span class="line">|/</span><br><span class="line">* b1aa3ed update 协作文档</span><br><span class="line">* 5c7018e update readme</span><br><span class="line">* 85c15e2 update readme</span><br><span class="line">* a803ecf update readme</span><br><span class="line">* bb3adfb update 协作文档</span><br><span class="line">*   acf2104 Merge pull request #1 from dta0502/add-license-1</span><br><span class="line">|\</span><br><span class="line">| * 4330188 Create LICENSE</span><br><span class="line">|/</span><br><span class="line">* f05e852 Initial commit</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="3、两种合并模式对比">3、两种合并模式对比<a class="anchor" href="#3、两种合并模式对比">·</a></h4><ul><li><p>合并模式对比图</p><img src="https://tding.top/archives/37b26b3a/1.png" alt="图1" style="zoom:50%;" /></li><li><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode" style="zoom:50%;" /></li></ul><h3 id="3、bug分支">3、bug分支<a class="anchor" href="#3、bug分支">·</a></h3><h4 id="1、git-stash">1、git stash<a class="anchor" href="#1、git-stash">·</a></h4><h5 id="1、使用场景：">1、使用场景：<a class="anchor" href="#1、使用场景：">·</a></h5><p>正在开发<strong>dev分支</strong>，需要紧急修复bug，需要新建分支，但dev分支上的开发内容仍在工作区，还未完成开发，且未提交</p><ul><li>**做法1：**将dev提交到版本库，再新建分支修复bug。但是手头提交的东西别人拉下了可能会造成项目无法启动，因为我当前还没开发完，可能项目都跑不起来</li><li>**做法2：**git stash</li></ul><h5 id="2、-git-stash操作流程：">2、<code> git stash</code>操作流程：<a class="anchor" href="#2、-git-stash操作流程：">·</a></h5><ol><li><p><code>git stash</code> ：把当前工作现场“储藏”起来，等以后恢复现场后继续工作；此时，git status查看工作区，就是干净的（除非有没有被Git管理的文件），放心创建分支来修复bug</p><ul><li>首先用<code>git status</code>看看，有没有add的，也就是新文件</li><li>有执行：<code>git stash -a</code> ,其中-a代表所有（追踪的&amp;未追踪的），没有执行：<code> git stash</code></li><li>总之:都可以执行<code>git stash -a </code></li></ul></li><li><p>新建修复bug分支，然后提交</p></li><li><p>回dev分支继续干活，工作区是干净的，刚才的工作现场怎么找回呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">$ git status</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></li><li><p><code>git stash list</code>查看之前保存的工作现场</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list  </span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure></li></ol><h5 id="3、恢复方式：">3、恢复方式：<a class="anchor" href="#3、恢复方式：">·</a></h5><ul><li><p>方式1：<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure><ul><li>可以多次stash，恢复时，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式2：<code>git stash pop</code>，恢复的同时把stash内容也删了，用<code>git stash list</code>就看不到任何stash内容了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、bug修复同步">2、bug修复同步<a class="anchor" href="#2、bug修复同步">·</a></h4><h5 id="1、bug修复的问题">1、bug修复的问题<a class="anchor" href="#1、bug修复的问题">·</a></h5><p>【问题】：dev分支是早期从master分支分出来的，在master分支上修复了bug后，这个bug其实<strong>在当前dev分支上也存在</strong>，怎么办？</p><ol><li><p>做法1：在dev分支上手动再把修bug的过程重复一遍   不现实</p></li><li><p>做法2：</p><ul><li>将bug的修复提交<code>4c805e2 fix bug 101</code>复制在dev分支上，但我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2   //能复制一个特定的提交到当前分支</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><ul><li>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但是两个不同的commit</li><li>同样，可以在dev分支上修复bug，然后在master分支上“重放”，不过记得<code>git stash</code>命令保存现场，才能从dev分支切换到master分支</li></ul></li></ol><h5 id="2、feature分支">2、feature分支<a class="anchor" href="#2、feature分支">·</a></h5><ol><li>开发一个新feature，新建一个分支；</li><li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D </code>强行删除</li><li>如果删除，将丢失掉修改</li></ol><h3 id="4、-协作开发">4、 协作开发<a class="anchor" href="#4、-协作开发">·</a></h3><h4 id="1、远程、本地仓库：">1、远程、本地仓库：<a class="anchor" href="#1、远程、本地仓库：">·</a></h4><ol><li>远程仓库克隆时，Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了</li><li>程仓库的默认名称是<code>origin</code>。用<code>git remote</code>查看远程库的信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote origin</span><br></pre></td></tr></table></figure><ol start="3"><li>用<code>git remote -v</code>显示更详细的信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br><span class="line">// 显示了可以抓取和推送的`origin`的地址。如果没有推送权限，就看不到push的地址</span><br></pre></td></tr></table></figure><h4 id="2、推送分支">2、推送分支<a class="anchor" href="#2、推送分支">·</a></h4><ol><li>把该分支上的所有本地提交推送到远程库，推送时，要指定本地分支</li><li>这样，Git就会把该分支推送到远程库对应的远程分支上</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li><strong>不是所有分支必须提交到远程：</strong><ul><li><p>bug分支只用于在本地修复bug，就没必要推到远程了</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发</p></li></ul></li></ul><h4 id="3、拉取分支">3、拉取分支<a class="anchor" href="#3、拉取分支">·</a></h4><ol><li><p>假如要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></li><li><p>小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而你也对同样的文件作了修改，并推送：就会有分支冲突产生：</p><ol><li><p>先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来</p><p>假如：<code>git pull</code>提示<code>no tracking information</code>，则说明本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接关系没有创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line"></span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure></li><li><p>重新**再pull：**然后，在本地合并，解决冲突</p></li><li><p>再推送</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="5、git-rebase">5、git rebase<a class="anchor" href="#5、git-rebase">·</a></h3><h4 id="1、分支合并merge问题">1、分支合并merge问题<a class="anchor" href="#1、分支合并merge问题">·</a></h4><ul><li><p>假如你有6个程序员一起工作，你就会有6个程序员的分支，使用merge, 你的代码历史树就会有六个branch跟这个主的branch交织在一起</p><ol><li><p>多人在同一个分支上协作时，很容易出现冲突</p></li><li><p>即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功</p></li><li><p>每次合并再push后，分支变成了这样：Git的提交历史不能是一条干净的直线</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure></li></ol></li><li><p>rebase可以给你提供一套清晰的代码历史</p></li></ul><h4 id="2、git-rebase做法">2、<code>git rebase</code>做法<a class="anchor" href="#2、git-rebase做法">·</a></h4><ul><li>如果你不希望看到这么乱的提交线，<code>git rebase</code>，它把分叉的提交历史“整理”成一条直线，看上去更直观</li><li>**缺点：**本地的分叉提交已经被修改过了</li></ul><ol><li><p>新建分支B1、B2、B3，并基于此开发。开发途中，master更新了，B1需要基于新Master开发功能，此时拉取远程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin B1 --rebase</span><br><span class="line">From gitlab.xpaas.lenovo.com:baiyl3/project1</span><br><span class="line"> * branch            B1         -&gt; FETCH_HEAD</span><br><span class="line">Already up-to-date.</span><br><span class="line">Current branch B1 is up to date.</span><br></pre></td></tr></table></figure></li><li><p>将master上面的代码合并到B1分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: FILE1 第一次修改</span><br></pre></td></tr></table></figure></li><li><p>开发完毕之后，推送到远程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin B1 --force</span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-2aaa4467856de84f746592f43e17944f_1440w.jpg" alt="img" style="zoom:50%;" /></li></ol><h4 id="3、解释过程">3、解释过程<a class="anchor" href="#3、解释过程">·</a></h4><ol><li>更新代码使用的是 <code>git pull origin B1 --rebase</code> 而不是 <code>git pull origin B1</code><ul><li><code>git pull</code>默认使用了 <code>--merge</code> 的方式更新代码</li><li>如果不指定用 <code>--rebase</code>，就会发现日志里有这样的一次提交 <code>Merge branch 'dev' of gitlab.xpaas.lenovo.com:liuyy23/lenovo-mbg into dev</code> ，自己分支合并到了自己分支，没有必要，时间轴上也不好看</li></ul></li><li>使用 rebase 之后，直接使用 <code>git push origin B1</code> 发现是不好使的<ul><li>rebase 之后，master分支上比B1分支上多的修改，直接“插入”到了B1分支修改的内容之后，也就是， master 分支的修改在 B1 分支上重演了一遍</li><li>相对远程 B1 分支而言，本地仓库的B1分支的“基底”已经变化了，直接 <code>push</code> 是不行的，确保没有问题的情况下必须使用 <code>--force</code> 参数才能提交，也是变基的解释</li></ul></li></ol><h4 id="4、git-merge过程">4、git merge过程<a class="anchor" href="#4、git-merge过程">·</a></h4><ol><li><p>新建分支B1、B2、B3，并基于此开发。开发途中，master更新了，B1需要基于新Master开发功能，此时拉取远程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin B1</span><br><span class="line">From gitlab.xpaas.lenovo.com:baiyl3/project2</span><br><span class="line"> * branch            B1         -&gt; FETCH_HEAD</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure></li><li><p>将master上面的代码合并到B1分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge master</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README.md | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure></li><li><p>开发完毕之后，推送到远程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin B1</span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-9f5e6526d5621ee39a45b93554bc6fe3_1440w.jpg" alt="img" style="zoom: 33%;" /></li></ol><h4 id="5、对比提交线">5、对比提交线<a class="anchor" href="#5、对比提交线">·</a></h4><h5 id="1、图形">1、图形<a class="anchor" href="#1、图形">·</a></h5><p>假如现在B1开发完成，合入到了master，整个提交线</p><ul><li><p>只提交B1，左边是git rebase，右边是git merge</p><p><img src="https://pic2.zhimg.com/80/v2-715f4b3b38f8d10c8b30403db5ae8211_1440w.jpg" alt="img" style="zoom:33%;" /><img src="https://pic1.zhimg.com/80/v2-11ccc0b77b3b6e2e93664e562ab27e84_1440w.jpg" alt="img" style="zoom:33%;" /></p></li><li><p>提交了B1、B2、B3，左边是git rebase，右边是git merge<img src="https://pic2.zhimg.com/80/v2-bc38eefe1fc068ddc4119ebc7d16eded_1440w.jpg" alt="img" style="zoom:33%;" /><img src="https://pic3.zhimg.com/80/v2-6df13493237417eda788e4031e894186_1440w.jpg" alt="img" style="zoom:33%;" /></p></li></ul><h5 id="2、git-log">2、git log<a class="anchor" href="#2、git-log">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git logs --graph</span><br><span class="line">* 5826260&lt;baiyl3&gt; - (HEAD -&gt; master, origin/master, origin/B3, B3) FILE3 第一次修改 (6 minutes ago)| </span><br><span class="line">| file3</span><br><span class="line"></span><br><span class="line">* cffcc9a&lt;baiyl3&gt; - (origin/B2, B2) FILE2 第一次修改 (8 minutes ago)| </span><br><span class="line">| file2</span><br><span class="line"></span><br><span class="line">* 00032a7&lt;baiyl3&gt; - (origin/B1, B1) FILE1 第一次修改 (87 minutes ago)| </span><br><span class="line">| file1</span><br><span class="line"></span><br><span class="line">* c782e83&lt;baiyl3&gt; - 添加README.md文件 (2 hours ago)| </span><br><span class="line">| README.md</span><br><span class="line"></span><br><span class="line">* b783e0a&lt;baiyl3&gt; - 在项目一中初始化三个代码文件 (3 hours ago)  </span><br><span class="line">  file1</span><br><span class="line">  file2</span><br><span class="line">  file3</span><br><span class="line">git logs --graph</span><br><span class="line">*   bc3f385&lt;baiyl3&gt; - (HEAD -&gt; master, origin/master, origin/B3, B3) Merge branch &#x27;master&#x27; into B3 (4 minutes ago)</span><br><span class="line">|\  </span><br><span class="line">| *   64b4f3d&lt;baiyl3&gt; - (origin/B2, B2) Merge branch &#x27;master&#x27; into B2 (5 minutes ago)</span><br><span class="line">| |\  </span><br><span class="line">| | *   e040c7b&lt;baiyl3&gt; - (origin/B1, B1) Merge branch &#x27;master&#x27; into B1 (35 minutes ago)</span><br><span class="line">| | |\  </span><br><span class="line">| | | * 2cedfcb&lt;baiyl3&gt; - 添加README.md文件 (2 hours ago)| | | | </span><br><span class="line">| | | | README.md</span><br><span class="line"></span><br><span class="line">| | * | d3ea69c&lt;baiyl3&gt; - FILE1 第一次修改 (2 hours ago)</span><br><span class="line">| | |/  | | |   </span><br><span class="line">| | |   file1</span><br><span class="line"></span><br><span class="line">| * | 5975eae&lt;baiyl3&gt; - FILE2 第一次修改 (2 hours ago)</span><br><span class="line">| |/  | |   </span><br><span class="line">| |   file2</span><br><span class="line"></span><br><span class="line">* | 37ec6de&lt;baiyl3&gt; - FILE3 第一次修改 (2 hours ago)</span><br><span class="line">|/  |   </span><br><span class="line">|   file3</span><br><span class="line"></span><br><span class="line">* 891d1ed&lt;baiyl3&gt; - 在项目二中初始化三个代码文件 (3 hours ago)  </span><br><span class="line">  file1</span><br><span class="line">  file2</span><br><span class="line">  file3</span><br></pre></td></tr></table></figure><h2 id="四、命令补充">四、命令补充<a class="anchor" href="#四、命令补充">·</a></h2><h3 id="1、git-commit-amend">1、git commit --amend<a class="anchor" href="#1、git-commit-amend">·</a></h3><h4 id="1、两个作用：">1、两个作用：<a class="anchor" href="#1、两个作用：">·</a></h4><ol><li><p>追加提交</p><p>它可以在不增加一个新的commit记录的情况下将新修改的代码追加到前一次的commit中，但commit-id会改变</p></li><li><p>覆盖上次提交的信息</p><p>也会生成一个新的commit-id</p></li></ol><h4 id="2、使用场景">2、使用场景<a class="anchor" href="#2、使用场景">·</a></h4><ol><li><p>代码提交至远程，突然发现还有几个文件没有提交，但又不想产生多余的commit</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>这时会弹出一个上一次提交的时候你写的提交信息，保存这个信息，：wq</p></li><li><p>把远端代码拉下来，git pull， 如果有冲突</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> git reset --merge</span><br><span class="line"> git add .</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure></li><li><p>推送到远程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin 你的feature名</span><br></pre></td></tr></table></figure></li></ol><h4 id="3、注意">3、注意<a class="anchor" href="#3、注意">·</a></h4><ul><li>GitHub目前不支持git commit --amend去追加修改而保持不增加提交记录</li><li>GitHub目前你的每次提交都会生成一个新的提交记录，即使你使用的是git commit --amend，不过gitlab都支持的</li></ul><h3 id="2、git-pull-git-fetch">2、git pull / git fetch<a class="anchor" href="#2、git-pull-git-fetch">·</a></h3><ul><li>待补充</li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.2-基建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP &amp;&amp; UDP传输</title>
      <link href="/posts/2124882507.html"/>
      <url>/posts/2124882507.html</url>
      
        <content type="html"><![CDATA[<h2 id="传输层">传输层<a class="anchor" href="#传输层">·</a></h2><h3 id="1、传输层概述">1、传输层概述<a class="anchor" href="#1、传输层概述">·</a></h3><ul><li><p>物理层、数据链路层以及网络层之间他们共同解决了将主机通过异构网络互连起来所面临的问题，<strong>实现了主机到主机之间的通信</strong></p></li><li><p>实际上在计算机网络中进行通信的真正实体是位于通信两端的主机中的进程</p></li><li><p>**传输层：**为运行在不同主机上的应用进程提供直接的通信服务，又被称为端到端协议</p><img src="https://img-blog.csdnimg.cn/20210204214054815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="运输层简单传输过程" style="zoom: 25%;" /></li><li><p><strong>逻辑通信的概念：</strong></p><p>指运输层之间的通信使人感觉是沿水平方向传送数据；</p><p>但事实上，这数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送</p><ul><li><p>举例：假设进程Ap1与Ap4之间进行基于网络的通信，通信的简单过程如下：</p><ol><li>根据不同的进程，在运输层选择使用不同的端口</li><li>通过网络层及其下层来传输应用层报文</li><li>将收到的应用层报文到达接收方的运输层后，通过不同的端口，交付给应用层中相应的应用进程</li></ol><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来<strong>区分不同应用进程的标识符</strong></p><img src="https://img-blog.csdnimg.cn/20210204214642914.png" alt="运输层屏蔽下面核心细节" style="zoom:50%;" /></li></ul></li></ul><h3 id="2、端口号、复用和分用">2、端口号、复用和分用<a class="anchor" href="#2、端口号、复用和分用">·</a></h3><h4 id="1、端口号">1、端口号<a class="anchor" href="#1、端口号">·</a></h4><ul><li>为什么要用到端口号：<ol><li>在操作系统中 ，运行在计算机上的进程使用进程标识符PID来标志，但是因特网上的计算机并不是使用统一的操作系统，不同的操作系统使用不同格式的进程标识符。</li><li><strong>为了使运行不同系统的计算机的应用进程之间能够进行网络通信</strong>，就必须使用统一的方法来对TCP/IP体系的应用进程进行标识。也就是使用端口号</li><li>TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程：<img src="https://img-blog.csdnimg.cn/20210204215346994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="端口号的知识" style="zoom: 33%;" /></li></ol></li></ul><h4 id="2、发送方的复用和接收方的分用">2、发送方的复用和接收方的分用<a class="anchor" href="#2、发送方的复用和接收方的分用">·</a></h4><ul><li><p>复用可以理解为<strong>多个进程重复使用一个协议进行应用报文的封装</strong></p></li><li><p>分用可以理解为<strong>一个封装好的应用报文根据某协议进行解析成不同的进程应用报文</strong></p><img src="https://img-blog.csdnimg.cn/20210204221120338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="发送方复用和接收方分用" style="zoom: 33%;" /></li><li><p><strong>发送方复用：</strong></p><p>在发送方中，多个进程通过端口利用一个运输层协议将数据封装成报文后发送，这就称为发送方复用</p><ul><li>不同协议就叫不同协议复用，如图中的UDP复用</li><li>在IP复用中也会<strong>根据协议字段的不同将其使用不同协议再次进行封装</strong></li></ul></li><li><p><strong>接收方复用：</strong></p><ul><li>在接收方中，利用一个协议，将用报文解析成不同数据，将数据根据端口发送不同进程，这就称为接收方分用</li><li>在IP分用中也会根据协议字段的不同将其使用不同协议进行解析</li></ul></li><li><p>TCP/IP体系的应用层常用协议的运输层熟知端口号：</p><img src="https://img-blog.csdnimg.cn/20210204221501845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="运用层熟知端口号" style="zoom:33%;" /></li></ul><h4 id="对一个域名访问中的运输层传输流程进行解读：">对<strong>一个域名访问中的运输层传输流程进行解读：</strong><a class="anchor" href="#对一个域名访问中的运输层传输流程进行解读：">·</a></h4><img src="https://img-blog.csdnimg.cn/20210204221831138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="运输层传输中的主要路由器" style="zoom:50%;" /><ul><li><p>首先先认识在一次运输层传输中的主要路由器：</p><ol><li>DNS服务器：记录有某域名所对应的IP地址，在输入网页域名后，在hosts中找不到网页对应的IP地址时，就要通过DNS服务器获取域名对应的IP地址</li><li>Web服务器:某域名的服务器，也就是前面几章所说的目的主机，在访问域名时IP数据报最终即使到达Web服务器，服务器进行响应</li></ol></li><li><p>在浏览器中输入某域名，点击回车键开始访问：</p><ol><li><p>若此时在本地hosts缓存中有该域名的IP地址，直接发送带有目的地址的IP数据报</p></li><li><p>若计算机中没有该域名对应的IP地址，进行以下操作：</p><ol><li><p>构建DNS请求报文：</p><img src="https://img-blog.csdnimg.cn/2021020422245862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="构建DNS请求报文" style="zoom:33%;" /></li><li><p>然后在空闲的短暂端口中随机选择一个端口来表表示本进程：</p><p>DNS协议请求是熟悉端口之一，根据常见端口熟悉协议可查到，DNS协议的端口为53</p></li><li><p>将该UDP请求数据报通过以太网发送给DNS服务器</p></li><li><p>DNS服务器接收到请求数据报文后，从中解封出UDP用户数据报：</p><p>从数据报的目的端口知道,其目的端口为53后，服务器会将数据载荷部分（DNS请求报文）交给53端口对应的进程进行处理，此例中也就是DNS服务器端进程</p></li><li><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按照其要求查找对应的IP地址。查找到后会发送DNS响应报文：</p></li><li><p>该响应报文使用运输层的UDP协议封装成UDP报文。然后将其源端口设置成发送来的端口，目的端口设置为发送来的源端口</p><img src="https://img-blog.csdnimg.cn/20210204223342657.png" alt="DNS响应报文" style="zoom:50%;" /></li><li><p>接收方将UDP用户响应数据报封装在IP数据报中发送给发送方</p></li><li><p>用户在获得响应报文后，从中解封出用户数据报。根据用户数据报的目的端口，可以知道其传输给DNS进程</p></li><li><p>此时会将数据载荷，也就是DNS响应报文交给DNS进程进行处理，DNS进程将其响应报文进行解析，就可知道自己之前所请求的Web服务器的域名，此时就可以开始进行<strong>访问域名</strong></p></li></ol></li><li><p>知道域名对应的IP地址后，可以开始构建HTTP请求，并发送该请求</p><img src="https://img-blog.csdnimg.cn/20210204224440923.png" alt="构建TCP请求报文" style="zoom: 50%;" /><ul><li>HTTP请求报文的构建需要TCP协议构建TCP首部，在首部中选择一个空闲的短暂端口作为源端口，此时该端口代表TCP应用进程。目的端口选择80，这是HTTP协议所占的常用端口。</li><li>将TCP报文段封装在IP数据报中，并进行发送</li><li>HTTP请求报文通过以太网传输到对应Web服务器中，在接收到报文后会对其进行解析，在知道其端口为80后，会将数据载荷部分传输给本服务器中的<strong>HTTP服务器端进程进</strong>行解析。</li></ul></li><li><p>解析到内容后按照其要求查找首页内容。查找到后会给给用户PC发送HTTP响应报文。此时构建的源端口和目的端口刚好和发送的端口含义相反，原因与上面查询DNS服务过程相同</p><img src="https://img-blog.csdnimg.cn/20210204225235116.png" alt="构建HTTP响应报文" style="zoom:50%;" /><ul><li><p>Web服务器发送响应报文回用户PC</p><p>用户PC接收到报文后进行解封，解封后发现目的端口是49152，也就是用户PC内的HTTP进程。因此将数据载荷（HTTP报文）传输给HTTP进程进行处理</p></li><li><p>HTTP进程解析到其内同后，在网页浏览器中进行展示</p></li></ul></li><li><p>至此，一次网页请求结束</p></li></ol></li></ul><h3 id="3、TCP、UDP协议">3、TCP、UDP协议<a class="anchor" href="#3、TCP、UDP协议">·</a></h3><h4 id="1、概念上">1、概念上<a class="anchor" href="#1、概念上">·</a></h4><ul><li>UDP（User Datagram Protocol）：用户数据报协议，向上层提供<strong>无连接、不可靠</strong>服务</li><li>TCP（Transmission Control Protocol）：传输控制协议，向上层提供<strong>面向连接、基于字节流</strong>的可靠服务<ul><li>流就是指不间断的数据结构，可以把它想象成排水管中的水流</li></ul></li></ul><h4 id="2、在连接方式上">2、在连接方式上<a class="anchor" href="#2、在连接方式上">·</a></h4><ul><li><p>UDP是无连接的通信方式；</p><ul><li>UDP 想发数据就可以开始发送了，不需要连接，它只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</li><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识为UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul></li><li><p>TCP是通过著名的**“三次握手”建立连接，“四次挥手”释放连接**</p><img src="https://img-blog.csdnimg.cn/20210205101524393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="连接方式" style="zoom: 33%;" /></li></ul><h4 id="3、在传播方式上：">3、在传播方式上：<a class="anchor" href="#3、在传播方式上：">·</a></h4><ul><li><p>UDP由于不建立连接，支持单播、多播和广播；</p></li><li><p>TCP由于每次通信需要建立基于TCP连接的可靠信道，且每次只能建立一条连接，因此只支持单播</p><img src="https://img-blog.csdnimg.cn/20210205101823359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="传播方式上的区别" style="zoom: 50%;" /></li></ul><h4 id="4、在报文传输处理上：">4、在报文传输处理上：<a class="anchor" href="#4、在报文传输处理上：">·</a></h4><img src="https://img-blog.csdnimg.cn/20210205102109359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="报文传输处理上" style="zoom: 33%;" /><ul><li><strong>UDP协议，面向报文。</strong><ol><li>UDP发送方：对应用层传下来的<strong>报文不进行处理，保留报文的边界</strong>。在给报文<strong>加上UDP首部就发送</strong>。</li><li>UDP接收方：首部接收到UDP数据后，去除其首部，交付给应用层</li><li>因此，应用程序必须选择合适大小的报文</li><li>可以看出，<strong>UDP是针对报文为单位进行处理的，也就是UDP是面向应用报文的</strong></li></ol></li></ul><ol start="5"><li>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</li></ol><ul><li><p><strong>TCP协议，面向字节流的。</strong></p><p>发送方：</p><ol><li>TCP协议会把应用进程交付下来的数据块（报文）看作是<strong>一连串无结构的字节流</strong>（TCP并不知道这些子节含义），将他们<strong>编号</strong>，并存储在自己的<strong>发送缓存</strong>中</li><li>TCP再根据发送策略，<strong>提取一定量的字节</strong>，加上TCP首部，构建成TCP报文进行发送</li></ol><p>接收方：</p><ol><li>从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中</li><li>同时将接收缓存中的一些字节交付给应用进程。</li></ol><p>【注意】：</p><ol><li><p>TCP协议保证接收方收到的字节流和发送方应用进程发出的字节流完全一样；</p></li><li><p>TCP<strong>不保证</strong>接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系：</p><p>例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但不会全部将数据交付给上层。</p><p>因此<strong>接收方的TCP应用进程必须有能力识别收到的字节流</strong>，把它还原成有意义的应用层数据</p></li></ol><p>可以看出，TCP对报文的处理是以子节为单位的，也就是TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p></li></ul><h4 id="5、在给上层提供的服务上：">5、在给上层提供的服务上：<a class="anchor" href="#5、在给上层提供的服务上：">·</a></h4><img src="https://img-blog.csdnimg.cn/20210205103545602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" /><ul><li><p>UDP提供的是不可靠服务：</p><ol><li><p>不可靠性首先体现在无连接上，通信不需要建立连接，想发就发，这样的情况肯定不可靠</p></li><li><p>对于发送的UDP数据报，接收方在检测到其误码后直接丢弃，不做其他操作</p><p>对于发送方发送过程中出现分组丢失，也不做处理。因此其传输数据是不一定能使接收方全部收到数据，因此是不可靠服务。</p></li><li><p>网络环境时好时坏，但 UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整</p></li><li><p>这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景 ( 比如电话会议 ) 就需要使用 UDP 而不是 TCP</p></li></ol></li><li><p>TCP提供的是可靠服务：</p><ol><li><p>TCP传输过程中需要建立连接，通过建立的可靠信道进行传输</p></li><li><p>TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收</p><p>判断误码、丢失、乱序、重复靠的是TCP的段编号以及确认号;</p><p>然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)，如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传</p></li><li><p>因此可以保证发送端发送什么，接收端接收到什么，是可靠传输</p></li></ol></li></ul><h4 id="6、协议首部对比">6、协议首部对比<a class="anchor" href="#6、协议首部对比">·</a></h4><img src="https://img-blog.csdnimg.cn/20210205104221506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="协议首部对比" style="zoom: 50%;" /><ul><li><p>由于UDP不提供可靠传输的服务，因此其首部只需要在<strong>网际层的基础上添加区分端口的子节</strong>，其头部包含了以下几个数据</p><ul><li>两个十六位的端口号，分别为发出端口和接收端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><p>所以UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时高效的</p></li><li><p>在TCP中，需要提供可靠传输、流量控制、拥塞控制等服务，首部比较复杂，字段比较多</p></li></ul><h3 id="4、TCP的流量控制">4、TCP的流量控制<a class="anchor" href="#4、TCP的流量控制">·</a></h3><h4 id="1、流量控制过程">1、流量控制过程<a class="anchor" href="#1、流量控制过程">·</a></h4><ul><li><p>流量控制：</p><p>数据传输中，希望传输的越快越好，但若传输过快会导致接收方不够时间接收数据，造成数据丢失。</p><p>流量控制就是为了让发送方速率不要太快，要让接收方来的及接收</p><p><strong>TCP 利用滑动窗口实现流量控制</strong></p><p><img src="https://img-blog.csdnimg.cn/20210205110201196.png" alt="A与B建立连接"></p></li><li><p>举例说明：</p><p><img src="https://img-blog.csdnimg.cn/20210205110243488.png" alt="400的数据窗口"></p><p>A与B建立连接,建立完后约定好一个数据传输窗口，例如400：此后，双方传输数据就会以此约束的窗口大小进行。</p><img src="https://img-blog.csdnimg.cn/20210205111208400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="流量控制发送第一步" style="zoom:50%;" /><ol><li><p>A主机根据窗口长度，向B主机分三次发送了300子节的数据，但是201-300子节数据报丢失，此时发送方还不知道丢失，只知道传输了300子节，还能传输100子节</p></li><li><p>此时接收方根据收到的数据进行累计确认，发送确认信号，第一次流量控制，此信号参数含义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACK = 1:这是一个TCP确认字段</span><br><span class="line">ack = 201 :201编号以前的数据全部确认收到</span><br><span class="line">rwnd = 300 : 将接收窗口大小调整为300</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210205111708336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="流量控制示例2" style="zoom:33%;" /></li><li><p>在A收到确认ACK报文后，根据报文内容，将窗口进行滑动，此时由于前200子节已确认，因此将其<strong>从缓存中删除</strong>。同时根据报文内容的窗口调整调整为300大小。继续发送数据，直到无法发送窗口已满</p><p>此时由于201-300分组丢失超过重传计数器设置时间，对开始重传201-300分组；</p><p>接收方在收到501号所有分组后，发送新的ACK确认报文，报文中将窗口设置为100大小（第二次流量控制）</p><img src="https://img-blog.csdnimg.cn/20210205112138766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="流量控制示例3" style="zoom:50%;" /></li><li><p>在接收方接收到ACK报文后，对前500字节数据在缓存中删除，并将窗口调整为100，然后调整滑动窗口位置，开始新的传输。</p><p>传输窗口数据后不再传输数据。等待ACK确认信号。</p><p>此时接收方接收到数据后再次发送ACK报文，将窗口大小设置为0。(第三次流量控制)</p></li><li><p>此时由于窗口为零，不再发送数据</p></li></ol></li></ul><h4 id="2、死锁情况考虑">2、死锁情况考虑<a class="anchor" href="#2、死锁情况考虑">·</a></h4><ul><li><p>出现的场景：</p><p>在缓存不足，接收方窗口调整为0后，过了一段时间便有了新的空间，此时发送一个新的调整窗口报文，但是此时报文传输丢失！无法到达发送方；</p><p>此时就会出现发送方等待接收方有缓存空间，接收方等待发送方发送数据的死锁情况</p></li><li><p>为了解决这个问题，TCP为每一个连接设有一个<strong>持续计时器：</strong></p><img src="https://img-blog.csdnimg.cn/20210205112832621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="持续计时器" style="zoom:50%;" /><ol><li><p>在连接的一方接收到对方的零窗口通知后一段时间后，超时计时器到时，就会发送一个1子节的<strong>零窗口发送报文</strong>，在接收方接收到该信号后，就会通告自己的窗口大小</p></li><li><p>当知道窗口可以传输数据后，就会开始通信</p></li><li><p>如果<strong>零窗口探测报文</strong>在发送过程中如果丢失，还是能打破死锁局面：</p><p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p></li></ol></li></ul><p>【注意】：TCP中规定不论接收方有没有空间，都必须接收发送方的3种报文：<strong>零窗口检测报文段</strong>、确认报文段、携带有紧急数据的报文段</p><h4 id="3、总结-2">3、总结<a class="anchor" href="#3、总结-2">·</a></h4><ul><li>利用滑动窗口机制，可以很方便地在TCP连接上实现对发送方的流量控制：<ol><li>TCP接收方利用自己的<strong>接收窗口</strong>的大小来限制发送方<strong>发送窗口</strong>的大小；</li><li>TCP发送官方收到接收方的<strong>零窗口通知</strong>后，应启动<strong>持续计时器</strong>，持续计时器超时后，向接收方发送<strong>零窗口探测报文</strong>。</li></ol></li></ul><h3 id="5、TCP拥塞控制">5、TCP拥塞控制<a class="anchor" href="#5、TCP拥塞控制">·</a></h3><ul><li><p>拥塞：</p><p>某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏；</p><p>而拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载；</p><p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降</p></li></ul><img src="https://img-blog.csdnimg.cn/20210205170452296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="拥塞情况" style="zoom:50%;" /><h4 id="0、拥塞算法的基本思路">0、拥塞算法的基本思路<a class="anchor" href="#0、拥塞算法的基本思路">·</a></h4><p>以下算法的前提条件：</p><img src="https://img-blog.csdnimg.cn/20210205171237333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="拥塞算法假定条件" style="zoom: 33%;" /><ul><li><p>发送方维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值取决于网络的拥塞程度，并且动态变化</p></li><li><p>**拥塞窗口的维护原则：**只要没有网络出现拥塞，拥塞窗口就再增大一些，只要网络出现拥塞，拥塞窗口就减少一些。</p></li><li><p>**判断网络拥塞的依据：**没有按时收到应到达的确认报文（发生超时重传）</p></li><li><p>发送方将拥塞窗口作为<strong>发送窗口swnd</strong>，即：swnd = cwnd</p></li><li><p>维护一个<strong>慢开始门限ssthresh</strong>状态便变量，其维护原则为:</p><img src="https://img-blog.csdnimg.cn/20210205172001338.png" alt="在这里插入图片描述" style="zoom:50%;" /></li></ul><h4 id="1、拥塞控制算法1：慢开始">1、拥塞控制算法1：慢开始<a class="anchor" href="#1、拥塞控制算法1：慢开始">·</a></h4><ul><li><p>慢开始算法：用来确定网络的负载能力或拥塞程度，</p><ul><li>实现是由小到大逐渐增大（以倍数增长）拥塞窗口数值；慢开始指的是一开始网络注入的报文段少，并不是指拥塞窗口cwnd的增长速度慢</li></ul></li><li><p>过程举例：</p><ul><li>横坐标为传输轮次，即完整发送一个拥塞窗口数据并收到确认报文的时间（可理解为往返时间）</li><li>纵坐标为拥塞窗口，并且根据不同情况会设置一个慢开始门限</li></ul><p><img src="https://img-blog.csdnimg.cn/20210205172339397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="坐标系"></p><p>初始化：发送方将初始拥塞窗口设为1，并设置一个ssthresh（慢开始传送位），然后开始传送数据</p><p>进行第一轮数据通信：</p><ol><li><p>在收到确认报文后：不断地将拥塞窗口设置为原来的两倍</p><img src="https://img-blog.csdnimg.cn/20210205172719478.png" alt="将拥塞窗口设置新值" style="zoom: 50%;" /></li><li><p>第四次发送顺利进行，成功接收到确认报文后，将<strong>拥塞窗口增大到16.</strong><img src="https://img-blog.csdnimg.cn/20210205173731557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="坐标轴情况3"></p></li><li><p>此时，**拥塞窗口已达到慢开始门限SSTHRESH,**此时，慢开始算法阶段结束，开始拥塞避免算法</p></li></ol></li></ul><h4 id="2、拥塞控制算法2：拥塞避免">2、拥塞控制算法2：拥塞避免<a class="anchor" href="#2、拥塞控制算法2：拥塞避免">·</a></h4><ul><li><p>拥塞避免算法：</p><p>让拥塞窗口 cwnd 缓慢地增大（每伦窗口大小+1），避免出现拥塞；</p><p>在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点</p><p>拥塞避免算法并不能完全避免拥塞，只是在拥塞避免阶段将容易拥塞的窗口控制为按线性规律增长，使网络比较不易出现拥塞</p></li><li><p>接着上面的例子：</p><ol><li><p>进行第六轮传输：此时不再使用慢开始算法，采用拥塞避免算法，每个轮次只给拥塞窗口+1。</p><img src="https://img-blog.csdnimg.cn/20210205173921444.png" alt="第六轮传输" style="zoom: 50%;" /><p><img src="https://img-blog.csdnimg.cn/20210205174101695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="坐标轴情况5"></p></li><li><p>第七轮传输：传输成功后，给拥塞窗口+1.</p></li></ol></li></ul><h5 id="假如报文段丢失：">假如报文段丢失：<a class="anchor" href="#假如报文段丢失：">·</a></h5><ul><li>循环重复此传输过程，若出现以下情况：</li></ul><img src="https://img-blog.csdnimg.cn/2021020517424021.png" alt="出现报文段丢失情况" style="zoom:50%;" /><ul><li><p>重传计时器超时后，判断网络很可能出现了拥塞，进行以下工作：</p><p>将ssthresh值更新为拥塞时cwnd值的一半将cwnd值减少为1，重新开始执行慢开始算法</p></li></ul><h5 id="以上两个算法的完整示意图：">以上两个算法的完整示意图：<a class="anchor" href="#以上两个算法的完整示意图：">·</a></h5><img src="https://img-blog.csdnimg.cn/20210205174838531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="两个算法的完整示意图" style="zoom:50%;" /><h5 id="新问题：">新问题：<a class="anchor" href="#新问题：">·</a></h5><p>因此提出了<strong>快重传算法和快恢复算法</strong></p><img src="https://img-blog.csdnimg.cn/20210205174947201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="错误设置窗口情况" style="zoom:50%;" /><h4 id="3、拥塞控制算法3：快重传">3、拥塞控制算法3：快重传<a class="anchor" href="#3、拥塞控制算法3：快重传">·</a></h4><ul><li><p>快重传算法：</p><p>在出现分组错误后，发送方尽快重传数据，而不是等待超时计时器超时再重传。</p><p>三个原则：</p><ol><li>要求接收方不要等等自己发送数据时才进行捎带确认，而是要立即发送确认</li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</li><li>发送方一旦收到了3个连续的重复确认，就立即将相应的报文段立即重传，不用等到超时计时器超时后再重传</li></ol></li><li><p>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（这会使拥塞窗口设置为1），该算法可以使整个网络吞吐量提高约20％</p><img src="https://img-blog.csdnimg.cn/20210205175746820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="快重传算法" style="zoom:50%;" /></li><li><p>举例说明：</p><ol><li>在快重传算法中，发送方会在接收到确认分组前就发送下一个分组（前提是在拥塞窗口大小内）</li><li>对于丢失的分组，会在收到3个分组后发送3个重复确认丢失分组序号</li><li>接收方收到3个重复分组序号后便开始重传，而不是等待超时计时器到时，这样子也不会误以为出现了拥塞</li></ol></li></ul><h4 id="4、拥塞控制算法4：快恢复">4、拥塞控制算法4：快恢复<a class="anchor" href="#4、拥塞控制算法4：快恢复">·</a></h4><ul><li><p>快恢复算法：</p><ul><li>是发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，并开始执行拥塞避免算法</li><li>发送方在收到3个重复确认后，就知道现在只是丢失了个别的报文段。于是不开始启动慢开始算法，转而执行快恢复算法</li></ul></li><li><p>四个算法再传输过程中的使用顺序图：</p></li></ul><img src="https://img-blog.csdnimg.cn/2021020518062065.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="算法使用顺序图" style="zoom:50%;" /><pre><code>1. 一开始使用慢开始算法，拥塞窗口开始指数规律增大到设定的ssthres值后执行拥塞避免算法2. 拥塞避免算法将拥塞窗口以1为单位线性增大，直到出现分组丢失3. 重传计时器时间到后，cwnd设置为1，ssthresh值设置为发生拥塞的窗口值大小一半，并重新开始执行慢开始算法4. 在发送方收到3个重复确认时及执行快重传和快恢复算法，将ssthresh的值更新为当前拥塞窗口值得一半，更新cwnd值为ssthresh值</code></pre><h3 id="6、TCP超时重传时间的选择">6、TCP超时重传时间的选择<a class="anchor" href="#6、TCP超时重传时间的选择">·</a></h3><p>TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p><ul><li><p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p></li><li><p>TCP超时重传时间的选择是TCP最复杂的问题之一：</p><ul><li>若RTTO超时重传时间过短会导致不必要的重传，使网络负荷增大。</li><li>RTO过长会导致网络的空闲时间增大，降低了传输效率</li><li>因此，<strong>RTTO的设置应该略大于RTT</strong></li></ul></li><li><p>新问题：RTTO的判定问题：</p><p>由于网络传输环境的不同，导致接下来的RTT是不确定的，不能直接用某次测量得到的RTT样本值来计算超时重传时间RTO。如此应该如何去认定RTO？</p><img src="https://img-blog.csdnimg.cn/20210205220126650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="RTT测量复杂" style="zoom:50%;" /></li><li><p>关于RTTs的计算：</p><img src="https://img-blog.csdnimg.cn/20210205215919856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="RTTs的计算" style="zoom: 67%;" /></li><li><p>计算超时重传时间RTO:</p><img src="https://img-blog.csdnimg.cn/20210205220003983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="RFC6298建议下的RTO计算" style="zoom:50%;" /></li></ul><p>针对以上问题，有以下解决方式：</p><img src="https://img-blog.csdnimg.cn/20210205220207182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="Karn解决算法" style="zoom:50%;" /><ul><li><p>一个计算RTO的例子：</p><img src="https://img-blog.csdnimg.cn/20210205220305521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="计算RTO例子" style="zoom:67%;" /></li></ul><h3 id="7、TCP可靠传输的实现">7、TCP可靠传输的实现<a class="anchor" href="#7、TCP可靠传输的实现">·</a></h3><p>TCP基于以子节为单位的滑动窗口来实现可靠传输：</p><img src="https://img-blog.csdnimg.cn/20210205222040265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="TCP可靠传输的实现" style="zoom: 33%;" /><h4 id="1、发送方">1、发送方<a class="anchor" href="#1、发送方">·</a></h4><ul><li><p>在要传递的字节流中，可以大致分为几个区域：</p><ol><li><strong>发送窗口后数据</strong>（图中的左边）：这些数据已经成功发送出去并且已经收到确认信号，因此这部分数据可以从缓存中删除</li><li><strong>发送窗口中数据</strong>（图中的蓝色部分）：这部分数据正处于发送窗口中，此时数据有两种情况，已发送正在等待确认或者未发送出去，对于已发送的数据要存在发送缓存中。</li><li><strong>发送窗口前数据</strong>（图中的右半部分）：这部分数据不允许发送</li></ol></li><li><p>根据发送的具体情况，<strong>发送窗口的后延移动</strong>情况有两种:</p><p>不动：没有收到新的确认信息。</p><p>前移：收到了新的确认信息。</p></li><li><p>根据发送的具体情况,前，<strong>发送窗口的前延移动</strong>情况有三种：</p><p>**不间断向前移动：**收到了新的确认分组</p><p>**不动：**没有收到新的确认分组并且对方的通知窗口信号大小不变；收到新的确认但对方通知的端口缩小个数等于后延移动的位数，使得发送窗口前沿正好不动。</p><p>**向后收缩：**对方通知的窗口缩小了，但是这种情况容易造成错误，是TCP协议不愿看到的情况</p></li></ul><h4 id="2、如何描述发送窗口中数据的状态">2、如何描述发送窗口中数据的状态<a class="anchor" href="#2、如何描述发送窗口中数据的状态">·</a></h4><p>由于发送窗口中的字节可能是已经发送的或者未发送的，就出现了一个问题，我们应该如何描述发送窗口中数据的状态？</p><ul><li><p>可以采用三个指针来定位不同状态区域</p><img src="https://img-blog.csdnimg.cn/20210205223228998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="描述发送窗口状态的方法" style="zoom: 33%;" /></li></ul><h4 id="3、接收方">3、接收方<a class="anchor" href="#3、接收方">·</a></h4><img src="https://img-blog.csdnimg.cn/20210205223433830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="接收方字节状态" style="zoom:50%;" /><p>在接收方中也有跟发送方相同的字节序列情况：</p><p>​其字节序列也可以分为三个部分，跟发送方一致，不过多赘述。</p><ol><li><p>若接收方收到未按序到达的数据，如本例收到32-33编号字节数据，<strong>由于TCP的确认方式是只能发送按序收到的最高序号确认</strong>，因此发送一个ack = 31的确认信号，也就是表示现在需要发送31号数据</p><img src="https://img-blog.csdnimg.cn/2021020522354113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="接受方收到未按序到达的数据" style="zoom: 33%;" /></li><li><p>发送方收到ack = 31报文后，知道31号数据未按序到达，但是根据上面所学的知识，只有<strong>第3次接收到同一个ack信号才会进行重传</strong>，此时<strong>不做处理，继续发送往下的数据</strong>。</p><img src="https://img-blog.csdnimg.cn/20210205224016267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="成功接收到31序号" style="zoom:50%;" /></li><li><p>此时若成功接收到31号数据，此时31-33号数据按序到达，此时接收方会<strong>择机将数据交给应用层，并且将窗口向后滑动3字节，同时发送确认报文</strong>。</p><img src="https://img-blog.csdnimg.cn/20210205224238102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="发送确认报文以及同时有数据来到" style="zoom: 33%;" /></li><li><p>在接收方发送的确认报文被发送方收到后，<strong>会将发送窗口向后滑动若干字节（此处为3字节）</strong>。<strong>发送方此时会将31.32.33字节数据从缓存中删除</strong>。</p><img src="https://img-blog.csdnimg.cn/20210205224631661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="发送方继续发送剩余的数据" style="zoom: 50%;" />此时若发送方**又发送了3个未按序到达的数据**。此时接收方接受数据后不做处理。<p>此时若迟迟等不到接收方确认信号，重传计时器超时，此时会重新发送发送窗口内已发送的数据，并重启重传计时器。</p></li></ol><ul><li>关于可靠传输实现的注意事项：</li></ul><img src="https://img-blog.csdnimg.cn/2021020522514810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="可靠传输实现的注意事项" style="zoom: 33%;" /><h3 id="8、TCP的3次握手、4次挥手">8、TCP的3次握手、4次挥手<a class="anchor" href="#8、TCP的3次握手、4次挥手">·</a></h3><ul><li><p>TCP是面向连接的协议，它基于运输连接来传送TCP报文段；运输连接管理就是使用运输连接的建立和释放都能正常的进行。<strong>连接建立</strong>有以下三个阶段：</p><ol><li>三次挥手建立连接</li><li>建立连接后进行数据传输</li><li>四次挥手释放TCP连接</li></ol></li><li><p>TCP的连接建立要解决以下3个问题：</p><p>1、使TCP双方都能确知对方的存在2、使TCP双方能够协商一些参数（如窗口最大值、是否使用窗口扩大选项和时间戳选项和服务质量等等）3、使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</p></li></ul><h4 id="1、3次握手">1、3次握手<a class="anchor" href="#1、3次握手">·</a></h4><blockquote><p>在三报文握手过程中，有<strong>两个角色</strong>，<strong>客户端</strong>发送握手连接请求，<strong>服务器</strong>等待接收请求。</p><p>在最开始：<strong>双方都是处于关闭状态，此时双方的TCP进程都是关闭的。</strong></p><p>此时，<strong>服务器在连接之前要进行准备</strong>：</p><p>1、服务器创建传输控制块，在块中有TCP连接表等一些TCP连接的重要信息。</p><p>2、<strong>创建后便开始监听</strong>，准备接收来自客户端的连接请求</p><p>【注意】：TCP服务器进程是被动等待来自TCP客户进程的连接请求。而不是主动发起，因此称为被动打开连接</p><p>与服务器类似，客户端进程也需要进行准备：其准备过程只有建立传输数据块。</p></blockquote><img src="https://img-blog.csdnimg.cn/20210205231822366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="客户端进程进行准备" style="zoom:33%;" /><h5 id="1、-第1次握手">1、 第1次握手<a class="anchor" href="#1、-第1次握手">·</a></h5><img src="https://img-blog.csdnimg.cn/202102052321410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第一次发送握手报文" style="zoom: 33%;" /><ul><li><p><strong>客户端</strong>向服务端发送连接请求报文段，并进入同步已发送( <code>SYN-SENT</code> 状态)</p></li><li><p>TCP连接请求报文段首部中，有两个关键数据：</p><ol><li>同步位SYN：被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq：被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ol><p>【注意】：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></li></ul><h5 id="2、-第2次握手">2、 第2次握手<a class="anchor" href="#2、-第2次握手">·</a></h5><img src="https://img-blog.csdnimg.cn/20210205232429727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="服务器收到信号后" style="zoom:33%;" /><ul><li><p><strong>TCP服务器进程</strong>收到客户端发送的TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP<strong>连接请求确认报文段</strong>，并进入<strong>同步已接受</strong>(  <code>SYN-RECEIVED</code> 状态)</p></li><li><p>连接请求确认报文段首部中有几个关键数据位：</p><ol><li>同步位SYN和确认为ACK：都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq：设置了一个初始值y，作为TCP服务器进程所选择的初始序号</li><li>确认号字段ack:值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ol><p>【注意】：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样消耗一个序号</p></li></ul><h5 id="3、-第3次握手">3、 第3次握手<a class="anchor" href="#3、-第3次握手">·</a></h5><ul><li><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接（ <code>ESTABLISHED</code> 状态）</p></li><li><p>普通的TCP确认报文段首部中有以下重点数据位：</p><ol><li>确认位ACK:设置为1，由于没有SYN同步字段，表明这是一个普通的TCP确认报文段，表示已确认收到建立连接报文。</li><li>序号字段seq:设置为x+1，因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1（SYN字段报文需要消耗一个序号）</li><li>确认号字段ack：设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ol><p>值得注意的是：TCP规定普通的<strong>TCP确认报文段(只有ACK没有SYN)可以携带数据</strong>，但<strong>如果不携带数据，则不消耗序号</strong></p></li><li><p>三次握手完毕后，服务器也进入连接已建立状态，此时双方连接已建立，可以开始进行数据传输</p></li></ul><h4 id="2、3次握手的问题">2、3次握手的问题<a class="anchor" href="#2、3次握手的问题">·</a></h4><h5 id="1、为什么是3次？">1、为什么是3次？<a class="anchor" href="#1、为什么是3次？">·</a></h5><ul><li><h5 id="三次握手的目的：三次握手才能确认双方的接收与发送能力都正常">三次握手的目的：三次握手才能确认双方的接收与发送能力都正常<a class="anchor" href="#三次握手的目的：三次握手才能确认双方的接收与发送能力都正常">·</a></h5></li><li><p>第一次：服务端确认自己的接收能力、客户端的发送能力</p><p>第2次：客户端确认自己的接收+发送能力、服务端的发送能力</p><p><strong>但此时服务器并不能确认客户端的接收能力是否正常</strong></p><p>第3次：客户端发包，服务端收到了，服务器就能确定</p></li></ul><h5 id="2、2次有什么问题？">2、2次有什么问题？<a class="anchor" href="#2、2次有什么问题？">·</a></h5><ul><li><h5 id="2次握手：不采用三次握手，只要服务端发出确认，就建立新的连接了">2次握手：不采用三次握手，只要服务端发出确认，就建立新的连接了<a class="anchor" href="#2次握手：不采用三次握手，只要服务端发出确认，就建立新的连接了">·</a></h5></li><li><p><strong>防止出现失效的连接请求报文段被服务端接收的情况</strong>，从而产生错误</p><ul><li>假如客户端共发出了两个连接请求报文段，其中第一个在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，第二个到达了服务端；</li><li>此时服务端<strong>误认为客户端又发出一次新的连接请求</strong>，于是就向客户端发出确认报文段，同意建立连接</li><li>此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，<strong>浪费资源</strong></li></ul></li></ul><h5 id="3、什么是半连接队列？">3、什么是半连接队列？<a class="anchor" href="#3、什么是半连接队列？">·</a></h5><ul><li><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，这种队列称为<strong>半连接队列</strong>。</p></li><li><p><strong>全连接队列</strong>：已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象</p></li><li><p><strong>SYN-ACK 重传次数</strong>：</p><p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，</p><p>等待一段时间仍未收到客户确认包，进行第二次重传。</p><p>如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p></li></ul><h5 id="4、ISN是固定的吗？">4、ISN是固定的吗？<a class="anchor" href="#4、ISN是固定的吗？">·</a></h5><ul><li>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。</li><li>ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</li><li><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></li></ul><h4 id="3、4次挥手">3、4次挥手<a class="anchor" href="#3、4次挥手">·</a></h4><img src="https://img-blog.csdnimg.cn/20210206101844970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="数据建立主动释放" style="zoom:33%;" /><p>在双方连接已建立后，此时需要客户端<strong>主动发出关闭</strong>信号</p><h5 id="1、第1次挥手">1、第1次挥手<a class="anchor" href="#1、第1次挥手">·</a></h5><img src="https://img-blog.csdnimg.cn/2021020610204186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第一次挥手" style="zoom: 33%;" /><ul><li><p>TCP客户进程会<strong>发送TCP连接释放报文段</strong>，并进入<strong>终止等待1</strong>状态</p></li><li><p>TCP连接释放报文段首部中有以下关键数据位：</p><ol><li>终止位FIN和确认位ACK：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段：值设置为u，u等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1，用来表示发送过程中的最后一个字节序号为u</li><li>确认号ack字段：值设置为v，v等于服务器进程之前发送的数据中最后一个字节的序号加1，也就是确认收到已经收到的服务器发送的数据</li></ol></li><li><p>**【注意】：**TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></li></ul><h5 id="2、第2次挥手">2、第2次挥手<a class="anchor" href="#2、第2次挥手">·</a></h5><img src="https://img-blog.csdnimg.cn/20210206103509759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第二次挥手" style="zoom: 33%;" /><ul><li><p>接收方再接收到连接释放报文后，会发送一个<strong>普通的TCP确认报文段</strong>并进入关闭等待（<code>CLOSE_WAIT</code> 状态）</p></li><li><p>普通的TCP确认报文段首部中有以下关键数据位：</p><ol><li><p>确认位ACK：值被设置为1，表明这是一个普通的TCP确认报文段。</p></li><li><p>序号seq：值设置为v，v等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，与之前收到的TCP连接释放报文段中的确认号ack值匹配</p></li><li><p>确认号ack字段：值为u+1，这是对TCP连接释放报文段的确认，也就是为发送方连接释放报文中的seq的值+1.</p></li></ol></li><li><p>在第2次挥手后，会产生以下过程：</p><ul><li>TCP服务器进程通知高层应用进程，TCP客户进程要断开与自己的TCP连接，此时的TCP连接进入半关闭状态。</li><li>半关闭状态可以认为，此时<strong>客户端与服务器的连接不再传输数据</strong>，也就是客户端没有数据在发生。而此时<strong>服务器若有剩余数据要发送会继续发送</strong>。</li><li>半关闭状态可能会持续一段时间，直到发送方没有数据进行发送</li></ul></li><li><p>在以上等待过程中，客户端会进入<strong>终止等待2状态：</strong></p><img src="https://img-blog.csdnimg.cn/20210206104044261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第二次挥手后服务器状态" style="zoom:33%;" /></li></ul><h5 id="3、第3次挥手">3、第3次挥手<a class="anchor" href="#3、第3次挥手">·</a></h5><p>此时当服务器没有数据要传输后。进行第三次挥手：</p><img src="https://img-blog.csdnimg.cn/2021020610480896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第三次挥手" style="zoom: 33%;" /><ul><li><p>此时TCP服务器进程会发送TCP连接释放报文段并进入最后确认状态：</p></li><li><p>在该报文段中有以下关键数据段：</p><p>1、终止位FIN和确认位ACK：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</p><p>2、序号seq：值为w，因为在半关闭状态下，TCP服务器进程可能又发送一段数据，因此w就是该段数据最后的序号。</p><p>3、确认号ack：值为u+1，这是对之前收到的TCP连接释放报文段的重复确认，因此值与发送方第一次挥手发送的seq值+1。</p></li></ul><h5 id="4、第4次挥手">4、第4次挥手<a class="anchor" href="#4、第4次挥手">·</a></h5><p>TCP客户进程<strong>收到TCP连接释放报文段</strong>后开始第四次挥手：</p><img src="https://img-blog.csdnimg.cn/20210206105234687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="第四次挥手" style="zoom:33%;" /><ul><li><p>针对第三次挥手的报文段发送<strong>普通的TCP确认报文段</strong>，之后进入<strong>时间等待状态。</strong></p></li><li><p>该报文段首部中有以下关键数据位：</p><p>1、确认位ACK：值被设置为1，表明这是一个普通的TCP确认报文段。</p><p>2、序号seq字段：值设置为u+1，用来表示最后一个发送的字节序号，</p><p>​但是为何没有发送数据，而此时值要设置为u+1（对比第一次挥手数据）？</p><p>​因为TCP客户进程之前发送的TCP连接释放报文段(带有FIN)虽不携带数据，但要消耗一个序号</p><p>3、确认号ack：值设置为w+1，这是对所收到的TCP连接释放报文段的确认</p></li><li><p>此时<strong>TCP服务器进程收到该报文段后就进入关闭状态</strong></p></li><li><p>而TCP客户进程还要<strong>经过2MSL</strong>后才能进入关闭状态，MSL具体的值（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）可以根据TCP协议的不同实现进行设置。</p></li></ul><h4 id="4、4次挥手的问题">4、4次挥手的问题<a class="anchor" href="#4、4次挥手的问题">·</a></h4><h5 id="1、为什么4次？">1、为什么4次？<a class="anchor" href="#1、为什么4次？">·</a></h5><ul><li>服务端收到客户端的FIN报文后，不能立刻回应FIN断开服务端-客户端的连接</li><li>因为自己可能还有数据发给客户端。所以先发ACK应答给客户端，告诉他已经知道要释放链接了，把自己的数据发送完，再开始发FIN来断开服务端-客户端的连接</li></ul><h5 id="2、为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？，是否有必要？">2、为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？，是否有必要？<a class="anchor" href="#2、为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？，是否有必要？">·</a></h5><ul><li><p>目的1：为了保证客户端发送的最后一个ACK报文段能够到达服务器，保证服务器关闭</p></li><li><p>目的2：防止“已失效的连接请求报文段”出现在本连接中</p></li><li><p>举例说明：</p><img src="https://img-blog.csdnimg.cn/20210206110230216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="不等待2MSL的情况" style="zoom: 33%;" /><ol><li><p>若客户端发送完最后一次报文后，也就是第四次挥手后就直接进入关闭状态，此时若第四次挥手报文丢失，会导致服务器的超时重传</p></li><li><p>此时客户端又已经关闭，导致不接受该报文，因此服务器会一直不断重传，并一直处于最后确认状态无法进入关闭状态。</p></li><li><p>因此，有以下结论：</p><ul><li><p>客户端进入时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p></li><li><p>TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p></li></ul></li></ol></li><li><p>假如另一种情况：</p><ol><li><p>TCP双方已经建立了连接，但是传输过程中<strong>TCP客户进程所在的主机</strong>出现了故障，此时TCP服务器进程以后就不能再收到TCP客户进程发来的数据，这时服务器进程会一直处于等待状态。</p></li><li><p>为了使TCP服务器进程不要再白白等待下去出现了<strong>TCP保活计时器：</strong></p><img src="https://img-blog.csdnimg.cn/20210206110921258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="保活计时器" style="zoom: 50%;" /></li></ol></li></ul><h5 id="3、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？">3、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？<a class="anchor" href="#3、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？">·</a></h5><ul><li>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但有可能最后一个ACK丢失。所以<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong></li></ul><h3 id="9、TCP报文的首部格式：">9、TCP报文的首部格式：<a class="anchor" href="#9、TCP报文的首部格式：">·</a></h3><p>为了实现可靠传输，TCP采用了面向字节流的方式。在发送数据时，<strong>从发送缓存中取出一部分或者全部字节，并给其添加一个首部</strong>使之称为<strong>TCP报文段</strong>。</p><ol><li>一个TCP报文段由首部、数据载荷两部分构成</li><li>TCP的<strong>全部功能都能体现在它首部中各字段</strong>的作用</li></ol><p>TCP首部和IP地址的首部类似，都由固定部分和扩展部分构成</p><img src="https://img-blog.csdnimg.cn/20210206111411616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="TCP首部" style="zoom:50%;" /><h4 id="1、固定部分">1、固定部分<a class="anchor" href="#1、固定部分">·</a></h4><ul><li>源端口和目的端口字段：</li></ul><img src="https://img-blog.csdnimg.cn/20210206111530978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="源端口和目的端口字段" style="zoom: 33%;" /><ul><li>序号、确认号、ACK字段：</li></ul><img src="https://img-blog.csdnimg.cn/20210206112000569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="序号" style="zoom: 33%;" /><img src="https://img-blog.csdnimg.cn/20210206112111207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="确认号" style="zoom:33%;" /><p>也就是四次挥手中的SEQ.</p><img src="https://img-blog.csdnimg.cn/20210206112144726.png" alt="ACK" style="zoom: 33%;" /><p>以上三个字段的使用例子：</p><img src="https://img-blog.csdnimg.cn/20210206112234844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="三个字段例子" style="zoom:50%;" /><ul><li>数据偏移字段：</li></ul><img src="https://img-blog.csdnimg.cn/2021020611235494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="数据偏移字段" style="zoom:33%;" /><p>例如：其数据偏移二进制数的十进制表示 * 4 = 首部长度</p><img src="https://img-blog.csdnimg.cn/20210206112504633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="数据偏移例子" style="zoom:33%;" /><ul><li><p>保留、窗口、校验和字段：</p><img src="https://img-blog.csdnimg.cn/20210206112718623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="保留、窗口" style="zoom: 50%;" /></li><li><p>与连接管理相关的字段：</p><img src="https://img-blog.csdnimg.cn/20210206112822979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="同步标志位" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/20210206112841284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="终止标志位" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210206112906122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="复位标志位字段" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210206112926575.png" alt="推送标志位字段" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210206113010144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="紧急标志位URG紧急指针" style="zoom: 50%;" /></li></ul><h4 id="2、拓展部分">2、拓展部分<a class="anchor" href="#2、拓展部分">·</a></h4><ul><li><p>选项和填充字段：</p><img src="https://img-blog.csdnimg.cn/20210206113129998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="选项字段" style="zoom:33%;" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS</title>
      <link href="/posts/HTTPS.html"/>
      <url>/posts/HTTPS.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTPS-概述">1. HTTPS 概述<a class="anchor" href="#1-HTTPS-概述">·</a></h2><h3 id="1、什么是HTTPS">1、什么是HTTPS<a class="anchor" href="#1、什么是HTTPS">·</a></h3><ul><li><p>HTTPS：HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><ul><li>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，</li><li>而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生</li><li>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10885a9d4d574d7caf3fee1416f623ca~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:25%;" /></li><li><p>**SSL：**是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输</p></li><li><p>http默认采用<strong>80</strong>作为通讯端口，传输不加密</p></li><li><p>https默认采用<strong>443</strong>，对于传输的数据进行加密传输。 主流</p></li></ul><h3 id="2、TSL工作原理">2、TSL工作原理<a class="anchor" href="#2、TSL工作原理">·</a></h3><p><strong>TLS/SSL</strong>全称<strong>安全传输层协议</strong>， 是介于TCP和HTTP之间的一层安全协议</p><h2 id="2-对称加密">2. 对称加密<a class="anchor" href="#2-对称加密">·</a></h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704172932212-1865243822.png" alt="img" style="zoom: 67%;" /><ul><li><strong>特点：<strong>客户端、服务端的对称加密算法的加密和解密都是用</strong>同一个密钥</strong></li><li><strong>安全性问题：</strong><ol><li>密钥需要通过网络传输，怎么让传输的双方知晓，同时不被别人知道？</li><li>传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容</li></ol></li></ul><h2 id="3-非对称加密-单向安全">3. 非对称加密             单向安全<a class="anchor" href="#3-非对称加密-单向安全">·</a></h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704172950412-1093634792.png" alt="img" style="zoom:67%;" /><ul><li><h4 id="特点：不需担心公钥泄露，确保了客户端发送到服务端数据的安全">特点：不需担心公钥泄露，确保了客户端发送到服务端数据的安全<a class="anchor" href="#特点：不需担心公钥泄露，确保了客户端发送到服务端数据的安全">·</a></h4><ol><li>非对称加密需要<strong>一组密钥对</strong>，分别是<strong>公钥</strong>和<strong>私钥</strong>，这两个密钥是成对出现的。</li><li><strong>公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密</strong></li><li>私钥由服务器自己保存，<strong>公钥发送给客户端</strong></li><li>客户端拿到公钥后对请求加密后发送给服务端，服务器收到后用私钥解开</li></ol></li></ul><h2 id="4-非对称加密改良-双向安全但解密慢">4. 非对称加密改良           双向安全但解密慢<a class="anchor" href="#4-非对称加密改良-双向安全但解密慢">·</a></h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173037022-575825113.png" alt="img" style="zoom:67%;" /><ul><li><h4 id="传输过程：">传输过程：<a class="anchor" href="#传输过程：">·</a></h4><p>服务器拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2</p><ol><li><p>浏览器向服务器请求，服务器把公钥A1明文传输给浏览器</p></li><li><p>浏览器把公钥B1明文传输给服务器</p></li><li><p>之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密</p><p>由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全</p></li><li><p>服务器向浏览器传输的东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。</p></li></ol></li><li><h4 id="但HTTPS并没有用这种方案">但HTTPS并没有用这种方案<a class="anchor" href="#但HTTPS并没有用这种方案">·</a></h4><p>最主要的原因是非对称加密算法非常耗时，而对称加密快很多。能不能运用<strong>非对称加密的特性</strong>解决对称加密中<strong>公钥传输的安全传输</strong>问题？？</p></li><li><h4 id="仍存在的漏洞：中间人攻击">仍存在的漏洞：中间人攻击<a class="anchor" href="#仍存在的漏洞：中间人攻击">·</a></h4></li></ul><h2 id="5-非对称加密-对称加密-HTTPS采用的加密方案">5. 非对称加密 + 对称加密          HTTPS采用的加密方案<a class="anchor" href="#5-非对称加密-对称加密-HTTPS采用的加密方案">·</a></h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173049712-841772692.png" alt="img" style="zoom:67%;" /><ul><li><h4 id="过程：-只需要服务端有一对公、私钥对">过程： 只需要服务端有一对公、私钥对<a class="anchor" href="#过程：-只需要服务端有一对公、私钥对">·</a></h4><p>服务器拥有用于非对称加密的公钥A1、私钥A2</p><ol><li>浏览器向服务器请求，服务器把公钥A1明文给传输浏览器</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器</li><li>服务器拿到后用私钥A2解密得到密钥X</li><li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可</li></ol></li><li><h4 id="漏洞：中间人攻击-中间人完全不需要拿到私钥A2就能劫持信息">漏洞：中间人攻击   中间人完全不需要拿到私钥A2就能劫持信息<a class="anchor" href="#漏洞：中间人攻击-中间人完全不需要拿到私钥A2就能劫持信息">·</a></h4></li></ul><h2 id="6-中间人攻击">6. 中间人攻击<a class="anchor" href="#6-中间人攻击">·</a></h2><p><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173100652-22100951.png" alt="img"></p><ul><li><h4 id="过程：">过程：<a class="anchor" href="#过程：">·</a></h4><p>服务器用于非对称加密的公钥A1、私钥A2</p><ol><li>浏览器向服务器请求，服务器把公钥A1明文传输给浏览器</li><li>中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器</li><li>中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器</li><li>在双方都不会发现异常的情况下，中间人得到了对称密钥X</li></ol></li><li><h4 id="根本原因：浏览器无法确认自己收到的公钥是不是服务端自己的，下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？">根本原因：浏览器无法确认自己收到的公钥是不是服务端自己的，下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？<a class="anchor" href="#根本原因：浏览器无法确认自己收到的公钥是不是服务端自己的，下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？">·</a></h4></li></ul><h2 id="7-数字证书">7. 数字证书<a class="anchor" href="#7-数字证书">·</a></h2><ul><li><p>网站在使用HTTPS前，需要向“<strong>CA机构</strong>”申请颁发一<strong>数字证书</strong>，数字证书里有<strong>证书持有者、证书持有者的公钥等信息</strong></p></li><li><p>服务器把证书传输给浏览器，浏览器<strong>从证书里取公钥</strong>就可以了</p></li><li><h4 id="问题：">问题：<a class="anchor" href="#问题：">·</a></h4><p>证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？</p></li></ul><h2 id="8-数字签名">8. 数字签名<a class="anchor" href="#8-数字签名">·</a></h2><h3 id="1-数字签名的制作过程：">1. 数字签名的制作过程：<a class="anchor" href="#1-数字签名的制作过程：">·</a></h3><ol><li>CA拥有非对称加密的私钥和公钥。</li><li>CA对证书明文信息进行hash。</li><li>对hash后的值用私钥加密，得到数字签名</li><li><strong>明文和数字签名共同组成了数字证书</strong>，这样一份数字证书就可以颁发给网站了</li></ol><h3 id="2-浏览器验证过程：">2. 浏览器验证过程：<a class="anchor" href="#2-浏览器验证过程：">·</a></h3><ol><li>拿到证书，得到明文T1，数字签名S1。</li><li>用CA机构的公钥对S1解密（由于是浏览器信任的机构，所以<strong>浏览器保有它的公钥</strong>），得到S2。</li><li>用证书里说明的hash算法对明文T1进行hash得到T2。</li><li>比较S2是否等于T2，等于则表明证书可信。</li></ol><ul><li>下图中左侧是数字签名的制作过程，右侧是验证过程</li></ul><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173241563-445049817.png" alt="img" style="zoom:67%;" /><h3 id="3-为什么这样可以证明证书可信？">3. 为什么这样可以证明证书可信？<a class="anchor" href="#3-为什么这样可以证明证书可信？">·</a></h3><ul><li>假设中间人篡改了证书的原文，<strong>由于他没有CA机构的私钥</strong>，所以无法得到此时加密后签名，无法相应地篡改签名。</li><li>浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人</li></ul><h3 id="4-既然不可能篡改，那如果整个证书被掉包呢？">4. 既然不可能篡改，那如果整个证书被掉包呢？<a class="anchor" href="#4-既然不可能篡改，那如果整个证书被掉包呢？">·</a></h3><ul><li>假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。</li><li>于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞</li><li><strong>其实这并不会发生</strong>，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</li></ul><h3 id="5-制作数字签名时为什么需要hash一次？">5. 制作数字签名时为什么需要hash一次？<a class="anchor" href="#5-制作数字签名时为什么需要hash一次？">·</a></h3><h4 id="性能问题：">性能问题：<a class="anchor" href="#性能问题：">·</a></h4><ul><li>非对称加密是非常耗时和耗性能的；</li><li>对一个字符加密和对100个字符加密哪个更快一些？越短加密越快</li><li>证书的明文基本都很长，但是经过hash之后都很短，而且基本都是固定的长度了</li></ul><h3 id="6-HTTPS必须在每次请求中都要先在SSL-TLS层进行握手传输密钥吗？">6. HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？<a class="anchor" href="#6-HTTPS必须在每次请求中都要先在SSL-TLS层进行握手传输密钥吗？">·</a></h3><p>显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？</p><ul><li>用session就可以，相当于服务器那里有个小本本记录着</li><li>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下</li><li>之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了</li></ul><h2 id="9-HTTPS-工作原理">9. HTTPS 工作原理<a class="anchor" href="#9-HTTPS-工作原理">·</a></h2><img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173337291-1775767129.png" alt="img" style="zoom:67%;" /><ol><li><p><strong>发请求</strong></p><p>client向server发送请求https://baidu.com，然后连接到server的443端口。</p></li><li><p>服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。</p></li><li><p><strong>传送证书</strong>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。</p></li><li><p><strong>客户端解析证书</strong>这部分工作是由客户端的TLS来完成的，首先会<strong>验证公钥是否有效</strong>，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。</p></li><li><p><strong>传送加密信息</strong>这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p></li><li><p><strong>服务端加密信息</strong>服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。</p></li><li><p><strong>传输加密后的信息</strong>这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。</p></li><li><p><strong>客户端解密信息</strong>客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/posts/2716721158.html"/>
      <url>/posts/2716721158.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、HTTP概述">1、HTTP概述<a class="anchor" href="#1、HTTP概述">·</a></h3><h4 id="1、是什么：">1、是什么：<a class="anchor" href="#1、是什么：">·</a></h4><ol><li>超文本传输协议，基于TCP/IP协议，<strong>是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></li><li>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如&quot;HTTP/1.1 200 OK&quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息</li></ol><h4 id="2、特点：">2、特点：<a class="anchor" href="#2、特点：">·</a></h4><h5 id="1、灵活可扩展">1、灵活可扩展<a class="anchor" href="#1、灵活可扩展">·</a></h5><ul><li>一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。</li><li>另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据</li></ul><h5 id="2、请求-应答模式">2、请求-应答模式<a class="anchor" href="#2、请求-应答模式">·</a></h5><ul><li>通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等</li></ul><h5 id="3、可靠传输">3、可靠传输<a class="anchor" href="#3、可靠传输">·</a></h5><ul><li>HTTP是基于TCP/IP，因此把这一特性继承了下来</li></ul><h5 id="4、无状态">4、无状态<a class="anchor" href="#4、无状态">·</a></h5><ul><li><p>指协议对于事物处理没有记忆能力。不对请求和响应之间的通信状态进行保存</p></li><li><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传</p></li><li><p>无状态协议解决办法：</p><p>1、通过、Cookie</p><p>2、通过Session会话保存</p></li></ul><h4 id="3、优、缺点">3、优、缺点<a class="anchor" href="#3、优、缺点">·</a></h4><h5 id="1、无状态">1、无状态<a class="anchor" href="#1、无状态">·</a></h5><ul><li>有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等</li><li>另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说</li></ul><h5 id="2、明文传输">2、明文传输<a class="anchor" href="#2、明文传输">·</a></h5><ul><li>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式</li><li>这让HTTP的报文信息暴露给了外界，给攻击者带来了便利</li><li>不验证对方信息，会遭遇伪装；</li></ul><h5 id="3、队头阻塞">3、队头阻塞<a class="anchor" href="#3、队头阻塞">·</a></h5><ul><li>当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题</li></ul><h3 id="2、HTTP-状态码">2、HTTP 状态码<a class="anchor" href="#2、HTTP-状态码">·</a></h3><p>RFC 规定 HTTP 的状态码为**「三位数」**，第一个数字定义了响应的类别，被分为五类:</p><ul><li><strong>「1xx」</strong>: 代表请求已被接受，需要继续处理。</li><li><strong>「2xx」</strong>: 表示成功状态。</li><li><strong>「3xx」</strong>: 重定向状态。</li><li><strong>「4xx」</strong>: 客户端错误。</li><li><strong>「5xx」</strong>: 服务器端错误。</li></ul><h4 id="1、1xx-信息类">1、1xx 信息类<a class="anchor" href="#1、1xx-信息类">·</a></h4><ul><li>100继续 ：指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100允许客户端继续或用417告诉客户端不同意接受附件。     HTTP 1.1中新加入的</li><li>101转换协议：指服务器将按照其上的头信息变为一个不同的协议。 HTTP 1.1中新加入的</li></ul><h4 id="2、2xx-成功">2、2xx 成功<a class="anchor" href="#2、2xx-成功">·</a></h4><ul><li><p>200 （成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页</p></li><li><p>201 （已创建） 请求成功并且服务器创建了新的资源</p></li><li><p>204：请求得到了成功处理，但返回的响应报文中不含实体的主体部分（没有资源可以返回）</p></li><li><p>206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 <strong>「Content-Range」</strong> 指定范围的实体内容。</p></li></ul><h4 id="3、3xx-重定向">3、3xx 重定向<a class="anchor" href="#3、3xx-重定向">·</a></h4><h5 id="同样是重定向，307，303，302的区别？">同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？<a class="anchor" href="#同样是重定向，307，303，302的区别？">·</a></h5><ul><li><p>302是http1.0的状态码，在http1.1版本的时候为了细化302状态码出来了两个303和307。</p><ul><li>303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。</li></ul></li><li><p>307会遵照浏览器标准，不会从post变为get。</p></li><li><p>301 （永久移动）表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI，新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。</p><ul><li>若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址</li><li>使用场景：<ul><li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul></li></ul></li><li><p>302 （临时移动） 表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。</p><ul><li>302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。</li><li>若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</li><li>同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li><li>使用场景：<ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。</li></ul></li></ul></li><li><p>303 （查看其他位置）表示由于请求对应的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源</p><ul><li>和 302 Found 相似功能，但 303 状态码明确表示客户端应当用 GET 方法获取资源</li><li>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</li><li>注意：<ul><li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li><li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做</li></ul></li></ul></li><li><p><strong>304 （未修改，协商缓存可用） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</strong></p><p>304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系</p><ol><li><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul></li><li><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。</li></ul></li><li><p><strong>HTTP状态码304是多好还是少好</strong></p><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。</p><p>若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累的回访率也会高</p></li></ol></li><li><p>305 （使用<strong>代理</strong>） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</p></li><li><p>307 （临时重定向）会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容</p></li></ul><h4 id="4、4XX-客户端错误">4、4XX 客户端错误<a class="anchor" href="#4、4XX-客户端错误">·</a></h4><ul><li><p>400  请求报文存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p></li><li><p>401 unauthorized，表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败。</p><ul><li><p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p></li><li><p>出现401场景：</p><ul><li>401.1 - 登录失败。</li><li>401.2 - 服务器配置导致登录失败。</li><li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li><li>401.4 - 筛选器授权失败。</li><li>401.5 - ISAPI/CGI 应用程序授权失败。</li><li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li></ul></li></ul></li><li><p>403 forbidden，表示对请求资源的访问被服务器拒绝。服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。**进入该状态后，不能再继续进行验证。**该访问是永久禁止的，并且与应用逻辑密切相关。</p></li><li><p>404 not found，表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：</p></li><li><p>405  表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。</p><p>GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、5XX-服务器错误">5、5XX 服务器错误<a class="anchor" href="#5、5XX-服务器错误">·</a></h4><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误。</li><li>502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li></ul><h3 id="3、HTTP版本差异">3、HTTP版本差异<a class="anchor" href="#3、HTTP版本差异">·</a></h3><h4 id="1、HTTP-0-9">1、HTTP 0.9<a class="anchor" href="#1、HTTP-0-9">·</a></h4><ul><li>91年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，已过时。</li></ul><h4 id="2、HTTP-1-0">2、HTTP 1.0<a class="anchor" href="#2、HTTP-1-0">·</a></h4><ul><li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件</li><li>除了GET命令，还引入了POST命令和HEAD命令</li><li>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</li><li>只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li><li>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</li></ul><h4 id="3、HTTP-1-1">3、HTTP 1.1<a class="anchor" href="#3、HTTP-1-1">·</a></h4><p><strong>http1.1是目前最为主流的http协议版本</strong>，从1999年发布至今，仍是主流的http协议版本。</p><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li><li>引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率</li><li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效</li><li>支持断点续传，通过使用请求头中的 <code>Range</code> 来实现</li><li>使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE</li></ul><h4 id="3-2、总结1-0与1-1区别">3.2、总结1.0与1.1区别<a class="anchor" href="#3-2、总结1-0与1-1区别">·</a></h4><ul><li><p><strong>连接方面</strong></p><p>http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延</p></li><li><p><strong>资源请求方面</strong></p><p>在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</p></li><li><p><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p></li><li><p>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</p></li><li><p>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</p></li></ul><h4 id="4、http1-x版本问题">4、http1.x版本问题<a class="anchor" href="#4、http1-x版本问题">·</a></h4><ul><li><h4 id="安全：">安全：<a class="anchor" href="#安全：">·</a></h4><p>在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性</p></li><li><h4 id="队头阻塞：">队头阻塞：<a class="anchor" href="#队头阻塞：">·</a></h4><p>HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞</p></li><li><h4 id="Keep-alive性能问题">Keep-alive性能问题<a class="anchor" href="#Keep-alive性能问题">·</a></h4><p>http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间</p></li></ul><h4 id="5、HTTP-2-0">5、HTTP 2.0<a class="anchor" href="#5、HTTP-2-0">·</a></h4><h5 id="1、二进制分帧">1、<code>二进制分帧</code><a class="anchor" href="#1、二进制分帧">·</a></h5><ul><li>这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;：头信息帧和数据帧。</li><li>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li></ul><h5 id="2、头部压缩">2、<code>头部压缩</code><a class="anchor" href="#2、头部压缩">·</a></h5><ul><li>HTTP 1.1版本会出现 <strong>「User-Agent、Cookie、Accept、Server、Range」</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。</li><li>HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li></ul><h5 id="3、多路复用">3、<code>多路复用</code><a class="anchor" href="#3、多路复用">·</a></h5><ul><li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</li></ul><h5 id="4、服务器推送">4、<code>服务器推送</code><a class="anchor" href="#4、服务器推送">·</a></h5><ul><li>允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li></ul><h5 id="5、请求优先级">5、<code>请求优先级</code><a class="anchor" href="#5、请求优先级">·</a></h5><ul><li>可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验</li></ul><h4 id="6、3-0-QUIC-协议">6、3.0  QUIC 协议<a class="anchor" href="#6、3-0-QUIC-协议">·</a></h4><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a0a2ec0ef143b49d79256cea543418~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:25%;" /><h5 id="1-特点：">1. 特点：<a class="anchor" href="#1-特点：">·</a></h5><ul><li>HTTP/3 是基于 UDP 实现的，实现了类似于 TCP 的多路数据流、传输可靠性等功能，称为 QUIC 协议<ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li><li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li><li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li><li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li></ul></li></ul><h5 id="2-HTTP-3-的挑战">2. HTTP/3 的挑战<a class="anchor" href="#2-HTTP-3-的挑战">·</a></h5><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ul><h3 id="4、对HTTP-2理解">4、对HTTP/2理解<a class="anchor" href="#4、对HTTP-2理解">·</a></h3><h4 id="1、头部压缩">1、头部压缩<a class="anchor" href="#1、头部压缩">·</a></h4><ul><li><p>由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。</p><ul><li><p>所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p></li><li><p><strong>「User-Agent、Cookie、Accept、Server、Range」</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重</p></li></ul></li><li><p>HTTP/2 实现了头信息压缩，引入了头信息压缩机制。</p><ul><li>一方面，头信息使用 gzip 或 compress 压缩后再发送；</li><li>另一方面，客户端和服务器同时维护一张头信息表<code>HPACK</code> 算法，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了</li></ul></li><li><h4 id="HPACK-算法：-传索引"><code>HPACK</code> 算法：  传索引<a class="anchor" href="#HPACK-算法：-传索引">·</a></h4><ul><li>类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引</li><li>对于之前出现过的头部信息，只需要把**「索引」**(比如1，2，…)传给对方，对方拿到索引查表就行了</li></ul></li></ul><img src="https://user-images.githubusercontent.com/34484322/89356545-a3fd4100-d6f0-11ea-8e0a-8870d832e96e.png" alt="img" style="zoom: 33%;" /><ul><li><h4 id="好处：">好处：<a class="anchor" href="#好处：">·</a></h4><ol><li><p>这种**「传索引」**的方式，可以说让请求头字段得到极大程度的精简和复用</p></li><li><p>其次是对于整数和字符串进行**「哈夫曼编码」**</p><p>哈夫曼编码的原理就是先将所有出现的字符建立一张索引表</p><p>然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的**「索引序列」**，可以达到非常高的压缩率</p></li></ol></li></ul><h4 id="2、多路复用">2、多路复用<a class="anchor" href="#2、多路复用">·</a></h4><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p><h5 id="HTTP2中：">HTTP2中：<a class="anchor" href="#HTTP2中：">·</a></h5><ul><li><p>同域名下所有通信都在单个连接上完成。</p></li><li><p>单个连接可以承载任意数量的双向数据流。</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是<code>Stream ID</code>，流标识符</p><p>有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。</p></li><li><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了**“队头堵塞”**的问题。</p></li></ul><h4 id="3、服务器推送">3、服务器推送<a class="anchor" href="#3、服务器推送">·</a></h4><ul><li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送，这样就可以相对减少一些延迟时间</li><li>需要注意的是 http2 下服务器主动推送的是<strong>静态资源</strong>，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><h5 id="相比较http-1-1的优势👇">相比较http/1.1的优势👇<a class="anchor" href="#相比较http-1-1的优势👇">·</a></h5><ul><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li></ul><h4 id="4、二进制分帧与数据流">4、二进制分帧与数据流<a class="anchor" href="#4、二进制分帧与数据流">·</a></h4><h5 id="二进制帧：">二进制帧：<a class="anchor" href="#二进制帧：">·</a></h5><ul><li><p>在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。</p></li><li><p>HTTP/2 则是一个彻底的二进制协议，一个报文格式就被拆分为一个个二进制帧，帧的概念是它实现多路复用的基础。</p><ul><li><p>用**「Headers帧」<strong>存放头部字段，</strong>「Data帧」**存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了HTTP队头阻塞问题</p></li><li><p>HTTP/2采用二进制格式，全部传输01串，便于机器解码</p><p>明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低</p></li></ul></li></ul><h5 id="数据流：">数据流：<a class="anchor" href="#数据流：">·</a></h5><ul><li>在客户端与服务器之间，双方都可以互相发送二进制帧，这样子**「双向传输的序列」<strong>，称为<code>流</code>，所以HTTP/2中以</strong>流<strong>来</strong>表示一个TCP连接上进行多个数据帧的通信**，这就是<strong>多路复用</strong>概念</li><li>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。<ul><li>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流；</li><li>每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li></ul></li></ul><h5 id="那乱序的二进制帧，是如何组装成对于的报文呢？">那乱序的二进制帧，是如何组装成对于的报文呢？<a class="anchor" href="#那乱序的二进制帧，是如何组装成对于的报文呢？">·</a></h5><ul><li>乱序，指的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的</li><li>接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文</li><li>二进制帧中有一些字段，控制着<code>优先级</code>和<code>流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验</li></ul><h5 id="队头阻塞">队头阻塞<a class="anchor" href="#队头阻塞">·</a></h5><ul><li>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的；</li><li>HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。</li><li>队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理；</li><li>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</li></ul><h3 id="5、keep-alive">5、keep-alive<a class="anchor" href="#5、keep-alive">·</a></h3><h4 id="1、什么是keep-alive">1、什么是keep-alive<a class="anchor" href="#1、什么是keep-alive">·</a></h4><ul><li><h4 id="普通模式：">普通模式：<a class="anchor" href="#普通模式：">·</a></h4><p>HTTP协议采用“请求-应答”模式，当使用普通模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接，这就是<strong>短连接</strong>。（HTTP协议为无连接的协议）</p></li><li><h4 id="Keep-Alive模式：">Keep-Alive模式：<a class="anchor" href="#Keep-Alive模式：">·</a></h4><p>当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 ，这就是<strong>长连接</strong>。</p></li></ul><h4 id="2、为什么要使用keep-alive">2、为什么要使用keep-alive<a class="anchor" href="#2、为什么要使用keep-alive">·</a></h4><ul><li>**创建目的：**能在多次HTTP之前重用同一个TCP连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）</li></ul><img src="https://user-images.githubusercontent.com/34484322/89356849-64832480-d6f1-11ea-8f53-5372f8c30f39.png" alt="img" style="zoom:50%;" /><ul><li>优点：<ul><li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li><li>允许请求和应答的HTTP管线化；</li><li>降低拥塞控制 （TCP连接减少了）；</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li><li>报告错误⽆需关闭TCP连；</li></ul></li><li>缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li></ul><h4 id="3、客户端如何开启">3、客户端如何开启<a class="anchor" href="#3、客户端如何开启">·</a></h4><p>Keep-Alive的<strong>建立过程</strong>：</p><ul><li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li><li>服务器收到请求并处理 Connection字段</li><li>服务器回送Connection:Keep-Alive字段给客户端</li><li>客户端接收到Connection字段</li><li>Keep-Alive连接建立成功</li></ul><p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p><ul><li>客户端向服务器只是发送内容报文（不包含Connection字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有Connection字段，断开连接</li></ul><p><strong>客户端请求断开连接过程</strong>：</p><ul><li>客户端向服务器发送Connection:close字段</li><li>服务器收到请求并处理connection字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接</li></ul><h3 id="6、请求方法get-post">6、请求方法get/post<a class="anchor" href="#6、请求方法get-post">·</a></h3><h4 id="1、HTTP请求方法">1、HTTP请求方法<a class="anchor" href="#1、HTTP请求方法">·</a></h4><ul><li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</li><li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li></ul><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li><p>GET：                请求获取Request-URI所标识的资源</p></li><li><p>POST：              在Request-URI所标识的资源后附加新的数据</p></li><li><p>HEAD：             请求获取由Request-URI所标识的资源的响应消息报头，没有响应体</p></li><li><p>PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）</p><ul><li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等</li><li>也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li></ul></li><li><p>OPTIONS：       用于请求获得由<code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项</p><ul><li>通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</li></ul><p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p><ul><li><p>获取服务器对该资源支持的所有HTTP请求方法；</p><p>该方法会用’*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。</p></li><li><p>用来检查访问权限。例如：JS 的 XMLHttpRequest对象在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</p></li></ul></li><li><p>DELETE：          请求服务器删除对应所标识的资源</p></li><li><p>TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断</p></li><li><p>CONNECT：      建立连接隧道，用于代理服务器</p></li></ul><h4 id="2、谈一谈GET-和-POST-的区别">2、谈一谈GET 和 POST 的区别<a class="anchor" href="#2、谈一谈GET-和-POST-的区别">·</a></h4><p>本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。</p><p>从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册</p><p>想装逼请参考 https://zhuanlan.zhihu.com/p/22536382</p><h5 id="1、缓存角度">1、缓存角度<a class="anchor" href="#1、缓存角度">·</a></h5><ul><li>GET 请求后浏览器会主动缓存，POST 默认情况下不能</li></ul><h5 id="2、参数角度">2、参数角度<a class="anchor" href="#2、参数角度">·</a></h5><ul><li>GET请求一般放在URL中，因此不太安全，因为请求的 url 会被保留在历史记录中</li><li>POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的</li></ul><h5 id="3、编码角度">3、编码角度<a class="anchor" href="#3、编码角度">·</a></h5><ul><li>GET请求只能进行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。</li></ul><h5 id="3-2、请求长度：">3.2、请求长度：<a class="anchor" href="#3-2、请求长度：">·</a></h5><ul><li><p>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</p><p><strong>为什么会限制长度？</strong></p><ul><li>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。</li><li>get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span>的长度值 = <span class="variable constant_">URL</span>（<span class="number">2083</span>）- （你的<span class="title class_">Domain</span>+<span class="title class_">Path</span>）-<span class="number">2</span>（<span class="number">2</span>是get请求中?=两个字符的长度）</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、请求幂等">4、请求幂等<a class="anchor" href="#4、请求幂等">·</a></h5><ul><li>GET请求幂等</li><li>POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致</li></ul><h5 id="5、请求时">5、请求时<a class="anchor" href="#5、请求时">·</a></h5><ul><li>GET请求会一次性发送请求报文</li><li>POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分</li></ul><h4 id="3、POST与PUT的区别">3、POST与PUT的区别<a class="anchor" href="#3、POST与PUT的区别">·</a></h4><ul><li>PUT不会产生新数据，只是覆盖老数据，是幂等的</li><li>POST请求一次就产生一个新数据，是非幂等的</li></ul><h3 id="6-1、请求头、响应头">6.1、请求头、响应头<a class="anchor" href="#6-1、请求头、响应头">·</a></h3><h4 id="HTTP-Request-Header-常见的请求头："><strong>HTTP Request Header 常见的请求头：</strong><a class="anchor" href="#HTTP-Request-Header-常见的请求头：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Accept:浏览器能够处理的内容类型</span><br><span class="line">* Accept-Charset:浏览器能够显示的字符集</span><br><span class="line">* Accept-Encoding：浏览器能够处理的压缩编码</span><br><span class="line">* Accept-Ranges：可以请求网页实体的一个或者多个子范围字段</span><br><span class="line">* Connection：浏览器与服务器之间连接的类型</span><br><span class="line">* Cookie：当前页面设置的任何Cookie</span><br><span class="line">* Host：发出请求的页面所在的域</span><br><span class="line">* Referer：发出请求的页面的URL</span><br><span class="line">* User-Agent：浏览器的用户代理字符串</span><br></pre></td></tr></table></figure><h4 id="响应头：">响应头：<a class="anchor" href="#响应头：">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP Responses Header 常见的响应头：</span><br><span class="line"></span><br><span class="line">Date：表示消息发送的时间，时间的描述格式由rfc822定义</span><br><span class="line">server:服务器名称</span><br><span class="line">Connection：浏览器与服务器之间连接的类型</span><br><span class="line">Cache-Control：控制HTTP缓存</span><br><span class="line">content-type:表示后面的文档属于什么MIME类型</span><br></pre></td></tr></table></figure><h4 id="常见的-Content-Type-属性值有四种：">常见的 Content-Type 属性值有四种：<a class="anchor" href="#常见的-Content-Type-属性值有四种：">·</a></h4><p>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><p>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。</p><p>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p><h3 id="7、对URL组成">7、对URL组成<a class="anchor" href="#7、对URL组成">·</a></h3><h4 id="1、URL与URI-2">1、URL与URI<a class="anchor" href="#1、URL与URI-2">·</a></h4><ul><li><p>URI：统一资源标识符</p><p>父类        表示请求服务器资源，定位这个资源</p></li><li><p>URL：统一资源定位符，常常被称为网址，是因特网上标准的资源地址</p><p>子类       而URL还要表示如何访问这个资源</p><p>通用的格式：scheme://host[:port]/path/…/?query#anchor</p></li></ul><h4 id="2、组成格式：-2">2、组成格式：<a class="anchor" href="#2、组成格式：-2">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.aspxfans.com:8080/news/index.…</span><br></pre></td></tr></table></figure><ul><li><p>**协议：**访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等后面一定接上://</p></li><li><p>**域名：**该URL的域名部分为“www.aspxfans.com”</p></li><li><p>**port：**跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。</p><ul><li>端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li></ul></li><li><p>（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</p></li><li><p><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</p></li><li><p><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分</p><ul><li>如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分</li><li>如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。</li><li>本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li></ul></li><li><p><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例的锚部分是“name”。锚部分也不是一个URL必须的部分；</p></li><li><p><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。</p><p>本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p></li></ul><h4 id="3、URL-编码-2">3、URL 编码<a class="anchor" href="#3、URL-编码-2">·</a></h4><ul><li>URL 只能使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3school.com.cn%2Ftags%2Fhtml_ref_ascii.asp">ASCII 字符集</a>来通过因特网进行发送。</li><li>由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</li><li>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</li><li>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">天天`转换为有效的ASCII格式就是`%CC%EC%CC%EC</span><br></pre></td></tr></table></figure><h3 id="8、队头阻塞问题">8、队头阻塞问题<a class="anchor" href="#8、队头阻塞问题">·</a></h3><h4 id="1、什么是队头阻塞？">1、什么是队头阻塞？<a class="anchor" href="#1、什么是队头阻塞？">·</a></h4><ul><li>对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的</li><li>一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<code>HTTP队头阻塞</code>问题</li></ul><h4 id="2、解决1：并发连接">2、解决1：并发连接<a class="anchor" href="#2、解决1：并发连接">·</a></h4><ul><li>我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务</li><li>在<code>RFC规范</code>中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。</li></ul><h4 id="3、解决2：域名分片">3、解决2：域名分片<a class="anchor" href="#3、解决2：域名分片">·</a></h4><ul><li>可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器</li><li>就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题</li></ul><p>比如<code>TianTian.com</code>，可以分出很多二级域名，比如<code>Day1.TianTian.com</code>，<code>Day2.TianTian.com</code>,<code>Day3.TianTian.com</code>,这样子就可以有效解决队头阻塞问题</p><h3 id="9、谈一谈HTTP数据传输">9、谈一谈HTTP数据传输<a class="anchor" href="#9、谈一谈HTTP数据传输">·</a></h3><p>大概遇到的情况就分为**「定长数据」** 与 **「不定长数据」**的处理吧。</p><h4 id="1、定长数据">1、定长数据<a class="anchor" href="#1、定长数据">·</a></h4><ul><li>发送端在发送数据的过程中，需要设置<code>Content-Length</code>,来指明发送数据的长度。如果采用了Gzip压缩的话，Content-Length设置的就是压缩后的传输长度</li></ul><p>【注意】：</p><ul><li>Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。</li><li>如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。</li><li>那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。</li><li>在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于<code>Content-Length</code>,若是非Keep-alive，跟前面情况一样，Content-Length可有可无</li></ul><h4 id="2、不定长数据">2、不定长数据<a class="anchor" href="#2、不定长数据">·</a></h4><p>现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>通过chunked机制，可以完成对不定长数据的处理，当然了，你需要知道的是</p><ul><li>如果头部信息中有<code>Transfer-Encoding</code>,优先采用Transfer-Encoding里面的方法来找到对应的长度。</li><li>如果设置了Transfer-Encoding，那么Content-Length将被忽视。</li><li>使用长连接的话，会持续的推送动态内容。</li></ul><p>那我们来模拟一下吧👇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const server = require(&#x27;http&#x27;).createServer();</span><br><span class="line">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  if(req.url === &#x27;/index&#x27;) &#123;</span><br><span class="line">   // 设置数据类型</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);</span><br><span class="line">    res.setHeader(&#x27;Content-Length&#x27;, 10);</span><br><span class="line">    res.setHeader(&#x27;Transfer-Encoding&#x27;, &#x27;chunked&#x27;);</span><br><span class="line">    </span><br><span class="line">    res.write(&quot;你好，使用的是Transfer-Encoding设置传输数据形式&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输数据给您&lt;br/&gt;&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    res.write(&quot;骚等一下&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输数据给您&quot;);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;成功启动--TinaTian&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3.3-基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的组件通信</title>
      <link href="/posts/react_components.html"/>
      <url>/posts/react_components.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据是如何在react组件上流动">数据是如何在react组件上流动<a class="anchor" href="#数据是如何在react组件上流动">·</a></h2><p>React视图会随着数据的变化而变化：UI= render(data)；因此data在react中非常重要；</p><p>react中如果希望两个组件之间能够产生耦合，那么**两个组件必须建立数据上的连接。也就是组件间通信，**其背后是一套 <strong>环环相扣的react数据流解决方案</strong>。</p><p>时下react中的组件通信解决方案：</p><h4 id="1、基于props的数据流">1、基于props的数据流<a class="anchor" href="#1、基于props的数据流">·</a></h4><ul><li><p>组件，从概念上类似于JS函数，它接收任意的入参（即props），并返回用于描述页面展示内容的React元素</p></li><li><p>既然props是入参，通过修改props来完成通信就是很自然的事。</p></li><li><p>遵循的原则：单向数据流。当前组件的state以props的形式流动时，只能流向组件树中比自己层级更低的树。比如父组件—&gt;子组件，而不能反过来。</p><p>基于这种原则，可以完成<strong>父子通信，子父通信、兄弟通信</strong></p><ul><li><h5 id="父子通信：父组件通过this-props传入子组件，实现父–子通信">父子通信：父组件通过this.props传入子组件，实现父–子通信<a class="anchor" href="#父子通信：父组件通过this-props传入子组件，实现父–子通信">·</a></h5></li><li><h5 id="子父通信：由于单向数据流的原则限制：">子父通信：由于单向数据流的原则限制：<a class="anchor" href="#子父通信：由于单向数据流的原则限制：">·</a></h5><p>父组件传递给子组件的是一个绑定在自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去</p></li><li><p>子传父，再由父传新子。</p></li></ul></li><li><p>优点：简单</p></li><li><p>缺点：层层嵌套的场景很繁琐</p></li></ul><h4 id="2、发布订阅模式">2、发布订阅模式<a class="anchor" href="#2、发布订阅模式">·</a></h4><p>解决通信类问题的“万金油”</p><p>最初的案例是：addEventlistener，监听事件的位置、触发事件的位置是不受限的。</p><h5 id="事件的监听、触发">事件的监听、触发<a class="anchor" href="#事件的监听、触发">·</a></h5><ul><li>on()负责注册事件的监听器，指定事件触发时的回调函数</li><li>emit（）：负责触发事件，可以通过传参使其在触发的时候携带数据</li><li>off()：负责监听器的删除</li></ul><h5 id="写出一个同时拥有on、emit、off的EventEmitter">写出一个同时拥有on、emit、off的EventEmitter<a class="anchor" href="#写出一个同时拥有on、emit、off的EventEmitter">·</a></h5><ol><li>事件和监听函数的对应关系应该如何处理？映射，因此全局应该设计一个对象来存储二者的关系</li><li>如何实现订阅？写操作，将具体的事件和监听函数写入到队列里去</li><li>如何实现发布？ 读操作，触发安装在某个事件上对应的监听函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myEventEmitter</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">eventMap</span> = &#123;&#125;; <span class="comment">//eventMap用来存储事件和监听函数的关系</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">on</span>(<span class="params">type, handler</span>)&#123;  <span class="comment">//type事件名称</span></span><br><span class="line"><span class="keyword">if</span>(!handler <span class="keyword">instanceof</span> <span class="title class_">Function</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;你传错了&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 判断type事件对应的队列是否存在</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">eventMap</span>[type])&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventMap</span>[type] = []; <span class="comment">// 若不存在该类型，新建该队列</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 直接往队列里推入handler</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">eventMap</span>[type].<span class="title function_">push</span>(handler);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">emit</span>(<span class="params">type, params</span>)&#123;  <span class="comment">// 触发时可以传参</span></span><br><span class="line">    <span class="comment">// 假设该事件是有订阅的（对应的事件队列存在）</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">eventMap</span>[type])&#123;</span><br><span class="line">      <span class="comment">// 将事件队列里的handler依次执行出队</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventMap</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">handler, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handler</span>(params);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">type, handler</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">eventMap</span>[type])&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventMap</span>[type].<span class="title function_">splice</span>(<span class="variable language_">this</span>.<span class="property">eventMap</span>[type].<span class="title function_">indexOf</span>(handler)&gt;&gt;&gt;<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试：">测试：<a class="anchor" href="#测试：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myEvent = <span class="keyword">new</span> <span class="title function_">myEventEmitter</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">testHandler</span> = params =&gt; &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test事件被处罚了,参数是:&#x27;</span>+<span class="string">`<span class="subst">$&#123;params&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">myEvent.<span class="title function_">on</span>(<span class="string">&#x27;test&#x27;</span>, testHandler); <span class="comment">//监听</span></span><br><span class="line">myEvent.<span class="title function_">emit</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;newState&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="借助发布订阅实现AB通信">借助发布订阅实现AB通信<a class="anchor" href="#借助发布订阅实现AB通信">·</a></h5><p>在B中编写一个handler，在handler中进行this.setState的操作，然后将handler作为监听器的回调，与某事件（自定义）关联起来，在A组件中触发对应的事件，并将希望携带的参数入参传入即可。</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121125421211.png" alt="image-20211121125421211" style="zoom: 33%;" /><h4 id="3、Context-API">3、Context API<a class="anchor" href="#3、Context-API">·</a></h4><p>React天然提供的一种组件树的全局通信方式，16.3之后具备更强的可用性；</p><h5 id="1、Context-API工作流">1、Context API工作流<a class="anchor" href="#1、Context-API工作流">·</a></h5><p>Provider作为数据的提供方，可以将数据下发给自身组件树中任意层级的consumer；</p><p>consumer不仅能读取到provider下发的数据，还能读取到这些数据的更新；</p><p>因此，数据在生产者、消费者之间能够及时同步；</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121130228283.png" alt="image-20211121130228283" style="zoom:33%;" /><h5 id="2、使用">2、使用<a class="anchor" href="#2、使用">·</a></h5><ol><li><p>创建Context容器对象：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">XxxContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultVlaue);</span><br></pre></td></tr></table></figure></li><li><p>从创建的context中，可以读取到Provider、Comsumer</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">Provider</span>, <span class="title class_">Consumer</span>&#125; = <span class="title class_">XxxContext</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用Provider(数据的提供者)对组件树中的根组件进行包裹，然后传入<strong>value的属性</strong>，这个value就是后续在组件树中流动的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> value=&#123;数据&#125;&gt;</span><br><span class="line">子组件</span><br><span class="line">&lt;<span class="title class_">Title</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Contet</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>数据其实是字符串，如果你想传对象，或多个值，可以再包一个{}</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> value=&#123;&#123;username, age, height&#125;&#125;&gt;</span><br><span class="line">子组件</span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>这个Value可以被consumer消费，可以读取Provider下发的数据。前提是需要函数、类组件作为它的子组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Consumer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="params">value</span> =&gt;</span> ( <span class="comment">// value就是context中的value数据</span></span><br><span class="line">        要显示的内容</span><br><span class="line">  &lt;div&gt; &#123;value.<span class="property">title</span>&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/<span class="title class_">Consumer</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>当consumer没有对应的Provider时，会直接去创建的地方defaultValue查找；</li></ul></li></ol><h5 id="3、-新的context-API解决了什么问题">3、 新的context API解决了什么问题<a class="anchor" href="#3、-新的context-API解决了什么问题">·</a></h5><ul><li><p>过时的context API存在的问题：</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121134007115.png" alt="image-20211121134007115" style="zoom:33%;" /><ul><li>前两者提供生产者的角色；</li><li>contextTypes的成为消费者；</li></ul></li><li><p>缺点：</p><ol><li><p>代码不够优雅，不能很好辨别provider、cosumer</p></li><li><p>无法保证数据在生产者和消费者之间的及时同步，官网描述：</p><p>如果组件提供的一个context发生了变化，而中间父组件的shouldComponentUpdate返回了false，那么使用该组件的后代组件不会尽心更新。</p><p>返回了context的组件则完全失控，所以基本上没有办法能够可靠的更新context</p></li></ol></li><li><p>新的context解决了什么问题：</p><p>即使组件的shouldComponentUpdate返回了false，它依然可以**“穿透”**组件继续向后代进行传播，进而确保了数据生产者、数据消费者之间数据的一致性。</p></li></ul><h4 id="4、Redux">4、Redux<a class="anchor" href="#4、Redux">·</a></h4><p>官网描述：是JS的状态容器，它提供可预测的状态管理；Vue、React可以用</p><img src="https://tomoya92.github.io/assets/2021-04-29-09-56-16.png" alt="img" style="zoom:50%;" /><h5 id="1、角色：">1、角色：<a class="anchor" href="#1、角色：">·</a></h5><ul><li>store：单一的数据源，而且是只读的；</li><li>action：对变化的描述</li><li>reducer：负责对变化进行分发、处理</li></ul><p>在Redux的整个工作过程中，数据流是严格单向的，很重要一定要说！！！</p><ul><li>如果想修改数据，只有一种方式：派发action，action会被reducer读取，进而根据action的不同对数据修改，返回新的state，新的state会更新到store里，进而驱动视图层做出对应的改变；</li><li>因此，任何组件都可以通过store读取到全局的状态；也可以通过合理地派发action，来修改全局的状态。redux提供了状态容器，使得状态能够自由地在组件之间传播；这就是redux实现的思路。</li></ul><h5 id="2、redux工作流">2、redux工作流<a class="anchor" href="#2、redux工作流">·</a></h5><ol><li><p>createStore：使用createStore创建包含指定reducer的store对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)   <span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)   <span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)   <span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer)</span><br></pre></td></tr></table></figure></li><li><p>reducer的作用：将新的state返回给store</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span>=  (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> new_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>action:通知reducer，让改变发生</p><p>如何在众多的store状态库中，准确地希望他改变state呢？将action对比，因此必须要用正确的action</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;add_mm&#x27;</span>,</span><br><span class="line"><span class="attr">payload</span>: <span class="string">&quot;ss&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>action只是一个对象，要想让action真正产生动作，还要靠store的dispatch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(action);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue&amp;&amp;React的数据流管理</title>
      <link href="/posts/react_vue_data.html"/>
      <url>/posts/react_vue_data.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redux">Redux<a class="anchor" href="#Redux">·</a></h2><h3 id="1、Flux">1、Flux<a class="anchor" href="#1、Flux">·</a></h3><p>redux的问题背景和架构思想是什么？</p><p>虽然它并不严格遵循flux的设定，但Redux可被认定为Flux的一种实现方式</p><h4 id="1、Flux4部分">1、Flux4部分<a class="anchor" href="#1、Flux4部分">·</a></h4><p>有FB提出的一套应用架构，并不是一套具体的框架，这套架构约束的是“应用处理数据的模式”。</p><p><strong>把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测</strong>。</p><p>在Flux架构中，一个应用被拆解为4部分：</p><ul><li><h4 id="View：用户界面，可以以任何形式展示">View：用户界面，可以以任何形式展示<a class="anchor" href="#View：用户界面，可以以任何形式展示">·</a></h4><ol><li>特性：store改变了VIew也要跟着改变</li><li>如何改变view：一般 Store 一旦发生改变，都会往外面发送一个事件，比如 change，通知所有的订阅者。View 通过订阅也好，监听也好，不同的框架有不同的技术，反正 Store 变了，View 就会变。</li></ol></li><li><h4 id="Action：视图层发出的消息，会触发应用状态的改变">Action：视图层发出的消息，会触发应用状态的改变<a class="anchor" href="#Action：视图层发出的消息，会触发应用状态的改变">·</a></h4><ol><li>必须经过一套流程，视图先要通过action告诉 Dispatcher，让 Dispatcher dispatch 一个 action</li><li>Dispatcher 会把 addUser 这个 action 发给所有的 store，store 就会触发 addUser 这个 action，来更新数据</li><li>数据一更新，那么 View 也就跟着更新了</li></ol></li><li><h4 id="Dispatcher：派发器，负责action的派发">Dispatcher：派发器，负责action的派发<a class="anchor" href="#Dispatcher：派发器，负责action的派发">·</a></h4></li><li><h4 id="store：数据层，应用状态的仓库，此外还定义修改状态的逻辑">store：数据层，应用状态的仓库，此外还定义修改状态的逻辑<a class="anchor" href="#store：数据层，应用状态的仓库，此外还定义修改状态的逻辑">·</a></h4></li></ul><h4 id="2、Flux工作流">2、Flux工作流<a class="anchor" href="#2、Flux工作流">·</a></h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/18/167c11c13ef4e9a8~tplv-t2oaga2asx-watermark.awebp" alt="image.png | center | 827x250" style="zoom:50%;" /><ol><li>用户与 view之间产生交互，通过view发起一个action，通过dispatch会把该action派发给store，通过store相应的状态更新</li><li>store完成更新后，会进一步通知View更新界面；</li></ol><p>【注意】：图中的箭头都是单向的，这也是Flux架构一个特点，<strong>单向数据流</strong></p><h4 id="3、Flux解决了什么">3、Flux解决了什么<a class="anchor" href="#3、Flux解决了什么">·</a></h4><p>Flux的核心特征是：<strong>单向数据流</strong>，那么双向数据流会有什么问题呢？</p><ol><li><p>典型应用场景：MVC架构，</p><ul><li><p>除了通过用户通过view层来触发数据以外，还可以通过control来触发逻辑</p></li><li><p>model：程序需要操作的数据或信息；</p></li><li><p>view视图：视图</p></li><li><p>controller：控制器，用于连接view和model，管理model与view之间的逻辑</p></li><li><p>用户操作view后，control来处理逻辑，将改变应用到model上，再反馈到view中，这个过程中，是单向的。在服务端的应用中，数据流确实能够保持单向。但是在前端场景下，处于交互的需要往往允许view和model进行直接通信。这就允许了数据流的存在，当业务场景比较复杂时，数据流就会比较混乱，出现这样：</p><p>这样即使一个小小的修改，也可能造成蝴蝶效应问题。因为你很难区分数据是哪个control，哪个view引发的。</p></li></ul></li><li><p><strong>而Flux的架构模式，最核心的是严格的单向数据流，在单向数据流下，状态的变化是可预测的，避免了混乱的数据结构</strong></p></li><li><p>缺点：</p><ol><li><p>对数据流约束的背后是成本，因此也只在大型的项目中才会使用，这一点对redux也是一样的。</p><p>Store 封装了数据还有处理数据的逻辑等等</p></li><li><p>比如一个应用可以拥有多个 Store，多个Store之间可能有依赖关系；</p></li></ol></li></ol><h3 id="2、Redux">2、Redux<a class="anchor" href="#2、Redux">·</a></h3><p>它与Flux设计思想上一脉相承</p><p>官网描述：是JS的状态容器，它提供可预测的状态管理；Vue、React可以用</p><img src="https://tomoya92.github.io/assets/2021-04-29-09-56-16.png" alt="img" style="zoom:50%;" /><h4 id="1、角色：-2">1、角色：<a class="anchor" href="#1、角色：-2">·</a></h4><ul><li>store：单一的数据源，而且是只读的；</li><li>action：对变化的描述</li><li>reducer：负责对变化进行分发、处理</li></ul><p>在Redux的整个工作过程中，数据流是严格单向的，很重要一定要说！！！</p><ul><li>如果想修改数据，只有一种方式：派发action，action会被reducer读取，进而根据action的不同对数据修改，返回新的state，新的state会更新到store里，进而驱动视图层做出对应的改变；</li><li>因此，任何组件都可以通过store读取到全局的状态；也可以通过合理地派发action，来修改全局的状态。redux提供了状态容器，使得状态能够自由地在组件之间穿梭；这就是redux实现的思路。</li></ul><h4 id="2、redux工作流-2">2、redux工作流<a class="anchor" href="#2、redux工作流-2">·</a></h4><ol><li><p>createStore：使用createStore创建包含指定reducer的store对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)   <span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="number">2</span>)   <span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="number">3</span>)   <span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer)</span><br></pre></td></tr></table></figure></li><li><p>reducer的作用：将新的state返回给store</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span>=  (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> new_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>action:通知reducer，让改变发生</p><p>如何在众多的store状态库中，准确地希望他改变state呢？将action对比，因此必须要用正确的action</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;add_mm&#x27;</span>,</span><br><span class="line"><span class="attr">payload</span>: <span class="string">&quot;ss&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>action只是一个对象，要想让action真正产生动作，还要靠store的dispatch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(action);</span><br></pre></td></tr></table></figure></li></ol><h3 id="3、redux源码分析">3、redux源码分析<a class="anchor" href="#3、redux源码分析">·</a></h3><ul><li>utils文件夹：工具方法库</li><li>index.js：入口文件，主要做模块导出</li><li>真正干活的文件：<ul><li>applyMiddleWare.js：中间件模块，将在后面单独讲解</li><li>bingActionCreator.js：用于将传入的actionCreator与dispatch方法相结合，揉成一个新的方法。工具性质的方法（即使不理解它也不影响了解redux）</li><li>combineReducer.js：用于将多个reducer合并起来。工具性质的方法</li><li>compose.js：用于把接收到的函数，从右向左进行结合。工具性质的方法</li><li><strong>createStore.js：了解redux的主要模块。使用redux最先调用的方法，是整个流程的入口，也是Redux中最核心的API</strong></li></ul></li></ul><h4 id="1、createStore-js分析">1、createStore.js分析<a class="anchor" href="#1、createStore-js分析">·</a></h4><ul><li>使用</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,   </span><br><span class="line">  initial_state, <span class="comment">//初始状态内容</span></span><br><span class="line">  <span class="title function_">applyMiddleware</span>(middleware1, middleware2,...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>源码截图<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225633907.png" alt="image-20211127225633907" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225732058.png" alt="image-20211127225732058" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225800737.png" alt="image-20211127225800737" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230121583.png" alt="image-20211127230121583" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230134769.png" alt="image-20211127230134769" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230309854.png" alt="image-20211127230309854" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230558433.png" alt="image-20211127230558433" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230626348.png" alt="image-20211127230626348" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230634791.png" alt="image-20211127230634791" style="zoom:15%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230646868.png" alt="image-20211127230646868" style="zoom:15%;" /></li></ul><h5 id="1、整体流程">1、整体流程<a class="anchor" href="#1、整体流程">·</a></h5><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230657392.png" alt="image-20211127230657392" style="zoom: 33%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230746655.png" alt="image-20211127230746655" style="zoom:33%;" /><ul><li><p>与redux主流程强相关的，也是使用较多的：getState、subscribe、dispatch</p><p>getState的源码：</p><p>subscribe、dispatch：关键的分发动作，最核心的</p></li></ul><h4 id="2、dispatch">2、dispatch<a class="anchor" href="#2、dispatch">·</a></h4><h5 id="源码">源码<a class="anchor" href="#源码">·</a></h5><p>redux关键要素：action   reducer   store    而dispatch刚好能够将这三位主角串起来：</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230309854.png" alt="image-20211127230309854" style="zoom:20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230558433.png" alt="image-20211127230558433" style="zoom:20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230626348.png" alt="image-20211127230626348" style="zoom:20%;" /></p><h5 id="dispatch核心工作流">dispatch核心工作流<a class="anchor" href="#dispatch核心工作流">·</a></h5><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127232248297.png" alt="image-20211127232248297" style="zoom:25%;" /><p><strong>通过上锁避免套娃式的dispatch</strong></p><p>最关键的是执行reducer，它通过reducer的更新规则，指定了应用状态的变化如何响应action，并发送到store。currentReducer包裹的try部分代码</p><ul><li><p>在调用dispatch之前会通过isDispatching变量设置为true，待reducer执行完毕后，再将isDispatching变量设置为false；这跟setState的批处理也很相似</p></li><li><p>这里这样做的目的是：<strong>避免套娃式的dispatch</strong>，也就是避免开发者在开发中手动调用dispatch</p></li><li><p><strong>为什么要这样设计呢？</strong></p><p>redux在设计reducer时就强调了它必须是纯净的，它不应该执行除了计算之外的任何脏操作。dispatch是一个脏操作；</p><p>其次从执行的角度看，若真的在reducer中调用dispatch，那么dispatch又会返过来调用reducer、reducer又会再次调用，陷入死循环。</p><p>因此，在dispatch中做了if判断，一旦识别isDispatching为true，直接抛错</p></li></ul><h4 id="3、subscribe触发订阅">3、subscribe触发订阅<a class="anchor" href="#3、subscribe触发订阅">·</a></h4><p>在reducer执行完毕后，会触发订阅执行的过程。</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230626348.png" alt="image-20211127230626348" style="zoom:20%;" /><ul><li><p>subscribe这个API执行订阅。接收一个function类型的listener做入参，返回是对应listener的解绑函数</p><p>因为redux中已经默认了订阅的对象就是<strong>状态的变化</strong>，准确来说是dispatch函数的调用这个事件</p></li><li><p>subscribe的工作流程：</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127234248963.png" alt="image-20211127234248963" style="zoom:25%;" /></li></ul><p><strong>问题：</strong></p><ol><li><p><strong>subscribe是如何与redux主流程相结合的呢？</strong></p><p>在store对象创建成功后，通过调用store.subscribe来注册监听函数，也可以通过subscribe的返回函数来解绑监听函数。</p><p>listeners数组用来维护监听函数。</p><p>当diapatch action发生变化时，redux会在reducer执行完毕后，将listeners数组中的监听函数逐个执行。</p></li><li><p>为什么会有currentListeners、nextListeners这两个数组呢？</p><p>redux中的订阅过程和发布过程是如何处理数组的？</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nextListeners = currentListeners;<span class="comment">// 二者指向同一个引用</span></span><br></pre></td></tr></table></figure><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225732058.png" alt="image-20211127225732058" style="zoom: 25%;" /><ul><li><p>但ensureCanMutateNextListener每次都会在注册listener之前无条件调用：用来确保两个数组引用不同。</p></li><li><p>在这个函数执行的是listener的注册逻辑： nextListener.push(listener)，注册到这个数组中。</p></li><li><p>触发订阅的逻辑：</p><p>在触发订阅的过程中，currentListeners会被赋值为nextListener，而即将被执行的数组listeners又被赋值为currentListeners。因此最终被执行的数组指向nextListener的同一个引用。</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230626348.png" alt="image-20211127230626348" style="zoom:20%;" /><p>既然注册监听使用nextListener、触发订阅也是nextListener。<strong>为什么还需要currentListeners数组呢？</strong></p><p>currentListeners用于确保监听函数执行过程中的稳定性。因为任何变更都是在nextListener上发生的，因此需要一个不会被变更的稳定的listener保证不出乱子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">listenerA</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> unSubscribeA = store.<span class="title function_">subscribe</span>(listenerA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listenerB</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">unSubscribeA</span>();<span class="comment">//在B中解绑A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listenerC</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">store.<span class="title function_">subscribe</span>(listenerB);<span class="comment">//订阅B</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(listenerC);<span class="comment">//订阅C</span></span><br></pre></td></tr></table></figure><ul><li><p>这种操作在redux是合法的。执行完毕后，listeners数组中[listenerA,  listenerB, listenerC]</p></li><li><p>触发订阅逻辑：遍历listener数组，分别执行自己的函数。而listenerB中执行了unSubscribeA这个动作，而监听、触发、解绑触发影响的都是nextListener数组</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127230134769.png" alt="image-20211127230134769" style="zoom: 25%;" /></li><li><p>假如不要currentListeners这个数组，也就不需要执行解绑函数中的ensureCanMutateNextListener这个调用。而没有这个动作，unSubscribeA执行完之后，listenerA会同时从listeners数组和nextListener数组中移除，那么listeners数组就只剩下listenerB、listenerC。也就是listeners数组的长度发生了改变，但for循环并不会感知到，它将继续循环下去。下一步索引对应的会出现undefined，进而导致函数异常。</p></li></ul></li><li><p>那怎么办呢？</p><ul><li><p>因此需要将当前正在执行的listeners数组与nextListener数组隔离开，将两者指向不同的引用。这也是ensureCanMutateNextListener所执行的事情，这个函数执行前：三者关系：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">listeners === nextListener === currentListeners</span><br></pre></td></tr></table></figure><p>执行后：nextListener上的任何改变都无法再影响正在执行中的listeners。而currentListeners就是为了记录下当前正在工作中的listeners数组的引用，将它与可能发生改变的nextListener区分开来，以确保监听函数在执行过程中的稳定性</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">nextListener = currentListeners.<span class="title function_">slice</span>()</span><br><span class="line">listeners === nextListener !== currentListeners</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="4、redux中间件">4、redux中间件<a class="anchor" href="#4、redux中间件">·</a></h3><h4 id="1、用法-5">1、用法<a class="anchor" href="#1、用法-5">·</a></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,   </span><br><span class="line">  initial_state, <span class="comment">//初始状态内容</span></span><br><span class="line">  <span class="title function_">applyMiddleware</span>(middleware1, middleware2,...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2、中间件的引入，为redux工作流带来什么改变？">2、中间件的引入，为redux工作流带来什么改变？<a class="anchor" href="#2、中间件的引入，为redux工作流带来什么改变？">·</a></h4><ul><li><p>redux-thunk  经典的<strong>异步action场景</strong></p><p>在redux源码中可以看出，只有同步操作，当我们dispatch一个action时，会立即更新，因此如果想在redux中引入异步数据流，该怎么办？</p><p>使用中间件来支持，其中最受欢迎的是redux-thunk</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thunkMiddleWare <span class="keyword">for</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, <span class="title function_">applyMiddleware</span>(thunkMiddleware));</span><br></pre></td></tr></table></figure></li><li><p>异步action的例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">for</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, <span class="title function_">applyMiddleware</span>(thunk));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">payMoney</span> = payInfo =&gt; <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;payStart&#x27;</span>&#125;);</span><br><span class="line">  <span class="title function_">fetch</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;./api/payMoney&#x27;</span>, &#123;</span><br><span class="line">    payInfo</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;paySuccess&#x27;</span>&#125;);<span class="comment">//付款成功</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;payError&#x27;</span>&#125;); <span class="comment">// 付款失败</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payInfo = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;ss&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">  <span class="attr">count</span>: <span class="number">5</span>,</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意action是函数这里</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">payMoney</span>(payInfo));</span><br></pre></td></tr></table></figure><ul><li>createStore的源码中，初始化时会检查中间件，使得即使写在第2个参数也可以识别</li></ul></li></ul><p>dispatch的入参从action对象，变成了一个函数，源码中是有校验的action入参必须是一个对象，thunk似乎绕开了这层校验，为什么呢？</p><h4 id="3、redux中间件的工作流程">3、redux中间件的工作流程<a class="anchor" href="#3、redux中间件的工作流程">·</a></h4><ul><li><p>当只有一个中间件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action -- middleWare -- dispatch -- reducer -- nextState</span><br></pre></td></tr></table></figure><p>middleWare会在action分发之后，到达reducer之前执行；</p></li><li><p>当有多个中间件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action -- middleWare1 （安装的执行顺序）</span><br><span class="line"> -- middleWare2</span><br><span class="line"> -- middleWare3...</span><br><span class="line">-- dispatch -- reducer -- nextState</span><br></pre></td></tr></table></figure><p>中间件的执行时机使得它能在状态正在发生之前结合action信息，做一些自己的处理。</p></li><li><h5 id="中间件如何绕过主流程的校验逻辑呢？">中间件如何绕过主流程的校验逻辑呢？<a class="anchor" href="#中间件如何绕过主流程的校验逻辑呢？">·</a></h5><p>其实并没有被绕过，而是被<strong>applyMiddleWare</strong>改写了，使得dispatch，在触发reducer之前首先执行对redux中间件的链式调用</p></li></ul><h3 id="5、redux-thunk源码">5、redux-thunk源码<a class="anchor" href="#5、redux-thunk源码">·</a></h3><p>主要做的事情：</p><ul><li><p>在拦截到action后，会检查它是否为一个函数：</p><p>若为函数，就会执行它；并且返回执行结果</p><p>若不是函数，就不处理它，直接调用next，工作流可以继续往下走</p></li></ul><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128140700555.png" alt="image-20211128140700555" style="zoom:25%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128141206440.png" alt="image-20211128141206440" style="zoom:25%;" /></p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211127225633907.png" alt="image-20211127225633907" style="zoom:15%;" /><ol><li><p><strong>applyMiddleWare</strong>是如何配合createStore工作的？</p><ul><li><p><strong>applyMiddleWare</strong>返回的是一个接收createStore作为入参的函数，这个函数将会作为入参传递给createStore</p></li><li><p>createStore中，会判断enhancer存在，就会返回一个针对enhancer的调用，调用中第一层入参是createStore，第二层入参是reducer、preloadedState</p></li><li><p>对应到applymiddelware中的逻辑：</p><p>这个函数中的return 的createStore对应createStore本身，args对应的就是reducer、preloadedState</p></li><li><p>applyMiddeware是enhancer的一种，而enhancer的意思是增强，增强的是createStore的能力。因此入参是传入这个函数是有必要的</p></li></ul><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128141742510.png" alt="image-20211128141742510" style="zoom:20%;" /><ol start="2"><li><p>dispatch函数是如何改写的？</p><p>做了两件事，以，，aPI作为入参逐个调用传入的middleWare函数，获取一个由内层函数组成的数组chain；</p><p>然后调用compose函数，将内层函数逐个组合起来。并调用最终组合出来的函数</p><p>内层函数：creatThunk函数的返回值 return next(action) 仍然是一个函数，高阶函数，要求redux中间节都是高阶函数，内层的就是内层函数。</p></li></ol><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128141804611.png" alt="image-20211128141804611" style="zoom:20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128141819905.png" alt="image-20211128141819905" style="zoom:20%;" /></li><li><p>compose函数是如何组合起来的？</p></li></ol><p><strong>redux中间件是如何实现的？</strong></p><p>​<strong>函数合成（组合函数</strong>）并不是redux的专利，而是<strong>函数式编程</strong>中的一个通用概念，它其实作为一个工具类的文件存在。源码：</p><ul><li><p>函数组合是通过调用reduce来实现的；特点是对数组中每个元素执行指定的逻辑，并将结果汇总为单个返回值。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">(...args) =&gt; <span class="title function_">f1</span>(<span class="title function_">f2</span>(<span class="title function_">f3</span>(<span class="title function_">f4</span>(...args)))) <span class="comment">//最后一行等效为</span></span><br></pre></td></tr></table></figure></li></ul><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211128020307931.png" alt="image-20211128020307931" style="zoom:25%;" /><h3 id="6、中间件背后的AOP">6、中间件背后的AOP<a class="anchor" href="#6、中间件背后的AOP">·</a></h3><ol><li>为什么中间件可以流行？</li><li>为什么我们的应用需要中间件？</li></ol><p>AOP的存在恰恰是为了解决OOP的局限性。AOP可以被看成是OOP的补充，在OOP模式下，想要拓展一个类的逻辑时，最常见的思路是：</p><ul><li>Class A继承Class B  classB继承classC，这样一层层 将逻辑向下传递</li><li>当我们想要为某几个类追加一段共同的逻辑时，可以通过修改他们的父类来实现，这会导致公共类越来越臃肿。但也没有更好的办法</li></ul><p>面向切面就登场了。切面是一个相对于执行流程来说的概念，以redux为例，其自上而下的工作流：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action</span><br><span class="line"> reducer</span><br><span class="line"> store</span><br></pre></td></tr></table></figure><ul><li>假如在每个action被派发后，都打印一个action被派发的记录，这样的逻辑通用性很强，但业务属性很弱，因此不适合与任何的业务逻辑耦合在一起。因此就可以以切面的方式，将其与业务功能剥离开来。扩展功能在工作流中的执行节点可以看做一个单独切点，我们把扩展功能的逻辑放到这个切点上来，形成的就是一个可以拦截连续逻辑的切面，如下图：</li><li>切面与业务逻辑是分离的，因此AOP是一种典型的非侵入式的逻辑扩容思路。在日常开发中，日志追溯、性能打点、异步工作流处理这种和业务逻辑关系不大的功能，都可以抽取到切面中去做。</li></ul><p>切面编程的收益？</p><ol><li>可以很大程度上提升了组织逻辑的灵活度与干净度、帮助了我们规避掉了逻辑冗余、逻辑耦合问题</li><li>通过将业务逻辑与切面剥离，更高地专注与开发。而切面这种即插即用的方式，自由组织想要的扩展功能</li></ol><h3 id="7、Vuex">7、Vuex<a class="anchor" href="#7、Vuex">·</a></h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/18/167c11c13fc70df1~tplv-t2oaga2asx-watermark.awebp" alt="image.png | center | 701x551" style="zoom: 50%;" /><h4 id="1、Vuex的设计">1、Vuex的设计<a class="anchor" href="#1、Vuex的设计">·</a></h4><ul><li><h5 id="五个核心属性：state、mutations、actions、Getter、modules">五个核心属性：state、mutations、actions、Getter、modules<a class="anchor" href="#五个核心属性：state、mutations、actions、Getter、modules">·</a></h5></li><li><p>把同步和异步拆分开，不要互相干涉</p></li><li><p>store的改变流程：</p><p><strong>在 vuex 中只有 mutations 可以更新state</strong></p><ul><li>commit 一个 mutation，mutation 负责更改 state（store状态更新的唯一方式）</li><li>dispatch 一个 action，在 action 中 commit 一个 mutation</li></ul></li><li><p>引入 Getter，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性</p></li><li><p>引入 Module 的概念，把一个大 Store 拆开，每个 Module 有自己的 state、mutation、action、getter：</p></li></ul><h4 id="1、Store">1、Store<a class="anchor" href="#1、Store">·</a></h4><ul><li>每一个 Vuex 里面有一个全局的 Store，包含着应用中的状态 <strong>State</strong></li><li>Vuex通过 store 选项，把 state 注入到整个应用中，这样子组件能通过 this.$store 访问到 state 了</li><li><strong>State 改变，View 就会跟着改变，这个改变利用的是 Vue 的响应式机制</strong></li></ul><h4 id="2、Mutation-同步-store状态更新的唯一方式">2、Mutation           同步    store状态更新的唯一方式<a class="anchor" href="#2、Mutation-同步-store状态更新的唯一方式">·</a></h4><ul><li><h5 id="改变state的唯一方法是提交commit来触发-mutations">改变state的唯一方法是提交commit来触发_mutations<a class="anchor" href="#改变state的唯一方法是提交commit来触发-mutations">·</a></h5></li><li><p>每个 mutation 都有一个字符串的 事件类型和 一个 回调函数</p></li><li><p>mutation 有些类似 Redux 的 Reducer，<strong>但Vuex直接修改 State</strong></p><ol><li><strong>Redux 强调的 immutability</strong>，在保证了每一次状态变化都能追踪，收益很有限</li><li>为了同构而设计的 API 很繁琐，必须依赖第三方库才能相对高效率地获得状态树的局部状态，这些不足的地方，所以也被 Vuex 舍掉了</li></ol></li></ul><h4 id="3、假如在mutation里面提交异步">3、假如在mutation里面提交异步<a class="anchor" href="#3、假如在mutation里面提交异步">·</a></h4><h5 id="1、问题、坑">1、问题、坑<a class="anchor" href="#1、问题、坑">·</a></h5><ul><li><p>提交的时候页面状态view发生变化，但是真正的状态是没有变化的，<strong>页面改变了</strong>，<strong>而devtool工具里面的state状态不一致</strong> 如下面图片</p></li><li><p>在/src/store/index.js 的mutations里面模拟异步发现状态是混乱的<img src="https://segmentfault.com/img/remote/1460000011528057?w=1406&amp;h=538" alt="image_1bs7rnpdd1slf119n1k6k1ltt1o8m9.png-73.7kB" style="zoom:50%;" /></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">num</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="comment">// 任何时候改变state的状态都通过提交 mutation 来改变</span></span><br><span class="line">        <span class="comment">// 里面可以定义多个函数，当触发这个函数就会改变state状态</span></span><br><span class="line">        <span class="title function_">addIncrement</span>(<span class="params">state, stark</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(stark);</span><br><span class="line">            <span class="comment">// 接收一个state作为参数， 相当于上面的state</span></span><br><span class="line">            <span class="comment">// 模拟异步，状态会发生混乱</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                state.<span class="property">num</span> += stark.<span class="property">n</span>;</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">minIncrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">            state.<span class="property">num</span> -= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h5 id="2、解决：">2、解决：<a class="anchor" href="#2、解决：">·</a></h5><ol><li>在组件里面利用this.$store.dispatch(“addAction”); 提交actions</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;加减法计算器&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;-&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;minHandle&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;+&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;addHandle&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">computed</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">num</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">num</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">addHandle</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// this.num += 5;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 点击的时候需要改变状态，提交mutation addIncrement</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 利用$store.commit 里面 写参数相当于 mutation的函数名字</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// this.$store.commit(&quot;addIncrement&quot;,&#123;name:&#x27;stark&#x27;,age:18,n:5&#125;)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// this.$store.commit(&#123;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">//     type:&quot;addIncrement&quot;,</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">//     n:5,</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">//     age:18,</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">//     name:&#x27;stark.wang&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// &#125;)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;addAction&quot;</span>); <span class="comment">// 在这提交 actions</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">minHandle</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// this.num -= 5;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;minIncrement&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// this.$store.         </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="3、为什么呢？">3、为什么呢？<a class="anchor" href="#3、为什么呢？">·</a></h5><ul><li><p>在vuex里，改变state的唯一方法是提交commit来触发_mutations，而调用actions时会判断是不是Promise，调用异步处理，你在mutations里写情求他都不会跑then方法，你怎么改变</p></li><li><h5 id="源码：">源码：<a class="anchor" href="#源码：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个就是 Store 类的 commit 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commit</span> (_type, _payload, _options) &#123;</span><br><span class="line">    <span class="comment">// check object-style commit</span></span><br><span class="line">    <span class="keyword">const</span> &#123;type, payload, options&#125; = <span class="title function_">unifyObjectStyle</span>(_type, _payload, _options)</span><br><span class="line">    <span class="comment">// 定义mutation对象，type 其实就是我们要操作的 mutation 的方法名， payload 是参数（载荷）</span></span><br><span class="line">    <span class="keyword">const</span> mutation = &#123; type, payload &#125;</span><br><span class="line">    <span class="comment">// entry 就是要被执行的 mutation 方法</span></span><br><span class="line">    <span class="keyword">const</span> entry = <span class="variable language_">this</span>.<span class="property">_mutations</span>[type]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略了一些中间不影响逻辑的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册一些回调函数，可以看到 mutation 方法（entry）最终是在这个回调函数中执行，直接就执行结束，没有任何的 return 以及 异步处理，这样也就是说在 commit 中不可以写异步逻辑</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_withCommit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        entry.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">commitIterator</span> (handler) &#123;</span><br><span class="line">            <span class="title function_">handler</span>(payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_subscribers</span></span><br><span class="line">    .<span class="title function_">slice</span>() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> <span class="title function_">sub</span>(mutation, <span class="variable language_">this</span>.<span class="property">state</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、在组件中执行异步操作，在异步的回调中执行commit可以吗？">4、在组件中执行异步操作，在异步的回调中执行commit可以吗？<a class="anchor" href="#4、在组件中执行异步操作，在异步的回调中执行commit可以吗？">·</a></h5><p>可以，但是一般不这么做</p><ul><li><p>state状态更新逻辑是可复用的，但是如果把这部分逻辑写在了组件内：</p><p>比如写在了组件A中，这时候另外一个组件B也需要更新这个状态，你就需要把组件A中的那段异步代码复制到组件B中</p><p>这个不是一个合理的方式（代码冗余，应该将公共逻辑抽离出来），虽然可以这么做，但是不推荐</p></li></ul><h4 id="4、vuex中为什么把异步操作封装在action，把同步操作放在mutations？">4、vuex中为什么把异步操作封装在action，把同步操作放在mutations？<a class="anchor" href="#4、vuex中为什么把异步操作封装在action，把同步操作放在mutations？">·</a></h4><ul><li><p>官方文档说明：“在 mutation 中混合异步调用会导致你的程序很难调试</p><p>例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念</p><p>在 Vuex 中，我们将全部的改变都用同步方式实现。我们将全部的异步操作都放在<a href="https://link.zhihu.com/?target=http%3A//vuex.vuejs.org/zh-cn/actions.html">Actions</a>中。”</p></li><li><p>如果同时出发了两个异步的actions，那么这两个回调的时间不一样，那么对于state的更新还是存在竞态的。所以我觉得这样进行区分并不能解决“那么先回调，哪个后回调”来更新state的问题</p></li><li><p>尤大的回答：区分 actions 和 mutations 并不是为了解决竞态问题，而是为了能用 devtools 追踪状态变化</p><ol><li><p>vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行</p></li><li><p>异步竞态怎么处理那是用户自己的事情。vuex 真正限制你的只有 mutation 必须是同步的这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）</p></li><li><p>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了</p></li><li><p>如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态</p></li><li><p>尤大没有做的：</p><p>把记录下来的 mutations 做成类似 rx-marble 那样的时间线图，对于理解应用的异步状态变化很有帮助</p></li></ol></li></ul><h4 id="5、Action">5、Action<a class="anchor" href="#5、Action">·</a></h4><ul><li><h5 id="源码：-2">源码：<a class="anchor" href="#源码：-2">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatch</span> (_type, _payload) &#123;</span><br><span class="line">    <span class="comment">// check object-style dispatch</span></span><br><span class="line">    <span class="keyword">const</span> &#123;type,payload&#125; = <span class="title function_">unifyObjectStyle</span>(\type, _payload)</span><br><span class="line">    <span class="comment">// 定义 action 对象，type 是 actions 对象中的一个属性，payload 是载荷</span></span><br><span class="line">    <span class="keyword">const</span> action = &#123; type, payload &#125;</span><br><span class="line">    <span class="comment">// 待执行的 action 方法</span></span><br><span class="line">    <span class="keyword">const</span> entry = <span class="variable language_">this</span>.<span class="property">_actions</span>[type]</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_actionSubscribers</span></span><br><span class="line">        .<span class="title function_">slice</span>() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">        .<span class="title function_">filter</span>(<span class="function"><span class="params">sub</span> =&gt;</span> sub.<span class="property">before</span>)</span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> sub.<span class="title function_">before</span>(action, <span class="variable language_">this</span>.<span class="property">state</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里执行了 action 方法，并将结果用 Promise.all 方法处理</span></span><br><span class="line">    <span class="keyword">const</span> result = entry.<span class="property">length</span> &gt; <span class="number">1</span></span><br><span class="line">    ? <span class="title class_">Promise</span>.<span class="title function_">all</span>(entry.<span class="title function_">map</span>(<span class="function"><span class="params">handler</span> =&gt;</span> <span class="title function_">handler</span>(payload)))</span><br><span class="line">    : entry[<span class="number">0</span>](payload)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 result.then 执行完以后会 return 一个结果出去（其实就是我们自己调用的异步逻辑的结果）</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_actionSubscribers</span></span><br><span class="line">            .<span class="title function_">filter</span>(<span class="function"><span class="params">sub</span> =&gt;</span> sub.<span class="property">after</span>)</span><br><span class="line">            .<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> sub.<span class="title function_">after</span>(action, <span class="variable language_">this</span>.<span class="property">state</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6、对比Redux">6、对比Redux<a class="anchor" href="#6、对比Redux">·</a></h4><ul><li><p>Redux： view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样）</p></li><li><p>Vuex： view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）</p><p>​             view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作）</p></li></ul><h4 id="3者总的思想：">3者总的思想：<a class="anchor" href="#3者总的思想：">·</a></h4><p><strong>总的来说都是让 View 通过某种方式触发 Store 的事件或方法，Store 的事件或方法对 State 进行修改或返回一个新的 State，State 改变之后，View 发生响应式改变</strong></p>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据流管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue&amp;&amp;React的路由管理</title>
      <link href="/posts/%E8%B7%AF%E7%94%B1.html"/>
      <url>/posts/%E8%B7%AF%E7%94%B1.html</url>
      
        <content type="html"><![CDATA[<h2 id="react-router">react-router<a class="anchor" href="#react-router">·</a></h2><p>最基本、核心的能力：路由跳转；3个重要部分：</p><ul><li><strong>路由器</strong>：BrowserRouter、HashRouter。根据Route定义的映射关系，为新路径匹配它对应的逻辑</li><li>路由：Route、switch。负责定义路径与组件之间的映射关系</li><li>导航：Link、NavLink、Redirect。负责触发路径的改变</li></ul><h3 id="1、路由器简介">1、路由器简介<a class="anchor" href="#1、路由器简介">·</a></h3><p>路由器是整个路由系统中最终重要功能。它负责感知路由的变化并作出反应。react-roter中支持两种路由器：BrowserRouter、HashRouter</p><p>两种路由器的不同仅在于调用的history不同。这两个API源码中</p><ul><li>BrowserRouter在浏览器中使用H5的history API来控制路由跳转：</li><li>HashRouter通过控制URL的hash属性来控制路由跳转的。</li></ul><h3 id="2、为什么需要路由？产生背景">2、为什么需要路由？产生背景<a class="anchor" href="#2、为什么需要路由？产生背景">·</a></h3><p>什么是路由、它能解决什么问题</p><h4 id="1-后端路由时代：">1. 后端路由时代：<a class="anchor" href="#1-后端路由时代：">·</a></h4><ul><li><p>在前后端不分离时代，一个url对应一个页面。</p></li><li><p>由<strong>后端来控制路由</strong>，当接收到客户端发来的   <code>HTTP</code> 请求，就会<strong>根据所请求的相应 <code>URL</code>，来找到相应的映射函数</strong>，然后执行该函数，并将函数的返回值发送给客户端</p></li><li><p>举例：请求页面：<code>http://www.xxx.com/login</code>，大致流程：</p><ol><li>浏览器发出请求</li><li>服务器监听到80端口（或443）有请求过来，并解析url路径</li><li>根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）</li><li>浏览器根据数据包的 Content-Type 来决定如何解析数据</li></ol><img src="http://www.conardli.top/img/wl/wlqq_1.png" alt="image" style="zoom: 67%;" /><ul><li><p><strong>好处：安全性好，<code>SEO</code> 好；</strong></p></li><li><p><strong>缺点：</strong></p><ol><li>加大服务器的压力</li><li>任何和服务器的交互都需要刷新页面，<strong>用户体验</strong>非常差     <strong>Ajax解决了它</strong></li><li>代码冗合不好维护；</li></ol></li></ul></li></ul><h4 id="2-前后端分离时代">2. 前后端分离时代<a class="anchor" href="#2-前后端分离时代">·</a></h4><ul><li><p><strong>Ajax：</strong></p><p>概念：<code>Async JavaScript And XML</code>，浏览器的<code>XMLHttpRequest</code>是实现<code>Ajax</code>最重要的对象，通过XHR对象获取数据后，可以使用DOM方法将数据插入到网页中</p></li><li><p><strong>最大优势特点</strong>：页面<strong>不刷新</strong>的情况下与服务器通信，异步交互体验好</p></li><li><p><strong>缺点：</strong></p><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源策略限制）</li><li>SEO不友好</li></ol></li></ul><h4 id="3-SPA">3. SPA<a class="anchor" href="#3-SPA">·</a></h4><p>在ajax的背景下，出现了SPA</p><ul><li><p>SPA 允许页面在不刷新的情况下更新页面内容，内容的切换更流畅</p></li><li><p>但SPA的问题：定位的问题</p><p>页面切换前后，页面的url都是一样的，这就导致了两个问题</p><ol><li>SPA并不知道：当前页面当前页面“进展到哪一步”，刷新页面之后，你必须重复之前的操作，才可以重新对内容进行定位，SPA并不会记住你的操作。</li><li>SPA有且仅有一个URL给页面做映射，这对SEO并不友好</li></ol></li></ul><h4 id="4-前端路由">4. 前端路由<a class="anchor" href="#4-前端路由">·</a></h4><p>它解决了SPA的什么问题呢？</p><ul><li><p>它可以帮助我们在仅有一个页面的情况下，<strong>记住用户走到了哪一步？</strong></p></li><li><p>它为各个SPA中的各个视图匹配唯一标识，这时候用户前进后退触发的新内容都映射到URL上去，此时即便刷新页面，当前的URL也可以标识出它所在的位置，因此内容也不会丢失</p></li></ul><p>是如何解决的呢？</p><ul><li><p>**解决问题1：**在SPA中，当用户刷新页面时，浏览器会默认根据当前的URL对资源进行重新定位（发送请求）。这个动作对SPA是不必要的。</p><p>因为SPA作为单页面，无论如何也只有一个页面与之对应；此时若走正常的请求刷新流程，反而会使用户的前进、后退流程无法被记录</p></li><li><p>**解决问题2：**单页面应用对服务器来说就是一个URL、一套资源，那么如何做到用不同的URL来映射不同的视图内容呢？</p></li></ul><p><strong>此时服务端已经无法解决SPA的场景了。前端自己解决：</strong></p><p>**提供解决思路：**拦截用户的刷新操作，避免服务器盲目响应，返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉，感知URL的变化，这里并不是改造URL，给他做一些处理，这些处理并不会影响其本身的性质，也不会影响服务器对它的识别。</p><p>一旦感知到它的变化，根据JS生成不同的页面。</p><h3 id="3、前端路由实践思路">3、前端路由实践思路<a class="anchor" href="#3、前端路由实践思路">·</a></h3><h4 id="1、hash模式">1、hash模式<a class="anchor" href="#1、hash模式">·</a></h4><ul><li><strong>#后面 hash 值的变化，不会导致浏览器向服务器发请求，浏览器不发请求，就不会刷新页面</strong></li><li>每次 hash 值的变化，还会触发 <strong>hashchange 这个事件</strong>，通过这个事件可知道 hash 值发生了哪些变化。便可以监听 hashchange 来实现更新页面部分内容的操作：</li></ul><h5 id="hash值改变的方式：">hash值改变的方式：<a class="anchor" href="#hash值改变的方式：">·</a></h5><ul><li><p>**方式1：**通过 <code>a</code> 标签，并设置 <code>href</code> 属性，当用户点击这个标签后，<code>URL</code> 就会发生改变，也就会触发 <code>hashchange</code> 事件了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#search&quot;</span>&gt;search&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>**方式2：**直接使用 <code>Js</code>来对 <code>loaction.hash</code> 进行赋值，从而改变 <code>URL</code>，触发 <code>hashchange</code> 事件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.<span class="property">hash</span>=<span class="string">&quot;#search&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="感知hash的方式：-hashChange事件">感知hash的方式： hashChange事件<a class="anchor" href="#感知hash的方式：-hashChange事件">·</a></h5><ul><li><p><code>hashchange</code> 事件来监听 <code>hash</code> 的变化：可以在回调中执行展示和隐藏不同UI显示的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#x27;hashChange&#x27;, () =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h5 id="Hash的特点：">Hash的特点：<a class="anchor" href="#Hash的特点：">·</a></h5><ul><li><p><strong>HTTP请求中不包括#及其后面的部分</strong>，都不会被发送到服务器端</p><p>所以，hash 虽然出现在 URL 中，<strong>但不会被包括在 HTTP 请求中，对后端完全没有影响</strong>，因此改变 hash 不会重新加载页面</p><p>对于后端来说，即使没有做到对路由的全覆盖，也<strong>不会返回 404 错误</strong></p></li><li><p><strong>改变#后面的内容不触发网页重载</strong>，浏览器只会滚动到相应位置</p><p>#代表网页中的一个位置。其右面的字符，就是该位置的标识符：http://www.example.com/index.html#print，就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域</p></li></ul><h4 id="2、history模式">2、history模式<a class="anchor" href="#2、history模式">·</a></h4><p>通过浏览器的回退、前进按钮控制，就可以实现页面跳转，这是通过API来实现的。浏览器的History API所赋予的。但H4只能切换，而不能改变。H5后增加了pushState、replaceState。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增一个历史记录，所以会相应地启用“后退”按钮</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(<span class="literal">null</span>,一个新状态的标题，path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接替换当前的历史记录</span></span><br><span class="line"><span class="comment">// 要确保每个“假”URL 背后都对应着服务器上一个真实的物理 URL。否则，单击“刷新”按钮会导致 404 错误</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">replaceState</span>(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br></pre></td></tr></table></figure><p>在hsitory模式下，可以通过监听 <code>popstate</code> 事件，达到目的：</p><ul><li><p>每当浏览记录发生变化， <code>popstate</code> 事件就会触发，go、forward、back等调用确实会触发popState、但<code>pushState()</code> 或 <code>replaceState()</code> 不会触发 <code>popstate</code> 事件。</p></li><li><p>但我们可以通过手动触发来实现。</p></li></ul><h3 id="4、404-错误">4、404 错误<a class="anchor" href="#4、404-错误">·</a></h3><p>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.abc.com/book/id 如果后端缺少对 /book/id 的子路由处理，将返回 404 错误</p><h4 id="为什么histroy需要额外配置？">为什么histroy需要额外配置？<a class="anchor" href="#为什么histroy需要额外配置？">·</a></h4><ul><li><p>假设应用地址为<code>abc.com</code>，服务端不加额外的配置。当通过<code>abc.com</code>来访问时，是没有问题的，可以正常加载到html文件</p></li><li><p>之后通过route-link或router.api来跳转也不会有问题，因为之后都不会刷新页面请求html，只是通过<code>history.pushState</code>或者<code>history.replaceState</code>改变history记录，修改地址栏地址而已；</p></li><li><p>但如果是<strong>直接访问子路由<code>abc.com/test</code>时就会有问题</strong>，<code>/test</code>是子路由名，但是服务器中并不存在该目录，就无法索引到html文件，此种情况下就会出现404，所以不管是访问什么路径，都应该加载根目录的html文件，因为<code>/xxx/yyy</code>对我们应用来讲是子路由路径而已</p></li><li><p><strong>处理：</strong></p><p>在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。一般需要后端将所有页面都配置重定向到首页路由</p></li></ul><h4 id="为什么hash不需要？">为什么hash不需要？<a class="anchor" href="#为什么hash不需要？">·</a></h4><ul><li>hash 虽然出现在 URL 中，<strong>但不会被包括在 HTTP 请求中，对后端完全没有影响</strong>，因此改变 hash 不会重新加载页面</li><li>对于后端来说，即使没有做到对路由的全覆盖，也<strong>不会返回 404 错误</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Hook的出现</title>
      <link href="/posts/ReactHooks.html"/>
      <url>/posts/ReactHooks.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hooks">Hooks<a class="anchor" href="#Hooks">·</a></h2><h3 id="一、-why">一、 why<a class="anchor" href="#一、-why">·</a></h3><ul><li>Hooks是React团队在实践中逐渐认知的一个改进点，背后设计到<strong>类组件、函数组件</strong>两种组件形式的思考和侧重</li></ul><h4 id="1、类组件">1、类组件<a class="anchor" href="#1、类组件">·</a></h4><ul><li>基于ES6的写法，通过继承React.component的组件</li></ul><h4 id="2、函数组件">2、函数组件<a class="anchor" href="#2、函数组件">·</a></h4><ul><li>以函数组件的形态存在的组件，在早期没有Hooks加持时，函数组件内部无法定义、维护state，因此也叫“无状态组件”</li></ul><h4 id="3、对比两种组件：">3、对比两种组件：<a class="anchor" href="#3、对比两种组件：">·</a></h4><ul><li>类组件继承自class，函数组件不需要；</li><li>类组件可以访问生命周期，函数组件不可；</li><li>类组件可以获取实例化后的this，并基于该this做事情，但函数组件不可；</li><li>类组件可以定义并维护state状态，但函数组件不可；</li></ul><h4 id="4、这是否意味着函数组件没有类组件好呢？">4、这是否意味着函数组件没有类组件好呢？<a class="anchor" href="#4、这是否意味着函数组件没有类组件好呢？">·</a></h4><p>不是，在Hooks出现之前，类组件的<strong>能力边界</strong>明显强于函数组件。一味鼓吹轻量、易上手、取代类组件也不是应该讨论谁优谁劣的依据。更多的关注点，应该是二者的不同之处，把对应的场景与不同的特性结合起来。</p><ol><li><p>类组件</p><p>类组件是一个面向对象编程思想的一种表现。面向对象的特性之一：</p><ul><li>封装：将一类属性和方法聚合到一个class中</li><li>继承：新的class可以通过继承现有的class，实现对某一类属性和方法的复用；</li></ul><p>react类组件内部只需要继承React.component，就轻易获得了内部丰富的配备。</p><ul><li>React.component提供了很多东西，学习成本更高，比如生命周期，用的不好也会让代码一团糟。大而全的背后是不可忽略的学习成本。可以但没有必要。</li><li>开发者编写的逻辑在封装后，是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。这就需要学习更高的设计模式，用更高的学习成本来交换一点编码的灵活度</li></ul></li><li><p>函数组件</p><p>不仅能承担数据渲染（简单的任务），同样可以承担复杂的交互逻辑；</p><ul><li>粗浅的认知：轻量、灵活、较低的学习成本</li><li><strong>Dam（React开发者）：函数组件会捕获render内部的状态，这是两类组件最大的不同。</strong></li><li>类组件、函数组件之间的千差万别，但最不能被我们忽视的是，**心智模式层面的差异。**是面向对象和函数式编程这两种不同设计思想的差异</li></ul></li><li><p><strong>函数式组件更加契合React的理念：</strong></p><p>UI = f(data)，react组件本身的定位就是函数，吃进去数据，吐出来UI。作为开发者，我们编写的是声明式的代码，而React就是把声明式的代码转换为命令式的DOM操作，把数据层面的描述映射到用户可见的UI变化中去。</p><p>这就意味着react中数据和渲染是紧密绑在一起的，但类组件是做不到这一点。<strong>为什么呢？</strong></p><p>因为<strong>函数组件会捕获render内部的状态，这是两类组件最大的不同。</strong></p></li></ol><h4 id="5、函数组件会捕获render内部的状态，这是两类组件最大不同">5、函数组件会捕获render内部的状态，这是两类组件最大不同<a class="anchor" href="#5、函数组件会捕获render内部的状态，这是两类组件最大不同">·</a></h4><ol><li><p>类组件：</p><ul><li>类组件中，虽然props是不可变的，但是this是可变的，this上的数据是可以修改的。this.props的调用每次都可以获取最新的props，而这正是react获取数据实时性的重要手段。多数情况下，this.props与预期的渲染动作的连贯。</li><li>假如通过setTimeout将预期的渲染推迟了3s，打破了this.props和渲染动作之间的这种时机上的联动。也就是渲染时捕获到的是一个错误的props，这就出现了问题</li></ul></li><li><p>函数组件：</p><p>在函数执行的一瞬间就被捕获，而props本身又是一个不可变值，因此在任何时机读取到的props都是最新的props。</p><p>当父组件传递新的props时，其实内部产生了一次新的函数调用，并不会影响上一个props。</p><p>函数组件是真正将数据与渲染绑定在了一起。</p></li></ol><p>【总结】：总的说，函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分和重用的组件表达形式。</p><h4 id="6、Hook">6、Hook<a class="anchor" href="#6、Hook">·</a></h4><ul><li>是一套使函数组件更强大、更灵活的钩子。函数组件相比于类组件少了很多东西，而Hooks的出现就是帮助函数式组件补齐这种缺陷。函数式组件可以自由的使用Hooks提供的丰富工具</li></ul><h3 id="二、what">二、what<a class="anchor" href="#二、what">·</a></h3><h4 id="1、useState：引入状态">1、useState：引入状态<a class="anchor" href="#1、useState：引入状态">·</a></h4><p>早期函数组件相比于类组件，劣势之一：缺乏维护和定义state的能力，而这个API就是为函数组件引入状态</p><ul><li><p>同样逻辑的函数组件比类组件复杂度更低，代码量更少</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法: const [xxx, setXxx] = React.useState(initValue)</span><br><span class="line">* 参数: 初始值，允许任意类型的值</span><br><span class="line">* 返回值:  第1个为state变量, 第2个为能够修改这个变量的API</span><br><span class="line">* React.useState的调用实际上给这个组件关联上了一个状态</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>  <span class="title function_">Button</span>(<span class="params"></span>)  &#123;</span><br><span class="line">  <span class="keyword">const</span>  [buttonText, setButtonText] =  <span class="title function_">useState</span>(<span class="string">&quot;Click me,   please&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>)  &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">setButtonText</span>(<span class="string">&quot;Thanks, been clicked!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>  <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>&#123;buttonText&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：多个状态声明时，必须分开写，且不能出现在条件判断语句中，因为它必须有一样的渲染顺序</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [ age , setAge ] = <span class="title function_">useState</span>(<span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> [ sex , setSex ] = <span class="title function_">useState</span>(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> [ work , setWork] = <span class="title function_">useState</span>(<span class="string">&#x27;前端程序员&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [ age , setAge ] = <span class="title function_">useState</span>(<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">if</span>(showSex)&#123;</span><br><span class="line">        <span class="keyword">const</span> [ sex , setSex ] = <span class="title function_">useState</span>(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">        showSex=<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ work , setWork ] = <span class="title function_">useState</span>(<span class="string">&#x27;前端程序员&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、useEffect：为组件引入副作用、生命周期">2、useEffect：为组件引入副作用、生命周期<a class="anchor" href="#2、useEffect：为组件引入副作用、生命周期">·</a></h4><p>过去在DidMount 、DidUpdate、willUnmount中做的事，可以放在该钩子做。比如：操作DOM、获取外部API</p><p>生命周期到useEffect的转换关系都不是最重要的，最重要的是构建组件有副作用，引入useEffect这样的条件反射。<strong>为函数组件引入副作用的钩子。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(callback, [](可选));</span><br><span class="line">--  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次渲染都执行</span></span><br><span class="line">    &#125;);</span><br><span class="line">--  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只在挂载阶段执行一次的副作用，且该函数的返回值不是一个函数</span></span><br><span class="line">    &#125;,[]);</span><br><span class="line">--  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只在挂载、卸载阶段执行的副作用，且该函数的返回值是一个函数</span></span><br><span class="line">  <span class="comment">// 业务逻辑A: 它会在挂载阶段执行</span></span><br><span class="line">  ....</span><br><span class="line">      <span class="comment">// 业务逻辑B:它会在卸载时执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    &#125;,[]);</span><br><span class="line">--  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 每一次渲染、且卸载阶段执行的副作用，且该函数的返回值是一个函数，不传第2个参数</span></span><br><span class="line">  <span class="comment">// 业务逻辑A: 它会在每次渲染时执行</span></span><br><span class="line">  ....</span><br><span class="line">      <span class="comment">// 业务逻辑B:它会在卸载时执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">--  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 根据一定的依赖条件出发的副作用</span></span><br><span class="line">      <span class="comment">// 业务逻辑：</span></span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">// 若xxx是一个函数，则xxx会在组件卸载时被触发</span></span><br><span class="line">  <span class="keyword">return</span> xxx;</span><br><span class="line">    &#125;,[count1, count2, count3]);</span><br></pre></td></tr></table></figure><p>【补充】：useEffect中返回的函数叫“清除函数”，当React识别到该函数，会在下卸载阶段执行其清除逻辑。这个规律不会收第2个参数、或其他参数因素的影响。只要你在useEffect回调中返回了一个函数，它就会被当做清除函数来处理。</p><h4 id="3、Hooks是如何升级工作模式的，为什么需要Hooks？重点">3、Hooks是如何升级工作模式的，为什么需要Hooks？重点<a class="anchor" href="#3、Hooks是如何升级工作模式的，为什么需要Hooks？重点">·</a></h4><h5 id="1、告别难以理解的class">1、告别难以理解的class<a class="anchor" href="#1、告别难以理解的class">·</a></h5><p>class的两大痛点：</p><ol><li><p>this</p><p>比如推出了箭头函数、bind来解决this问题，但本质上是在用实践层面解决设计层面的问题。而函数组件就没有这个问题了。</p></li><li><p>生命周期</p><ol><li>学习成本</li><li>不合理的逻辑规划方式</li></ol></li></ol><h5 id="2、解决业务逻辑难以拆分的问题">2、解决业务逻辑难以拆分的问题<a class="anchor" href="#2、解决业务逻辑难以拆分的问题">·</a></h5><ol><li><p>类组件：</p><p>过去组织业务逻辑时，先想清楚业务需要，将对应的业务逻辑拆到对应的生命周期中，逻辑与生命周期强耦合。比如：DidMout去获取数据，在DidUpdate里获取数据的变化，但是大型项目中，一个生命周期做的事情很多。这些事情看起来毫无关联，而有关联的被分散在不同的生命周期里。</p></li><li><p>但是Hooks有专门管理状态的、有引入副作用的等等，<strong>它能帮我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。</strong></p></li></ol><h5 id="3、使状态逻辑复用变得更简单可行">3、使状态逻辑复用变得更简单可行<a class="anchor" href="#3、使状态逻辑复用变得更简单可行">·</a></h5><ol><li>过去复用状态逻辑，靠的是HOC、renderer Props这些组件设计模式，但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是**“嵌套地狱”**的现象。</li><li>而Hooks可以看做是React解决状态逻复用的原生途径，达到既不破坏组件结构，又能够实现逻辑复用的效果</li><li>这块在第3下一个专题上会展开</li></ol><h5 id="4、从设计思想上更加契合React的理念">4、从设计思想上更加契合React的理念<a class="anchor" href="#4、从设计思想上更加契合React的理念">·</a></h5><p>前面的函数组件、类组件已经做了对比分析。</p><h4 id="4、Hooks的局限性">4、Hooks的局限性<a class="anchor" href="#4、Hooks的局限性">·</a></h4><p>Hooks并非万能，在认识到Hooks利好的同时，也需要认识到他的局限性。</p><ol><li><p>Hooks暂时还不嫩而过完全第为函数组件补全类组件的能力：比如，某些钩子还是没有；</p></li><li><p>函数组件仍然是“轻量”，这可能使得它并不能很好地消化“复杂”</p></li><li><p>在使用层面严格的约束</p><p>耦合和内聚的边界很难把握，函数式组件给了更多自由，却对开发者代码能力提了更高的要求。</p></li></ol><h3 id="三、how：深入React-Hooks工作机制">三、how：深入React-Hooks工作机制<a class="anchor" href="#三、how：深入React-Hooks工作机制">·</a></h3><h4 id="1、HOOKS的使用原则2个：">1、HOOKS的使用原则2个：<a class="anchor" href="#1、HOOKS的使用原则2个：">·</a></h4><ol><li><p>只在函数组件中调用Hook</p></li><li><p>不要在循环、条件、嵌套函数中调用Hook</p><p>目的：确保Hooks在每次渲染时，都能保持同样的渲染执行顺序。</p></li></ol><h4 id="2、为什么渲染顺序如此重要呢？">2、为什么渲染顺序如此重要呢？<a class="anchor" href="#2、为什么渲染顺序如此重要呢？">·</a></h4><ul><li><p>如果不保证Hooks执行顺序会导致什么问题？</p><p>下面的代码按照意图，预期希望初次渲染时，展示出来，点击后，只获取carrer，并且名字修改更新（第二次渲染）</p><p>现象：组件没有发生变化，且报错渲染Hooks钩子减少。</p><p>初次渲染输出：isMounted是false， carrer：搬砖</p><p>单机修改按钮：isMounted为true，但carrer：小1，为什么发生的是carrer呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eslint-disable-next-line   禁止校验</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isMounted = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">personInfo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> name, age, career, serName, setCareer;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isMounted is:&#x27;</span>, isMounted);</span><br><span class="line">  <span class="keyword">if</span>(!isMounted)&#123;</span><br><span class="line">    [name, setName] = <span class="title function_">useState</span>(<span class="string">&#x27;小1&#x27;</span>);</span><br><span class="line">    [age] = <span class="title function_">useState</span>(<span class="string">&#x27;100&#x27;</span>);</span><br><span class="line">    isMounted = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [career, setCareer] = <span class="title function_">useState</span>(<span class="string">&#x27;搬砖&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;career&#x27;</span>, career);</span><br><span class="line">  rerurn (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">&quot;personInfo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123;name&#125; ? <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名： &#123;name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;&#123;age&#125; ? <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄： &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>职业：&#123;career&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        setName(&#x27;小2&#x27;);</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        修改姓名</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、源码调用流程">3、源码调用流程<a class="anchor" href="#3、源码调用流程">·</a></h4><p>Hooks的正常运作，在底层依赖于顺序链表；</p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121185614905.png" alt="image-20211121185614905" style="zoom: 33%;" /><h5 id="1、mounState">1、mounState<a class="anchor" href="#1、mounState">·</a></h5><p>useState的调用会落脚到mounState中：</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121185632743.png" alt="image-20211121185632743" style="zoom: 20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121185651487.png" alt="image-20211121185651487" style="zoom: 20%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121185932268.png" alt="image-20211121185932268" style="zoom: 20%;" /></p><ul><li><p>主要工作是：初始化Hooks，最需要关注的是mountWorkInProgressHook</p><p><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121190156553.png" alt="image-20211121190156553" style="zoom: 25%;" /><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121190221958.png" alt="image-20211121190221958" style="zoom:25%;" /></p></li></ul><p>Hooks所有的信息收在Hook对象里，而对象以单向链表的形式相互串联。</p><h5 id="2、mountState">2、mountState<a class="anchor" href="#2、mountState">·</a></h5><p>首次渲染和更新的区别是，是调用的mounState还是updateState。</p><ul><li><p>mountState：首次渲染，构建链表并渲染</p></li><li><p>updateState做的事情：依次遍历链表并渲染。</p></li><li><p>因此Hooks的渲染是通过“一次遍历”来定位每个Hooks的内容的，如果前后两次读到的链表在顺序出现差异，那么渲染的结果自然是不可控的。</p></li><li><p>Hooks的本质是链表。</p></li></ul><h5 id="3、重现2中的执行过程">3、重现2中的执行过程<a class="anchor" href="#3、重现2中的执行过程">·</a></h5><ol><li>首次渲染时的链表结构：</li></ol><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121191404195.png" alt="image-20211121191404195" style="zoom: 20%;" /><ol start="2"><li>第二次渲染时，只有一个钩子</li></ol><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121191424244.png" alt="image-20211121191424244" style="zoom:20%;" /><ol start="3"><li>在更新时，只会按照顺序取到链表头结点</li></ol><img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20211121191456565.png" alt="image-20211121191456565" style="zoom:20%;" />]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的生命周期</title>
      <link href="/posts/vue_lifeCycle.html"/>
      <url>/posts/vue_lifeCycle.html</url>
      
        <content type="html"><![CDATA[<h2 id="生命周期">生命周期<a class="anchor" href="#生命周期">·</a></h2><h3 id="1-概念">1. 概念<a class="anchor" href="#1-概念">·</a></h3><ul><li><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程</p></li><li><img src="https://img-blog.csdnimg.cn/20200418101911580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX1RvZ2V0aGVy,size_16,color_FFFFFF,t_70" alt="图片转自coderwhy老师" style="zoom: 33%;" /></li></ul><h3 id="2-各个钩子的作用">2. 各个钩子的作用<a class="anchor" href="#2-各个钩子的作用">·</a></h3><p>**过程：**均不可用——初始数据获取，方法——虚拟Dom创建 ——el完成挂载，真实DOM创建——Diff算法，打补丁——更新数据</p><h5 id="1）beforeCreate：">1）beforeCreate：<a class="anchor" href="#1）beforeCreate：">·</a></h5><ul><li>在<strong>实例初始化之后</strong>，数据观测(data observer) 和 event/watcher 事件配置之前被调用</li><li>特点： data、methods、computed 以及 watch 上的数据和方法都不能被访问</li></ul><h5 id="2）created：">2）created：<a class="anchor" href="#2）created：">·</a></h5><ul><li>实例已完成以下的配置：<ul><li><strong>数据劫持 (data observer)，属性和方法</strong>的运算。</li><li>数据已经和<strong>data属性绑定</strong>（放在data中的属性将来值发生改变的同时，视图也会改变）</li></ul></li><li>此时操作数据，不会触发update函数，一般在这里做初始数据的获取，且相比在 beforeMount 获取数据页面渲染速度较快</li><li>然而，<strong><code>$el</code> 属性</strong>目前尚不可用。如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom</li></ul><h5 id="3）beforeMount">3）beforeMount<a class="anchor" href="#3）beforeMount">·</a></h5><ul><li><p>在挂载开始之前被调用：</p><p>相关的 <code>render</code> 函数首次被调用。</p><p><strong>虚拟dom 创建完成，真实 dom未完成挂载</strong>，这里更改数据不会触发 update函数，这里是渲染前最后一次更改数据的机会，在这里也可以做初始数据的获取</p></li></ul><h5 id="4）mounted：">4）mounted：<a class="anchor" href="#4）mounted：">·</a></h5><ul><li>实例完成的配置：<ul><li><strong>完成了挂载，这时 <code>el</code></strong> 被新创建的 <code>vm.$el</code> 替换了。</li><li><strong>数据、真实dom</strong>都已经处理，一般在这里初始化一些操作真实 dom 的方法</li></ul></li><li>注意：此阶段不会保证所有的子组件也都一起被挂载，如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a></li></ul><h5 id="5）beforeUpdate：">5）beforeUpdate：<a class="anchor" href="#5）beforeUpdate：">·</a></h5><ul><li><p>时机：当组件或实例的数据更改，会立即执行beforeUpdate，发生在虚拟 DOM 打补丁之前</p></li><li><p>特点：可以监听到 <strong>data 变化，但view层的数据还没有变化</strong></p></li><li><p>适合：在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器</p></li></ul><h5 id="6）updated：">6）updated：<a class="anchor" href="#6）updated：">·</a></h5><ul><li><p>时机：完成虚拟 DOM 重新渲染和打补丁后，来到这个钩子</p></li><li><p>特点：</p><ul><li><p>此时组件 DOM 已经更新，可以操作更新后的虚拟dom，view层的数据重新渲染完成；</p></li><li><p>应该避免在此期间更改状态，如果要相应状态改变，通常最好使用<a href="https://cn.vuejs.org/v2/api/#computed">计算属性</a>或 <a href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之；</p></li><li><p><strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p></li></ul></li></ul><h5 id="7）beforeDestroy：">7）beforeDestroy：<a class="anchor" href="#7）beforeDestroy：">·</a></h5><ul><li>时机：实例销毁之前调用，实例仍然完全可用</li><li>工作：做一些善后工作，例如**清除计时器、数据和事件的监听等 **</li></ul><h5 id="8）destroyed：">8）destroyed：<a class="anchor" href="#8）destroyed：">·</a></h5><ul><li>时机：实例销毁后调用，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</li></ul><h5 id="9）activated：被-keep-alive-缓存的组件激活时调用">9）activated：被 keep-alive 缓存的组件激活时调用<a class="anchor" href="#9）activated：被-keep-alive-缓存的组件激活时调用">·</a></h5><ul><li>keep-alive：当在组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题</li></ul><h5 id="10）deactivated：被-keep-alive-缓存的组件停用时调用">10）deactivated：被 keep-alive 缓存的组件停用时调用<a class="anchor" href="#10）deactivated：被-keep-alive-缓存的组件停用时调用">·</a></h5><h5 id="11）errorHandler：被-keep-alive-缓存的组件停用时调用">11）errorHandler：被 keep-alive 缓存的组件停用时调用<a class="anchor" href="#11）errorHandler：被-keep-alive-缓存的组件停用时调用">·</a></h5><ul><li><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm, info</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="12）errorCaptured">12）errorCaptured<a class="anchor" href="#12）errorCaptured">·</a></h5><ul><li>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播</li><li>触发时机都是相同的，不同的是 errorCaptured 发生在前，且如果某个组件的 errorCaptured 方法返回了 false，那么这个异常信息不会再向上冒泡也不会再调用 errorHandler 方法</li></ul><h3 id="3-常见问题">3. 常见问题<a class="anchor" href="#3-常见问题">·</a></h3><h4 id="1-调用异步请求">1. 调用异步请求<a class="anchor" href="#1-调用异步请求">·</a></h4><ul><li>可以 created、beforeMount、mounted 中调用：在这三个钩子函数中，<strong>data 已经创建</strong>，可以将服务端端返回的<strong>数据进行赋值。</strong></li><li>如果异步请求不需要依赖 Dom 推荐在 <strong>created</strong> 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<ul><li>能更快获取到服务端数据，减少页面  loading 时间；</li><li>ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></li></ul><h4 id="2-el选项对生命周期影响：">2. el选项对生命周期影响：<a class="anchor" href="#2-el选项对生命周期影响：">·</a></h4><ul><li><p><strong>没有el选项，则停止编译</strong>，也意味着暂时停止了生命周期。生命周期到created就结束了</p></li><li><p>而当我们不加el选项，但是手动执行<code>vm.$mount(el)</code>方法的话，也能够使暂停的生命周期进行下去</p></li><li><p><code>template</code>和<code>HTML</code>的优先级：</p><blockquote><p>结论</p></blockquote><ol><li>如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数</li><li>如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高</li><li>如果1,2条件都不具备，则报错</li></ol><blockquote><p>注意</p></blockquote><ol><li>Vue需要通过el去找对应的template，Vue实例通过el的参数，首先找自己有没有template，如果没有再去找外部的html，找到后将其编译成render函数。</li><li>runtime-only也可以直接调用<a href="https://cn.vuejs.org/v2/api/#render">render</a>选项，优先级：<code>render函数选项  &gt; template参数  &gt; 外部HTML</code></li></ol></li></ul><h3 id="4-父子组件">4. 父子组件<a class="anchor" href="#4-父子组件">·</a></h3><ul><li><h4 id="执行顺序：">执行顺序：<a class="anchor" href="#执行顺序：">·</a></h4><ul><li><p>加载渲染过程：父要等子的挂载</p><p><code>父beforeCreate </code>----<code>父created</code>------<code>父beforeMounted</code>------<code>子beforeCreate </code>------<code>子created</code>------<code>子beforeMounted</code>—<code>子mounted</code>------<code>父mounted</code></p></li><li><p>子组件更新过程：父要等子的更新</p><p><code>父beforeUpdate</code>----<code>子beforeUpdate</code>—<code>子updated</code>—<code>父updated</code></p></li><li><p>父组件更新过程</p><p><code>父 beforeUpdate</code> -&gt; <code> 父 updated</code></p></li><li><p>销毁过程</p><p><code>父beforeDestroy</code>----<code>子beforeDestroy</code>----<code>子destroyed</code>----<code>父destroyed</code></p></li></ul></li><li><h4 id="数据传输流程：">数据传输流程：<a class="anchor" href="#数据传输流程：">·</a></h4><ul><li>当子组件被点击后，会向外emit一个事件，父组件会监听这个自定义事件，methods里改变data的list</li><li>这个list会由于单向数据流，传递给子组件</li><li>所以子组件列表渲染好了，此时父组件才整个更新：<code>父beforeUpdate</code>----<code>子beforeUpdate</code>—<code>子updated</code>—<code>父updated</code></li></ul></li><li><h4 id="场景设计：">场景设计：<a class="anchor" href="#场景设计：">·</a></h4><p>**层级：**父–子–孙  3级层级组件</p><p><strong>需求：<strong>在组件显示在页面上之后，再将数据初始化进行回显。父组件获取数据后传递到子组件，要求子组件根据这个值将内部元数据进行加工，那么</strong>在子组件中什么时机下才能获取父组件传递过来的新值呢？</strong></p><p><strong>分析：</strong></p><ol><li>子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件<code>mounted</code>中获取api的数据，子组件的<code>mounted</code>是拿不到的</li><li>发现<code>created</code>这个钩子是按照从外内顺序执行，所以<strong>回显场景</strong>的解决方案是：在created中发起请求获取数据，依次在子组件的created中会接收到这个数据</li><li>问题在于如何在子组件中知道远程数据回来了，并且通过对远程数据的加工处理，最终形成正确的回显</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的生命周期</title>
      <link href="/posts/React_lifecycle.html"/>
      <url>/posts/React_lifecycle.html</url>
      
        <content type="html"><![CDATA[<h2 id="React生命周期">React生命周期<a class="anchor" href="#React生命周期">·</a></h2><h3 id="1、组件与虚拟DOM">1、组件与虚拟DOM<a class="anchor" href="#1、组件与虚拟DOM">·</a></h3><h4 id="虚拟DOM：">虚拟DOM：<a class="anchor" href="#虚拟DOM：">·</a></h4><ul><li><strong>组件初始化时：</strong><ul><li>调用render方法 — 生成虚拟DOM —再通过ReactDom.render()—生成真实Dom</li></ul></li><li><strong>组件更新时：</strong><ul><li>通过render方法 ----- 生成新的虚拟DOM------借助diff算法-------定位出两次虚拟Dom的差异</li></ul></li></ul><h4 id="组件化：">组件化：<a class="anchor" href="#组件化：">·</a></h4><p>React中所有可见、不可见的都可以被抽象为组件，每个组件既是“封闭”的，也是“开放”的；</p><p><strong>封闭</strong>：针对渲染工作流而言</p><ul><li>在每个组件自身的渲染工作流中，每个组件都只处理它内部的逻辑，各自为政</li><li>**渲染工作流：**组件数据改变到组件实际更新发生的过程</li></ul><p><strong>开放</strong>：针对组件通信而言</p><ul><li>React允许开发者基于“单向数据流”的原则完成组件的通信</li><li>而组件之间的通信又将改变通信双方/某一方内部的数据流，进而对渲染结果构成影响；</li></ul><h4 id="组件的分类">组件的分类<a class="anchor" href="#组件的分类">·</a></h4><ul><li>这些概念有很多重叠，但是他们最主要是关注数据逻辑和UI展示的分离：<ul><li>函数组件、无状态组件、UI组件主要关注UI的展示;</li><li>类组件、有状态组件、容器组件主要关注数据逻辑</li></ul></li></ul><h5 id="1-无状态、有状态组件">1. 无状态、有状态组件<a class="anchor" href="#1-无状态、有状态组件">·</a></h5><p>根据组件内部是否有状态需要维护</p><ul><li><h5 id="无状态组件：">无状态组件：<a class="anchor" href="#无状态组件：">·</a></h5><ol><li><p>是一个函数，组件中只有一个render函数，会接受一个props，返回组件，只负责展示，例如函数组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HelloComponent</span>(<span class="params">props</span>) &#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：简单清晰，容易理解，可读性较好；</p><p>缺点：满足不了复杂的应用，往往需要结合<strong>高阶组件</strong>使用，利用高阶组件托管所需状态数据；</p></li><li><p>举例：例如redux中就是将组件分为<strong>容器组件</strong>和<strong>ui组件</strong></p><p>容器组件作为一个高阶组件，<strong>提供数据和行为给ui组件或者其他的容器组件</strong>，负责调用action，并作为回调给展示组件，因此容器组件通常是有状态的，往往作为数据源；</p><p>而ui组件关心组件的展示，通过props接收数据和回调很少有它们自己的state，有也是UI状态而不是数据</p></li></ol></li><li><h5 id="有状态组件">有状态组件<a class="anchor" href="#有状态组件">·</a></h5><ol><li><p>**特点：**组件内部包含状态，并且状态随着事件或者外部的消息而发生改变，这就构成了有状态组件。使用有状态组件通常会结合react的生命周期钩子控制组件状态更新的时机</p></li><li><p>react中，有两种更新组件的方式：props和state。</p><p>props是只读的，只能由父组件控制；而state是由组件内部维护的。</p><p>无状态组件通常只通过props来存储数据，而有状态组件使用state来存储数据</p></li></ol></li></ul><h5 id="2-UI-容器组件">2. UI/容器组件<a class="anchor" href="#2-UI-容器组件">·</a></h5><ul><li><h5 id="UI组件">UI组件<a class="anchor" href="#UI组件">·</a></h5><p>负责页面的渲染，将todolist关于页面渲染相关的内容全部放到ToDoListUI.js文件中，只负责页面的显示而不是逻辑，所以也叫傻瓜组件</p></li><li><h5 id="容器组件">容器组件<a class="anchor" href="#容器组件">·</a></h5><p>负责业务逻辑的代码，而不是组件的页面。所以也叫聪明组件，ToDoList组件</p></li></ul><h5 id="3-函数组件-类组件">3. 函数组件/类组件<a class="anchor" href="#3-函数组件-类组件">·</a></h5><ul><li><h5 id="函数组件">函数组件<a class="anchor" href="#函数组件">·</a></h5><ol><li>本质是JS函数，只是return的内容是描述页面展示内容的React元素</li><li>也会被更新并挂载，但是没有生命周期函数;可以通过hooks来模拟一些生命周期</li><li>没有this(组件实例);</li><li>没有内部状态(state);</li></ol></li><li><h5 id="类组件">类组件<a class="anchor" href="#类组件">·</a></h5><ol><li>必须实现render函数， class 组件中唯一必须实现的方法</li><li>constructor：可选，常用来初始化数据</li></ol></li></ul><h5 id="4-受控-非受控组件">4.  受控/非受控组件<a class="anchor" href="#4-受控-非受控组件">·</a></h5><ul><li><h5 id="受控组件">受控组件<a class="anchor" href="#受控组件">·</a></h5><ol><li><p><strong>可变状态</strong>通常保存在组件的状态属性中，并且只能使用 setState() 更新；</p></li><li><p>而包裹着受控表单组件的React父组件控制着在后续用户输入时该表单中发生的情况；</p></li><li><p>以这种<strong>由React控制的输入表单元素而改变其值的方式</strong>，称为：“受控组件”。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span> /&gt;;</span><br></pre></td></tr></table></figure></li><li><h5 id="非受控组件">非受控组件<a class="anchor" href="#非受控组件">·</a></h5><ul><li><p>受控与非受控，关键在于站在哪个视角去看，</p></li><li><p>对于一组包含关系的父子组件，如果子组件的状态不受父组件控制，而是子组件在其内部维护了自己的状态state，对于父组件来说，子组件就是一个非受控组件。</p></li><li><p>相反的，如果父组件可以通过props控制子组件的展示状态，那他就是一个受控组件。</p></li></ul></li></ul><h3 id="2、生命周期的本质：render方法为react组件的“灵魂“；">2、生命周期的本质：render方法为react组件的“灵魂“；<a class="anchor" href="#2、生命周期的本质：render方法为react组件的“灵魂“；">·</a></h3><ul><li><p>虚拟DOM、组件化这两个概念，都在围绕这render方法，虚拟DOM的生成需要render、而组件化中跟的渲染工作流这个过程同样离不开render；</p></li><li><p>如果将render方法比喻为灵魂，render之外的生命周期可以理解为组件的躯干</p></li><li><p>躯干和灵魂共同构成了完整而不可分割的生命时间轴</p></li></ul><h3 id="3、15生命周期">3、15生命周期<a class="anchor" href="#3、15生命周期">·</a></h3><img src="https://img-blog.csdnimg.cn/20210713213159633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhZ256b25n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h4 id="1-初始化：初次渲染阶段">1. 初始化：初次渲染阶段<a class="anchor" href="#1-初始化：初次渲染阶段">·</a></h4><ol><li><p><code>constructor</code> 构造函数：主要2件事</p><ul><li>给 this.state 赋值对象来初始化内部的state;</li><li>为事件绑定实例(this);</li></ul><ul><li>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数</li></ul></li><li><p><code>componentWillMount</code> 组件初始化渲染前调用1次</p></li><li><p><strong><code>render</code> 组件渲染</strong>                 <strong>重要 高频</strong></p><ul><li>注意：render在执行过程中并不会真实操作Dom，它的工作是把需要渲染的内容返回出来</li><li>真实的Dom渲染工作在初始化阶段是由ReactDOM.render()干的；</li></ul></li><li><p><strong><code>componentDidMount</code> 组件挂载到 <code>DOM</code> 后调用</strong>                      <strong>高频</strong></p><ul><li><strong>只执行1次，后续修改数据，不会执行</strong>,可做的操作：<ul><li>依赖于DOM的操作、开启定时器、发送网络请求、订阅消息</li></ul></li></ul></li></ol><h4 id="2-更新阶段">2. 更新阶段<a class="anchor" href="#2-更新阶段">·</a></h4><ul><li><h5 id="情况1：state触发更新的流程：-状态更新-this-state">情况1：state触发更新的流程： 状态更新   this.state<a class="anchor" href="#情况1：state触发更新的流程：-状态更新-this-state">·</a></h5><ol><li><p><code>shouldComponentUpdate</code> 组件是否需要更新</p></li><li><p><code>componentWillUpdate</code> 组件更新前调用：</p></li><li><p><code>render</code> 组件渲染                                             <strong>重要 高频</strong></p></li><li><p><code>componentDidUpdate</code> 组件更新后调用：</p></li></ol></li><li><h5 id="情况2：父组件render触发的更新流程：-父组件更新">情况2：父组件render触发的更新流程： 父组件更新<a class="anchor" href="#情况2：父组件render触发的更新流程：-父组件更新">·</a></h5><ol><li><p><code>componentWillReceiveProps</code> ：</p><p>注意：如果父组件导致组件重新渲染，即使props没有更改，也会调用此方法；如果只是想处理更改，请确保进行当前值与变更值的比较；（官网）</p><ul><li>所以这个钩子的触发并不是props更新触发的，而是父组件触发的。即使props并没有更新</li></ul></li><li><p><code>shouldComponentUpdate</code> 组件是否需要更新：                 <strong>性能优化</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br><span class="line">* 返回值：默认true；并且只要写了这个钩子，就必须写true/false，不允许你不写</span><br><span class="line">* 如果这个函数返回fasle，类比于阀门关闭，后面的所有流程都不往下走</span><br></pre></td></tr></table></figure></li><li><p><code>componentWillUpdate</code> 组件更新前调用</p></li><li><p><code>render</code> 组件渲染                                                <strong>重要 高频</strong></p></li><li><p><code>componentDidUpdate</code> 组件更新后调用</p></li></ol></li><li><h5 id="情况3：forceUpdate触发更新的流程：强制更新">情况3：forceUpdate触发更新的流程：强制更新<a class="anchor" href="#情况3：forceUpdate触发更新的流程：强制更新">·</a></h5><p>通过调用<code>this.forceUpdate()</code>，不更改任何数据，强制更新</p><ol><li><code>componentWillUpdate</code> 组件更新前调用</li><li><code>render</code> 组件渲染                                                <strong>重要 高频</strong></li><li><code>componentDidUpdate</code> 组件更新后调用：<ul><li>基于组件更新后的Dom操作</li><li>基于props的更新，来进行新的网络请求</li></ul></li></ol></li></ul><h4 id="3、卸载">3、卸载<a class="anchor" href="#3、卸载">·</a></h4><ul><li><code>componentWillUnmount</code> 组件卸载前调用：             <strong>高频</strong></li><li>调用场景：<ol><li>组件在父组件中被移除了</li><li>组件中设置了key属性，父组件在render的过程中，发现key和上一次不一致</li><li>清除 timer、取消网络请求或清除、取消在 componentDidMount() 中创建的订阅</li></ol></li></ul><h3 id="4、生命周期16-3">4、生命周期16.3<a class="anchor" href="#4、生命周期16-3">·</a></h3><img src="https://img-blog.csdnimg.cn/2021071322465195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhZ256b25n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /><h4 id="1、初始化阶段">1、初始化阶段<a class="anchor" href="#1、初始化阶段">·</a></h4><p>对比15：</p><ol><li><p>将<code>componentWillMount</code>替换为<code>getDerivedStateFromProps</code>：但只是工作流程的废弃，而不是替代。</p><p><code>getDerivedStateFromProps</code>：只有一个用途，使用props来更新/派生state。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getDerivedStateFromProps</span>(props, state)</span><br><span class="line"><span class="comment">// 1. 当前组件接收到的来自父组件的props,自身的 state；</span></span><br><span class="line"><span class="number">2.</span> 需要一个对象格式的返回值，否则会警告。因为react需要这个返回值更新组件的state；因此当你不需要派生state时，最好不要写这钩子，否则<span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>挂载、更新</strong>的两个阶段都会调用；</p></li><li><p>是一个静态方法，不是实例调用的，是类自身调用的，static；在这个组件内部访问不到this，否则报错</p></li><li><p>必须返回值</p><p>返回null则说明不需要更新 <code>state</code> ；返回状态对象（对象，且必须得和state里面对应）</p></li><li><p>该方法对state的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新；更新后，原属性与更新属性并存；</p></li><li><p>从接收到的props中，得到一个派生的状态：每次接收新的props之后都会返回一个对象作为新的 <code>state</code> 。<strong>你的状态state什么时候都会完全取决于props</strong>，初始化之类的不起作用</p></li></ul></li><li><p>render方法改进：</p><p>16之前render方法必须返回单个元素，而16允许返回元素数组和字符串</p></li></ol><h4 id="2、更新阶段">2、更新阶段<a class="anchor" href="#2、更新阶段">·</a></h4><p>对比15：</p><ol><li><p>废弃了<code>componentWillReceivePorps</code>，增加了<code>getDerivedStateFromProps</code></p></li><li><p>废弃了<code>componentWillUpdate</code>，新增了<code>getSnapshotBeforeUpdate</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate（参数1， 参数2）</span><br><span class="line">参数1：是之前的props；</span><br><span class="line">参数2：是之前的state，都不是最新的；</span><br><span class="line">返回值：必须有，否则警告。返回null</span><br></pre></td></tr></table></figure><ul><li><p>触发时间: 在 <code>render</code> 之后，在真实 <code>dom</code> 渲染之前</p></li><li><p>返回值会传递给下个钩子：<code>componentDidUpdat</code>的第三个参数</p></li><li><p>使用的场景：可以用于获取前后更新的dom的某些状态，例如高度、滚动高度等等</p><p>实现一个内容会发生变化的滚动列表，要求根据滚动列表的内容是否发生变化来决定是否要记录滚动条的当前位置</p></li></ul></li></ol><h5 id="3、卸载：相同">3、卸载：相同<a class="anchor" href="#3、卸载：相同">·</a></h5><h4 id="5、为什么废弃某些钩子？">5、为什么废弃某些钩子？<a class="anchor" href="#5、为什么废弃某些钩子？">·</a></h4><ol><li><p>废弃了componentWillMount</p></li><li><p>getDerivedStateFromProps代替了componentWillUpdate</p></li></ol><p>与componentWillUpdate一起，这个新生命周期涵盖过时componentWillReceivePorps的所有用例。</p><ul><li><p>getDerivedStateFromProps代替了componentWillReceivePorps，但不是百分之百cover到</p></li><li><p>为啥不能完全cover住呢？</p><p>它做一件事：实现基于props派生state；</p><p>这个方法被封装为静态方法，使得你不能直接获取this，所以也无法操作this.state这类可能产生副作用的工作，因此这个钩子替换是react强制推行getDerivedStateFromProps，使用props到state的映射，再确保生命周期函数的行为更加可控，帮开发者避免不合理的编程方式，同时也是在为新的fiber架构铺路；</p></li></ul><p><code>componentWillMount</code>的存在鸡肋且危险，因此它不值得被替代，应该废弃；为什么呢？</p><ul><li><p>与fiber有关，出于render阶段，因此都可能被反复执行；另一方面，这些钩子常年被滥用的过程中，存在风险</p></li><li><p>比如某些骚操作：</p><ol><li>setState()：</li><li>发起异步请求</li><li>操作真实Dom</li></ol></li><li><p>不合理的原因：</p><ol><li><p>完全可以转移到其他生命周期里去做：</p><p>比如发起异步请求，会有人错认为这样就可以让异步请求早点回来，避免渲染白屏；</p><p>但异步请求再怎么快也快不过同步的生命周期，componentwillmount结束后，render会迅速的触发，首次渲染依然会在数据返回之前执行；</p><p>这样做，不仅达不到预想的目的，还会造成服务端的冗余请求等额外问题，得不偿失；</p></li><li><p>fiber带来的异步渲染机制下，可能会导致非常严重bug：</p><p>假如你在这个钩子里发了个付款请求：</p><p>由于render阶段的生命周期都可以重复执行，在componentwill***被打断+重启多次后，就会发出多个付款请求。</p><p>假如商品只要10元，用户也只点了一次付款，却因为钩子的打断重启，导致接口频繁调用，导致多付了钱；</p><p>再比如，在componentWillReceivePorps里操作Dom，若该钩子执行了2次，可能会删除两个符合某特征的元素</p></li><li><p>getDerivedStateFromProps封装设计</p><p>这个方法被封装为静态方法，使得你不能直接获取this，所以也无法操作this.state这类可能产生副作用的工作，因此这个钩子替换是react强制推行getDerivedStateFromProps，使用props到state的映射，再确保生命周期函数的行为更加可控，帮开发者避免不合理的编程方式，同时也是在为新的fiber架构铺路；</p></li><li><p>即使你没有开启异步，15下也能把自己玩死</p><p><strong>16改造的主要动机是为了配合Fiber架构带来的异步渲染机制；</strong></p><p>比如：componentWillReceivePorps、componentWillUpdate里重复滥用state导致死循环</p></li></ol></li></ul><h4 id="6、Fiber">6、Fiber<a class="anchor" href="#6、Fiber">·</a></h4><p>fiber是16对核心算法的一次重写：会使原本的同步的渲染过程变成异步的；</p><ul><li><p>在16之前，每当触发react的更新，react都会重新生成一个虚拟DOM树，通过与之前的diff，通过递归的方式实现定向更新；</p><p>同步渲染的递归调用栈很深，只有最底层的返回，才会开始逐层返回；这个漫长且不可打断的过程将会一直占有渲染线程，浏览器此期间处于不能做别的事情，用户体验也不好；</p></li><li><p>16的架构：将一个大的更新任务拆分为几个小任务，每当执行完一个小任务时，都会把主线程交换，让更高优先级的执行，<strong>实行可中断的更新</strong>，避免卡顿；</p></li></ul><h4 id="7、同步、与异步如何影响生命周期？">7、同步、与异步如何影响生命周期？<a class="anchor" href="#7、同步、与异步如何影响生命周期？">·</a></h4><p>Fiber架构的重要特征就是可被打断的异步渲染模式；根据“能否被打断”这一标准，16的生命周期分为了render、commit两个阶段：</p><ul><li><p>render阶段：render及以前：纯净且无副作用，可能会被暂停、终止、重新启动</p><ol><li>因此，该阶段可能打断，为什么呢？</li></ol><p>render阶段的操作对用户来说是不可见的，即使打断再重启，也是0感知；</p><ol start="2"><li><p>被暂停的细节：</p><p>当执行该任务抢回执行的线程时，任务重启的方式并不是从之前暂停的地方执行，而是重新执行该任务，这就导致render阶段的生命周期都是有可能被重复执行的；</p><p><strong>按照这个结论，为什么react打算废弃那几个钩子呢？</strong></p></li></ol></li><li><p>pre-commit阶段：可以读取Dom</p></li><li><p>conmit阶段：可以使用Dom运行副作用、安排更新；</p><p>该阶段总是同步执行的，为什么这样设计呢？</p><p>因为commit阶段涉及到真实Dom渲染，带来视图的更改，求稳</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.4-框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的过渡transition</title>
      <link href="/posts/2075292597.html"/>
      <url>/posts/2075292597.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、过渡transition">1、过渡transition<a class="anchor" href="#1、过渡transition">·</a></h3><h4 id="1、所有属性都执行">1、所有属性都执行<a class="anchor" href="#1、所有属性都执行">·</a></h4><ul><li><p>如果希望所有属性都执行过渡动画：</p><ul><li>注意：无先后顺序。如存在持续和延迟两种时间，第一个是持续，第二个是等待</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">简写属性：</span><br><span class="line"><span class="attribute">transition</span>: transition-property | transition-duration | timing-function | delay</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> id = &#x27;box&#x27;&gt; 你好呀，你好&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">3s</span> ease-out <span class="number">1s</span>; // 此时hover里面的所有属性都会发生过渡效果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#box</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、指定属性执行">2、指定属性执行<a class="anchor" href="#2、指定属性执行">·</a></h4><ul><li><p>如果不希望所有的属性都执行过渡动画，可以分开写</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: width, height;</span><br><span class="line"><span class="attribute">transition-duration</span>: 可分别指定时间，用 , 号隔开,单位可秒和毫秒;</span><br><span class="line"><span class="attribute">transition-timing-function</span>: 为过渡效果指定过渡的执行方式</span><br><span class="line">- ease 默认值，慢速开始，先加速，后减速  </span><br><span class="line">- ease-in 加速运动  ease-out 减速运动   ease-in-out 先加速后减速</span><br><span class="line">- linear 匀速运动</span><br><span class="line">- <span class="built_in">cublic-bezier</span>() 贝塞尔曲线</span><br><span class="line">- <span class="built_in">step</span>(步数, start/end) 分步执行过渡效果   start / end 时间开始/结束时执行，默认值</span><br><span class="line">transition-delay: 延迟时间</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id = <span class="string">&#x27;box&#x27;</span>&gt; qwwe&lt;/div&gt;</span><br><span class="line">#box &#123;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 30px;</span><br><span class="line">  background-<span class="attr">color</span>: red;</span><br><span class="line">  </span><br><span class="line">  transition-<span class="attr">property</span>: width, height;</span><br><span class="line">  transition-<span class="attr">duration</span>: 3s, 5s;</span><br><span class="line">  transition-<span class="attr">timingfunction</span>: ease-<span class="keyword">in</span>, linear;</span><br><span class="line">  transition-<span class="attr">delay</span>: 1s, 3s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="attr">box</span>:hover&#123;</span><br><span class="line">  <span class="attr">width</span>: 400px;</span><br><span class="line">  <span class="attr">height</span>: 60px;</span><br><span class="line">  background-<span class="attr">color</span>: green;  <span class="comment">// 不会有过渡效果，hover后马上变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、触发方式：">3、触发方式：<a class="anchor" href="#3、触发方式：">·</a></h4><ul><li>常见3种：hover、active（鼠标按下、松开）、focus（表单）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的flex布局</title>
      <link href="/posts/3120977046.html"/>
      <url>/posts/3120977046.html</url>
      
        <content type="html"><![CDATA[<h2 id="弹性盒">弹性盒<a class="anchor" href="#弹性盒">·</a></h2><p>弹性盒：布局手段，代替浮动布局，可以跟随页面大小的改变而改变</p><h3 id="1、弹性容器">1、弹性容器<a class="anchor" href="#1、弹性容器">·</a></h3><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img" style="zoom:50%;" /><ul><li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）</li><li><strong>项目默认沿主轴排列</strong>。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</li><li>display: flex; 设置块级弹性容器</li><li>display: inline-flex 设置行内弹性容器（少用）</li><li>弹性元素：<ol><li>弹性容器的子元素是弹性元素，不包含后代元素；</li><li>一个元素可以是弹性盒同时也是弹性元素</li></ol></li></ul><h3 id="2、弹性容器属性">2、弹性容器属性<a class="anchor" href="#2、弹性容器属性">·</a></h3><h4 id="1、flex-direction-主轴的方向">1、flex-direction 主轴的方向<a class="anchor" href="#1、flex-direction-主轴的方向">·</a></h4><ul><li>row（默认排列方向）、row-reverse、column、column-reverse<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img" style="zoom:50%;" /></li></ul><h4 id="2、flex-wrap-子元素换行">2、flex-wrap    子元素换行<a class="anchor" href="#2、flex-wrap-子元素换行">·</a></h4><p>一条轴线排不下，设置子元素是否换行</p><ul><li>nowrap（默认不换行）<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img" style="zoom: 33%;" /></li><li>wrap：换行，第一行在上方<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img" style="zoom: 33%;" /></li><li>wrap-reverse：换行，但是第一行会在下面<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img" style="zoom: 33%;" /></li></ul><h4 id="3、flex-flow-前2者简写">3、flex-flow 前2者简写<a class="anchor" href="#3、flex-flow-前2者简写">·</a></h4><ul><li><code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></li></ul><h4 id="4、justify-content-主轴子元素排列">4、justify-content 主轴子元素排列<a class="anchor" href="#4、justify-content-主轴子元素排列">·</a></h4><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img" style="zoom: 33%;" /><p>主轴上的子元素的排列方式</p><ul><li>flex-start、center、flex-end    默认 从main start对齐</li><li>space-between，两边贴边，中间平分</li><li>space-evenly，item之间、item和container之间距离都相等</li><li>space-around，平分。所以，<strong>项目之间的间隔比项目与边框的间隔大一倍</strong>。</li></ul><h4 id="5、align-content-侧轴多子元素排列">5、align-content  侧轴多子元素排列<a class="anchor" href="#5、align-content-侧轴多子元素排列">·</a></h4><p>侧轴上<strong>子元素的排列方式</strong>（多行） <strong>使用前提是flex-wrap:wrap，要换行</strong></p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img" style="zoom:33%;" /><ul><li>flex-start、flex-end、center（<strong>垂直对齐</strong>）</li><li>space-around、space-between</li><li>stretch：默认值，将元素的长度设置为相同的值</li></ul><h4 id="6、align-items-侧轴单子元素排列">6、align-items 侧轴单子元素排列<a class="anchor" href="#6、align-items-侧轴单子元素排列">·</a></h4><p>侧轴上<strong>子元素的排列方式</strong>（单行）</p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img" style="zoom:33%;" /><ul><li>flex-start、flex-end、center（<strong>垂直对齐</strong>）：交叉轴顶部对齐，item有高度的情况下，就是顶部对齐</li><li>stretch：<strong>默认值</strong>，如果项目未设置高度或设为auto，item纵向拉伸，将占满整个容器的高度</li><li>baseline：item<strong>第一行文字</strong>基线对齐</li></ul><h3 id="3、弹性元素属性">3、弹性元素属性<a class="anchor" href="#3、弹性元素属性">·</a></h3><h4 id="1、-flex-grow">1、 flex-grow<a class="anchor" href="#1、-flex-grow">·</a></h4><ul><li><p>定义项目的放大比例，默认为<code>0</code>，即如果<strong>存在剩余空间，也不放大</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">item</span> &#123;</span><br><span class="line">  flex-<span class="attr">grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>放大规则：</p><ol><li>所有项目的<code>flex-grow</code>设置为1，则它们将等分剩余空间（如果有的话）</li><li>如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</li></ol></li></ul><h4 id="2、-flex-shrink">2、 flex-shrink<a class="anchor" href="#2、-flex-shrink">·</a></h4><ul><li><p>定义了项目的缩小比例，默认为<code>1</code>，即<strong>如果空间不足，该项目将自动缩小</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">item</span> &#123;</span><br><span class="line">  flex-<span class="attr">shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缩小规则：</p><ol><li>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小</li><li>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小</li><li>负值对该属性无效</li></ol></li></ul><h4 id="3、-flex-basis">3、 flex-basis<a class="anchor" href="#3、-flex-basis">·</a></h4><ul><li><p>定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">item</span> &#123;</span><br><span class="line">  flex-<span class="attr">basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>auto</code>：首先检索该子元素的主尺寸，如果主尺寸不为 <code>auto</code>，则使用值采取主尺寸之值；如果也是 <code>auto</code>，则使用值为 <code>content</code>。</li><li><code>content</code>：指根据该子元素的内容自动布局。有的用户没有实现取 <code>content</code> 值，等效的替代方案是 <code>flex-basis</code> 和主尺寸都取 <code>auto</code>。</li><li>百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 <code>auto</code> 一样</li></ul></li><li><p>剩余空间的计算：</p><p>剩余空间＝父容器空间－子容器1.flex-basis或width - 子容器2.flex-basis或width - …</p></li></ul><h4 id="4、flex">4、flex<a class="anchor" href="#4、flex">·</a></h4><ul><li><code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写</li></ul><blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">flex</span>的可选值：</span><br><span class="line">initial  --默认值、表示<span class="attribute">flex</span>：<span class="number">0</span>、<span class="number">1</span>、auto</span><br><span class="line">auto <span class="attr">--flex</span>：<span class="number">1</span>、<span class="number">1</span>、auto</span><br><span class="line"><span class="attribute">none</span>  <span class="attr">--flex</span>：<span class="number">0</span>、<span class="number">0</span>、auto，此时表示元素没有弹性</span><br></pre></td></tr></table></figure></blockquote><ul><li><h4 id="flex取值情况">flex取值情况<a class="anchor" href="#flex取值情况">·</a></h4></li></ul><ol><li><code>默认取值：0 1 auto</code><ul><li>有剩余空间时，不会放大；没有剩余空间时，会缩小</li><li>剩余空间的计算，按指定宽度属性width计算</li></ul></li><li><code>flex：auto（1 1 auto）</code><ul><li>有剩余空间时，会放大；没有剩余空间时，会缩小</li><li>剩余空间的计算按指定宽度属性width计算</li></ul></li><li><code>flex：none（0 0 auto）</code><ul><li>有剩余空间时，不会放大；没有剩余空间时，不会缩小，所以会超出容器</li><li>剩余空间的计算按指定宽度属性width计算</li></ul></li><li><code>flex：1（1 1 0%）</code><ul><li>有剩余空间时，会放大；没有剩余空间时，会缩小</li><li>flex中此元素占据宽度为0，不论flex-shrink为多少，都不再起作用，不会再压缩</li></ul></li><li><code>flex：百分比（1 1 百分比）</code><ul><li>百分比则视为 <code>flex-basis</code> 值，<code>flex-grow</code> 取 <code>1</code>，<code>flex-shrink</code> 取 <code>1</code></li><li>flex中此元素占据宽度为0，不论flex-shrink为多少，都不再起作用，不会再压缩</li></ul></li><li><code>flex：0 （0 0 0）</code><ul><li>有剩余空间时，不会放大；不会缩小，所以会超出容器</li><li>剩余空间的计算按元素内容撑开的宽度</li></ul></li></ol><h4 id="5、其他子项属性">5、其他子项属性<a class="anchor" href="#5、其他子项属性">·</a></h4><ul><li><p><code>align-self</code>：允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img" style="zoom:33%;" /></p><blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">align-self</span>: auto | flex-start | flex-end | center </span><br><span class="line">   | baseline |  stretch;</span><br><span class="line">&#125;</span><br><span class="line">该属性可能取<span class="number">6</span>个值，除了auto，其他都与<span class="attribute">align-items</span>属性完全一致。</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong><code>order</code>：定义项目的排列顺序。数值越小，排列越靠前，默认为0</strong></p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img" style="zoom:33%;" /></li></ul><h3 id="4、flex解决了什么">4、flex解决了什么<a class="anchor" href="#4、flex解决了什么">·</a></h3>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的定位</title>
      <link href="/posts/619926249.html"/>
      <url>/posts/619926249.html</url>
      
        <content type="html"><![CDATA[<h2 id="定位">定位<a class="anchor" href="#定位">·</a></h2><h3 id="1、定位position">1、定位position<a class="anchor" href="#1、定位position">·</a></h3><ul><li><p><strong>static：</strong>         正常文档流的位置（从上到下，从左到右）</p></li><li><p><strong>relative</strong>：    不脱标， 相对于原本占据的位置，且占用原位    不会改变元素的性质</p></li><li><p><strong>absolute</strong>       脱标</p><ul><li><p>会改变元素的性质：行内元素变行内块元素，在不手动设置宽高的情况下，该元素的大小为内容的大小，在设置宽高时，大小变为设置的宽高</p></li><li><p>会提升元素层级：可以进行覆盖</p></li><li><p>绝对定位元素是**相对于包含块进行定位的：**其实就是，相对于第一个不是static的父元素定位，如果没有，就以html元素为基准</p><p><strong>包含块概念</strong>：离当前元素最近的祖先块元素</p><p>这里的<strong>包含块概念</strong>：离当前元素最近的，开启了定位的祖先元素。如果所有的祖先元素都没有开启，就相对于html根元素，也是初始包含块</p></li></ul></li><li><p><strong>fixed：</strong>          脱标        相对于浏览器窗口</p><ul><li>大部分特点跟绝对定位很像，唯一不同的是他们的参考系一定是视口（不会随滚动条，固定不动）</li><li>会改变元素的性质：行内元素变行内块元素，在不手动设置宽高的情况下，该元素的大小为内容的大小，在设置宽高时，大小变为设置的宽高</li></ul></li><li><p><strong>sticky：</strong>  基于用户的滚动位置来定位，在 <strong>relative</strong> 与 <strong>fixed</strong> 之间切换</p><ul><li><p>一般它的行为就像 <strong>relative</strong></p></li><li><p>而当页面滚动超出目标区域（特定阈值top, right, bottom 或 left 之一）时，表现就像 <strong>fixed</strong>固定在目标位置</p></li><li><p>指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同</p></li><li><p>相对于：一个sticky元素会“固定”在离它最近的一个有“滚动机制”的祖先上（当该祖先的<code>overflow</code> 是 <code>hidden</code>, <code>scroll</code>, <code>auto</code>, 或 <code>overlay</code>时），即便这个祖先不是最近的真实可滚动祖先</p></li></ul></li></ul><h3 id="2、绝对定位的水平垂直方向布局">2、绝对定位的水平垂直方向布局<a class="anchor" href="#2、绝对定位的水平垂直方向布局">·</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子元素Σmargin +border + padding + width +绝对定位的left right=父元素宽度</span><br></pre></td></tr></table></figure><h4 id="水平方向：">水平方向：<a class="anchor" href="#水平方向：">·</a></h4><ul><li><p>当发生过度约束的时候：</p><ol><li><p>如果9个值没有auto就调整right</p></li><li><p>如果有auto就调整auto，可以设置auto的值是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width、margin、left、right</span><br></pre></td></tr></table></figure></li><li><p>left right的默认值是auto，如果不指定这几个值，默认有auto的值。当等式不满足时，会自动调整这两个值。所以使用margin auto设置居中时，要写上left、right为0。否则会调默认的left、right</p></li></ol></li></ul><h4 id="垂直方向：">垂直方向：<a class="anchor" href="#垂直方向：">·</a></h4><p>垂直方向的等式也必须满足：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top + margin2 + padding2 + height + buttom = h</span><br></pre></td></tr></table></figure><ul><li><p>当过度约束时，</p><ol><li><p>如果9个值没有auto就调整buttom</p></li><li><p>如果有auto就调整auto，可以设置auto的值是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height、margin、top、buttom</span><br></pre></td></tr></table></figure></li><li><p>top、buttom的默认值是auto，如果不指定这几个值，默认有auto的值。当等式不满足时，会自动调整这两个值。所以使用margin auto设置居中时，要写上top、buttom为0。否则会调默认的top、buttom</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> position </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的浮动及其应用问题</title>
      <link href="/posts/2007769797.html"/>
      <url>/posts/2007769797.html</url>
      
        <content type="html"><![CDATA[<h2 id="浮动">浮动<a class="anchor" href="#浮动">·</a></h2><h3 id="1、浮动元素">1、浮动元素<a class="anchor" href="#1、浮动元素">·</a></h3><h4 id="1、浮动元素的特点">1、浮动元素的特点<a class="anchor" href="#1、浮动元素的特点">·</a></h4><ol><li>浮动元素会完全脱离文档流，不再占据文档流中的位置；</li><li>设置浮动后，元素会向父元素的左侧或右侧移动；</li><li>浮动元素默认不会从父元素中移出，边界就是父元素；</li><li>浮动元素，向左或向右移动时，不会超过其他浮动元素；</li><li>如果浮动元素上边是一个不浮动的块级元素，则浮动元素无法上移；（垂直）</li><li>浮动元素不会超过它上边的浮动的兄弟元素，最多就是和它一行；（水平）</li></ol><p><code>float</code>设计的初衷就是为了“文字环绕”效果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、脱离文档流的特点">2、脱离文档流的特点<a class="anchor" href="#2、脱离文档流的特点">·</a></h4><ul><li>块元素<ol><li>块元素不在独占一行</li><li>脱离文档流以后宽度和高度被内容撑开</li></ol></li><li>行内元素<ol><li>行内元素脱离文档流之后会变成块元素，可以设置宽高；也就是不区分行内和块了</li></ol></li></ul><h3 id="2、高度塌陷、清除浮动">2、高度塌陷、清除浮动<a class="anchor" href="#2、高度塌陷、清除浮动">·</a></h3><h4 id="出现场景：">出现场景：<a class="anchor" href="#出现场景：">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box1 clearfix&quot;&gt;  //无高度</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;box2&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;  //浮动</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>子浮动、父无高度塌陷</p><ul><li><p>浮动布局中，父元素的高度默认是子元素撑开的；</p></li><li><p>当子元素浮动后，其完全脱离文档流，此时子元素无法撑起父元素的高度，导致父元素高度丢失；</p></li><li><p>父元素高度丢失，导致其下的元素会自动上移，导致页面的布局混乱；</p></li></ul><h4 id="怎么解决：">怎么解决：<a class="anchor" href="#怎么解决：">·</a></h4><ul><li><h4 id="解决1：clear属性">解决1：clear属性<a class="anchor" href="#解决1：clear属性">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box1 clearfix&quot;&gt;  // 没有高度</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;box2&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;  // 浮动</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box3&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;  // 会跑到跟box2一行，父元素没有高度</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>为后面的元素添加：clear：both</p><p>效果：这种方式并不能改变前面元素的浮动属性，但是后面的元素不会再受到影响。</p><p><strong>原理：<strong>设置清除后，浏览器会自动为元素添加</strong>上外边距</strong>，使其位置不受其他元素的影响。both属性会清除两侧中，最大影响的那侧；</p></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  // 这种情况下，box3会<span class="attribute">margin-top</span>，撑起来父元素的高度，此时并不是box2撑开的</span><br><span class="line"><span class="attribute">clear</span>：both  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="解决2：原理同上">解决2：原理同上<a class="anchor" href="#解决2：原理同上">·</a></h4><p>解决方式1，在用结构去修改样式，新添加样式。但我们希望css的问题就css解决。</p><ul><li>可以使用css中伪元素选择器</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; //伪元素选择器，行内元素，不会独占一行，要转换一下</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用这种方式，同样可以解决外边距重叠问题</li></ul></li><li><h4 id="解决3：BFC-不是很推荐">解决3：BFC       不是很推荐<a class="anchor" href="#解决3：BFC-不是很推荐">·</a></h4><ul><li><p>方法1：<strong>父元素也设置浮动</strong>               <strong>不推荐</strong></p></li><li><p>方法2：<strong>父级添加overflow</strong>   BFC，在IE6中还需要触发 hasLayout    不是很推荐</p><ul><li>优点：代码简洁，不存在结构和语义化问题</li><li>缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素；</li></ul></li><li><p>方法3：**父元素设置display:table **      <strong>不推荐</strong></p><ul><li>优点：结构语义化完全正确，代码量极少</li><li>缺点：盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用</li></ul></li></ul></li></ul><h3 id="3、BFC">3、BFC<a class="anchor" href="#3、BFC">·</a></h3><h4 id="1、概念：">1、概念：<a class="anchor" href="#1、概念：">·</a></h4><p>块级盒子渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用</p><ul><li>BFC本身不会发生<code>margin</code>重叠。</li><li><strong>BFC可以彻底解决子元素浮动带来的的高度坍塌和文字环绕问题。</strong></li></ul><h4 id="2、规则：">2、规则：<a class="anchor" href="#2、规则：">·</a></h4><ol><li><p>内部<code>box</code>在垂直方向，一个接一个的放置</p><ul><li>内部bx就是块级元素，所以平常div、p是独占一行</li></ul></li><li><p>box的垂直方向由<code>margin</code>决定，<strong>属于同一个BFC的两个box间的margin会重叠</strong></p><ul><li><p>HTML是BFC，所以内部垂直方向的元素margin会发生重叠；</p></li><li><p>但子孙元素与该BFC上下边界margin不能重叠，保证了BFC内部的元素不会影响外部的元素；</p></li><li><p>两个上下相邻的BFC之间折不折叠要看具体情况：</p><p>如display: inline-block、float: left不会折叠；而overflow: hidden会折叠</p></li></ul></li><li><p>每一个盒子的左外边距应该和<strong>包含块</strong>的左边缘相接触。即使存在浮动也是如此，除非子盒子形成了一个新的BFC。</p><ul><li><p>是普通的流布局和定位布局默认贴着“左侧”思想的总结：</p><ol><li><p>包含块未必就是父级元素。对于<code>position: absolute</code>来说，包含块是指第一个<code>positoin</code>不为<code>static</code>的祖先元素</p></li><li><p>BFC中的盒子应该与其自身的包含块相接触，而非与BFC盒子本身相接触</p></li><li><p>BFC中的盒子是与其包含块的 左边缘 相接触，而不是包含块的 <code>left-border</code> 相接触</p><p>左边缘可能是<code>content box</code>的左边缘（非绝对定位如<code>position: relative</code> <code>float: left</code>，也可能是<code>padding box</code>的左边缘（如绝对定位<code>position: absolute</code> <code>position: fixed</code>）</p></li></ol></li></ul></li><li><p>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；</p></li><li><p>一个隔离独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</p></li><li><p>BFC的区域不会与<code>float box</code>重叠；</p></li></ol><h4 id="3、如何触发：">3、如何触发：<a class="anchor" href="#3、如何触发：">·</a></h4><ol><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>overflow</code>不为<code>visible</code></li><li><code>display</code>为<code>inline-block</code>, <code>flex</code>，<code>table</code>，<code>table-cell</code></li></ol><h3 id="4、IFC">4、IFC<a class="anchor" href="#4、IFC">·</a></h3><h4 id="1、包含块">1、包含块<a class="anchor" href="#1、包含块">·</a></h4><ul><li>概念：离当前元素最近的祖先块元素</li><li>作用：元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系</li><li>举例：<ul><li>元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li><li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li><li>fixed的包含块是当前可视窗口</li><li>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li></ul></li></ul></li></ul><h4 id="2、控制框">2、控制框<a class="anchor" href="#2、控制框">·</a></h4><p>块级元素和块框以及行内元素和行框的相关概念</p><p><strong>块框:</strong></p><ul><li><p><strong>块级元素</strong>会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</p></li><li><p><strong>块框</strong>同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被<strong>匿名块框</strong>包围</p></li><li><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">Some text</span><br><span class="line">&lt;P&gt;More text</span><br><span class="line">&lt;/DIV&gt;</span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含</p></li><li><p><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p></li></ul><p><strong>行内框：</strong></p><ul><li><p>一个行内元素生成一个<strong>行内框</strong>，行内元素能排在一行，允许左右有其它元素</p></li><li><p>关于<strong>匿名行内框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/EM&gt; text&lt;/P&gt;</span><br></pre></td></tr></table></figure><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some </code>，<code> text</code>，此时会专门为这些文本生成匿名行内框</p></li></ul><h4 id="3、display属性的影响">3、display属性的影响<a class="anchor" href="#3、display属性的影响">·</a></h4><p><code>display</code>的几个属性也可以影响不同框的生成：</p><ul><li><code>block</code>，元素生成一个块框</li><li><code>inline</code>，元素产生一个或多个的<strong>行内框</strong></li><li><code>inline-block</code>，元素产生一个<strong>行内级块框</strong>，行内块框的内部会被当作块框来格式化（这也是为什么会产生<code>BFC</code>），而此元素本身会被当作行内框来格式化（）</li><li><code>none</code>，<strong>不生成框</strong>，不在格式化结构中，另一个<code>visibility: hidden</code>则<strong>会产生一个不可见的框</strong></li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列</li></ul><h4 id="4-IFC">4. IFC<a class="anchor" href="#4-IFC">·</a></h4><ul><li><p>IFC即行内框产生的格式上下文，行内元素自身如何显示以及在框内如何摆放的渲染规则</p></li><li><p>特点：</p><ul><li>框一个接一个地水平排列，起点是包含块的顶部。</li><li>水平方向上的 margin，border 和 padding 在框之间得到保留</li><li>框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</li></ul></li><li><p><strong>行框</strong></p><p><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong></p></li><li><p>行框的规则：</p><ul><li>行内框的分割：如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中</li><li>行框在堆叠时没有垂直方向上的分割且永不重叠</li><li>行框的宽度由它的包含块和其中的浮动元素决定，高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框</li><li>行框的左边接触到其包含块的左边，右边接触到其包含块的右边</li></ul></li><li><p>补充下IFC规则：</p><ul><li>浮动元素可能会处于包含块边缘和行框边缘之间</li><li>尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</li><li>同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</li><li>当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 <code>text-align</code> 特性</li><li>空的行内框应该被忽略。即不包含文本，保留空白符，margin/padding/border非0的行内元素，以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，并且不是以换行结束的行框，必须被当作零高度行框对待</li></ul></li></ul><h4 id="5、总结：">5、总结：<a class="anchor" href="#5、总结：">·</a></h4><ul><li>行内元素总是会应用IFC渲染规则</li><li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li><li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li><li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li><li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮动 </tag>
            
            <tag> 高度塌陷 </tag>
            
            <tag> BFC </tag>
            
            <tag> IFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的选择器</title>
      <link href="/posts/854292428.html"/>
      <url>/posts/854292428.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS选择器">一、CSS选择器<a class="anchor" href="#一、CSS选择器">·</a></h2><h3 id="1、CSS选择器">1、CSS选择器<a class="anchor" href="#1、CSS选择器">·</a></h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/613b29f0bfb74f8e84947e243f865875~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 50%;" /><h4 id="1、分类">1、分类<a class="anchor" href="#1、分类">·</a></h4><ul><li><h4 id="基本选择器">基本选择器<a class="anchor" href="#基本选择器">·</a></h4></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* ID 选择器， 如 <span class="selector-id">#id</span>&#123;&#125;</span><br><span class="line">* 类选择器， 如 <span class="selector-class">.class</span>&#123;&#125;</span><br><span class="line">* 标签选择器， 如 <span class="selector-tag">span</span>&#123;&#125;</span><br><span class="line">* 通配选择器， 如 *&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="组合选择器">组合选择器<a class="anchor" href="#组合选择器">·</a></h4></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/* 后代选择器  空格隔开   匹配所有符合的后代元素*/</span></span><br><span class="line">    <span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">background</span>: <span class="number">#ff8585</span>  &#125;</span><br><span class="line">    <span class="comment">/* 子元素选择器  &gt; 连接; 匹配符合的直接子元素; 不包括子元素的子元素 */</span></span><br><span class="line">    <span class="selector-class">.div1</span>&gt;<span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: <span class="number">#6155a6</span> &#125;</span><br><span class="line">    <span class="comment">/* 群组选择器  逗号隔开 */</span></span><br><span class="line">    <span class="selector-class">.div1</span>, <span class="selector-class">.div2</span> &#123; <span class="attribute">color</span>: <span class="number">#a7c5eb</span> &#125;</span><br><span class="line">    <span class="comment">/* 相邻兄弟元素选择器  + 连接; 匹配某元素后紧邻的兄弟元素 */</span></span><br><span class="line">    <span class="selector-class">.div3</span> + <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: <span class="number">#fd3a69</span> &#125;</span><br><span class="line">    <span class="comment">/* 兄弟选择器   ~ 连接; 匹配某元素后所有同级的指定元素，强调的是所有的 */</span></span><br><span class="line">    <span class="selector-class">.div5</span> ~ <span class="selector-tag">div</span> &#123;  <span class="attribute">color</span>: <span class="number">#008891</span> ; &#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="伪元素选择器-略">伪元素选择器         略<a class="anchor" href="#伪元素选择器-略">·</a></h4></li><li><h4 id="伪类选择器-略">伪类选择器             略<a class="anchor" href="#伪类选择器-略">·</a></h4></li><li><h4 id="属性选择器">属性选择器<a class="anchor" href="#属性选择器">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[属性名]</span> 选择含有指定属性的元素</span><br><span class="line"><span class="selector-attr">[属性名=属性值]</span> 选择含有指定属性和属性值的元素</span><br><span class="line"><span class="selector-attr">[属性名^=属性值]</span> 以属性值开头的元素</span><br><span class="line"><span class="selector-attr">[属性名$=属性值]</span> 以属性值结尾的元素</span><br><span class="line"><span class="selector-attr">[属性名*=属性值]</span> 以属性值含有某值的元素</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title^=abc]</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、选择器优先级">2、选择器优先级<a class="anchor" href="#2、选择器优先级">·</a></h4><ul><li>!important（最强势） &gt; 内联(1000) &gt; id(100) &gt; class(10) = 属性选择器 = 伪类选择器 &gt; 标签选择器(1) = 伪元素选择器 &gt; 通用</li><li>权重计算important不参与；它高于没有important的，多个会互相抵消，具体不知道</li><li>权重值相同时，写在后面的样式生效</li><li>如果针对同一元素样式存在冲突且同时存在 !important ，那么选择器总权重值高者生效</li><li>权重即使无限叠加也不能跨层级</li><li>指定大于继承，继承最低</li></ul><h4 id="3、样式优先级">3、样式优先级<a class="anchor" href="#3、样式优先级">·</a></h4><ul><li>内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表&gt; @import导入</li></ul><h3 id="2、伪元素选择器">2、伪元素选择器<a class="anchor" href="#2、伪元素选择器">·</a></h3><ul><li><p>特点：无中生有，用于创建一些不在DOM树中的元素，并为其添加样式</p><p>比如：通过:before 来在一个元素前增加一些文本，并为其添加样式。虽然用户可以看到这些文本，但是实际上不在文档树中</p></li><li><p>用途：</p><ol><li>清除浮动</li><li>辅助生成一些装饰性的箭头之类，保证html语义，不会出现无意义的空元素</li></ol></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ::after 在选中元素的最后添加一个子元素，默认为行内元素 (替换元素上不生效) */</span></span><br><span class="line"><span class="selector-class">.div1</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">content</span>: <span class="string">&#x27;div1 的 after&#x27;</span>; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">color</span>: <span class="number">#ef4f4f</span> &#125;</span><br><span class="line"><span class="comment">/* ::before 在选中元素的第一个位置添加一个子元素 (其他用法同 ::after) */</span></span><br><span class="line"><span class="selector-class">.div2</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content</span>: <span class="string">&#x27;div2 的 before&#x27;</span>; <span class="attribute">margin-right</span>: <span class="number">10px</span>; <span class="attribute">color</span>: <span class="number">#ee9595</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ::first-letter 匹配选中块级元素的第一行的第一个字符 */</span></span><br><span class="line"><span class="selector-class">.div3</span><span class="selector-pseudo">::first-letter</span> &#123; <span class="attribute">color</span>: <span class="number">#ff4646</span> &#125;</span><br><span class="line"><span class="comment">/* ::first-line 匹配选中块级元素的第一行 */</span></span><br><span class="line"><span class="selector-class">.div4</span><span class="selector-pseudo">::first-line</span> &#123; <span class="attribute">color</span>:  <span class="number">#9dab86</span> &#125;</span><br><span class="line"><span class="comment">/* ::marker 匹配选中有序或无序列表的序号或符号 */</span></span><br><span class="line"><span class="selector-class">.div5</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">::marker</span> &#123; <span class="attribute">color</span>: <span class="number">#fdb827</span> &#125;</span><br><span class="line"><span class="comment">/* ::selection 匹配元素中被选中高亮的部分 */</span></span><br><span class="line"><span class="selector-class">.div6</span><span class="selector-pseudo">::selection</span> &#123; <span class="attribute">background</span>: <span class="number">#9dab86</span>; <span class="attribute">color</span>: white &#125;</span><br></pre></td></tr></table></figure><h3 id="3、伪类选择器">3、伪类选择器<a class="anchor" href="#3、伪类选择器">·</a></h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/310652ad0bf040cda0b17b4054cecaa1~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 80%;" /><ul><li><p>特点：</p><ol><li>当已有元素处于的某个状态时，为其添加对应的样式</li><li>虽然和普通css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类</li></ol></li><li><p>用途：改变超链接的样式</p></li></ul><h4 id="1、动态伪类">1、动态伪类<a class="anchor" href="#1、动态伪类">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="attribute">color</span>: <span class="number">#11698e</span>; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: <span class="number">#9fb8ad</span>; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123; <span class="attribute">color</span>: <span class="number">#383e56</span>; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123; <span class="attribute">color</span>: <span class="number">#fb743e</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="2、结构性伪类">2、结构性伪类<a class="anchor" href="#2、结构性伪类">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/* 父元素的第一个子元素且该子元素为 p 的元素 */</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123; <span class="attribute">background</span>: <span class="number">#046582</span>; &#125;</span><br><span class="line">    <span class="comment">/* 父元素中第 2n 个子元素且为 p 的元素 */</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n) &#123; <span class="attribute">background</span>: <span class="number">#bb8082</span>; &#125;</span><br><span class="line">    <span class="comment">/* 父元素中唯一子元素的 i 元素 */</span></span><br><span class="line">    <span class="selector-tag">i</span><span class="selector-pseudo">:only-child</span> &#123; <span class="attribute">background</span>: <span class="number">#865858</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 父元素中第一个 span 元素 */</span></span><br><span class="line">    <span class="selector-tag">span</span><span class="selector-pseudo">:first</span>-of-type &#123; <span class="attribute">background</span>: <span class="number">#6e7582</span>; &#125;</span><br><span class="line">    <span class="comment">/* 父元素中第 2n 个 span 元素 */</span></span><br><span class="line">    <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>n) &#123; <span class="attribute">background</span>: <span class="number">#f39189</span>; &#125;</span><br><span class="line">    <span class="comment">/* 父元素有且仅有一个为 i 的元素 */</span></span><br><span class="line">    <span class="selector-tag">strong</span><span class="selector-pseudo">:only-of-type</span> &#123; <span class="attribute">background</span>: <span class="number">#8e7f7f</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 没有子元素的元素 */</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:empty</span> &#123; <span class="attribute">height</span>: <span class="number">16px</span>; <span class="attribute">background</span>: <span class="number">#bbb</span>; &#125;</span><br><span class="line">    <span class="comment">/* 根元素   HTML 中相当于 &lt;html&gt; */</span></span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123; <span class="attribute">background</span>: <span class="number">#e2d5d5</span>; <span class="attribute">color</span>: <span class="number">#fff</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="3、目标伪类、否定伪类、语言伪类">3、目标伪类、否定伪类、语言伪类<a class="anchor" href="#3、目标伪类、否定伪类、语言伪类">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 目标伪类 :target: 代表一个唯一的页面元素(目标元素)，其 id 与当前URL片段匹配 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:target</span> &#123; <span class="attribute">color</span>: <span class="number">#f05454</span>; &#125;</span><br><span class="line"><span class="comment">/* 否定伪类 :not   注: 仅 Chrome、Firefox 和 Safari 高版本浏览器适用*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:not</span>(<span class="selector-id">#p1</span>)&#123; <span class="attribute">color</span>: <span class="number">#e27802</span>; &#125;</span><br><span class="line"><span class="comment">/* 语言伪类 :lang */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:lang</span>(zh) &#123; <span class="attribute">color</span>: <span class="number">#ffc1b6</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="4、表单类伪类">4、表单类伪类<a class="anchor" href="#4、表单类伪类">·</a></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* :enabled 可用状态 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:enabled</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#7c9473</span>; &#125;</span><br><span class="line">   <span class="comment">/* :disabled 禁用状态 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:disabled</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#cfdac8</span>;  <span class="attribute">cursor</span>: not-allowed; &#125;</span><br><span class="line">   <span class="comment">/* :checked radio 或 checkbox 表单被勾选状态 */</span></span><br><span class="line">   <span class="comment">/* 注意书写顺序，选择元素相同时 :checked 应写在 :enabled/:disabled 后面 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:checked</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#c0e218</span> ; &#125;</span><br><span class="line">   <span class="comment">/* :default 表示一组相关元素中的默认(选中)表单元素   此处 :default 应用于默认设置了 checked 的 radio 表单上 */</span></span><br><span class="line">   <span class="comment">/* 该选择器可以在 &lt;button&gt;, &lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 以及 &lt;option&gt; 上使用 */</span></span><br><span class="line">    <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:default</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#86aba1</span>;&#125;</span><br><span class="line">   <span class="comment">/* :read-write 可读及可写状态。 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-pseudo">:read-write</span> &#123; <span class="attribute">background</span>: <span class="number">#7c9473</span>; &#125;</span><br><span class="line">   <span class="comment">/* :read-only 只读状态 */</span></span><br><span class="line">   <span class="selector-tag">input</span><span class="selector-pseudo">:read-only</span> &#123; <span class="attribute">background</span>: <span class="number">#cfdac8</span>; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择器 </tag>
            
            <tag> 选择器优先级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的样式隔离</title>
      <link href="/posts/710205459.html"/>
      <url>/posts/710205459.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、为什么需要css隔离">1、为什么需要css隔离<a class="anchor" href="#1、为什么需要css隔离">·</a></h3><p>基于组件化的搭建系统在提升研发效率的同时，组件化面临着一个痛点—组件样式隔离的问题</p><ul><li>全局污染：CSS 选择器的作用域是全局的，所以很容易引起选择器冲突；而为了避免全局冲突，又会导致类命名的复杂度上升</li><li>复用性低：CSS 缺少抽象的机制，选择器很容易出现重复，不利于维护和复用</li></ul><p>css隔离就是为了解决这个问题，vue 框架已经帮我们实现了 css 模块化, 通过 style 标签的 scoped 指令定义作用域，通过编译为该作用域所有标签生成唯一的属性。如图：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b86cc72b94e4df49adb0fba1ffee3eb~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 33%;" /><p>但是 react 并未给我们实现，解决方案主要有以下几种：</p><img src="https://segmentfault.com/img/bVcQ2Nm" alt="image.png" style="zoom:50%;" /><h3 id="做法1、命名空间-代码维护困难">做法1、命名空间          代码维护困难<a class="anchor" href="#做法1、命名空间-代码维护困难">·</a></h3><ul><li><p>做法：</p><p>给每个不同模块使用的css规划好命名，以不同的前缀代表不同的含义，实现样式分组，文件分块，达到模块化的目的</p><p>第三方组件在导出 css 文件时，很多都使用的是这种方式：</p><p>比如，<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design">ant-design</a> 导出的 css 中使用 <code>ant-</code> 前缀标识，<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2Fdcloudio%2Fmui">mui</a> 导出的 css 中使用 <code>mui-</code> 前缀标识等等</p></li><li><p>缺点：</p><ol><li>并不是真正意义上的模块化，因为无法避免全局冲突的问题</li><li>编写起来很繁琐，维护成本会很高</li></ol></li></ul><h4 id="最佳实践：">最佳实践：<a class="anchor" href="#最佳实践：">·</a></h4><p>比如网易的 css 规范框架 <a href="https://link.segmentfault.com/?url=http%3A%2F%2Fnec.netease.com%2F">NEC</a>，<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fwww.h-ui.net%2F">H-ui</a></p><ul><li>一个 css 文件不宜过大，可以使用 <code>@import</code> 进行文件分块；</li><li>样式渲染尽量不要使用 <code>#id</code> <code>[attr]</code>，应尽量使用 <code>.class</code>；</li><li>使用 js 库操作 dom 时，尽量不要用 <code>.class</code>，应尽量用 <code>#id</code> <code>data-set</code>，如 <code>$('#main'), $('[data-tab=&quot;1&quot;]')</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-tab</span>=<span class="string">&quot;1&quot;</span>&gt;</span>tab1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-tab</span>=<span class="string">&quot;2&quot;</span>&gt;</span>tab2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-tab-container</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-tab-container</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="做法2-css-modules（导出为-js-）-代码维护困难">做法2. css-modules（导出为 js ） 代码维护困难<a class="anchor" href="#做法2-css-modules（导出为-js-）-代码维护困难">·</a></h3><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/30/16f5477372d2bee3~tplv-t2oaga2asx-watermark.awebp" alt="总结" style="zoom: 80%;" /><h4 id="1、思想">1、思想<a class="anchor" href="#1、思想">·</a></h4><ul><li>使用 <code>js</code> 来加载 <code>css</code> 文件，并将 <code>css</code> 的内容导出为一个对象，使用 <code>js</code> 来渲染整个 dom 树和匹配相应的样式到对应的元素上</li><li>在这个过程中，我们便有机会对 css 做额外的处理，来达到模块化的目的。</li></ul><h4 id="2、做法">2、做法<a class="anchor" href="#2、做法">·</a></h4><p><strong>它需要在 jsx 中进行 className 的动态绑定：</strong>，其中对 css 书写需求主要是：</p><ol><li>应用 <code>.class</code>，而非<code>#id</code> <code>[attr]</code>（因为只有 <code>.class</code> 才能导出为对象的属性）；</li><li>推荐用 <code>.className</code> 书写，而非 <code>.class-name</code>（前者可以通过 <code>styles.className</code> 访问，后者需要通过 <code>styles['class-name']</code> 才能访问）</li><li>这个功能需要构建工具的支持，如果使用 <a href="https://link.segmentfault.com/?url=http%3A%2F%2Fwebpack.js.org">webpack</a> 构建工程的话，可以使用 <a href="https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fcss-loader">css-loader</a>，并设置 <code>options.modules</code> 为 <code>true</code>， 便可使用模块化的功能了</li></ol><h4 id="3、它的问题：">3、它的问题：<a class="anchor" href="#3、它的问题：">·</a></h4><ol><li><p>问题1：需要先编写样式而不是先编写元素结构和定义 className</p></li><li><p>问题2：在 className 写法上由于需要使用获取对象属性的写法，会导致一些使用连字符的样式类名需要用中括号才行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">container</span>-title &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#123;style[</span>&quot;<span class="attr">container-title</span>&quot;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      Hello World</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>问题3：其编译产物中 className 的值会变成一个哈希字符串，类名确实独一无二了，但可读性极差、且如果在作为其他组件的子组件使用时，如果父组件想要覆盖子组件样式，就没法儿支持了</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;h1 <span class="keyword">class</span>=<span class="string">&quot;_3zyde4l1yATCOkgn-DBWEL&quot;</span>&gt;</span><br><span class="line"><span class="title class_">Hello</span> <span class="title class_">World</span></span><br><span class="line">&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">.<span class="property">_3zyde4l1yATCOkgn</span>-<span class="variable constant_">DBWEL</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4、webpack配置-这个配置已过时，请看excel解析说的">4、webpack配置   这个配置已过时，请看excel解析说的<a class="anchor" href="#4、webpack配置-这个配置已过时，请看excel解析说的">·</a></h4><p>这个功能需要构建工具的支持，如果使用 <a href="https://link.segmentfault.com/?url=http%3A%2F%2Fwebpack.js.org">webpack</a> 构建工程的话，可以 配置 css-loader 或者 scss-loader , module 为 true</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">modules</span>: <span class="literal">true</span>, <span class="comment">// 开启模块化</span></span><br><span class="line">        <span class="attr">localIdentName</span>: <span class="string">&#x27;[path][name]-[local]-[hash:base64:5]&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e81eff3bce7b4d168b7cf72899d75325~tplv-k3u1fbpfcp-watermark.awebp" alt="效果图"></p><p>localIdentName 自定义生成的类名格式，可选参数有：</p><ul><li>[path]表示样式表相对于项目根目录所在的路径(默认不拼接)</li><li>[name] 表示样式表文件名称</li><li>[local] 表示样式表的类名定义名称</li><li>[hash:length] 表示 32 位的 hash 值 注意：只有类名选择器和 ID 选择器才会被模块化控制，类似 body h2 span 这些标签选择器是不会被模块化控制</li></ul><h4 id="4-2-补充">4.2 补充<a class="anchor" href="#4-2-补充">·</a></h4><h5 id="1、引入css文件：">1、引入css文件：<a class="anchor" href="#1、引入css文件：">·</a></h5><p>【注意1】：create-react-app, 默认已支持CSS Modules，所以不需webpack做开启模块化的添加配置了；</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#123;styles[<span class="string">&#x27;upload-wrap&#x27;</span>]&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Upload</span> &#123;<span class="attr">...uploadProps</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">icon</span>=<span class="string">&#123;</span>&lt;<span class="attr">UploadOutlined</span>/&gt;</span>&#125; &gt;上传文件<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">file-text</span>&#x27;]&#125;&gt;</span>支持扩展名: .doc .docx .jpg .png <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Upload</span>&gt;</span></span> </span><br><span class="line">  <span class="comment">// 这两种方式完全一样的：注意cssModule推荐使用驼峰</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">&#123;styles[</span>&#x27;<span class="attr">upload-end</span>&#x27;]&#125;&gt;</span>蛤蛤蛤11<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">&#123;styles.uploadEnd&#125;</span>&gt;</span>蛤蛤蛤22<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>【注意2】：</p><ol><li>以styles[‘upload-end’]形式写的：样式也要这样写</li><li>以styles.uploadEnd形式写的：样式也是uploadEnd，形式对应   <strong>推荐√</strong></li></ol><p>【注意3】：引入方式，这种方式下，<strong>样式不生效的</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>将index.css文件名改为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./style.module.css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>【疑问】：为什么要带module呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2、引入less文件-？">2、引入less文件          ？<a class="anchor" href="#2、引入less文件-？">·</a></h5><p>要解决的问题：</p><ol><li><p>配置webpack，让less文件生效：</p><p>配置less-loader，注意less-loader版本降级</p></li><li><p>less文件模块化：</p><p>开启less的模块化</p></li></ol><p>【这部分还没有配置好，~~】</p><h4 id="5、css-module-作用域">5、css module 作用域<a class="anchor" href="#5、css-module-作用域">·</a></h4><ul><li>作用域默认为 local 即只在当前模块生效</li><li>global 被 :global 包裹起来的类名，不会被模块化</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 加上 :global 会全局样式 */</span></span><br><span class="line">:<span class="title function_">global</span>(<span class="params">.<span class="variable language_">global</span>-color</span>) &#123;</span><br><span class="line">  <span class="attr">color</span>: blue;</span><br><span class="line">  :<span class="title function_">global</span>(<span class="params">.common-width</span>) &#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、css-module-高级使用">6、css module 高级使用<a class="anchor" href="#6、css-module-高级使用">·</a></h4><h5 id="1、和外部样式混用">1、和外部样式混用<a class="anchor" href="#1、和外部样式混用">·</a></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapperClassNames = <span class="title function_">classNames</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;common-show&#x27;</span>: visible,</span><br><span class="line">  <span class="string">&#x27;common-hide&#x27;</span>: !visible,</span><br><span class="line">  [styles1[<span class="string">&#x27;view-wrapper&#x27;</span>]]: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用classNames库</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;wrapperClassNames&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 使用模板字符串</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">styles1.content</span>&#125; $&#123;<span class="attr">styles1.color</span>&#125; <span class="attr">common-show</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">  我是文章内容我是文章内容我是文章内容我是文章内容我是文章内容我是文章内容</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2、覆盖第三方-UI-库">2、覆盖第三方 UI 库<a class="anchor" href="#2、覆盖第三方-UI-库">·</a></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 覆盖第三方UI库 样式*/</span>&#125;</span><br><span class="line">&lt;div className=&#123;styles1[<span class="string">&#x27;am-button-custom-wrapper&#x27;</span>]&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">primary</span>&#x27;&#125; <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> toggle()&#125;&gt;</span></span><br><span class="line"><span class="language-xml">     &#123;visible ? &#x27;隐藏&#x27; : &#x27;显示&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  覆盖第三方UI库的 样式</span></span><br><span class="line">.<span class="property">am</span>-button-custom-wrapper &#123;</span><br><span class="line">  :<span class="variable language_">global</span> &#123;</span><br><span class="line">    .<span class="property">am</span>-button-primary &#123;</span><br><span class="line">      <span class="attr">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做法3-CSS-in-JS（内置-js，绑定组件）">做法3. CSS-in-JS（内置 js，绑定组件）<a class="anchor" href="#做法3-CSS-in-JS（内置-js，绑定组件）">·</a></h3><h4 id="1、思想-2">1、思想<a class="anchor" href="#1、思想-2">·</a></h4><ul><li><p>思路1：把整个组件的资源进行封装，并只对外暴露一个对象，而调用者无需关心组件的内部实现和资源，直接调用这个对象就够了</p></li><li><p>思路2：就是将 css 内置 js 中，成为 js 的一部分，这样做的目的，一是 css 的模块化，二是直接绑定到组件上</p><p>比如，<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2Fmui-org%2Fmaterial-ui">material-ui</a>、<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2Fzeit%2Fstyled-jsx">styled-jsx</a>、<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2Fcssinjs%2Fjss">jss</a>、<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue">vue style scoped</a> 便是使用的这种方式</p></li><li><p><strong>缺点</strong>：</p><ol><li>不太符合关注点分离的开发习惯</li><li>不仅会导致js文件的膨胀，并且其构建产物中样式大多是通过 style 内联的形式，这种方式对于样式复写也会造成较高的成本</li></ol></li></ul><h4 id="2、实践1">2、实践1<a class="anchor" href="#2、实践1">·</a></h4><p>比如（以 react 为例），一个 Welcome 组件，包括一个 js 文件、一个 css 文件、图片：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Welcome</span> 组件</span><br><span class="line">|-- welcome.<span class="property">js</span></span><br><span class="line">|-- welcome.<span class="property">css</span></span><br><span class="line">|-- images/</span><br></pre></td></tr></table></figure><p>在 <code>welcome.js</code> 中便可如下加载（使用“导出为 js 对象”的 css 模块化）：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./welcome.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> image1 <span class="keyword">from</span> <span class="string">&#x27;./images/1.jpg&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="3、实践2：styled-jsx">3、实践2：styled-jsx<a class="anchor" href="#3、实践2：styled-jsx">·</a></h4><p><a href="https://zhuanlan.zhihu.com/p/188318692">jsx组件样式隔离的最佳实践 - 知乎 (zhihu.com)</a></p><ul><li><p><code>styled-jsx</code> 的原理：</p><p>根据当前文件的位置、内容生成一个全局唯一的标识，然后把这个标识追加到组件每一个元素上，每一个样式选择器上，达到模块化的目的</p></li></ul><h5 id="1、安装工具（babel-转码所需）">1、安装工具（babel 转码所需）<a class="anchor" href="#1、安装工具（babel-转码所需）">·</a></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">npm install --save styled-jsx</span><br></pre></td></tr></table></figure><h5 id="2、配置-babel-plugins（如-babelrc）">2、配置 babel plugins（如 <code>.babelrc</code>）<a class="anchor" href="#2、配置-babel-plugins（如-babelrc）">·</a></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;styled-jsx/babel&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、添加源文件代码">3、添加源文件代码<a class="anchor" href="#3、添加源文件代码">·</a></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">container</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">hello</span>&#x27;&#125;&gt;</span>Hello! Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">hi</span>&#x27;&#125;&gt;</span>Hi!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">jsx</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            &#123;`</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="selector-class">.container</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">              <span class="attribute">color</span>: blue;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">              <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="selector-class">.hello</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">              <span class="attribute">color</span>: yellow;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="selector-id">#hi</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">              <span class="attribute">color</span>: green;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            &#125;`</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">          &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="4、转码">4、转码<a class="anchor" href="#4、转码">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">babel path/to/hello.<span class="property">js</span> -d target/dir</span><br></pre></td></tr></table></figure><p>转码后的文件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _JSXStyle <span class="keyword">from</span> <span class="string">&#x27;styled-jsx/style&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">jsx-234963469</span>&#x27; + &#x27; &#x27; + &#x27;<span class="attr">container</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">jsx-234963469</span>&#x27; + &#x27; &#x27; + &#x27;<span class="attr">hello</span>&#x27;&#125;&gt;</span>Hello! Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">hi</span>&#x27;&#125; <span class="attr">className</span>=<span class="string">&#123;</span>&quot;<span class="attr">jsx-234963469</span>&quot;&#125;&gt;</span>Hi!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">_JSXStyle</span> <span class="attr">styleId</span>=<span class="string">&#123;</span>&quot;<span class="attr">234963469</span>&quot;&#125; <span class="attr">css</span>=<span class="string">&#123;</span>&quot;<span class="attr">.container.jsx-234963469</span>&#123;<span class="attr">color:blue</span>;&#125;<span class="attr">p.jsx-234963469:first-child</span>&#123;<span class="attr">color:red</span>;&#125;<span class="attr">.hello.jsx-234963469</span>&#123;<span class="attr">color:yellow</span>;&#125;#<span class="attr">hi.jsx-234963469</span>&#123;<span class="attr">color:green</span>;&#125;&quot;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="5、运行">5、运行<a class="anchor" href="#5、运行">·</a></h5><p>实际渲染效果</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">data-styled-jsx</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span><span class="selector-class">.jsx-234963469</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:blue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-class">.jsx-234963469</span><span class="selector-pseudo">:first</span>-child&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.hello</span><span class="selector-class">.jsx-234963469</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:yellow;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#hi</span><span class="selector-class">.jsx-234963469</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:green;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jsx-234963469 container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;jsx-234963469 hello&quot;</span>&gt;</span>Hello! Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;jsx-234963469&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4、实践2：styled-components">4、实践2：styled-components<a class="anchor" href="#4、实践2：styled-components">·</a></h4><ul><li>针对 React 写的一套 css in js 框架, 在你使用 styled-components 进行样式定义的同时，你也就创建了一个 React 组件</li><li>优势: 支持将 props 以插值的方式传递给组件,以调整组件样式, 跨平台可在 RN 和 next 中使用</li><li>缺点： 预处理器和后处理器不兼容</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">const DivWrapper = styled<span class="selector-class">.div</span>`</span><br><span class="line">  <span class="attribute">width</span>: <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: $&#123;(props) =&gt; props<span class="selector-class">.color</span>&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 封装第三方组件库</span><br><span class="line">const AntdButtonWrapper = styled(<span class="selector-tag">Button</span>)`</span><br><span class="line">  <span class="attribute">color</span>: <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 通过属性动态定义样式</span><br><span class="line">const MyButton = styled<span class="selector-class">.button</span>`</span><br><span class="line">  <span class="attribute">background</span>: $&#123;(props) =&gt; (props<span class="selector-class">.primary</span> ? &#x27;palevioletred&#x27; : <span class="string">&#x27;white&#x27;</span>)&#125;;</span><br><span class="line">  <span class="attribute">color</span>: $&#123;(props) =&gt; (props<span class="selector-class">.primary</span> ? &#x27;white&#x27; : <span class="string">&#x27;palevioletred&#x27;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.25em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid palevioletred;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 样式复用</span><br><span class="line">const TomatoButton = styled(MyButton)`</span><br><span class="line">  <span class="attribute">color</span>: tomato;</span><br><span class="line">  <span class="attribute">border-color</span>: tomato;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建动画组件</span><br><span class="line">const Rotate = styled<span class="selector-class">.div</span>`</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">animation</span>: $&#123;rotate&#125; <span class="number">2s</span> linear infinite;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2rem</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><h3 id="做法4：预处理器的嵌套语法和CSS-属性选择器">做法4：预处理器的嵌套语法和CSS 属性选择器<a class="anchor" href="#做法4：预处理器的嵌套语法和CSS-属性选择器">·</a></h3><p>借鉴Vue中的Scoped的做法：</p><ul><li>通过 style 标签的 scoped 指令定义作用域，通过编译为该作用域所有标签生成唯一的属性</li></ul><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b86cc72b94e4df49adb0fba1ffee3eb~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 33%;" /><h4 id="1、做法">1、做法<a class="anchor" href="#1、做法">·</a></h4><ul><li><h4 id="JS文件：">JS文件：<a class="anchor" href="#JS文件：">·</a></h4><p>data-component可以限制为每个组件的名字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app&quot;</span> <span class="attr">data-component</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>隔离css<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="预处理器文件：less、sass">预处理器文件：less、sass<a class="anchor" href="#预处理器文件：less、sass">·</a></h4><p>这样就解决了css class全局污染的问题。简单易用，不用引入新的概率和扩展。</p><p>create-react-app脚手架默认也支持引入scss、less</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[data-component=app]</span> &#123;</span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="selector-class">.title</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">      <span class="attribute">font-weight</span>: bold;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#333333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.text</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#333333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 样式污染 </tag>
            
            <tag> cssModule </tag>
            
            <tag> CSS-in-JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的执行编译过程</title>
      <link href="/posts/3783644122.html"/>
      <url>/posts/3783644122.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS执行过程、垃圾、内存泄漏">JS执行过程、垃圾、内存泄漏<a class="anchor" href="#JS执行过程、垃圾、内存泄漏">·</a></h2><img src="https://img-blog.csdnimg.cn/20201129121945306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdmZWlqaXU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><h3 id="1、JS执行过程-编译">1、JS执行过程----编译<a class="anchor" href="#1、JS执行过程-编译">·</a></h3><ul><li>JS是解释型语音，所以它无需提前编译，而是由解释器实时运行</li><li>JS代码执行时，两个过程：编译阶段和执行阶段</li><li>在编译阶段 <code>JS</code> 引擎主要做了三件事：词法分析、语法分析和代码生成</li></ul><h4 id="1、词法分析">1、词法分析<a class="anchor" href="#1、词法分析">·</a></h4><ul><li><code>JS</code> 引擎会将代码将代码分解成词元（token），每个词法单元<code>token</code>不可再分割</li><li>例如，<code>var a = 2</code> ，这段程序会被分解成：“var、a、=、2、；” 五个 <code>token</code></li></ul><h4 id="2、语法分析">2、语法分析<a class="anchor" href="#2、语法分析">·</a></h4><ul><li>对词元（token）转换成树状结构的 “抽象语法树（AST）”</li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/7/170b245d2c0ba592~tplv-t2oaga2asx-watermark.awebp" alt="2语法分析.png" style="zoom:25%;" /><h4 id="3、生成可执行代码">3、生成可执行代码<a class="anchor" href="#3、生成可执行代码">·</a></h4><p><strong>将<code>AST</code>转换为可执行代码的过程</strong></p><ul><li><p>使用翻译器（translator），将代码转为字节码（bytecode）</p></li><li><p>使用字节码解释器（bytecode interpreter），将字节码转为机器码，最终计算机执行的就是机器码</p></li><li><p>即时编译：</p><p>为了提高运行速度，现代浏览器一般采用即时编译，即<strong>字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存</strong></p></li></ul><h3 id="2、执行上下文分类">2、执行上下文分类<a class="anchor" href="#2、执行上下文分类">·</a></h3><ul><li>执行程序需要有执行环境， 同样解析 <code>JavaScript</code> 也需要执行环境，称它为“执行上下文”</li><li>JS是解释型语言，所以它无需提前编译，而是由解释器实时运行</li></ul><h4 id="1、全局执行上下文">1、全局执行上下文<a class="anchor" href="#1、全局执行上下文">·</a></h4><ul><li>是默认的、最基础的执行上下文，一个程序中只能存在一个全局执行上下文</li><li>做的事情：<ol><li>在执行全局代码前，创建一个全局对象，在浏览器中就是 <code>window</code> 对象</li><li>对全局数据进行预处理：<ul><li>var定义的全局变量==&gt;undefined, 添加为window的属性</li><li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li><li>将 <code>this</code> 指针指向这个全局对象(window)</li></ul></li><li>开始执行全局代码</li></ol></li></ul><h4 id="2、函数执行上下文">2、函数执行上下文<a class="anchor" href="#2、函数执行上下文">·</a></h4><ul><li><p>每次<strong>调用函数时</strong>，都会为该函数<strong>创建</strong>对应的函数执行上下文对象(虚拟的, 存在于栈中)</p></li><li><p>一个程序中可以存在任意数量的函数执行上下文，每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤</p></li><li><p>对局部数据进行预处理：</p><ol><li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li><li><code>arguments</code>==&gt;赋值(实参列表), 添加为执行上下文的属性 --&gt;<a href="https://developer.mozilla.org/zh-CN/docs/orphaned/Web/JavaScript/Reference/Functions/arguments">不懂的同学看这里</a></li><li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性</li><li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li><li>this==&gt;赋值(调用函数的对象)</li></ol></li><li><p>每个函数都拥有自己的执行上下文，但是只有<strong>在函数被调用的时候</strong>才会被创建</p></li><li><p>开始执行函数体代码</p></li></ul><h3 id="3、管理执行上下文–执行栈">3、管理执行上下文–执行栈<a class="anchor" href="#3、管理执行上下文–执行栈">·</a></h3><ul><li>执行栈：栈结构，用来存储代码运行时创建的所有执行上下文</li><li>JS引擎如何创建执行上下文：<ol><li>当 <code>JavaScript</code> 引擎首次读取脚本时，会创建一个全局执行上下文(window)并将其推入当前执行栈</li><li>每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端</li><li>引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出</li><li>上下文控制权将移到当前执行栈的下一个执行上下文</li><li>当所有的代码执行完后, 栈中只剩下window：<code>上下文栈数==函数调用数+1</code></li></ol></li></ul><p>【注意】：作用域与执行上下文不是同一概念：</p><ul><li>执行上下文在运行时，随时可变，甚至没有过上下文（从不调用），调用完毕销毁。而作用域不改变</li></ul><h3 id="4、创建执行上下文">4、创建执行上下文<a class="anchor" href="#4、创建执行上下文">·</a></h3><p>JS引擎创建执行上下文分为两个阶段：<strong>创建阶段 和 执行阶段</strong></p><h4 id="1、创建阶段：在JS代码执行之前，该阶段会发生三件事：">1、创建阶段：在JS代码执行之前，该阶段会发生三件事：<a class="anchor" href="#1、创建阶段：在JS代码执行之前，该阶段会发生三件事：">·</a></h4><h5 id="1、This-绑定：">1、This 绑定：<a class="anchor" href="#1、This-绑定：">·</a></h5><ol><li><p>全局执行上下文中，<code>this</code> 的值指向全局对象</p></li><li><p>函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的</p><p>如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象</p><p>否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）</p></li></ol><h5 id="2、创建词法环境组件：">2、创建词法环境组件：<a class="anchor" href="#2、创建词法环境组件：">·</a></h5><p>词法环境：是一种持有**标识符（变量/函数的名字）—变量映射（对实际对象[包含函数类型对象]或原始数据的引用）**的结构，内部组成两部分：</p><ol><li><strong>环境记录器</strong>：存储变量和函数声明的实际位置</li><li><strong>外部环境的引用</strong>：意味着它可以访问其父级词法环境（作用域）</li></ol><p>词法环境的2种类型：</p><ol><li><p><strong>全局环境</strong>：</p><p>（在全局执行上下文中）是没有外部环境引用的词法环境，外部环境引用是 <strong>null</strong></p><p>它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 <code>this</code>的值指向全局对象</p></li><li><p><strong>函数环境</strong></p><p>函数内部用户定义的变量存储在<strong>环境记录器</strong>中</p><p>并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数</p></li></ol><p><strong>环境记录器</strong>也有两种类型：</p><ul><li><strong>声明式环境记录器</strong>存储变量、函数和参数。注意他还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。               函数环境</li><li><strong>对象环境记录器</strong>用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系。     全局环境</li></ul><h5 id="3、创建变量环境组件">3、<strong>创建</strong>变量环境组件<a class="anchor" href="#3、创建变量环境组件">·</a></h5><ul><li><p>变量环境：</p><p>也是一个词法环境，有着上面定义的词法环境的所有属性</p><p>在 ES6 中，<strong>词法环境</strong>组件和<strong>变量环境</strong>的一个不同就是前者被用来存储函数声明和变量（<code>let</code> 和 <code>const</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定</p></li><li><p>为什么可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>）?</p><ul><li>因为在创建阶段时，**引擎检查代码找出变量和函数声明，**变量最初设置为 <code>undefined</code>（<code>var</code> 情况下）</li><li>而<code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值</li><li>所以在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。这也是所说的变量提升</li></ul></li></ul><h4 id="2、执行阶段：完成对所有这些变量的分配，最后执行代码">2、执行阶段：完成对所有这些变量的分配，最后执行代码<a class="anchor" href="#2、执行阶段：完成对所有这些变量的分配，最后执行代码">·</a></h4><ul><li>变量对象和作用域链是ES3规范中的内容，ES5之后就不再用了</li><li><strong>注意</strong> — 在执行阶段，如果 JS 引擎不能在源码中声明的实际位置（说明已经被声明过了）找到 <code>let</code> 变量的值，它会被赋值为 <code>undefined</code></li></ul><h3 id="3、执行上下文-执行阶段-ES3规范">3、执行上下文 ----- 执行阶段      ES3规范<a class="anchor" href="#3、执行上下文-执行阶段-ES3规范">·</a></h3><p>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><img src="https://img-blog.csdnimg.cn/20201129121945306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdmZWlqaXU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><ul><li><p>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</p></li><li><p><strong>VO（变量对象）和AO（活动对象）</strong></p><ul><li>VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）</li><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>变量对象：</p><ol><li>每个执行上下文都会分配一个变量对象</li><li>变量对象的属性由变量和函数声明构成，在函数上下文情况下，参数列表也会被加入到变量对象中作为属性</li><li>变量对象与当前作用域息息相关：不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量</li></ol></li><li><p><strong>作用域链</strong>：</p><ul><li>在函数上下文中，查找一个变量foo，如果函数的VO中找到了，就直接使用</li><li>否则去它的父级作用域链中（<strong>parent</strong>）找</li><li>如果父级中没找到，继续往上找，直到全局上下文中也没找到就报错</li></ul></li><li><p><strong>this机制等</strong>：</p><ul><li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li>this的值只取决中进入上下文时的情况</li></ul></li><li><p>每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object，VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul></li></ul><h3 id="4、作用域与执行上下文的区别与联系">4、作用域与执行上下文的区别与联系<a class="anchor" href="#4、作用域与执行上下文的区别与联系">·</a></h3><blockquote><ol><li>区别1:</li></ol><ul><li>全局作用域之外，每个函数都会创建自己的作用域，<code>作用域在函数定义时就已经确定了。而不是在函数调用时</code></li><li>全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建</li><li>函数执行上下文是在调用函数时, 函数体代码执行之前创建</li></ul><ol start="2"><li>区别2:</li></ol><ul><li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</li><li>执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放</li></ul><ol start="3"><li>联系:</li></ol><ul><li>执行上下文(对象)是从属于所在的作用域</li><li>全局上下文环境==&gt;全局作用域</li><li>函数上下文环境==&gt;对应的函数使用域</li></ul><p><img src="C:/Users/%E5%B0%8F%E8%99%8E%E7%89%99/Desktop/JavaScript%E7%AC%94%E8%AE%B0/A_JavaScript%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210727141319410.png" alt="image-20210727141319410"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数组</title>
      <link href="/posts/349024060.html"/>
      <url>/posts/349024060.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组">数组<a class="anchor" href="#数组">·</a></h2><h3 id="1、对象、数组遍历-√">1、对象、数组遍历 √<a class="anchor" href="#1、对象、数组遍历-√">·</a></h3><h4 id="1、对象√">1、对象√<a class="anchor" href="#1、对象√">·</a></h4><h5 id="1、for-in-：可枚举属性，包括实例属性、原型属性（无序）">1、<code>for ...in </code>：可枚举属性，包括实例属性、原型属性（无序）<a class="anchor" href="#1、for-in-：可枚举属性，包括实例属性、原型属性（无序）">·</a></h5><ul><li><p>可以拿到constructor：原型上是不可枚举属性但<strong>在实例属性中对它进行了屏蔽</strong></p></li><li><p><code>Object.propertyIsEnumberable()</code>: true/false检测自身属性是否可枚举，对继承来的属性无效</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置属性是否可枚举：</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(对象，修改或新增的属性名，&#123;</span><br><span class="line"><span class="attr">value</span>:修改或新增的属性的值,</span><br><span class="line"><span class="attr">writable</span>:<span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">false</span>,<span class="comment">//enumerable 如果值为false 则不允许遍历</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>  <span class="comment">//configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、Object-keys：">2、<code>Object.keys</code>：<a class="anchor" href="#2、Object-keys：">·</a></h5><p>实例上的可枚举属性，原型继承的不会被遍历，不包含symbol属性</p><h5 id="3、Object-getOwnPropertyNames-：">3、<code>Object.getOwnPropertyNames()</code>：<a class="anchor" href="#3、Object-getOwnPropertyNames-：">·</a></h5><p>遍历实例上的所有属性，不论是否枚举，但不包含Symbol属性，返回一个属性字符串数组</p><h5 id="4、Reflect-ownKeys-：">4、<code>Reflect.ownKeys()</code>：<a class="anchor" href="#4、Reflect-ownKeys-：">·</a></h5><p>遍历实例上的所有属性，不论是否枚举，包含Symbol属性</p><h4 id="2、数组√">2、数组√<a class="anchor" href="#2、数组√">·</a></h4><h5 id="1、forEach">1、<code>forEach</code><a class="anchor" href="#1、forEach">·</a></h5><ul><li><p>迭代中间无法跳出，break，contine均无效；</p></li><li><p>参数是函数，对每个元素做了处理，返回值<strong>undefined</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>currentValue—数组当前值</p></li><li><p>index—当前值索引（可选）</p></li><li><p>arr—该数组（可选）</p></li></ul></li></ul><h5 id="2、for-of">2、<code>for...of</code><a class="anchor" href="#2、for-of">·</a></h5><ul><li>可迭代对象（Array、Map、Set、String、Arguments等）</li></ul><h5 id="3、map、filter、Some、reduce、every">3、<code>map</code>、<code>filter</code>、<code>Some</code>、<code>reduce</code>、<code>every</code><a class="anchor" href="#3、map、filter、Some、reduce、every">·</a></h5><h4 id="3、-for-in-与for-of的区别">3、 <code>for ...in </code>与<code>for...of</code>的区别<a class="anchor" href="#3、-for-in-与for-of的区别">·</a></h4><ul><li><p><code>for...in</code>：本身是为了对象的迭代，但也可用于数组，对象拿到的是key，数组拿到的是value</p></li><li><p><code>for...of</code> ：遍历<strong>可迭代对象</strong>定义要迭代的数据</p></li></ul><h3 id="2、类数组√">2、类数组√<a class="anchor" href="#2、类数组√">·</a></h3><ul><li><p>是一个对象，不是数组。可以索引取值、length属性、for遍历</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;job&#x27;</span>];</span><br></pre></td></tr></table></figure><p><strong>Arguments</strong>对象：是经典的类数组对象：</p><ul><li>函数传递的参数</li><li>length属性：实参的长度</li><li>callee属性：指向的函数自身，可以通过它来调用自身函数</li></ul></li><li><p>区别在于它不能直接使用数组的方法，如果想使用，则需要借助call/apply</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript权威指南判断是否为类数组对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isArrayLike</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                    <span class="comment">// o不是null、undefined等</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp;                <span class="comment">// o是对象</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.<span class="property">length</span>) &amp;&amp;                   <span class="comment">// o.length是有限数值</span></span><br><span class="line">        o.<span class="property">length</span> &gt;= <span class="number">0</span> &amp;&amp;                        <span class="comment">// o.length为非负值</span></span><br><span class="line">        o.<span class="property">length</span> === <span class="title class_">Math</span>.<span class="title function_">floor</span>(o.<span class="property">length</span>) &amp;&amp;    <span class="comment">// o.length是整数</span></span><br><span class="line">        o.<span class="property">length</span> &lt; <span class="number">4294967296</span>)                  <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、类数组转为数组√">2、类数组转为数组√<a class="anchor" href="#2、类数组转为数组√">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. slice  (有副本 ，截取start+end)</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. splice (原数组会被修改，返回删除元素构成的数组，0表示没有删除)</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. ES6 Array.from</span></span><br><span class="line"><span class="comment">// Array.from可以把类数组对象和可遍历（interable）对象（包括set和map）转换为数组</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. concat</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 ES6 ...运算符 作为函数参数的时候可以吧arguments转换成数组</span></span><br><span class="line"><span class="comment">// 扩展运算符...，有Interator接口的对象都可用，对象就不行了，函数的arguments对象就可用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">translateArray</span>(<span class="params">...<span class="variable language_">arguments</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、数组方法">3、数组方法<a class="anchor" href="#3、数组方法">·</a></h3><h4 id="1、splice">1、splice<a class="anchor" href="#1、splice">·</a></h4><p>作用：向数组中添加/删除项目，然后返回被删除的项目构成的新数组，同时原数组也发生了改变</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure><ul><li><p>index：添加/删除项目的位置，使用负数可从数组结尾处规定位置 —必需</p></li><li><p>howmany：要删除的项目数量。<strong>如果设置为 0</strong>，<strong>则不会删除项目</strong> --必需</p></li><li><p>第3项：向数组添加的新项目      --可选</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;William&quot;</span>)<span class="comment">//创建一个新数组，并将索引为2的那项添加wiliam，后面的索引依次后移</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;William&quot;</span>) <span class="comment">//删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;William&quot;</span>) <span class="comment">//删除从 index 2 (&quot;Thomas&quot;) 开始的三个元素，并添加一个新元素 (&quot;William&quot;) 来替代被删除的元素</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、slice：没有修改原数组，返回新数组">2、slice：没有修改原数组，返回新数组<a class="anchor" href="#2、slice：没有修改原数组，返回新数组">·</a></h4><p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</p><ul><li>若传参为空，则返回数组拷贝</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arrayObject.<span class="title function_">slice</span>(start,end)</span><br></pre></td></tr></table></figure><ul><li>start：从何处开始选取。负数，从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。  —必需</li><li>end：从何处结束选取。如果没有指定，那么start到数组结束的所有元素，负数，从数组尾部开始算起   --可选</li></ul><h4 id="3、filter">3、filter<a class="anchor" href="#3、filter">·</a></h4><ul><li><p>遍历数组中每一个元素，返回所有函数返回结果为true的元素，这些元素构成的数组就是filter()方法的返回值</p></li><li><pre><code class="language-js">// 定义数组var names = [&quot;abc&quot;, &quot;cb&quot;, &quot;mba&quot;, &quot;dna&quot;]// 获取names中所有包含'a'字符的元素var newNames = names.filter(function (t) &#123;    return t.indexOf(&quot;a&quot;) != -1&#125;)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">array.filter(function(value,index,array),contetx)</span><br><span class="line">- value—当前数组值，必须</span><br><span class="line">- index—数组索引，非必须</span><br><span class="line">- array—当前数组，非必须</span><br><span class="line">- context—指定回调函数的this值，一般不穿，默认是undefined的</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>实现如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFilter</span> = <span class="keyword">function</span>(<span class="params">fn,context</span>)&#123;</span><br><span class="line">  <span class="comment">// 调用.myFilter方法的那个数组</span></span><br><span class="line">      <span class="keyword">var</span> arr = <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">var</span> newArr = []</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fn.<span class="title function_">call</span>(context,arr[i],i,arr))&#123;</span><br><span class="line">          newArr.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduceToFilter</span> = <span class="keyword">function</span> (<span class="params">fn,context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, current, index)) &#123;</span><br><span class="line">      target.<span class="title function_">push</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、map">4、map<a class="anchor" href="#4、map">·</a></h4><ul><li>遍历数组，每个元素经过某函数的作用后，变成新元素，最后形成一个新数组</li><li>与forEach的区别：<ol><li>forEach返回的是undefined，因此它也不支持链式调用；而map不改变原数组但是会 返回新数组</li><li>forEach没有返回值，不可以中断，不能使用return返回到外层函数；map可以break中断循环，可以return返回到外层函数<ul><li>forEach() 对于空数组是不会执行回调函数的。</li><li>for可以用continue跳过循环中的一个迭代，forEach用continue会报错。</li><li>forEach() 需要用 return 跳过循环中的一个迭代，跳过之后会执行下一个迭代。</li></ul></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">value,index,array</span>), context)</span><br><span class="line">- value—当前数组值，必须</span><br><span class="line">- index—数组索引，非必须</span><br><span class="line">- array—该数组，非必须</span><br><span class="line">- context—指定回调函数的<span class="variable language_">this</span>值</span><br></pre></td></tr></table></figure><ul><li>实现如下</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMap</span> = <span class="keyword">function</span>(<span class="params">fn, context</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//map处理完就push</span></span><br><span class="line">    newArr.<span class="title function_">push</span>(fn.<span class="title function_">call</span>(context, arr[i], i, arr))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">用reduce实现map</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduceToMap</span> = <span class="keyword">function</span> (<span class="params">fn, context</span>) &#123;</span><br><span class="line"><span class="comment">// this就是使用map的数组实例</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">target.<span class="title function_">push</span>(fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, current, index))</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5、reduce">5、reduce<a class="anchor" href="#5、reduce">·</a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">pre,cur,index,arr</span>),initalval)</span><br><span class="line">- pre—当前累加值，必须</span><br><span class="line">- cur—当前数组值，必须</span><br><span class="line">- index—数组索引，非必须</span><br><span class="line">- arr—该数组，非必须</span><br><span class="line">- initalVal—累加值初始值，非必须，**不传值的话，数组第一个元素为默认值**</span><br></pre></td></tr></table></figure><ul><li>实现核心：没有传入initalVal时，初始值设为数组第1个元素，并从第2个元素开始便利。回到函数应该处理第二个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReduce</span>=<span class="keyword">function</span>(<span class="params">fn,inital</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> arr = <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">var</span> total = inital?<span class="attr">inital</span>:arr[<span class="number">0</span>]  <span class="comment">//关键</span></span><br><span class="line">      <span class="keyword">var</span> startIndex = inital?<span class="number">0</span>:<span class="number">1</span>       <span class="comment">//关键</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=startIndex;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        total = fn.<span class="title function_">call</span>(<span class="literal">null</span>,total,arr[i],i,arr)  <span class="comment">//注意要传入一个null，第二个是total</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="6、Sort">6、Sort<a class="anchor" href="#6、Sort">·</a></h4><p>在原数组上排序，不生成副本</p><ul><li><p>若参数为空，按照字符编码的顺序进行排序</p></li><li><p>其他标准：提供比较函数</p><ul><li><p>该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数 a 和 b，其返回值如下：</p><ul><li><p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</p></li><li><p>若 a 等于 b，则返回 0。</p></li><li><p>若 a 大于 b，则返回一个大于 0 的值</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="title class_">Array</span>.<span class="title function_">from</span>(map).<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 如果a是较小的，那么b[1]-a[1]就是正的。a应该在b之后。所以输出是降序排列</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7、some">7、some<a class="anchor" href="#7、some">·</a></h4><p>只要有一个元素比对结果为true，返回结果就为true</p><h4 id="8、every">8、every<a class="anchor" href="#8、every">·</a></h4><ul><li><p>使用指定函数检测数组中的所有元素是否都符合指定条件，所有符合，return true，否则返回false</p></li><li><p>不会改变原始数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), thisValue)</span><br></pre></td></tr></table></figure></li></ul><h4 id="9、Array-from">9、Array.from<a class="anchor" href="#9、Array-from">·</a></h4><ul><li>从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例<ul><li>伪数组对象（拥有一个 <code>length</code> 属性和若干索引属性的任意对象）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/iterable">可迭代对象</a>（可以获取对象中的元素,如 Map和 Set 等）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">// [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ] 从 String 生成数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]);  从 <span class="title class_">Set</span> 生成数组</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(set);     <span class="comment">// [ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapper = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]);  <span class="comment">//从 Map 生成数组</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(map);    <span class="comment">//[[&#x27;1&#x27;, &#x27;a&#x27;], [&#x27;2&#x27;, &#x27;b&#x27;]]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(mapper.<span class="title function_">values</span>());  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;];</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(mapper.<span class="title function_">keys</span>());   <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;];</span></span><br><span class="line"></span><br><span class="line">从类数组对象（<span class="variable language_">arguments</span>）生成数组</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">x</span> =&gt;</span> x + x);       <span class="comment">// [2, 4, 6] 在 Array.from 中使用箭头函数</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i);    <span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="title class_">Array</span>.<span class="title function_">from</span>(map).<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="4、是否改变数组">4、是否改变数组<a class="anchor" href="#4、是否改变数组">·</a></h3><ul><li><h4 id="改变：push、unshift、pop、shift、reverse-、sort、splice">改变：push、unshift、pop、shift、reverse 、sort、splice<a class="anchor" href="#改变：push、unshift、pop、shift、reverse-、sort、splice">·</a></h4></li><li><h4 id="不改变：concat-、map、every、some-、filter、toString、slice-、join、indexOf">不改变：concat 、map、every、some 、filter、toString、slice 、join、indexOf<a class="anchor" href="#不改变：concat-、map、every、some-、filter、toString、slice-、join、indexOf">·</a></h4></li></ul><h3 id="5、数组去重">5、数组去重<a class="anchor" href="#5、数组去重">·</a></h3><h4 id="法1：双层for-splice-基本数据类型">法1：双层for+splice            基本数据类型<a class="anchor" href="#法1：双层for-splice-基本数据类型">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.<span class="property">length</span>;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]===arr[j])&#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(j,<span class="number">1</span>)  <span class="comment">//splice是能改变原数组的，slice不行</span></span><br><span class="line">        j--  <span class="comment">//如果有重复元素，删除之后一定要j--</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法2：用额外空间存储已经出现过的元素">法2：用额外空间存储已经出现过的元素<a class="anchor" href="#法2：用额外空间存储已经出现过的元素">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="title function_">indexOf</span>(arr[i])==-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//  if(!res.includes(arr[i]))&#123;</span></span><br><span class="line">      res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">版本<span class="number">2</span>：对象的键名存储(能对<span class="variable constant_">NAN</span>去重，对象只留前面一个，基本数据类型：)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj.<span class="title function_">hasOwnProperty</span>(<span class="keyword">typeof</span> item + item))&#123;</span><br><span class="line">      res.<span class="title function_">push</span>(item)</span><br><span class="line">      obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">版本<span class="number">3</span>：<span class="title class_">Map</span> 的键名可以是任意类型，而不是像对象那样必须是字符串类型，所以利用这一点，简化版本<span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.<span class="title function_">has</span>(item))&#123;  <span class="comment">//map没有当前元素键名</span></span><br><span class="line">      res.<span class="title function_">push</span>(item)</span><br><span class="line">      map.<span class="title function_">set</span>(item,<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法3：filter-indexOf，基本数据类型：">方法3：filter+indexOf，基本数据类型：<a class="anchor" href="#方法3：filter-indexOf，基本数据类型：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">法<span class="number">1</span>：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">cur,index</span>)&#123;</span><br><span class="line">    <span class="comment">// indexOf:返回的是元素在数组中跟的索引位置，-1代表不存，</span></span><br><span class="line">    <span class="comment">// 否则结果是索引位置，且是从左到右第一次找到的与该元素相等或就是该元素的位置</span></span><br><span class="line">    <span class="comment">// 所以arr.indexOf(cur) == index说明是第一次出现的元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(cur) == index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">法<span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> arr.<span class="title function_">indexOf</span>(i) === arr.<span class="title function_">lastIndexOf</span>(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法4：Set，基本数据类型：NaN能去重，对象不可以">方法4：Set，基本数据类型：NaN能去重，对象不可以<a class="anchor" href="#方法4：Set，基本数据类型：NaN能去重，对象不可以">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">  <span class="comment">// 或者：return Array.from(new Set(arr))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、扁平化数组">6、扁平化数组<a class="anchor" href="#6、扁平化数组">·</a></h3><h4 id="法1：递归-支持指定深度写这个">法1：递归                   支持指定深度写这个<a class="anchor" href="#法1：递归-支持指定深度写这个">·</a></h4><p>遍历数组元素，遇到元素是数组时，递归flatten函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr, deep = <span class="number">1</span></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i]) &amp;&amp; deep &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      res = res.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]))    <span class="comment">//这里一定要连接数组</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">flatten</span>(array, <span class="number">2</span>); <span class="comment">//[1, 2, 3, Array(2), 6, 7]</span></span><br></pre></td></tr></table></figure><h4 id="法2：reduce-递归-支持指定深度-重点√">法2：reduce+递归                 支持指定深度  重点√<a class="anchor" href="#法2：reduce-递归-支持指定深度-重点√">·</a></h4><p>因为是遍历数组所有元素，最终返回一个值-数组，可以用reduce来简化递归代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total,current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(current)? <span class="title function_">flatten</span>(current) : current)</span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定深度版本：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flattenByDeep</span>(<span class="params">array, deep = <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">previousValue, current</span>) =&gt;</span></span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">isArray</span>(current) &amp;&amp; deep &gt; <span class="number">1</span> ?</span><br><span class="line">previousValue.<span class="title function_">concat</span>(<span class="title function_">flattenByDeep</span>(current, deep - <span class="number">1</span>)) :previousValue.<span class="title function_">concat</span>(current)</span><br><span class="line">   , [])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="法3：扩展运算符-不支持指定深度">法3：扩展运算符                       不支持指定深度<a class="anchor" href="#法3：扩展运算符-不支持指定深度">·</a></h4><ul><li>拍平一层</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="title function_">concat</span>(...array)); <span class="comment">//[1,2,3,[4,5],6,7]</span></span><br></pre></td></tr></table></figure><ul><li>检查数组每个元素，如果有元素是数组就要拍平一次，所以这里用到了数组的some方法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)))&#123;</span><br><span class="line">    arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法4：es6的flat-支持指定深度-快手手写实现">法4：es6的flat     支持指定深度    快手手写实现<a class="anchor" href="#法4：es6的flat-支持指定深度-快手手写实现">·</a></h4><p>es6中的新方法，数组拍平用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> a = array.<span class="title function_">flat</span>(<span class="number">1</span>)     <span class="comment">//拍平一层   </span></span><br><span class="line"><span class="keyword">var</span> b = array.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)  <span class="comment">//完全拍平</span></span><br></pre></td></tr></table></figure><h4 id="法5：toString-数组元素均为数字-不支持指定深度">法5：toString    数组元素均为数字  不支持指定深度<a class="anchor" href="#法5：toString-数组元素均为数字-不支持指定深度">·</a></h4><ul><li>toString效果如下</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> a = array.<span class="title function_">toString</span>()         <span class="comment">//&#x27;1,2,3,4,5,6,7&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>字符串的split方法以’,'分割，得到字符串数组，然后把数组每个元素数转换为数字</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> +item)  </span><br><span class="line">  <span class="comment">//用到了类型转换，+item把item字符串变成数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组API </tag>
            
            <tag> 去重 </tag>
            
            <tag> 扁平化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios的源码的一些妙用</title>
      <link href="/posts/1794184575.html"/>
      <url>/posts/1794184575.html</url>
      
        <content type="html"><![CDATA[<h1 id="Axios">Axios<a class="anchor" href="#Axios">·</a></h1><h2 id="1-特点">1. 特点<a class="anchor" href="#1-特点">·</a></h2><ul><li>基于 xhr + promise 的异步 ajax 请求库 ，前端最流行的 ajax 请求库</li><li>浏览器端/node 端都可以使用</li><li>支持请求／响应拦截器 、支持请求取消</li><li>请求/响应数据转换</li><li>批量发送多个请求</li></ul><h2 id="2-常用方法">2. 常用方法<a class="anchor" href="#2-常用方法">·</a></h2><img src="C:/Users/小虎牙/Desktop/hongs-study-notes/编程_前端开发学习笔记/Ajax、Axios学习笔记/Axios入门与源码解析笔记中的图片/Axios系统学习笔记原理图.png" alt="Axios系统学习笔记原理图" style="zoom: 80%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. axios(config): `通用/最本质`的发任意类型请求的方式 </span><br><span class="line">2. axios(url[, config]): 可以只指定 url 发 get 请求 </span><br><span class="line"></span><br><span class="line">3. axios.request(config): 等同于 axios(config) </span><br><span class="line">4. axios.get(url[, config]): 发 get 请求 </span><br><span class="line">5. axios.delete(url[, config]): 发 delete 请求 </span><br><span class="line">6. axios.post(url[, data, config]): 发 post 请求</span><br><span class="line">7. axios.put(url[, data, config]): 发 put 请求 </span><br><span class="line"></span><br><span class="line">8. axios.defaults.xxx: 请求的默认全局配置 </span><br><span class="line"></span><br><span class="line">9. axios.interceptors.request.use(): 添加请求拦截器 </span><br><span class="line">10. axios.interceptors.response.use(): 添加响应拦截器 </span><br><span class="line"></span><br><span class="line">11. axios.create([config]): 创建一个新的 axios(它没有下面的功能) </span><br><span class="line"></span><br><span class="line">12. axios.Cancel(): 用于创建取消请求的错误对象 </span><br><span class="line">13. axios.CancelToken(): 用于创建取消请求的 token 对象 </span><br><span class="line">14. axios.isCancel(): 是否是一个取消请求的错误 </span><br><span class="line"></span><br><span class="line">15. axios.all(promises): 用于批量执行多个异步请求 </span><br><span class="line">16. axios.spread(): 用来指定接收所有成功数据的回调函数的方法</span><br></pre></td></tr></table></figure><h2 id="3-重点用法">3. 重点用法<a class="anchor" href="#3-重点用法">·</a></h2><h3 id="1、axios-create-config">1、axios.create(config)<a class="anchor" href="#1、axios-create-config">·</a></h3><blockquote><ol><li><p>根据指定配置创建一个新的 axios, 也就是每个新 axios 都有自己的配置</p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的</p></li><li><p>为什么要设计这个语法?</p></li></ol><p>(1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理</p><p>(2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line"><span class="keyword">const</span> duanzi = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> onather = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://b.com&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line"><span class="comment">// duanzi(&#123;</span></span><br><span class="line"><span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(response);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line">duanzi.<span class="title function_">get</span>(<span class="string">&#x27;/getJoke&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、拦截器">2、拦截器<a class="anchor" href="#2、拦截器">·</a></h3><blockquote><ol><li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程</li><li><strong>流程:</strong> 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器 2 =&gt; 请求的回调</li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// Promise</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 设置请求拦截器  config 配置对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//修改 config 中的参数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  config.<span class="property">params</span> = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">a</span>: <span class="number">100</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> config;  <span class="comment">// 必须传config</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//修改 config 中的参数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  config.<span class="property">timeout</span> = <span class="number">2000</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> config;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 设置响应拦截器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> response.<span class="property">data</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// return response;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> response;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">axios</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3、取消请求">3、取消请求<a class="anchor" href="#3、取消请求">·</a></h3><blockquote><ol><li>基本流程 配置 cancelToken 对象</li><li>缓存用于取消请求的 cancel 函数</li><li>在后面特定时机调用 cancel 函数取消请求</li><li>在错误回调中判断如果 error 是 cancel, 做相应处理</li><li>实现功能 点击按钮, 取消某个正在请求中的请求,</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//获取按钮</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//2.声明全局变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//检测上一次的请求是否已经完成</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//取消上一次的请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">cancel</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//1. 发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">axios</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//1.1请求配置： 添加配置对象的属性，必须先配置好cancelToken</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//3. 将 c 的值赋值给 cancel</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      cancel = c;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//将 cancel 的值初始化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    cancel = <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//绑定第二个事件取消请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">cancel</span>(); &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="4-默认配置">4. 默认配置<a class="anchor" href="#4-默认配置">·</a></h3><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//默认配置</span></span><br><span class="line">&gt;axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">&gt;axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">&gt;axios.<span class="property">defaults</span>.<span class="property">params</span> = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;</span><br><span class="line">&gt;axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">3000</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&gt;btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">&gt;<span class="title function_">axios</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-问题">4. 问题<a class="anchor" href="#4-问题">·</a></h2><h3 id="1-axios-与-Axios-的关系">1. axios 与 Axios 的关系<a class="anchor" href="#1-axios-与-Axios-的关系">·</a></h3><blockquote><ol><li>从<code>语法</code>上来说: axios 不是 Axios 的实例</li><li>从<code>功能</code>上来说: axios 是 Axios 的实例</li></ol><ul><li>axios 是 <code>Axios.prototype.request</code> 函数 bind()返回的函数</li><li>axios 作为对象，有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性</li></ul></blockquote><h3 id="2-instance-与-axios-的区别">2. instance 与 axios 的区别?<a class="anchor" href="#2-instance-与-axios-的区别">·</a></h3><blockquote><ol><li>相同:(1) 都是一个能发任意请求的函数: request(config)(2) 都有发特定请求的各种方法: get()/post()/put()/delete()(3) 都有默认配置和拦截器的属性: defaults/interceptors</li><li>不同:(1) 默认配置很可能不一样(2) instance 是通过createInstance创建出来的对象，但创建新对象的instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all()</li></ol></blockquote><h3 id="3-axios运行的整体流程">3. axios运行的整体流程<a class="anchor" href="#3-axios运行的整体流程">·</a></h3><blockquote><ol><li><p>整体流程:request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config)</p></li><li><p>request(config):将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,返回 promise</p></li><li><p>dispatchRequest(config):转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数据. 返回 promise</p></li><li><p>xhrAdapter(config):创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,返回 promise</p></li><li><p>流程图:</p></li></ol><img src="C:/Users/小虎牙/Desktop/hongs-study-notes/编程_前端开发学习笔记/Ajax、Axios学习笔记/Axios入门与源码解析笔记中的图片/Axios系统学习流程图.png" alt="Axios系统学习流程图" style="zoom: 80%;" /></blockquote><h3 id="4-axios-的请求-响应拦截器是什么">4. axios 的请求/响应拦截器是什么?<a class="anchor" href="#4-axios-的请求-响应拦截器是什么">·</a></h3><blockquote><ol><li>请求拦截器:Ⅰ- 在真正发送请求前执行的回调函数Ⅱ- 可以对请求进行检查或配置进行特定处理Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)Ⅳ- 失败的回调函数, 传递的默认是 error</li><li>响应拦截器Ⅰ- 在请求得到响应后执行的回调函数Ⅱ- 可以对响应数据进行特定处理Ⅲ- 成功的回调函数, 传递的默认是 responseⅣ- 失败的回调函数, 传递的默认是 error</li></ol></blockquote><h3 id="5-axios-的请求-响应数据转换器是什么">5. axios 的请求/响应数据转换器是什么?<a class="anchor" href="#5-axios-的请求-响应数据转换器是什么">·</a></h3><blockquote><ol><li>请求转换器: 对请求头和请求体数据进行特定处理的函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (utils.<span class="title function_">isObject</span>(data)) &#123;</span><br><span class="line"><span class="title function_">setContentTypeIfUnset</span>(headers, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;response.<span class="property">data</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response.<span class="property">data</span>)</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-response与error-的整体结构">6. response与error  的整体结构<a class="anchor" href="#6-response与error-的整体结构">·</a></h3><blockquote><ol><li>response的整体结构</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;data, status,statusText,headers,config,request</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>error  的整体结构</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;message,response,request,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="7-如何取消未完成的请求">7. 如何取消未完成的请求?<a class="anchor" href="#7-如何取消未完成的请求">·</a></h3><blockquote><ol><li>当配置了 cancelToken 对象时, 保存 cancel 函数(1) 创建一个用于将来中断请求的 cancelPromise(2) 并定义了一个用于取消请求的 cancel 函数(3) 将 cancel 函数传递出来</li><li>调用 cancel()取消请求(1) 执行 cacel 函数, 传入错误信息 message(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,失败的 reason 为 Cancel 对象</li></ol></blockquote><h2 id="5-源码分析">5. 源码分析<a class="anchor" href="#5-源码分析">·</a></h2><h3 id="目录结构">目录结构<a class="anchor" href="#目录结构">·</a></h3><blockquote><p>├── /dist/ # 项目输出目录<br>├── /lib/ # 项目源码目录    核心目录│ ├── /adapters/ # 定义请求的适配器 xhr.js、http.js│ │ ├── http.js # 实现 http 适配器(包装 http 包)，远端爬虫│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)，网页中发送ajax请求│ ├── /cancel/ # 定义取消功能│ ├── /core/ # 一些核心功能│ │ ├── Axios.js # axios 的<strong>核心主类</strong>│ │ ├── dispatchRequest.js # <strong>用来调用 http 请求适配器方法发送请求的函数</strong>│ │ ├── InterceptorManager.js # 拦截器的管理器│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态│ ├── /helpers/ # 一些辅助方法│ ├── axios.js # 对外暴露接口│ ├── defaults.js # axios 的默认配置│ └── utils.js # 公用工具├── package.json # 项目信息├── index.d.ts # 配置 TypeScript 的声明文件└── index.js # 入口文件</p></blockquote><h3 id="Ⅰ-axios-的创建过程模拟实现">Ⅰ- axios 的创建过程模拟实现<a class="anchor" href="#Ⅰ-axios-的创建过程模拟实现">·</a></h3><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//2.2 Axio内部做的事：</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//2.3 默认配置属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">this</span>.<span class="property">defaults</span> = config; <span class="comment">//为了创建 default 默认属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 2.4 添加拦截器的属性request、response，这属性就是在new 拦截器的时候加的属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 至此defaults、intercepters完成了配置</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">this</span>.<span class="property">intercepters</span> = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="attr">request</span>: &#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="attr">response</span>: &#123;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//2.5 原型添加相关的方法（源码不止这几个），这样axios上面就有很多方法，实例就可以调用他们的方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送 AJAX 请求 请求的类型为 &#x27;</span> + config.<span class="property">method</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">post</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//2. createInstance函数的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//2.1 实例化Axios的一个对象 --&gt; Axios</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(config); <span class="comment">// context.get()  context.post()  但是不能当做函数使用 context() X</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//2.6 创建请求函数 bind会返回新的函数，它与 Axios.prototype.request的作用是一样的，而这个方法是用来发送请求的，并修改了this指向，指向实例对象身上</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> instance = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context); </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 2.7 源码中使用extends做到的：可以当对象去使用，调用某些方法，而不是只能做函数调用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// instance 是一个函数 并且可以 instance(&#123;&#125;)  此时 instance 不能 instance.get X</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....，</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 思想：先造一个函数，再去函数身上添加对应的属性，形成最终的结构  </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 2.8 保证内部的this始终执行实例</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;instance[key] = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[key].<span class="title function_">bind</span>(context); <span class="comment">// this.default  this.interceptors</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//2.9 为 instance 函数对象添加属性 default 与 interceptors</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="title class_">Obect</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;instance[key] = context[key];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//3. 完成返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">return</span> instance;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 1. axios是通过createInstance创造出来的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> axios = <span class="title function_">createInstance</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// axios(&#123;method:&#x27;POST&#x27;&#125;);// 可以当函数使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;axios.<span class="title function_">get</span>(&#123;&#125;); <span class="comment">// 可以当对象，调方法使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;axios.<span class="title function_">post</span>(&#123;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-axios发送请求过程详解">Ⅱ-axios发送请求过程详解<a class="anchor" href="#Ⅱ-axios发送请求过程详解">·</a></h3><ol><li><p>判断传入的config是什么类型，做mergeConfig，，将用户配置的config与默认的合并</p></li><li><p>判断请求方法，都没有传方法，默认值是get，小写设置</p></li><li><p>声明一个数组chains，第一个元素dispatchRequest，它是一个用来发请求的函数，它来调http或xhr这两个打工仔</p></li><li><p>用promise.resolve()创建一个promise对象，传入config（因为它是普通对象，所以状态成功的）</p></li><li><p>请求拦截/响应拦截  略</p></li><li><p>chains的长度做循环，执行回调函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(chain.<span class="property">length</span>)&#123;</span><br><span class="line">  <span class="comment">// 一开始promise是成功的，执行第一个回调，shift出来的是第一个元素dispatchRequest</span></span><br><span class="line">  <span class="comment">// dispatchRequest的结果决定then的返回值，进而决定下一个promise的值</span></span><br><span class="line">promise = promise.<span class="title function_">then</span>(chain.<span class="title function_">shift</span>(), chain.<span class="title function_">shift</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在dispatchRequest函数中：</p><ol><li><p>取消请求 略</p></li><li><p>确保头信息存在</p></li><li><p>对请求体内容进行转化</p></li><li><p>对请求头信息整合</p></li><li><p>获取适配器对象：要么是http适配器要么是xhr适配器</p><p>**xhrAdapter：**函数内部new XMLHttpRequest，发ajax请求，返回的是promise</p></li><li><p>最终返回：适配器返回的promise，并指定响应成功的函数：</p><p>对响应的结果格式化处理，return response，他是一个普通对象，所以最上面的promise的then返回就是一个成功的promise</p></li></ol></li><li><p>此时request函数执行完毕-----axios执行结果完成</p></li></ol><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// axios 发送请求   axios  Axios.prototype.request  bind</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//1. 声明构造函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//1.1创建一个 promise 对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//声明一个数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> chains = [dispatchRequest, <span class="literal">undefined</span>]; <span class="comment">// undefined 占位</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//调用 then 方法指定回调</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> result = promise.<span class="title function_">then</span>(chains[<span class="number">0</span>], chains[<span class="number">1</span>]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//返回 promise 的结果</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">return</span> result;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//2. dispatchRequest 函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//调用适配器发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//响应的结果进行转换处理</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//....</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">return</span> response;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">throw</span> error;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//3. adapter 适配器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;xhrAdapter 函数执行&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//发送 AJAX 请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//初始化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//发送</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;xhr.<span class="title function_">send</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//绑定事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//判断成功的条件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//成功的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">resolve</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//配置对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">config</span>: config,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//响应体</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: xhr.<span class="property">response</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//响应头</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">headers</span>: xhr.<span class="title function_">getAllResponseHeaders</span>(), <span class="comment">//字符串  parseHeaders</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// xhr 请求对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">request</span>: xhr,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//响应状态码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//响应状态字符串</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//失败的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败 失败的状态码为&#x27;</span> + xhr.<span class="property">status</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">//4. 创建 axios 函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(<span class="literal">null</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="title function_">axios</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-拦截器的模拟实现">Ⅲ-拦截器的模拟实现<a class="anchor" href="#Ⅲ-拦截器的模拟实现">·</a></h3><ol><li><strong>调use的时候：</strong><ul><li>InterceptorManager中会往实例的<strong>handlers属性</strong>（数组）里面<strong>push</strong>两个函数，分别是resolve，reject，其实就是use传参的时候传的两个函数，这对应一组请求拦截器</li><li>如果有第2个请求拦截器，再push第2组：成功、失败的回调函数</li><li>此时request的handlers身上已经有每个请求对应的每组回调了</li></ul></li><li><strong>response的use：</strong><ul><li>同样的，如果有第2个响应拦截器，再push第2组：成功、失败的回调函数此时response的handlers身上已经有每个响应对应的每组回调了</li></ul></li></ol><p>use在执行的时候：只是把两个函数保存在了request的handlers属性里面，response也是这样</p><ol><li><p><strong>真正发请求：</strong></p><ol><li><p>request发送请求，跟之前一样，参数检测合并</p></li><li><p>chain数组  dispatchRequest undefined</p></li><li><p>创建成功promise对象</p></li><li><p>对拦截器的实例对象中的InterceptorManager封装了一个forEach方法来遍历handlers，其实就是遍历request对象身上的handlers的数组，并将请求拦截器回调往chains数组的前面追加<strong>unshift</strong></p><p>此时chains数组就发生了变化：two two one one dispatchRequest undefined</p></li><li><p>forEach方法来遍历handlers：将响应拦截器的每组回调<strong>push</strong>到<strong>chains</strong>数组里面</p><p>此时chains变化：two two one one dispatchRequest undefined one one two two</p></li><li><p>不停的循环：从chains中取出<strong>shift</strong>执行，一组一组的执行</p><p>所以2号响应拦截器先执行：返回promise对象 --取出1号响应器执行，返回promise对象</p><p>dispatchRequest</p><p>响应1号 — 响应2号</p><p>假如这个过程中：发生了失败：失败会穿透</p></li></ol></li></ol><blockquote><ol><li>array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</li><li>思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行</li><li><code>promise = promise.then(chains.shift(), chains.shift());</code> 通过循环使用promise的then链条得到最终的结果–&gt;等式前面的<code>promise</code>将被最终的结果覆盖</li></ol></blockquote><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>)&#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">config</span> = config;</span><br><span class="line">&gt;<span class="comment">// 最后造出来的interceptors属性可以使用request等，use实际是实例对象上面的方法</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">interceptors</span> = &#123;</span><br><span class="line"><span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span><br><span class="line"><span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//发送请求  难点与重点</span></span><br><span class="line">&gt;<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span>(<span class="params">config</span>)&#123;</span><br><span class="line">&gt;<span class="comment">//创建一个 promise 对象</span></span><br><span class="line">&gt;<span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span><br><span class="line">&gt;<span class="comment">//创建一个数组</span></span><br><span class="line">&gt;<span class="keyword">const</span> chains = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">&gt;<span class="comment">//处理拦截器</span></span><br><span class="line">&gt;<span class="comment">//请求拦截器 将请求拦截器的回调 压入到 chains 的前面  request.handles = []</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">chains.<span class="title function_">unshift</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//响应拦截器</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">chains.<span class="title function_">push</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">while</span>(chains.<span class="property">length</span> &gt; <span class="number">0</span>)&#123; </span><br><span class="line">promise = promise.<span class="title function_">then</span>(chains.<span class="title function_">shift</span>(), chains.<span class="title function_">shift</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> promise;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//发送请求</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>)&#123;</span><br><span class="line">&gt;<span class="comment">//返回一个promise 队形</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//创建实例</span></span><br><span class="line">&gt;<span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span><br><span class="line">&gt;<span class="comment">//创建axios函数</span></span><br><span class="line">&gt;<span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context);</span><br><span class="line">&gt;<span class="comment">//将 context 属性 config interceptors 添加至 axios 函数对象身上</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">&gt;axios[key] = context[key];</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//拦截器管理器构造函数</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">InterceptorManager</span>(<span class="params"></span>)&#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">handlers</span> = [];</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title class_">InterceptorManager</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">use</span> = <span class="keyword">function</span>(<span class="params">fulfilled, rejected</span>)&#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">fulfilled,</span><br><span class="line">rejected</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>​功能测试代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下为</span></span><br><span class="line"><span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅳ-请求取消功能模拟实现">Ⅳ-请求取消功能模拟实现<a class="anchor" href="#Ⅳ-请求取消功能模拟实现">·</a></h3><ul><li>原理：未来某个时刻调用cancel() --&gt; promise属性上的promise状态变为成功–&gt; 执行成功回调:xhr.abort()取消请求：</li><li>设计思想：把代码全放在一个promise成功回调之中，在未来想让代码执行的话，你只需要改变这个promsie的状态就可以了，而它将状态改变的函数暴露给了外层，交由程序员去控制</li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//构造函数</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">config</span> = config;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//原型 request 方法</span></span><br><span class="line">&gt;<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">dispatchRequest</span>(config);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//dispatchRequest 函数</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//xhrAdapter</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>) &#123;</span><br><span class="line">&gt;<span class="comment">//发送 AJAX 请求</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">//实例化对象</span></span><br><span class="line">&gt;<span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">&gt;<span class="comment">//初始化</span></span><br><span class="line">&gt;xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>);</span><br><span class="line">&gt;<span class="comment">//发送</span></span><br><span class="line">&gt;xhr.<span class="title function_">send</span>();</span><br><span class="line">&gt;<span class="comment">//处理结果</span></span><br><span class="line">&gt;xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">&gt;<span class="comment">//判断结果</span></span><br><span class="line">&gt;<span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">&gt;<span class="comment">//设置为成功的状态</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>(&#123;</span><br><span class="line"><span class="attr">status</span>: xhr.<span class="property">status</span>,</span><br><span class="line"><span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>));</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//5. 关于取消请求的处理</span></span><br><span class="line">&gt;<span class="comment">//5.1 如果你之前配置过cancelToken</span></span><br><span class="line">&gt;<span class="keyword">if</span> (config.<span class="property">cancelToken</span>) &#123;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//5.2 对 cancelToken 对象身上的 promise 对象指定成功的回调</span></span><br><span class="line">&gt;config.<span class="property">cancelToken</span>.<span class="property">promise</span>.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">&gt;xhr.<span class="title function_">abort</span>();</span><br><span class="line">&gt;<span class="comment">//将整体结果设置为失败</span></span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求已经被取消&#x27;</span>))</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//创建 axios 函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//CancelToken 构造函数</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">CancelToken</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">&gt;<span class="comment">//1. 声明一个变量</span></span><br><span class="line">&gt;<span class="keyword">var</span> resolvePromise;</span><br><span class="line">&gt;<span class="comment">//2. 为实例的CancelToken对象身上添加属性promise，它还是一个promise对象</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">//3. 将 resolve 赋值给 resolvePromise，它的执行就会改变这个promise的状态，因为有这个赋值了</span></span><br><span class="line">&gt;resolvePromise = resolve</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//4. 调用 executor 函数：它就是你在实例化CancelToken时传入的那个函数，此时执行</span></span><br><span class="line">&gt;<span class="comment">//4.1 而它的参数也是函数，它在运行的时候，改变了CancelToken属性的promsie状态</span></span><br><span class="line">&gt;<span class="comment">// 4.2 这个函数实际上就是c，如果c执行：说明executor内部的函数参数执行，也就是resolvePromise()会执行，相当于resolve执行，promise状态改变        重点</span></span><br><span class="line">&gt;<span class="title function_">executor</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="comment">//执行 resolvePromise 函数，</span></span><br><span class="line">&gt;<span class="title function_">resolvePromise</span>();</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取按钮 以上为模拟实现的代码</span></span><br><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="comment">//2.声明全局变量</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line"> <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">//取消上一次的请求</span></span><br><span class="line">   <span class="title function_">cancel</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建 cancelToken 的值，是</span></span><br><span class="line"> <span class="keyword">let</span> cancelToken = <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">   <span class="comment">//4.3 在这里c赋值给了cancel，所以cancel函数执行，就会触发cancelToken内部的resolve的执行，改变promise的状态</span></span><br><span class="line">   cancel = c;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="title function_">axios</span>(&#123;</span><br><span class="line">   <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">   <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">   <span class="attr">cancelToken</span>: cancelToken</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">   <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">   cancel = <span class="literal">null</span>;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">cancel</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于axios的网络封装">基于axios的网络封装<a class="anchor" href="#基于axios的网络封装">·</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* //封装axios方法,为不需要登录操作时使用,也可以提前传入token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> options 配置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">Axios</span>= (<span class="params">options</span>)=&gt;&#123;</span><br><span class="line">   <span class="title function_">axios</span>(&#123;</span><br><span class="line">       <span class="attr">url</span>:options.<span class="property">url</span>,</span><br><span class="line">       <span class="attr">method</span>:options.<span class="property">method</span>||<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">       <span class="attr">data</span>: options.<span class="property">data</span>,</span><br><span class="line">       <span class="attr">params</span>: options.<span class="property">data</span></span><br><span class="line">   &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (options.<span class="property">success</span>)  options.<span class="title function_">success</span>(result.<span class="property">data</span>)</span><br><span class="line">   &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> msg = err.<span class="property">response</span> ? err.<span class="property">response</span>.<span class="property">data</span>:<span class="string">&#x27;请求异常&#x27;</span></span><br><span class="line">       <span class="keyword">if</span> (options.<span class="property">error</span>)&#123;</span><br><span class="line">           options.<span class="title function_">error</span>(msg)</span><br><span class="line">           <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123;<span class="attr">message</span>: msg, <span class="attr">offset</span>: <span class="number">150</span>&#125;);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="title class_">Message</span>.<span class="title function_">error</span>(&#123;<span class="attr">message</span>: msg, <span class="attr">offset</span>: <span class="number">150</span>&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不拦截的(不带token)往往用在vue创建前的生命周期中</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$Axios</span> = <span class="title class_">Axios</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.3-Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> 网络请求 </tag>
            
            <tag> axios </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Ajax</title>
      <link href="/posts/1078088869.html"/>
      <url>/posts/1078088869.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Ajax是什么">一、Ajax是什么<a class="anchor" href="#一、Ajax是什么">·</a></h2><h3 id="1-ajax之前">1. ajax之前<a class="anchor" href="#1-ajax之前">·</a></h3><ul><li>服务端与客户端的交互方式：</li></ul><img src="http://www.conardli.top/img/wl/wlqq_1.png" alt="image" style="zoom: 67%;" /><ul><li><p>缺点：</p><p>任何和服务器的交互都需要刷新页面，用户体验非常差，<code>Ajax</code>的出现解决了这个问题</p></li></ul><h3 id="2-Ajax是什么">2. Ajax是什么<a class="anchor" href="#2-Ajax是什么">·</a></h3><p><a href="https://segmentfault.com/a/1190000004322487#articleHeader13">你真的会使用XMLHttpRequest吗？ - SegmentFault 思否</a></p><ul><li><p><code>Async JavaScript And XML</code>，<code>ajax</code>是一种技术方案，但并不是一种<strong>新技术</strong>。它依赖的是现有的<code>CSS</code>/<code>HTML</code>/<code>Javascript</code></p><ul><li><p>而其中最核心的依赖是浏览器提供的<code>XMLHttpRequest</code>对象，是这个对象使得浏览器可以发出<code>HTTP</code>请求与接收<code>HTTP</code>响应</p></li><li><p>总结两者的关系：我们使用<code>XMLHttpRequest</code>对象来发送一个<code>Ajax</code>请求</p></li><li><p>XML：可拓展标记语言，被设计用来传输、存储数据，历史后端中返回的形式，现在被JSON取代了</p></li></ul></li><li><p><strong>最大优势特点：</strong></p><ul><li>页面<strong>不刷新</strong>的情况下与服务器通信</li><li>允许根据用户事件来更新部分页面内容</li></ul></li><li><p><strong>缺点：</strong></p><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源策略限制）</li><li>SEO不友好</li></ol></li></ul><h3 id="3、XMLHttpRequest发展历程">3、<code>XMLHttpRequest</code>发展历程<a class="anchor" href="#3、XMLHttpRequest发展历程">·</a></h3><p>一开始只是微软浏览器提供的一个接口，后来W3C对它进行了标准化，再后来提出了<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2FXMLHttpRequest%2F"><code>XMLHttpRequest</code>标准</a>。<code>XMLHttpRequest</code>标准又分为<code>Level 1</code>和<code>Level 2</code></p><h4 id="1、Level-1主要缺点：">1、Level 1主要缺点：<a class="anchor" href="#1、Level-1主要缺点：">·</a></h4><ul><li>受同源策略的限制，不能发送跨域请求；</li><li>不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；</li><li>在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</li></ul><h4 id="2、Level-2中新增：">2、Level 2中新增：<a class="anchor" href="#2、Level-2中新增：">·</a></h4><ul><li>可以发送跨域请求，在服务端允许的情况下；</li><li>支持发送和接收二进制数据；</li><li>新增formData对象，支持发送表单数据；</li><li>发送和获取数据时，可以获取进度信息；</li><li>可以设置请求的超时时间；</li></ul><h4 id="3、XMLHttpRequest兼容性">3、<code>XMLHttpRequest</code>兼容性<a class="anchor" href="#3、XMLHttpRequest兼容性">·</a></h4><p>Can I use”这个网站提供的结果<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fcaniuse.com%2F%23search%3DXMLHttpRequest">XMLHttpRequest兼容性</a></p><p><img src="https://segmentfault.com/img/bVsiDk" alt="clipboard.png"></p><p>从图中可以看到：</p><ul><li>IE8/IE9、Opera Mini 完全不支持<code>xhr</code>对象</li><li>IE10/IE11部分支持，不支持 <code>xhr.responseType</code>为<code>json</code></li><li>部分浏览器不支持设置请求超时，即无法使用<code>xhr.timeout</code></li><li>部分浏览器不支持<code>xhr.responseType</code>为<code>blob</code></li></ul><h2 id="二、XMLHttpRequest如何使用">二、<code>XMLHttpRequest</code>如何使用<a class="anchor" href="#二、XMLHttpRequest如何使用">·</a></h2><p>使用<code>XMLHttpRequest</code>发送<code>Ajax</code>请求</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendAjax</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//构造表单数据</span></span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;johndoe&#x27;</span>);</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">123456</span>);</span><br><span class="line">  <span class="comment">//创建xhr对象 </span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  <span class="comment">//设置xhr请求的超时时间</span></span><br><span class="line">  xhr.<span class="property">timeout</span> = <span class="number">3000</span>;</span><br><span class="line">  <span class="comment">//设置响应返回的数据格式</span></span><br><span class="line">  xhr.<span class="property">responseType</span> = <span class="string">&quot;text&quot;</span>;</span><br><span class="line">  <span class="comment">//创建一个 post 请求，采用异步</span></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//注册相关事件回调处理函数</span></span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>||<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">304</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; ... &#125;;</span><br><span class="line">  xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; ... &#125;;</span><br><span class="line">  xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; ... &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发送数据</span></span><br><span class="line">  xhr.<span class="title function_">send</span>(formData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、如何设置request-header">1、如何设置request header<a class="anchor" href="#1、如何设置request-header">·</a></h3><p>在发送<code>Ajax</code>请求（实质是一个<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fwww.tutorialspoint.com%2Fhttp%2Fhttp_header_fields.htm">HTTP</a>请求）时，我们可能需要设置一些请求头部信息，比如<code>content-type</code>、<code>connection</code>、<code>cookie</code>、<code>accept-xxx</code>等。<code>xhr</code>提供了<code>setRequestHeader</code>来允许我们修改请求 header。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setRequestHeader(DOMString header, DOMString value);</span><br></pre></td></tr></table></figure></blockquote><p><strong>注意点</strong>：</p><ul><li>方法的第一个参数 header 大小写不敏感，即可以写成<code>content-type</code>，也可以写成<code>Content-Type</code>，甚至写成<code>content-Type</code>;</li><li><code>Content-Type</code>的默认值与具体发送的数据类型有关</li><li><strong><code>setRequestHeader</code>必须在<code>open()</code>方法之后，<code>send()</code>方法之前调用，否则会抛错；</strong></li><li><code>setRequestHeader</code>可以调用多次，最终的值不会采用覆盖<code>override</code>的方式，而是采用追加<code>append</code>的方式。下面是一个示例代码：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">client.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;demo.cgi&#x27;</span>);</span><br><span class="line">client.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;X-Test&#x27;</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">client.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;X-Test&#x27;</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line"><span class="comment">// 最终request header中&quot;X-Test&quot;为: one, two</span></span><br><span class="line">client.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><h3 id="2、如何获取response-header">2、如何获取response header<a class="anchor" href="#2、如何获取response-header">·</a></h3><p><code>xhr</code>提供了2个用来获取响应头部的方法：</p><ol><li><p><code>getAllResponseHeaders</code>：获取 response 中的所有header 字段</p></li><li><p><code>getResponseHeader</code>：只是获取某个指定 header 字段的值，<code>header</code>参数不区分大小写</p></li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOMString getAllResponseHeaders();</span><br><span class="line">DOMString getResponseHeader(DOMString header);</span><br></pre></td></tr></table></figure></blockquote><h4 id="【注意大坑】：">【注意大坑】：<a class="anchor" href="#【注意大坑】：">·</a></h4><ol><li><p>使用<code>getAllResponseHeaders()</code>看到的所有<code>response header</code>与实际在控制台 <code>Network</code> 中看到的 <code>response header</code> 不一样</p><p>这个方法只能拿到<strong>限制以外</strong>（即被视为<code>safe</code>）的header字段，而不是全部字段</p></li><li><p>使用<code>getResponseHeader()</code>获取某个 <code>header</code> 的值时，浏览器抛错<code>Refused to get unsafe header &quot;XXX&quot;</code></p><p><code>header</code>参数必须是***限制以外***的header字段，否则调用就会报<code>Refused to get unsafe header</code>的错误</p></li></ol><p>经过一番寻找最终在 <a href="https://link.segmentfault.com/?url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F7462968%2Frestrictions-of-xmlhttprequests-getresponseheader">Stack Overflow找到了答案</a>。</p><ul><li>原因1：<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2FXMLHttpRequest%2F">W3C的 xhr 标准中做了限制</a>，规定客户端无法获取 response 中的 <code>Set-Cookie</code>、<code>Set-Cookie2</code>这2个字段，无论是同域还是跨域请求；</li><li>原因2：<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2Fcors%2F%23access-control-allow-credentials-response-header">W3C 的 cors 标准对于跨域请求也做了限制</a>，规定对于跨域请求，客户端允许获取的response header字段只限于“<code>simple response header</code>”和“<code>Access-Control-Expose-Headers</code>”<ul><li>&quot;<code>simple response header</code>&quot;包括的 header 字段有：<code>Cache-Control</code>,<code>Content-Language</code>,<code>Content-Type</code>,<code>Expires</code>,<code>Last-Modified</code>,<code>Pragma</code>;</li><li>“<code>Access-Control-Expose-Headers</code>”：首先得注意是&quot;<code>Access-Control-Expose-Headers</code>&quot;进行<strong>跨域请求</strong>时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段</li></ul></li></ul><h3 id="3、如何指定xhr-response的数据类型">3、如何指定<code>xhr.response</code>的数据类型<a class="anchor" href="#3、如何指定xhr-response的数据类型">·</a></h3><p>有些时候我们希望<code>xhr.response</code>返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过<code>xhr.response</code>拿到的直接就是一个 js 对象，我们该怎么实现呢？</p><ul><li>一个是<code>level 1</code>就提供的<code>overrideMimeType()</code>方法</li><li>另一个是<code>level 2</code>才提供的<code>xhr.responseType</code>属性</li></ul><h4 id="1、xhr-overrideMimeType">1、<code>xhr.overrideMimeType()</code><a class="anchor" href="#1、xhr-overrideMimeType">·</a></h4><p>作用就是用来重写<code>response</code>的<code>content-type</code></p><p>意义：</p><ol><li>比如：server 端给客户端返回了一份<code>document</code>或者是 <code>xml</code>文档，我们希望最终通过<code>xhr.response</code>拿到的就是一个<code>DOM</code>对象，那么就可以用<code>xhr.overrideMimeType('text/xml; charset = utf-8')</code>来实现</li><li>们都知道<code>xhr level 1</code>不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用<code>overrideMimeType</code>方法来解决这个问题的</li></ol><p>下面是一个获取图片文件的代码示例：</p><ul><li>通过将 <code>response</code> 的 <code>content-type</code> 改为’text/plain; charset=x-user-defined’，使得 <code>xhr</code> 以纯文本格式来解析接收到的blob 数据</li><li>最终用户通过<code>this.responseText</code>拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">//向 server 端获取一张图片</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这行是关键！</span></span><br><span class="line"><span class="comment">//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集</span></span><br><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&#x27;text/plain; charset=x-user-defined&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">//通过 responseText 来获取图片文件对应的二进制字符串</span></span><br><span class="line">    <span class="keyword">var</span> binStr = <span class="variable language_">this</span>.<span class="property">responseText</span>;</span><br><span class="line">    <span class="comment">//然后自己再想方法将逐个字节还原为二进制数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = binStr.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="keyword">var</span> c = binStr.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">      <span class="comment">//String.fromCharCode(c &amp; 0xff);</span></span><br><span class="line">      <span class="keyword">var</span> byte = c &amp; <span class="number">0xff</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><h4 id="2、xhr-responseType">2、<code>xhr.responseType</code><a class="anchor" href="#2、xhr-responseType">·</a></h4><ul><li>它有兼容性问题，那么<code>responseType</code>可以设置为哪些格式呢</li></ul><table><thead><tr><th>值</th><th><code>xhr.response</code> 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td><code>String</code>字符串</td><td>默认值(在不设置<code>responseType</code>时)</td></tr><tr><td><code>&quot;text&quot;</code></td><td><code>String</code>字符串</td><td></td></tr><tr><td><code>&quot;document&quot;</code></td><td><code>Document</code>对象</td><td>希望返回 <code>XML</code> 格式数据时使用</td></tr><tr><td><code>&quot;json&quot;</code></td><td><code>javascript</code> 对象</td><td>存在兼容性问题，IE10/IE11不支持</td></tr><tr><td><code>&quot;blob&quot;</code></td><td><code>Blob</code>对象</td><td></td></tr><tr><td><code>&quot;arrayBuffer&quot;</code></td><td><code>ArrayBuffer</code>对象</td><td></td></tr></tbody></table><p>下面是同样是获取一张图片的代码示例，用<code>xhr.response</code>来实现简单得多。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`</span></span><br><span class="line"><span class="comment">//xhr.responseType = &#x27;arrayBuffer&#x27;;</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="variable language_">this</span>.<span class="property">response</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><ul><li><code>xhr.responseType</code>就是用来取代<code>xhr.overrideMimeType()</code>的，<code>xhr.responseType</code>功能强大的多</li></ul><h3 id="4、如何获取response数据">4、如何获取response数据<a class="anchor" href="#4、如何获取response数据">·</a></h3><p><code>xhr</code>提供了3个属性来获取请求返回的数据，分别是：<code>xhr.response</code>、<code>xhr.responseText</code>、<code>xhr.responseXML</code></p><h4 id="1、xhr-response">1、<code>xhr.response</code><a class="anchor" href="#1、xhr-response">·</a></h4><ul><li>默认值：空字符串<code>&quot;&quot;</code></li><li>当请求完成时，此属性才有正确的值</li><li>请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></li></ul><h4 id="2、xhr-responseText">2、<code>xhr.responseText</code><a class="anchor" href="#2、xhr-responseText">·</a></h4><ul><li>默认值为空字符串<code>&quot;&quot;</code></li><li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错</li><li>只有当请求成功时，才能拿到正确值。请求未完成、请求失败值都为空字符串<code>&quot;&quot;</code></li></ul><h4 id="3、xhr-responseXML">3、<code>xhr.responseXML</code><a class="anchor" href="#3、xhr-responseXML">·</a></h4><ul><li><p>默认值为 <code>null</code></p></li><li><p>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseXML</code>，否则抛错</p></li><li><p>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为<code>null</code>：</p><p>请求未完成、请求失败、请求成功但返回数据无法被正确解析时</p></li></ul><h3 id="5、如何追踪ajax请求的当前状态">5、如何追踪<code>ajax</code>请求的当前状态<a class="anchor" href="#5、如何追踪ajax请求的当前状态">·</a></h3><p>用<code>xhr.readyState</code>这个属性即可追踪到，总共有5种可能值，分别对应<code>xhr</code>不同的不同阶段，次<code>xhr.readyState</code>的值发生变化时，都会触发<code>xhr.onreadystatechange</code>事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(xhr.<span class="property">readyState</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//OPENED</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//HEADERS_RECEIVED</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//LOADING</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//DONE</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>UNSENT</code> (初始状态，未打开)</td><td>此时<code>xhr</code>对象被成功构造，<code>open()</code>方法还未被调用</td></tr><tr><td><code>1</code></td><td><code>OPENED</code> (已打开，未发送)</td><td><code>open()</code>方法已被成功调用，<code>send()</code>方法还未被调用。注意：只有<code>xhr</code>处于<code>OPENED</code>状态，才能调用<code>xhr.setRequestHeader()</code>和<code>xhr.send()</code>,否则会报错</td></tr><tr><td><code>2</code></td><td><code>HEADERS_RECEIVED</code> (已获取响应头)</td><td><code>send()</code>方法已经被调用, 响应头和响应状态已经返回</td></tr><tr><td><code>3</code></td><td><code>LOADING</code> (正在下载响应体)</td><td>响应体(<code>response entity body</code>)正在下载中，此状态下通过<code>xhr.response</code>可能已经有了响应数据</td></tr><tr><td><code>4</code></td><td><code>DONE</code> (整个数据传输过程结束)</td><td>整个数据传输过程结束，不管本次请求是成功还是失败</td></tr></tbody></table><h3 id="6、如何设置请求的超时时间">6、如何设置请求的超时时间<a class="anchor" href="#6、如何设置请求的超时时间">·</a></h3><p>如果请求过了很久还没有成功，为了不会白白占用的网络资源，一般会主动终止请求</p><ul><li>XMLHttpRequest提供了<code>timeout</code>属性来允许设置请求的超时时间</li><li>从*<strong>请求开始*</strong> 算起，若超过 <code>timeout</code> 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.timeout            单位：毫秒     默认值：`0`，即不设置超时</span><br></pre></td></tr></table></figure></blockquote><h4 id="1、什么时候才算是请求开始-？">1、什么时候才算是请求开始 ？<a class="anchor" href="#1、什么时候才算是请求开始-？">·</a></h4><p><code>xhr.onloadstart</code>事件触发的时候，也就是你调用<code>xhr.send()</code>方法的时候：</p><ul><li><code>xhr.open()</code>只是创建了一个连接，但并没有真正开始数据的传输</li><li>而<code>xhr.send()</code>才是真正开始了数据的传输过程。只有调用了<code>xhr.send()</code>，才会触发<code>xhr.onloadstart</code></li></ul><h4 id="2、什么时候才算是请求结束？">2、什么时候才算是请求结束？<a class="anchor" href="#2、什么时候才算是请求结束？">·</a></h4><p><code>xhr.loadend</code>事件触发的时候</p><h4 id="3、2个坑：">3、2个坑：<a class="anchor" href="#3、2个坑：">·</a></h4><ol><li>可以在 <code>send()</code>之后再设置此<code>xhr.timeout</code>，但计时起始点仍为调用<code>xhr.send()</code>方法的时刻。</li><li>当<code>xhr</code>为一个<code>sync</code>同步请求时，<code>xhr.timeout</code>必须置为<code>0</code>，否则会抛错。原因可以参考本文的【如何发一个同步请求】</li></ol><h3 id="7、如何发一个同步请求">7、如何发一个同步请求<a class="anchor" href="#7、如何发一个同步请求">·</a></h3><p>由<code>xhr.open（）</code>传入的<code>async</code>参数决定，默认发异步true</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(method, url [, async = true [, username = null [, password = null]]])</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>method</code>: 请求的方式，如<code>GET/POST/HEADER</code>等，这个参数不区分大小写</li><li><code>url</code>: 请求的地址，可以是相对地址如<code>example.php</code>，这个<strong>相对</strong>是相对于当前网页的<code>url</code>路径；也可以是绝对地址如<code>http://www.example.com/example.php</code></li><li><code>async</code>: 默认值为<code>true</code>，即为异步请求，若<code>async=false</code>，则为同步请求</li></ul><h4 id="1、同步与异步的区别：">1、同步与异步的区别：<a class="anchor" href="#1、同步与异步的区别：">·</a></h4><p>当<code>xhr</code>为同步请求时，有如下限制：任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制</p><ul><li><code>xhr.timeout</code>必须为<code>0</code></li><li><code>xhr.withCredentials</code>必须为 <code>false</code></li><li><code>xhr.responseType</code>必须为<code>&quot;&quot;</code>（注意置为<code>&quot;text&quot;</code>也不允许）</li></ul><h4 id="2、为什么尽量避免使用sync同步请求">2、为什么尽量避免使用<code>sync</code>同步请求<a class="anchor" href="#2、为什么尽量避免使用sync同步请求">·</a></h4><ol><li><p>因为无法设置请求超时时间（<code>xhr.timeout</code>为<code>0</code>，即不限时）</p><p>在不限制超时的情况下，有可能同步请求一直处于<code>pending</code>状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互</p></li><li><p>标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象</p><p>如在 chrome中，当<code>xhr</code>为同步请求时，在<code>xhr.readyState</code>由<code>2</code>变成<code>3</code>时，并不会触发 <code>onreadystatechange</code>事件，<code>xhr.upload.onprogress</code>和 <code>xhr.onprogress</code>事件也不会触发</p></li></ol><h3 id="8、如何获取上传、下载的进度">8、如何获取上传、下载的进度<a class="anchor" href="#8、如何获取上传、下载的进度">·</a></h3><p>在上传或者下载比较大的文件时，可以通过<code>onprogress</code>事件来实时显示进度</p><ul><li><p>默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的<code>onprogress</code>事件：</p></li><li><p>上传触发的是<code>xhr.upload</code>对象的 <code>onprogress</code>事件</p></li><li><p>下载触发的是<code>xhr</code>对象的<code>onprogress</code>事件</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onprogress</span> = updateProgress;</span><br><span class="line">xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = updateProgress;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> completedPercent = event.<span class="property">loaded</span> / event.<span class="property">total</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="9、可以发送什么类型的数据">9、可以发送什么类型的数据<a class="anchor" href="#9、可以发送什么类型的数据">·</a></h3><h4 id="1、支持的类型">1、支持的类型<a class="anchor" href="#1、支持的类型">·</a></h4><p><code>xhr.send(data)</code>的参数data可以是类型：<code>ArrayBuffer</code>、<code>Blob</code>、<code>Document</code>、<code>DOMString</code>、<code>FormData</code>、<code>null</code></p><ul><li><p>GET/HEAD请求：<code>send()</code>方法一般不传参或传 <code>null</code></p><p>即使你真传入了参数，参数也最终被忽略，<code>xhr.send(data)</code>中的data会被置为 <code>null</code></p></li></ul><h4 id="2、如何影响请求头部">2、如何影响请求头部<a class="anchor" href="#2、如何影响请求头部">·</a></h4><p><code>xhr.send(data)</code>中data参数的数据类型会影响请求头部<code>content-type</code>的默认值：</p><ul><li>如果<code>data</code>是 <code>Document</code> 类型，同时也是<code>HTML Document</code>类型，则<code>content-type</code>默认值为<code>text/html;charset=UTF-8</code>;否则为<code>application/xml;charset=UTF-8</code>；</li><li>如果<code>data</code>是 <code>DOMString</code> 类型，<code>content-type</code>默认值为<code>text/plain;charset=UTF-8</code>；</li><li>如果<code>data</code>是 <code>FormData</code> 类型，<code>content-type</code>默认值为<code>multipart/form-data; boundary=[xxx]</code></li><li>如果<code>data</code>是其他类型，则不会设置<code>content-type</code>的默认值</li></ul><p>但如果用<code>xhr.setRequestHeader()</code>手动设置了中<code>content-type</code>的值，以上默认值就会被覆盖</p><h4 id="3、注意-2">3、注意<a class="anchor" href="#3、注意-2">·</a></h4><p>若在断网状态下调用<code>xhr.send(data)</code>方法，则会抛错：<code>Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest'</code></p><ul><li>一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 <code>xhr.send(data)</code>方法时，应该用 <code>try-catch</code>捕捉错误</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    xhr.<span class="title function_">send</span>(data)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">//doSomething...</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="10、xhr-withCredentials与-CORS-什么关系">10、<code>xhr.withCredentials</code>与 <code>CORS</code> 什么关系<a class="anchor" href="#10、xhr-withCredentials与-CORS-什么关系">·</a></h3><h4 id="1、跨域不自动加cookie？">1、跨域不自动加cookie？<a class="anchor" href="#1、跨域不自动加cookie？">·</a></h4><ul><li>在发同域请求时，浏览器会将<code>cookie</code>自动加在<code>request header</code>中</li><li>但，在发送跨域请求时，<code>cookie</code>并没有自动加在<code>request header</code>中</li></ul><h4 id="2、为什么？">2、为什么？<a class="anchor" href="#2、为什么？">·</a></h4><p>【注意】造成这个问题的原因是：</p><ol><li><p>在<code>CORS</code>标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（<code>credentials</code>）如&quot;<code>cookies</code>&quot;和&quot;<code>HTTP authentication schemes</code>&quot;，除非<code>xhr.withCredentials</code>为<code>true</code>（<code>xhr</code>对象有一个属性叫<code>withCredentials</code>，默认值为<code>false</code>）</p></li><li><p><code>cookies</code>也是一种认证信息，在跨域请求中，<code>client</code>端必须手动设置<code>xhr.withCredentials=true</code>，且<code>server</code>端也必须允许<code>request</code>能携带认证信息（即<code>response header</code>中包含<code>Access-Control-Allow-Credentials:true</code>），这样浏览器才会自动将<code>cookie</code>加在<code>request header</code>中</p></li></ol><p>【特别注意】：</p><ul><li>一旦跨域<code>request</code>能够携带认证信息，<code>server</code>端一定不能将<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，而必须设置为请求页面的域名</li></ul><h2 id="三、xhr相关事件">三、<code>xhr</code>相关事件<a class="anchor" href="#三、xhr相关事件">·</a></h2><h3 id="1、事件分类">1、事件分类<a class="anchor" href="#1、事件分类">·</a></h3><p><code>XMLHttpRequestEventTarget</code>接口定义了7个事件：</p><ul><li><code>onloadstart</code>、<code>onprogress</code>、<code>onabort</code>、<code>ontimeout</code>、<code>onerror</code>、<code>onload</code>、<code>onloadend</code></li></ul><h4 id="2、特点-2">2、特点<a class="anchor" href="#2、特点-2">·</a></h4><p>总结：<code>xhr</code>一共有8个相关事件：7个<code>XMLHttpRequestEventTarget</code>事件+1个独有的<code>onreadystatechange</code>事件；而<code>xhr.upload</code>只有7个<code>XMLHttpRequestEventTarget</code>事件</p><ol><li>每一个<code>XMLHttpRequest</code>里面都有一个<code>upload</code>属性，而<code>upload</code>是一个<code>XMLHttpRequestUpload</code>对象</li><li><code>XMLHttpRequest</code>和<code>XMLHttpRequestUpload</code>都继承了同一个<code>XMLHttpRequestEventTarget</code>接口，所以<code>xhr</code>和<code>xhr.upload</code>都有第一条列举的7个事件</li><li><code>onreadystatechange</code>是<code>XMLHttpRequest</code>独有的事件</li></ol><h3 id="2、事件触发条件">2、事件触发条件<a class="anchor" href="#2、事件触发条件">·</a></h3><p>下面是我自己整理的一张<code>xhr</code>相关事件触发条件表，其中最需要注意的是 <code>onerror</code> 事件的触发条件。</p><table><thead><tr><th>事件</th><th>触发条件</th></tr></thead><tbody><tr><td><code>onreadystatechange</code></td><td>每当<code>xhr.readyState</code>改变时触发；但<code>xhr.readyState</code>由非<code>0</code>值变为<code>0</code>时不触发。</td></tr><tr><td><code>onloadstart</code></td><td>调用<code>xhr.send()</code>方法后立即触发，若<code>xhr.send()</code>未被调用则不会触发此事件。</td></tr><tr><td><code>onprogress</code></td><td><code>xhr.upload.onprogress</code>在上传阶段(即<code>xhr.send()</code>之后，<code>xhr.readystate=2</code>之前)触发，每50ms触发一次；<code>xhr.onprogress</code>在下载阶段（即<code>xhr.readystate=3</code>时）触发，每50ms触发一次。</td></tr><tr><td><code>onload</code></td><td>当请求成功完成时触发，此时<code>xhr.readystate=4</code></td></tr><tr><td><code>onloadend</code></td><td>当请求结束（包括请求成功和请求失败）时触发</td></tr><tr><td><code>onabort</code></td><td>当调用<code>xhr.abort()</code>后触发</td></tr><tr><td><code>ontimeout</code></td><td><code>xhr.timeout</code>不等于0，由请求开始即<code>onloadstart</code>开始算起，当到达<code>xhr.timeout</code>所设置时间请求还未结束即<code>onloadend</code>，则触发此事件。</td></tr><tr><td><code>onerror</code></td><td>在请求过程中，若发生<code>Network error</code>则会触发此事件（若发生<code>Network error</code>时，上传还没有结束，则会先触发<code>xhr.upload.onerror</code>，再触发<code>xhr.onerror</code>；若发生<code>Network error</code>时，上传已经结束，则只会触发<code>xhr.onerror</code>）。<br /><strong>注意</strong>，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的<code>xhr.statusCode</code>是<code>4xx</code>时，并不属于<code>Network error</code>，所以不会触发<code>onerror</code>事件，而是会触发<code>onload</code>事件。</td></tr></tbody></table><h3 id="3、事件触发顺序">3、事件触发顺序<a class="anchor" href="#3、事件触发顺序">·</a></h3><p>当请求一切正常时，相关的事件触发顺序如下：</p><ol><li>触发<code>xhr.onreadystatechange</code>(之后每次<code>readyState</code>变化时，都会触发一次)</li><li>触发<code>xhr.onloadstart</code>//上传阶段开始：</li><li>触发<code>xhr.upload.onloadstart</code></li><li>触发<code>xhr.upload.onprogress</code></li><li>触发<code>xhr.upload.onload</code></li><li>触发<code>xhr.upload.onloadend</code>//上传结束，下载阶段开始：</li><li>触发<code>xhr.onprogress</code></li><li>触发<code>xhr.onload</code></li><li>触发<code>xhr.onloadend</code></li></ol><h3 id="4、发生abort-timeout-error异常处理">4、发生<code>abort</code>/<code>timeout</code>/<code>error</code>异常处理<a class="anchor" href="#4、发生abort-timeout-error异常处理">·</a></h3><p>在请求的过程中，有可能发生 <code>abort</code>/<code>timeout</code>/<code>error</code>这3种异常。那么一旦发生这些异常，<code>xhr</code>后续会进行哪些处理呢？后续处理如下：</p><ol><li>一旦发生<code>abort</code>或<code>timeout</code>或<code>error</code>异常，先立即中止当前请求</li><li>将 <code>readystate</code> 置为<code>4</code>，并触发 <code>xhr.onreadystatechange</code>事件</li><li>如果上传阶段还没有结束，则依次触发以下事件：<ul><li><code>xhr.upload.onprogress</code></li><li><code>xhr.upload.[onabort或ontimeout或onerror]</code></li><li><code>xhr.upload.onloadend</code></li></ul></li><li>触发 <code>xhr.onprogress</code>事件</li><li>触发 <code>xhr.[onabort或ontimeout或onerror]</code>事件</li><li>触发<code>xhr.onloadend</code> 事件</li></ol><h3 id="5、在哪个xhr事件中注册成功回调？">5、在哪个<code>xhr</code>事件中注册成功回调？<a class="anchor" href="#5、在哪个xhr事件中注册成功回调？">·</a></h3><h4 id="1、onreadystatechange、onload">1、onreadystatechange、onload<a class="anchor" href="#1、onreadystatechange、onload">·</a></h4><ul><li>若<code>xhr</code>请求成功，就会触发<code>xhr.onreadystatechange</code>和<code>xhr.onload</code>两个事件</li><li>但倾向于 <code>xhr.onload</code>事件，因为<code>xhr.onreadystatechange</code>是每次<code>xhr.readyState</code>变化时都会触发，而不是<code>xhr.readyState=4</code>时才触发</li></ul><h4 id="2、坑">2、坑<a class="anchor" href="#2、坑">·</a></h4><p>这样的判断是有坑儿的，比如当返回的<code>http</code>状态码不是<code>200</code>，而是<code>201</code>时，请求虽然也是成功的，但并没有执行成功回调逻辑</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//如果请求成功</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//do successCallback</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>更靠谱的判断方法应该是：当<code>http</code>状态码为<code>2xx</code>或<code>304</code>时才认为成功</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//如果请求成功</span></span><br><span class="line">  <span class="keyword">if</span>((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>)&#123;</span><br><span class="line">    <span class="comment">//do successCallback</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用场景：</strong></p><ul><li>页面上拉加载更多数据，页面没有更新只是把请求来的数据呈现出来</li><li>列表数据无刷新分页</li><li>表单数据离开焦点验证，比如邮箱注册的时候输完地址会自动显示该地址是否已被注册</li><li>搜索框文字自动提示</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 跨域携带cookie</span></span><br><span class="line">   xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 处理请求参数</span></span><br><span class="line">   postData = &#123;<span class="string">&quot;name1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;name2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;;</span><br><span class="line">   postData = (<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> dataString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> value)&#123;</span><br><span class="line">        dataString += key+<span class="string">&quot;=&quot;</span>+value[key]+<span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">   &#125;;</span><br><span class="line">     <span class="keyword">return</span> dataString;</span><br><span class="line">   &#125;(postData));</span><br><span class="line">  </span><br><span class="line">   xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;www.xxx.com&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line">   xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">   xhr.<span class="title function_">send</span>(postData);</span><br><span class="line">  </span><br><span class="line">   xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span> )&#123;</span><br><span class="line">           <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>)&#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 异常处理</span></span><br><span class="line">   xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Network request failed&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="http://www.conardli.top/img/wl/wlqq_2.png" alt="image" style="zoom: 67%;" /><h2 id="四、xhr相关API用法">四、xhr相关API用法<a class="anchor" href="#四、xhr相关API用法">·</a></h2><h3 id="1、xhr方法">1、xhr方法<a class="anchor" href="#1、xhr方法">·</a></h3><h4 id="1-open方法">1. open方法<a class="anchor" href="#1-open方法">·</a></h4><ul><li><p>用于初始化一个请求，为请求做准备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(method,URL,async)</span><br><span class="line">// 注意：只能访问同源URL,域名，端口，协议相同</span><br><span class="line">// 如果请求的URL和发送请求的页面在任何地方有所不同，就会抛出安全错误</span><br></pre></td></tr></table></figure><ul><li><code>method</code>：请求方式，如<code>get、post</code></li><li><code>url</code>：请求的<code>url</code></li><li><code>async</code>：是否为异步请求，true/false</li></ul></li></ul><h4 id="2-send方法">2. send方法<a class="anchor" href="#2-send方法">·</a></h4><ul><li><p>用于发送HTTP请求，即调用该方法后HTTP请求才会被真正发出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.send(param)</span><br></pre></td></tr></table></figure></li><li><p><code>param</code>：http请求的参数，作为请求体发送的数据，可以为<code>string、Blob</code>等类型。null代表不发</p></li><li><p>这个请求是同步的，所以JS代码会等待服务器相应后，再继续执行。</p></li><li><p>收到服务器响应后，XHR对象的某些属性会被填充数据</p><ul><li>ResponseText：作为响应返回的文本</li><li>ResponseXML：如果响应的内容类型是&quot;text\html&quot;，那就是包含响应数据的XML DOM文档</li><li>status：响应HTTP状态</li><li>statusText：响应的HTTP状态描述</li></ul></li></ul><h4 id="3-setRequestHeader">3. setRequestHeader<a class="anchor" href="#3-setRequestHeader">·</a></h4><ul><li><p>用于设置<code>HTTP</code>请求头，默认情况，会发头部字段，还可以发额外的请求</p></li><li><p>必须在<code>open()</code>方法和<code>send()</code>之间调用</p></li><li><p>可以与通用字段重名（即重写，有的浏览器不支持），或自定义</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">setRequestHeader</span>(header, value);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://www.example.com&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&#x27;name=zhangsan&amp;age=12&#x27;</span>) <span class="comment">//请求参数放在send方法中</span></span><br></pre></td></tr></table></figure><ul><li>header：自定义的头部字段的名称</li><li>value：值</li></ul></li></ul><h5 id="设置请求参数格式：">设置请求参数格式：<a class="anchor" href="#设置请求参数格式：">·</a></h5><ul><li><p><strong>application/x-www-form-urlencoded</strong></p><p>请求参数就是&amp;连接的<strong>键值对</strong>，如<code>name=zhangsan&amp;age=12</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(&#x27;Content-type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;)</span><br></pre></td></tr></table></figure></li><li><p><strong>application/json</strong></p><p>请求参数是<strong>json对象</strong>，如<code>&#123;name:'zhangsan',age:'12'&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(&#x27;Content-type&#x27;,&#x27;appliation/json)&#x27;</span><br></pre></td></tr></table></figure><p>但是要把json对象转换为字符串，用JSON.stringify方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.send(JSON.stringify(&#123;name:&#x27;zhangsan&#x27;,age:&#x27;12&#x27;&#125;))</span><br></pre></td></tr></table></figure><p><strong>get是不能传递json对象的请求参数的，表单提交也不支持json数据</strong></p></li></ul><h4 id="4-1-getResponseHeader">4.1 getResponseHeader<a class="anchor" href="#4-1-getResponseHeader">·</a></h4><ul><li><p>用于获取<code>http</code>返回头，如果在返回头中有多个一样的名称，那么返回的值就会是用逗号和空格将值分隔的字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var header = xhr.getResponseHeader(name);</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-getAllResponseHeaders">4.2 getAllResponseHeaders<a class="anchor" href="#4-2-getAllResponseHeaders">·</a></h4><ul><li>用于所有响应头部的字符串</li></ul><h4 id="5-abort">5. abort<a class="anchor" href="#5-abort">·</a></h4><ul><li><p>用于终止一个<code>ajax</code>请求，调用此方法后<code>readyState</code>将被设置为<code>0</code>，用法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.abort()</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、xhr属性">2、xhr属性<a class="anchor" href="#2、xhr属性">·</a></h3><img src="https://note.youdao.com/yws/public/resource/05ca5e90ee117da30b7751ae1e23528a/xmlnote/331ECC69CEA04C3DA2DFA12B5888B1FB/3581" alt="img" style="zoom:67%;" /><h4 id="1-readyState">1. readyState<a class="anchor" href="#1-readyState">·</a></h4><ul><li><p>标识当前<code>XMLHttpRequest</code>对象所处状态，<code>XMLHttpRequest</code>对象总是位于下列状态之一</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td><code>UNSENT</code></td><td>代理被创建，但尚未调用 <code>open()</code> 方法。</td></tr><tr><td>1</td><td><code>OPENED</code></td><td><code>open()</code> 方法已经被调用。</td></tr><tr><td>2</td><td><code>HEADERS_RECEIVED</code></td><td><code>send()</code>方法已经被调用，并且头部和状态已经可获得。</td></tr><tr><td>3</td><td><code>LOADING</code></td><td>下载中； <code>responseText</code> 属性已经包含部分数据。</td></tr><tr><td>4</td><td><code>DONE</code></td><td>下载操作已完成。   <strong>最关心这个</strong></td></tr></tbody></table></li></ul><h4 id="2-status：">2. status：<a class="anchor" href="#2-status：">·</a></h4><ul><li>表示<code>http</code>请求的状态, 初始值为<code>0</code>。如果服务器没有显式地指定状态码, 那么<code>status</code>将被设置为默认值, 即<code>200</code>。</li></ul><h4 id="3-responseType：">3. responseType：<a class="anchor" href="#3-responseType：">·</a></h4><ul><li><p>表示响应的数据类型，并允许我们手动设置，如果为空，默认为<code>text</code>类型，可以有下面的取值</p></li><li><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td>将 <code>responseType</code>设为空字符串与设置为<code>&quot;text&quot;</code>相同， 是默认类型 （实际上是 <code>DOMString</code>）。</td></tr><tr><td><code>&quot;arraybuffer&quot;</code></td><td><code>response</code> 是一个包含二进制数据的<code>JavaScript ArrayBuffer</code> 。</td></tr><tr><td><code>&quot;blob&quot;</code></td><td><code>response</code>是一个包含二进制数据的 <code>Blob</code> 对象 。</td></tr><tr><td><code>&quot;document&quot;</code></td><td>response 是一个<code>HTML Document</code>或<code>XML XMLDocument</code>，这取决于接收到的数据的 MIME 类型。</td></tr><tr><td><code>&quot;json&quot;</code></td><td><code>response</code> 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为<code>JSON</code>解析得到的。</td></tr><tr><td><code>&quot;text&quot;</code></td><td><code>response</code>是包含在<code>DOMString</code>对象中的文本。</td></tr></tbody></table></li></ul><h4 id="4-response">4. response<a class="anchor" href="#4-response">·</a></h4><h4 id="5-withCredentials">5. withCredentials<a class="anchor" href="#5-withCredentials">·</a></h4><ul><li><code>ajax</code>请求默认会携带同源请求的<code>cookie</code>，而跨域请求则不会携带<code>cookie</code>，设置<code>xhr</code>的<code>withCredentials</code>的属性为<code>true</code>将允许携带跨域<code>cookie</code></li></ul><h3 id="3、事件处理">3、事件处理<a class="anchor" href="#3、事件处理">·</a></h3><h4 id="1-onreadystatechange-进度事件">1. onreadystatechange             进度事件<a class="anchor" href="#1-onreadystatechange-进度事件">·</a></h4><ul><li><p>当<code>readyState</code>属性发生变化时，callback会被触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = callback;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-onloadstart-进度事件">2. onloadstart                               进度事件<a class="anchor" href="#2-onloadstart-进度事件">·</a></h4><ul><li><p>在接收到响应的第一个字节时触发，在<code>ajax</code>请求发送之前（<code>readyState==1</code>后, <code>readyState==2</code>前），<code>callback</code>会被触发</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.onloadstart = callback;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-onprogress-进度事件">3. onprogress                                进度事件<a class="anchor" href="#3-onprogress-进度事件">·</a></h4><ul><li><p>在接收响应期间反复触发，回调函数可以获取资源总大小<code>total</code>，已经加载的资源大小<code>loaded</code>，用这两个值可以计算加载进度。事件处理程序上携带event对象，其target属性是XHR对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">loaded</span> / event.<span class="property">total</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-onload-进度事件">4. onload                                      进度事件<a class="anchor" href="#4-onload-进度事件">·</a></h4><ul><li><p>在成功接收完响应时触发，通常在回调中返回值。</p></li><li><p>最初火狐增加了load事件用来代替readystatechange事件，load在响应接收完成后，立即触发，无论状态码是什么，都会触发，所以还需要检查状态码属性才能确定是否有效。并非所有浏览器支持</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onload</span> = callback;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-ontimeout：-请求超时">5. ontimeout：                                 请求超时<a class="anchor" href="#5-ontimeout：-请求超时">·</a></h4><ul><li><p>当进度由于预定时间到期而终止时，会触发<code>callback</code>，超时时间可使用<code>timeout</code>属性进行设置。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">ontimeout</span> = callback;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-onerror-进度事件">6. onerror                                           进度事件<a class="anchor" href="#6-onerror-进度事件">·</a></h4><ul><li>在请求出错时会触发<code>callback</code></li></ul><h4 id="7-loadend-进度事件">7. loadend                                          进度事件<a class="anchor" href="#7-loadend-进度事件">·</a></h4><ul><li>在通信完成时，且在 error、abort 或 load 之后触发。 每次请求都会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后以 loadend 事件结束</li></ul><h3 id="6-低版本IE缓存问题">6. 低版本IE缓存问题<a class="anchor" href="#6-低版本IE缓存问题">·</a></h3><h4 id="1-问题：-2">1. 问题：<a class="anchor" href="#1-问题：-2">·</a></h4><ul><li>在请求地址不发生变化的情况下，ajax只会发送第一次的请求，剩余的多次请求不会再发送给浏览器而是直接加载缓存中的数据</li><li>即使服务器中数据已经发生改变，客户端拿到的依旧是缓存的就数据</li></ul><h4 id="2-解决办法">2. 解决办法<a class="anchor" href="#2-解决办法">·</a></h4><ul><li><p>浏览器的缓存是根据url地址来记录的，所以我们只需要修改url地址既可避免缓存问题：添加<strong>请求参数</strong>，每次请求都不相同，该参数是随机数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GEt&#x27;</span>,<span class="string">&#x27;http://www.example.com&#x27;</span>+<span class="title class_">Math</span>.<span class="title function_">random</span>())</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;/testAJAX?t=&#x27;</span>+<span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-重复请求问题">7. 重复请求问题<a class="anchor" href="#7-重复请求问题">·</a></h3><ul><li><p>**标识量：**发请求之前判断请求是否在发送中，如果是，就调用abort停止强求，在收到响应之后，标识位变为false</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isSending)&#123;</span><br><span class="line">    xhr.<span class="title function_">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  isSending = <span class="literal">true</span>;</span><br><span class="line">  x.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">  xhr.<span class="property">onreadystateChange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">      isSending = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-发ajax请求的方式：">8. 发ajax请求的方式：<a class="anchor" href="#8-发ajax请求的方式：">·</a></h3><h4 id="1-jquery-略">1. jquery 略<a class="anchor" href="#1-jquery-略">·</a></h4><h4 id="2-Fetch-略">2. Fetch 略<a class="anchor" href="#2-Fetch-略">·</a></h4><h4 id="3-axios">3. axios<a class="anchor" href="#3-axios">·</a></h4><p>基于<strong>promise的HTTP库</strong>，本质上也是对<strong>原生XHR的封装</strong></p><ul><li><p>常见方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.get(url, data, params);</span><br><span class="line">axios.post(url, data, params)</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-AJAX封装-⭐️⭐️">9. AJAX封装 ⭐️⭐️<a class="anchor" href="#9-AJAX封装-⭐️⭐️">·</a></h3><ul><li><p>封装函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">options</span>)&#123;</span><br><span class="line">  <span class="comment">//1.创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.处理请求参数，默认请求参数是对象，要弄成键值对形式</span></span><br><span class="line">  <span class="keyword">var</span> params = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> options.<span class="property">data</span>)&#123;</span><br><span class="line">      params += attr+<span class="string">&#x27;=&#x27;</span>+options.<span class="property">data</span>[attr]+<span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  params = params.<span class="title function_">substr</span>(<span class="number">0</span>,params.<span class="property">length</span>-<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.调用open方法，get请求要把请求参数加入url中，post要把请求参数放入send方法中</span></span><br><span class="line">  <span class="keyword">if</span>(options.<span class="property">type</span> == <span class="string">&#x27;get&#x27;</span>)&#123;</span><br><span class="line">    options.<span class="property">url</span> = options.<span class="property">url</span>+<span class="string">&#x27;?&#x27;</span>+params</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.<span class="title function_">open</span>(options.<span class="property">type</span>,options.<span class="property">url</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//4.调用send方法，get请求就直接调用，post请求要设置头字段，请求参数要放入send方法中</span></span><br><span class="line">  <span class="keyword">if</span>(options.<span class="property">type</span> == <span class="string">&#x27;post&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> contentType = options.<span class="property">header</span>[<span class="string">&#x27;Content-Type&#x27;</span>]</span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,contentType)</span><br><span class="line">    <span class="keyword">if</span>(contentType == <span class="string">&#x27;application/json&#x27;</span>)&#123;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(options.<span class="property">data</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      xhr.<span class="title function_">send</span>(params)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    xhr.<span class="title function_">send</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//5.接收响应数据</span></span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> contentType = xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> responseText = xhr.<span class="property">responseText</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(contentType.<span class="title function_">includes</span>(<span class="string">&#x27;json&#x27;</span>))&#123;</span><br><span class="line">      responseText = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(responseText)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">      options.<span class="title function_">success</span>(responseText)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      options.<span class="title function_">error</span>(responseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">header</span>:&#123;</span><br><span class="line"><span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">  <span class="attr">error</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.3-Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> 网络请求 </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的EventLoop</title>
      <link href="/posts/656350506.html"/>
      <url>/posts/656350506.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、JS执行机制">1、JS执行机制<a class="anchor" href="#1、JS执行机制">·</a></h3><ul><li>JS分为同步任务和异步任务，同步任务都在主线程上（JS引擎线程）执行，形成一个<code>执行栈</code></li><li>主线程之外，<strong>事件触发线程</strong>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件</li><li>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到可执行栈中，开始执行</li></ul><h3 id="2、事件循环">2、事件循环<a class="anchor" href="#2、事件循环">·</a></h3><h4 id="1、流程：">1、流程：<a class="anchor" href="#1、流程：">·</a></h4><ol><li>首先，执行栈开始顺序执行</li><li>判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行</li><li>执行栈空，询问任务队列中是否有事件回调</li><li>任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行</li><li>任务队列中没有事件回调则不停发起询问</li></ol><h4 id="2、涉及到的线程特点：">2、涉及到的线程特点：<a class="anchor" href="#2、涉及到的线程特点：">·</a></h4><ol><li>**定时触发线程：**只管理定时器且只关注定时不关心结果，定时结束就把回调扔给事件触发线程</li><li>**异步http请求线程：**只管理http请求同样不关心结果，请求结束把回调扔给事件触发线程</li><li>**事件触发线程：**只关心异步回调入事件队列</li><li><strong>JS引擎线程：<strong>只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的</strong>事件循环(Event Loop)</strong></li></ol><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/18/16fb7acab03b35fa~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:25%;" /><h3 id="3、宏任务-task">3、宏任务         task<a class="anchor" href="#3、宏任务-task">·</a></h3><ul><li><p>可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p></li><li><p>由于<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</span><br></pre></td></tr></table></figure></li><li><p>常见的宏任务</p><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul></li></ul><h3 id="4、微任务-jobs">4、微任务    jobs<a class="anchor" href="#4、微任务-jobs">·</a></h3><h4 id="1、概念：-2">1、概念：<a class="anchor" href="#1、概念：-2">·</a></h4><ul><li><p>ES6新引入了Promise标准，同时浏览器实现上多了一个<code>microtask</code>微任务概念</p></li><li><p><code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而微任务可以理解成在当前<code>宏任务</code>执行后立即执行的任务</p><p>会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</span><br></pre></td></tr></table></figure></li><li><p>常见微任务</p><ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul></li></ul><h4 id="2、注意点">2、注意点<a class="anchor" href="#2、注意点">·</a></h4><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p></li><li><h4 id="微任务和宏任务不在一个任务队列，不在一个任务队列">微任务和宏任务不在一个任务队列，不在一个任务队列<a class="anchor" href="#微任务和宏任务不在一个任务队列，不在一个任务队列">·</a></h4><ul><li>例如<code>setTimeout</code>是一个宏任务，它的事件回调在宏任务队列，<code>Promise.then()</code>是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>有关渲染的都是在渲染进程中执行：<ol><li>渲染进程中的任务（DOM树构建，js解析…等等），其中需要主线程执行的任务都会在主线程中执行</li><li>而浏览器维护了一套事件循环机制，主线程会循环消息队列，并从头部取出任务进行执行</li><li>如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，<strong>消息队列中的任务都是宏任务</strong></li></ol></li></ul></li><li><h4 id="微任务是如何产生的呢？">微任务是如何产生的呢？<a class="anchor" href="#微任务是如何产生的呢？">·</a></h4><ol><li>当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列</li><li>当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文</li><li>这也就是为什么微任务要早于宏任务</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventLoop </tag>
            
            <tag> 宏任务 </tag>
            
            <tag> 微任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的异步解决方案</title>
      <link href="/posts/3384747987.html"/>
      <url>/posts/3384747987.html</url>
      
        <content type="html"><![CDATA[<h2 id="异步解决方案">异步解决方案<a class="anchor" href="#异步解决方案">·</a></h2><h3 id="1、JS的异步任务">1、JS的异步任务<a class="anchor" href="#1、JS的异步任务">·</a></h3><ul><li>JS各种事件</li><li>setTimeout、setInterval 定时器</li><li>Ajax网络请求</li><li>Promise</li><li>async function</li></ul><h3 id="2、几种异步解决方案">2、几种异步解决方案<a class="anchor" href="#2、几种异步解决方案">·</a></h3><ul><li>回调函数</li><li>事件监听(发布/订阅)</li><li>Promise</li><li>Generator</li><li>Async/Await</li></ul><h3 id="3-1、方式1：回调函数">3.1、方式1：回调函数<a class="anchor" href="#3-1、方式1：回调函数">·</a></h3><p>异步编程最基本的方法，举例</p><ul><li><p>假定有两个函数f1和f2，后者等待前者的执行结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f1</span>();  <span class="comment">// 耗时较长的任务，直接这样写会导致阻塞</span></span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure></li><li><p>改写：</p><p><strong>把同步操作f1变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">callback</span>)&#123;<span class="comment">//此时f1就是一个异步任务</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="title function_">callback</span>(); <span class="comment">// f2的逻辑，会在f1执行完毕后就能执行</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>(f2);</span><br></pre></td></tr></table></figure></li><li><p>优点：简单易理解</p></li><li><p>缺点：</p><ul><li>不利于代码的阅读和维护，各个部分之间高度耦合</li><li>流程会很混乱，而且每个任务只能指定一个回调函数</li><li><strong>异步回调中，回调函数的执行栈与原函数分离，外部无法抓住异常，异常会变得不可控。这会导致什么呢？？？</strong></li></ul></li></ul><h3 id="3-2、方式2：事件监听">3.2、方式2：事件监听<a class="anchor" href="#3-2、方式2：事件监听">·</a></h3><p>采用事件驱动模式。任务的执行<strong>不取决于代码的顺序，而取决于某个事件是否发生</strong></p><ul><li><p>首先，为f1绑定一个done事件，f2作为回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1.<span class="title function_">on</span>(<span class="string">&#x27;done&#x27;</span>, f2);  <span class="comment">// f1事件执行完毕后，执行f2</span></span><br></pre></td></tr></table></figure></li><li><p>然后，对f1进行改写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　　　<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// f1.trigger(&#x27;done&#x27;)手动触发done事件，从而开始执行f2</span></span><br><span class="line">　　　　　　f1.<span class="title function_">trigger</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">　　　　&#125;, <span class="number">1000</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li>易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li><li>可以去耦合</li><li>有利于模块化</li></ul></li><li><p>缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰</p></li></ul><h3 id="3-3、方式3：发布订阅">3.3、方式3：发布订阅<a class="anchor" href="#3-3、方式3：发布订阅">·</a></h3><p><strong>发布/订阅模式：</strong></p><ul><li>存在一个“信号中心”，某个任务执行完成，就向信号中心发布一个信号；</li><li>其他任务可以向信号订阅这个信号，从而知道什么时候自己可以开始执行；</li></ul><h4 id="1、用class实现">1、用class实现<a class="anchor" href="#1、用class实现">·</a></h4><ol><li><p>创建了一个<code>Emitter</code>类，有两个原型方法<code>on</code>和<code>trigger</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Emitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// _listener数组，key为自定义事件名，value为执行回调数组-因为可能有多个</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_listener</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, fn</span>) &#123; <span class="comment">// 订阅 监听事件</span></span><br><span class="line">    <span class="comment">// 判断_listener数组中是否存在该事件命</span></span><br><span class="line">    <span class="comment">// 存在将回调push到事件名对应的value数组中，不存在直接新增</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_listener</span>[type] </span><br><span class="line">      ? <span class="variable language_">this</span>.<span class="property">_listener</span>[type].<span class="title function_">push</span>(fn) </span><br><span class="line">    : (<span class="variable language_">this</span>.<span class="property">_listener</span>[type] = [fn])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">trigger</span>(<span class="params">type, ...rest</span>) &#123; <span class="comment">// 发布 触发事件</span></span><br><span class="line">    <span class="comment">// 判断该触发事件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_listener</span>[type]) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 遍历执行该事件回调数组并传递参数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_listener</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(...rest))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、使用-3">2、使用<a class="anchor" href="#2、使用-3">·</a></h4><p>创建一个emitter实例，接着注册事件，再触发事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> <span class="title class_">Emitter</span>()</span><br><span class="line"></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&quot;done&quot;</span>, <span class="keyword">function</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1, arg2)</span><br><span class="line">&#125;)</span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&quot;done&quot;</span>, <span class="keyword">function</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg2, arg1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是主程序&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    emitter.<span class="title function_">trigger</span>(<span class="string">&quot;done&quot;</span>, <span class="string">&quot;异步参数一&quot;</span>, <span class="string">&quot;异步参数二&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure><ul><li>这种方法的性质与&quot;事件监听&quot;类似，但是明显优于后者。因为我们可以通过查看&quot;消息中心&quot;，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行</li></ul><h3 id="3-4、方式4：promise">3.4、方式4：promise<a class="anchor" href="#3-4、方式4：promise">·</a></h3><ul><li><p>思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数</p></li><li><p>比如，f1的回调函数f2,可以写成：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f1</span>().<span class="title function_">then</span>(f2);</span><br></pre></td></tr></table></figure><p>f1改写为promise：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pomise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  　　<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// f1的任务代码</span></span><br><span class="line">           ....</span><br><span class="line">  　　　　　　<span class="title function_">resolve</span>();</span><br><span class="line">  　　　　&#125;, <span class="number">500</span>);</span><br><span class="line">  　　&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ol><li><p>可以指定多个回调、错误的回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f1</span>().<span class="title function_">then</span>(f2).<span class="title function_">then</span>(f3);</span><br><span class="line"><span class="title function_">f1</span>().<span class="title function_">then</span>(f2).<span class="title function_">catch</span>(f3);</span><br></pre></td></tr></table></figure></li><li><p>其他三个没有的：</p><p>如果一个任务已经完成，<strong>再添加回调函数（指定then），该回调函数会立即执行</strong>。所以，你不用担心是否错过了某个事件或信号</p></li></ol></li></ul><h3 id="3-5、Generator">3.5、Generator<a class="anchor" href="#3-5、Generator">·</a></h3><h3 id="3-6、async-await">3.6、async await<a class="anchor" href="#3-6、async-await">·</a></h3><h2 id="2-1、Promise概念及关键问题">2.1、Promise概念及关键问题<a class="anchor" href="#2-1、Promise概念及关键问题">·</a></h2><p>一句话：用同步的方式写异步的代码，可用来解决回调地狱问题</p><h3 id="1、是什么">1、是什么<a class="anchor" href="#1、是什么">·</a></h3><ul><li><h5 id="抽象表达">抽象表达:<a class="anchor" href="#抽象表达">·</a></h5><ol><li>Promise <strong>就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。承诺不一定会完成，但是一定都会有一个结果</strong></li><li>Promise 是 JS <code>异步编程</code>的新方案，是一门新技术(ES6 规范) , 备注：旧方案是回调</li></ol></li><li><h5 id="具体表达">具体表达:<a class="anchor" href="#具体表达">·</a></h5><ol><li>从语法上: Promise 是一个<code>构造函数</code>，实例是一个对象，从它可以获取异步操作的消息</li><li>从功能上: promise 对象用来封装一个异步操作，而且Promise 提供统一的 API，可以获取其成功/ 失败的结果值</li></ol></li></ul><h3 id="2、2个特点">2、2个特点:<a class="anchor" href="#2、2个特点">·</a></h3><ol><li>Promise对象的状态不受外界影响。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果<ul><li><code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</li><li>只要这两种情况发生，状态就凝固了。</li><li>如果改变已经发生了，再对<code>Promise</code>对象添加回调函数，会立即得到这个结果。这与事件完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul></li></ol><h3 id="3、优-缺点：">3、优/缺点：<a class="anchor" href="#3、优-缺点：">·</a></h3><h4 id="3-1、优点：">3.1、优点：<a class="anchor" href="#3-1、优点：">·</a></h4><ul><li><h5 id="以往异步编程模式">以往异步编程模式<a class="anchor" href="#以往异步编程模式">·</a></h5><ul><li>普通异步回调：异步函数的返回值只在短时间内存在，需要提前准备好回调函数来接收它</li><li>嵌套异步回调：异步返回值依赖与另一个返回值，多个会造成回调地狱，代码维护很难</li></ul></li><li><h5 id="promise">promise<a class="anchor" href="#promise">·</a></h5><ol><li><p><strong>指定回调函数的方式更加灵活:</strong></p><ul><li><p>启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定/多个)</p></li><li><p>而旧版必须在启动异步任务前指定</p></li><li><p><code>Promise</code>对象提供统一的接口，使得<strong>控制异步操作更加容易</strong></p></li></ul></li><li><p><strong>支持链式调用, 解决回调地狱问题</strong></p></li></ol></li><li><p>同步的方式写异步的代码，避免了层层嵌套的回调函数</p></li><li><p>promise <code>链式调用</code>：用来解决回调地狱问题，但<code>只是简单改变格式</code>，并没有彻底解决</p></li></ul><h4 id="3-2、缺点：">3.2、缺点：<a class="anchor" href="#3-2、缺点：">·</a></h4><ol><li><strong>一旦新建它就会立即执行，无法中途取消</strong></li><li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</li><li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li><li>一眼看上去都是promise的API，而且链式语法总觉得不好看，不优雅</li></ol><h3 id="4、onRejected和catch区别">4、onRejected和catch区别<a class="anchor" href="#4、onRejected和catch区别">·</a></h3><p><code>promise.then(onresolved, onRejected)</code>在 <code>onresolved</code>回调中发生异常时：</p><ul><li><p><code>onRejected</code>中是捕获不到这个异常，可以在末尾多加一个<code>then</code>从而达到和<code>catch</code>相同的作用（流转到下一个错误处理）</p></li><li><p><strong>使用<code>catch</code>可以捕获到前面的<code>onRejected</code>的异常</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是对的&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;111&#x27;</span>  <span class="comment">// 抛出异常</span></span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//情况1： 我是对的  111   返回undefined的resolved的promise</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res), <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line"><span class="comment">// 情况2：    </span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 我是对的  err:111   返回undefined的resolved的promise</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span> + err) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、then中抛错未处理">5、then中抛错未处理<a class="anchor" href="#5、then中抛错未处理">·</a></h3><ul><li><p>如果在then中抛错，而没有对错误进行处理(catch)，那么会一直保持reject状态的promise，就不会往下执行了</p></li><li><p>直到catch了错误，状态变为resolved</p></li><li><p>promise的缺点之一就是无法让promise中断，利用这个特性可让Promise中断执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 错误：未声明的变量</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Task 1&quot;</span>);</span><br><span class="line">&#125;)<span class="comment">//跳过了第二个then</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Task 2&quot;</span>);</span><br><span class="line">&#125;)<span class="comment">//如果我们没有处理这个错误(无catch)的话，就不会往下执行了</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 这时候变成undefined的resolved的promise</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span> + err)</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finaltask&quot;</span>, res)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// err:ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// finaltask  undefined</span></span><br></pre></td></tr></table></figure></li><li><h4 id="流程图：">流程图：<a class="anchor" href="#流程图：">·</a></h4></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/14/17041c4ba347afe2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 50%;" /><h3 id="6、异步回调中抛错catch捕捉不到">6、异步回调中抛错catch捕捉不到<a class="anchor" href="#6、异步回调中抛错catch捕捉不到">·</a></h3><ol><li><p>在Promise对象的处理器函数中直接抛出错误，<code>catch</code>是可以捕捉到的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br></pre></td></tr></table></figure></li><li><p>在Promise对象的处理器函数中异步抛错，**catch捕获不到：**为什么</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span>=&gt;</span>&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br></pre></td></tr></table></figure><p>JS 事件循环列表有宏任务与微任务之分，setTimeOut是宏任务， promise是微任务，执行顺序不同</p><ul><li>执行栈进入promise 触发setTimeOut，setTimeOut回调函数入宏任务队列</li><li>执行promise的catch方法，入微任务队列，此时setTimeOut回调还没执行</li><li>执行栈检查发现当前微任务队列执行完毕，开始执行宏任务队列</li><li>执行<code>throw new Error('这是一个错误')</code> 此<strong>时这个异常其实是在promise外部抛出的</strong></li></ul></li></ol><ul><li><p><strong>解决</strong>：使用<code>try catch</code>捕获异常主动触发<code>reject</code>       不太理解？？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>) </span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">       <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="7、中断-promise-链">7、中断 promise 链?<a class="anchor" href="#7、中断-promise-链">·</a></h3><p>场景：有5个then()，但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何？</p><ul><li><p>回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;</span><br><span class="line">);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);&#125;)<span class="comment">//有且只有这一个方式</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="8、一个-promise-指定多个成功-失败回调函数-都会调用吗">8、一个 promise 指定多个成功/失败回调函数, 都会调用吗?<a class="anchor" href="#8、一个-promise-指定多个成功-失败回调函数-都会调用吗">·</a></h3><ul><li>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">&gt;<span class="comment">///指定回调1</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); &#125;);</span><br><span class="line">&gt;<span class="comment">//指定回调2</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="title function_">alert</span>(value);&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="9、改变-promise-状态和指定回调函数谁先谁后">9、改变 promise 状态和指定回调函数谁先谁后?<a class="anchor" href="#9、改变-promise-状态和指定回调函数谁先谁后">·</a></h3><p>都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p><h4 id="1、先指定回调再改变状态">1、先指定回调再改变状态<a class="anchor" href="#1、先指定回调再改变状态">·</a></h4><ul><li><p>先指定回调–&gt; 再改变状态 --&gt;改变状态后才进入异步队列执行回调函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//异步写法,这样写会先指定回调,再改变状态</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当状态发生改变时, 回调函数就会调用, 得到数据</p></li></ul><h4 id="2、先改状态再指定回调">2、先改状态再<code>指定</code>回调<a class="anchor" href="#2、先改状态再指定回调">·</a></h4><ul><li><p>先改状态再<code>指定</code>回调：</p><p>方法1：在执行器中直接调用 resolve()/reject()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//这是同步写法,这样写会先改变状态,再指定回调</span></span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); </span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>方法2：延迟更长时间才调用 then() ，在<code>.then()</code>外再包一层例如延时器</p></li><li><p>当指定回调时, 回调函数就会调用, 得到数据</p></li></ul><h4 id="3、个人理解–结合源码">3、个人理解–结合源码<a class="anchor" href="#3、个人理解–结合源码">·</a></h4><p>源码中,promise的状态是通过一个<code>默认为padding</code>的变量进行判断：</p><ol><li><p>当你<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是<code>进行中</code>，如果只是这样会导致只有同步操作才能成功</p></li><li><p>所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的</p></li></ol><h2 id="2-2、Promise用法">2.2、Promise用法<a class="anchor" href="#2-2、Promise用法">·</a></h2><h3 id="1-Promise-构造函数-Promise-excutor">1- Promise 构造函数: Promise (excutor) {}<a class="anchor" href="#1-Promise-构造函数-Promise-excutor">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>executor 函数: 执行器 (resolve, reject) =&gt; {}，会在 <strong>Promise 内部立即<code>同步调用</code></strong></li><li>resolve 函数：会将promise状态改成resolved，<strong>参数正常的值/另一个 Promise 实例</strong></li><li>reject 函数：<strong>参数通常是<code>Error</code>对象的实例，表示抛出的错误</strong></li></ul><h4 id="1、参数传递问题：">1、参数传递问题：<a class="anchor" href="#1、参数传递问题：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>p1：正常值，参数p1会作为promise的结果，保存在promise对象的<strong>promiseResult</strong>属性中，被传递给<strong>回调函数的参数</strong></li><li>p1：promise对象，<strong><code>p1</code>的状态决定了<code>p2</code>的状态</strong><ul><li>如果<code>p1</code>状态是<code>pending</code>，那<code>p2</code>的回调函数会等待<code>p1</code>的状态改变</li><li>如果<code>p1</code>状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行</li></ul></li></ul><h4 id="2、resolve或reject对执行器函数的执行影响">2、<code>resolve</code>或<code>reject</code>对执行器函数的执行影响<a class="anchor" href="#2、resolve或reject对执行器函数的执行影响">·</a></h4><ul><li><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行，后面的仍然是同步任务</p></li><li><p>而then：是在微任务中执行的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为<strong>立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</strong></li></ul></li></ul><h4 id="3、return的影响：">3、return的影响：<a class="anchor" href="#3、return的影响：">·</a></h4><p>一般来说，一个promise对象内部<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了。但执行器本身后面还是执行的，所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-原型方法then">2-原型方法then<a class="anchor" href="#2-原型方法then">·</a></h3><p>Promise实例生成以后，可用<code>then</code>方法指定<code>resolved</code>状态和<code>reject</code>状态的回调函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">then</span>(onFulfilled [, onRejected])</span><br></pre></td></tr></table></figure><h4 id="1、返回值：返回一个新的-promise-对象">1、返回值：返回一个新的 promise 对象<a class="anchor" href="#1、返回值：返回一个新的-promise-对象">·</a></h4><ul><li>返回一个新的 promise 对象，因此可用链式写法，即<code>then</code>后面再<code>then</code></li><li>链式写法中，后一个回调函数，会等待前<code>Promise</code>对象的状态发生变化，才会被调用</li></ul><h4 id="2、返回结果promise-对象的状态-重要5条">2、返回结果promise 对象的状态          重要5条<a class="anchor" href="#2、返回结果promise-对象的状态-重要5条">·</a></h4><p>总结：由 then()指定<strong>的回调函数执行的结果决定</strong></p><ol><li><p>如果没有return值，那会返回的新promise变为resolved，传参undefined</p></li><li><p>如果return非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</p></li><li><p>如果<strong>then里抛出异常</strong>，<code>then</code>方法的第二个参数onRejected是监测不到当前<code>then</code>方法回调异常的，promise规范规定调用失败态方法(reject)<strong>流转到下一个<code>then</code>的onRejected</strong></p></li><li><p>如果return另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 1. 如果只是执行语句，没有返回，新promise变为resolved，且传参undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line"><span class="comment">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line"><span class="comment">// 3. 抛出错误 ,变为 rejected，流转到下一个then的onRejected</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line"><span class="comment">// 4. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 流转到下一个then的onRejected</span></span><br><span class="line">  <span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">   <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(即所谓的值穿透)</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="number">2</span>)</span><br><span class="line">.<span class="title function_">then</span>()</span><br><span class="line">.<span class="title function_">then</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-原型方法catch">3-原型方法catch<a class="anchor" href="#3-原型方法catch">·</a></h3><p>then()的语法糖, 相当于: then(undefined, onRejected)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">catch</span>(onRejected);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1、返回值：返回一个新的promise实例，因此后面还可以接着调用then-方法">1、返回值：返回一个新的promise实例，因此后面还可以接着调用<code>then()</code>方法<a class="anchor" href="#1、返回值：返回一个新的promise实例，因此后面还可以接着调用then-方法">·</a></h4><ol><li><p>如果 <code>onRejected</code>回调抛出一个错误或返回一个本身失败的 Promise ，返回rejected的promise</p></li><li><p>否则返回成功的promise</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  <span class="comment">// 这里只是return了错误信息，并没有抛出错误或者返回一个失败promise</span></span><br><span class="line">  <span class="comment">// 所以第一个`catch`执行返回的promise对象是resolved</span></span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、catch可以捕获什么？">2、catch可以捕获什么？<a class="anchor" href="#2、catch可以捕获什么？">·</a></h4><ol><li><h5 id="Promise-内部的错误">Promise 内部的错误<a class="anchor" href="#Promise-内部的错误">·</a></h5><p>如果没有用<code>catch()</code>方法指定错误处理的回调函数，<strong>Promise 对象抛出的错误不会传递到外层代码</strong>，即不会有任何反应</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);<span class="comment">//内部有语法错误。浏览器运行到这一行，会抛错，但不会退出进程、终止脚本执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="title function_">someAsyncThing</span>();  <span class="comment">//m是rejected的，promise中的不会执行下去</span></span><br><span class="line">m.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//不执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;everything is great&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">alert</span>(<span class="number">11</span>,err))<span class="comment">//不执行</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">alert</span>(<span class="number">22</span>, err)) <span class="comment">//不执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>) &#125;, <span class="number">2000</span>); <span class="comment">// 仍然执行</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>但如果将then替换为catch：m.then —m.catch，promise就能继续执行下去</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">everything is great</span><br><span class="line"><span class="number">11</span> <span class="number">22</span></span><br></pre></td></tr></table></figure></li><li><h5 id="then-方法中抛出错误"><code>then()</code>方法中抛出错误<a class="anchor" href="#then-方法中抛出错误">·</a></h5><p>在<code>then()</code>方法里面定义 Reject 状态的回调函数，捕获不到then里面的错误</p><p>但会被<strong>后面的<code>catch()</code>方法捕获。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li><li><h5 id="promise异常穿透">promise异常穿透<a class="anchor" href="#promise异常穿透">·</a></h5><p>前面任何操作出了异常, 都会传到最后失败的回调中处理；所以</p><ul><li>可以在每个then()的第二个回调函数中进行err处理</li><li>也可以利用异常穿透特性，到最后用<code>catch</code>去承接统一处理</li><li>两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</li></ul></li><li><p>【注意】：catch无法捕获在它后面出现的错误，案例1：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><ul><li>案例2：resolve之后，在下一轮事件循环中抛错。那时候，**Promise 的运行已经结束了，**所以这个错误是在 Promise 函数体外抛出的，<strong>会冒泡到最外层，成了未捕获的错误</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-原型方法finally">4-原型方法finally<a class="anchor" href="#4-原型方法finally">·</a></h3><ul><li><p>在promise结束时，不管成功还是失败都将执行其<code>onFinally</code>回调</p></li><li><p>不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，与状态无关的，不依赖于 Promise 的执行结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">finally</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 返回状态为(resolved 或 rejected)</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-静态方法Promise-resolve">1-静态方法Promise.resolve :<a class="anchor" href="#1-静态方法Promise-resolve">·</a></h3><ul><li>接收一个值，将现有对象转为Promise 对象</li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure></blockquote><h4 id="1、传参情况4种">1、传参情况4种<a class="anchor" href="#1、传参情况4种">·</a></h4><ol><li><p><strong>参数是一个 Promise 实例</strong>：<code>Promise.resolve</code>将原封不动地返回这个实例</p></li><li><p><strong>参数是一个原始值，或一个不具有<code>then()</code>方法的对象</strong>：返回一个新的<code>resolved</code>的 Promise 对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li><li><p><strong>参数是空</strong>：直接返回一个<code>resolved</code>状态的 Promise 对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>参数是一个<code>thenable</code>对象：</strong><code>Promise.resolve()</code>将这个对象转为 Promise 对象，然后立即执行<code>thenable</code>对象的<code>then()</code>方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、执行顺序">2、执行顺序<a class="anchor" href="#2、执行顺序">·</a></h4><p>立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”结束时执行，而不是在下一轮“事件循环”开始时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.在下一轮“事件循环”开始时执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//2. Promise.resolve()在本轮“事件循环”结束时执行</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);  <span class="comment">//1. 立即执行</span></span><br><span class="line"><span class="comment">// one two  three</span></span><br></pre></td></tr></table></figure><h3 id="2-静态方法Promise-reject">2-静态方法Promise.reject :<a class="anchor" href="#2-静态方法Promise-reject">·</a></h3><ul><li><p>返回一个失败的 promise 对象,直接改变promise状态</p></li><li><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数</p></li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;&#125;)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3-静态方法Promise-all">3-静态方法Promise.all :<a class="anchor" href="#3-静态方法Promise-all">·</a></h3><ul><li>iterable类型：代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型</li><li>应用场景：有一个接口，需要其他两个或多个接口返回的数据作为参数时</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.all(iterable)</span><br></pre></td></tr></table></figure><h3 id="4-静态方法Promise-race">4-静态方法Promise.race :<a class="anchor" href="#4-静态方法Promise-race">·</a></h3><ul><li>迭代对象中状态全部改变才会执行</li><li>只要迭代对象中有一个状态改变了，它的状态就跟着改变，并将那个改变状态实例的返回值传递给回调函数</li><li>p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(iterable)</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、Generaor">3、Generaor<a class="anchor" href="#3、Generaor">·</a></h2><h3 id="1、协程">1、协程<a class="anchor" href="#1、协程">·</a></h3><ul><li><p>协程：多个线程互相协作，完成异步任务。它的运行流程大致如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步，协程A开始执行。</span><br><span class="line"></span><br><span class="line">第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</span><br><span class="line"></span><br><span class="line">第三步，（一段时间后）协程B交还执行权。</span><br><span class="line"></span><br><span class="line">第四步，协程A恢复执行。</span><br></pre></td></tr></table></figure><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行</p></li></ul><h4 id="举例文件读取：">举例文件读取：<a class="anchor" href="#举例文件读取：">·</a></h4><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asnycJob</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// ...其他代码</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line"><span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线</li><li>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</li></ul><h3 id="2、Generator-函数">2、Generator 函数<a class="anchor" href="#2、Generator-函数">·</a></h3><p>Generator 函数是<strong>协程在 ES6 的实现</strong>，是一种异步解决方案。最大特点就是可以交出函数的执行权（即暂停执行）</p><ul><li>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态</li><li>Generator 函数除了状态机，还是一个遍历器对象生成函数<ul><li>可暂停函数, yield可暂停。next方法可启动</li><li>yield表达式本身没有返回值，或者说总是返回undefined</li><li>next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</li></ul></li></ul><h4 id="运行方式举例">运行方式举例<a class="anchor" href="#运行方式举例">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>代码分析：</p><ul><li><p>首先 Generator 函数调用和普通函数不同，它会返回一个迭代器</p></li><li><p>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6</p></li><li><p>当执行第二次 next 时，传入的参数12就会被当作上一个yield表达式的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8</p></li><li><p>当执行第三次 next 时，传入的参数13就会被当作上一个yield表达式的返回值，所以 z = 13, x = 5, y = 24，相加等于 42</p></li></ul><h4 id="文件读取举例">文件读取举例<a class="anchor" href="#文件读取举例">·</a></h4><ul><li>有三个本地文件，分别1.txt,2.txt和3.txt，内容都只有一句话，<strong>下一个请求依赖上一个请求的结果</strong>，想通过Generator函数依次调用三个文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(file, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err)</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">r</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> <span class="title function_">read</span>(<span class="string">&#x27;./1.txt&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> <span class="title function_">read</span>(r1)</span><br><span class="line">  <span class="keyword">let</span> r3 = <span class="keyword">yield</span> <span class="title function_">read</span>(r2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">r</span>()</span><br><span class="line"><span class="keyword">let</span> &#123; value, done &#125; = it.<span class="title function_">next</span>()</span><br><span class="line">value.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123; <span class="comment">// value是个promise</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">//data=&gt;2.txt</span></span><br><span class="line">  <span class="keyword">let</span> &#123; value, done &#125; = it.<span class="title function_">next</span>(data)</span><br><span class="line">  value.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">//data=&gt;3.txt</span></span><br><span class="line">    <span class="keyword">let</span> &#123; value, done &#125; = it.<span class="title function_">next</span>(data)</span><br><span class="line">    value.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">//data=&gt;结束</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.txt=&gt;3.txt=&gt;结束</span></span><br></pre></td></tr></table></figure><ul><li>手动迭代<code>Generator</code> 函数很麻烦，实现逻辑有点绕，而实际开发一般会配合 <code>co</code> 库去使用</li><li><strong><code>co</code>是一个为Node.js和浏览器打造的基于生成器的流程控制工具，借助于Promise，你可以使用更加优雅的方式编写非阻塞代码</strong></li></ul><h4 id="安装co库后：">安装co库后：<a class="anchor" href="#安装co库后：">·</a></h4><ul><li>npm install co，代码更简单</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">r</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> <span class="title function_">read</span>(<span class="string">&#x27;./1.txt&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> <span class="title function_">read</span>(r1)</span><br><span class="line">  <span class="keyword">let</span> r3 = <span class="keyword">yield</span> <span class="title function_">read</span>(r2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>)</span><br><span class="line"><span class="title function_">co</span>(<span class="title function_">r</span>()).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.txt=&gt;3.txt=&gt;结束=&gt;undefined</span></span><br></pre></td></tr></table></figure><h4 id="回调地狱问题">回调地狱问题<a class="anchor" href="#回调地狱问题">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">fetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">ajax</span>(url, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">ajax</span>(url1, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">ajax</span>(url2, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">fetch</span>()</span><br><span class="line"><span class="keyword">let</span> result1 = it.<span class="title function_">next</span>()</span><br><span class="line"><span class="keyword">let</span> result2 = it.<span class="title function_">next</span>()</span><br><span class="line"><span class="keyword">let</span> result3 = it.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><h3 id="3、优缺点">3、优缺点<a class="anchor" href="#3、优缺点">·</a></h3><h4 id="优点-5">优点<a class="anchor" href="#优点-5">·</a></h4><ul><li>优雅的流程控制方式，可以让函数可中断执行，在某些特殊需求里还是很实用的</li></ul><h4 id="缺点-6">缺点<a class="anchor" href="#缺点-6">·</a></h4><ul><li>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，但co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，只针对<strong>异步处理来说，还是不太方便</strong></li></ul><h2 id="4、async、await">4、async、await<a class="anchor" href="#4、async、await">·</a></h2><p>JS异步操作的最终且最优雅的解决方案</p><h3 id="0、async-await带来了什么">0、async/await带来了什么<a class="anchor" href="#0、async-await带来了什么">·</a></h3><p>使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：</p><h4 id="1、优点">1、优点<a class="anchor" href="#1、优点">·</a></h4><ol><li><p>内置执行器</p><p>Generator 函数的执行必须靠执行器，所以才有了 co 函数库；</p><p>而 <code>async</code> 函数自带执行器，也就是说，<code>async</code> 函数的执行，与普通函数一模一样，只要一行</p></li><li><p>更好的语义、结构清晰</p><p><code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚了，几乎跟同步写法一样，十分优雅</p><p><code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果</p></li><li><p>更广的适用性</p><p>co 函数库约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象</p><p>而 <code>async</code> 函数的 <code>await</code> 命令后面，可以跟 Promise 对象和原始类型的值(数值、字符串和布尔值，但这时等同于同步操作)</p></li><li><p>更好的错误处理</p><p>链式调用了很多promises，一级接一级。紧接着，promises链中某处出错。此链条的错误堆栈信息并没用线索指示错误到底出现在哪里</p></li></ol><h4 id="2、缺点">2、缺点<a class="anchor" href="#2、缺点">·</a></h4><ul><li><p>滥用 <code>await</code> 可能会导致性能问题</p><p>因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p></li></ul><h3 id="1、async返回值">1、async返回值<a class="anchor" href="#1、async返回值">·</a></h3><p>一个函数如果加上 <strong>async</strong> ，那么该函数就会<strong>返回一个 Promise</strong>：return的情况分析</p><ul><li><h5 id="返回值为promise，状态和值取决于这个promise">返回值为promise，状态和值取决于这个promise<a class="anchor" href="#返回值为promise，状态和值取决于这个promise">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// resolve(99);</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="number">66</span>); </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 新的promise状态成功,值为99</span></span><br><span class="line"><span class="comment">// 2 新的promise状态失败,值为66</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值">函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值<a class="anchor" href="#函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>()) <span class="comment">// 成功promsie,值为1</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数返回值为undefined-状态成功-值为undefined">函数返回值为undefined.状态成功,值为undefined<a class="anchor" href="#函数返回值为undefined-状态成功-值为undefined">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>());<span class="comment">//  成功promise,值为undefined</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数体内抛出异常">函数体内抛出异常<a class="anchor" href="#函数体内抛出异常">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>()); <span class="comment">// 失败promise,值为&quot;异常&quot;;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2、await">2、await<a class="anchor" href="#2、await">·</a></h3><h4 id="1、await在等什么？">1、await在等什么？<a class="anchor" href="#1、await在等什么？">·</a></h4><p><code>await</code> <strong>在等待一个异步完成</strong>，等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值</p><ul><li><p><code>await</code> 后面不是Promise对象，直接返回对应的值，效果等同于直接return</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;   <span class="comment">// 等同于  return 123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>await</code> 后面是Promise对象，会造成异步函数暂停执行先返回，并且等待 promise 的解决，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。所以<strong>会阻塞后面的代码</strong></p></li><li><p><code>await</code>一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），<code>await</code>会将其等同于 Promise 对象</p></li></ul><h4 id="2、为什么await-只能在-async-函数中使用">2、为什么<code>await</code> 只能在 <code>async</code> 函数中使用<a class="anchor" href="#2、为什么await-只能在-async-函数中使用">·</a></h4><ul><li><code>await</code> 会阻塞后面代码，如果允许我们直接使用 <code>await</code> 的话，假如我们使用<code>await</code>等待一个消耗时间比较长的异步请求，那代码直接就阻塞不往下执行了，只能等待 <code>await</code> 拿到结果才会执行下面的代码，那不乱套了</li><li>而 <code>async</code> 函数调用不会造成阻塞，因为它内部所有的阻塞都被封装在一个 Promise 对象中异步执行，所以才规定 <code>await</code> 必须在 <code>async</code> 函数中</li></ul><h4 id="3、await后面代码是微任务microtask">3、await后面代码是微任务microtask<a class="anchor" href="#3、await后面代码是微任务microtask">·</a></h4><p>实际上<strong>await是一个让出线程的标志</strong>，因为async await 本身就是promise+generator的语法糖。所以await后面的代码是微任务microtask</p><ul><li>await后面的表达式会先执行一遍</li><li>将await后面的代码加入到微任务microtask中</li><li>然后就会跳出整个async函数来执行后面的代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="comment">// 3.1 不会执行，添加到微任务</span></span><br><span class="line">  <span class="comment">// 5 真正执行是在微任务中执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="4、读取文件的例子重写">4、读取文件的例子重写<a class="anchor" href="#4、读取文件的例子重写">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(file, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err)</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readResult</span>(<span class="params">params</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="keyword">await</span> <span class="title function_">read</span>(params, <span class="string">&#x27;utf8&#x27;</span>)<span class="comment">//await后面跟的是一个Promise实例</span></span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="keyword">await</span> <span class="title function_">read</span>(p1, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="keyword">await</span> <span class="title function_">read</span>(p2, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1&#x27;</span>, p1)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2&#x27;</span>, p2)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3&#x27;</span>, p3)</span><br><span class="line">    <span class="keyword">return</span> p3</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">readResult</span>(<span class="string">&#x27;1.txt&#x27;</span>).<span class="title function_">then</span>( <span class="comment">// async函数返回的也是个promise</span></span><br><span class="line">  <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// p1 2.txt</span></span><br><span class="line"><span class="comment">// p2 3.txt</span></span><br><span class="line"><span class="comment">// p3 结束</span></span><br><span class="line"><span class="comment">// 结束</span></span><br></pre></td></tr></table></figure><h3 id="3、处理异常">3、处理异常<a class="anchor" href="#3、处理异常">·</a></h3><h4 id="错误导致中断">错误导致中断<a class="anchor" href="#错误导致中断">·</a></h4><p>任何一个<code>await</code>后面的 <strong>Promise 对象变为<code>reject</code>状态</strong>，那么<strong>整个<code>async</code>函数都会中断执行</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="catch">catch<a class="anchor" href="#catch">·</a></h4><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>的回调接收</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);  <span class="comment">//这里如果在await前面加上return，效果是一样的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>,e))</span><br><span class="line"><span class="comment">// error 出错了</span></span><br></pre></td></tr></table></figure><h4 id="try…catch">try…catch<a class="anchor" href="#try…catch">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">ajax</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结：">总结：<a class="anchor" href="#总结：">·</a></h4><p>假如希望即使前一个异步操作失败，也不要中断后面的异步操作：</p><ul><li>方法1：第一个<code>await</code>放在<code>try...catch</code>结构里面。这样不管这个异步操作是否成功，第二个<code>await</code>都会执行</li><li>方法2：<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法处理前面可能出现的错误</li></ul><h3 id="4、async-await继、并发、promise-all">4、async/await继、并发、promise.all<a class="anchor" href="#4、async-await继、并发、promise-all">·</a></h3><h4 id="1、继发及其应用场景">1、继发及其应用场景<a class="anchor" href="#1、继发及其应用场景">·</a></h4><p>await本身是继发的</p><ul><li>当函数执行的时候，一旦遇到<code>await</code>就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>，比较耗时</li><li>所以如果<strong>多个异步代码没有依赖性</strong>却使<strong>用了 await 会导致性能上的降低</strong></li><li>因此，<strong>代码没有依赖性的话，完全可以并发的方式</strong></li></ul><p><strong>经常会遇到这种业务，多个请求，每个请求依赖于上一个请求的结果。</strong></p><ul><li>用setTimeout模拟异步操作，用Promise和Async/Await分别来实现下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">analogAsync</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(n + <span class="number">500</span>), n);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">analogAsync</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">analogAsync</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">analogAsync</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Promise">使用Promise:<a class="anchor" href="#使用Promise">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> time1 = <span class="number">0</span></span><br><span class="line">  <span class="title function_">fn1</span>(time1)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">time2</span>) =&gt;</span> <span class="title function_">fn2</span>(time2))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">time3</span>) =&gt;</span> <span class="title function_">fn3</span>(time3))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><h5 id="使用async-await">使用async/await<a class="anchor" href="#使用async-await">·</a></h5><ul><li>输出效果一样，但代码结构看起来清晰得多，几乎跟同步写法一样，十分优雅</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> time1 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> time2 = <span class="keyword">await</span> <span class="title function_">fn1</span>(time1)</span><br><span class="line">  <span class="keyword">let</span> time3 = <span class="keyword">await</span> <span class="title function_">fn2</span>(time2)</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">fn3</span>(time3)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><h4 id="2、手动实现一个继发：">2、手动实现一个继发：<a class="anchor" href="#2、手动实现一个继发：">·</a></h4><p>只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> <span class="title function_">getBar</span>();</span><br></pre></td></tr></table></figure><ul><li><h4 id="for循环实现">for循环实现<a class="anchor" href="#for循环实现">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="reduce实现">reduce实现<a class="anchor" href="#reduce实现">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> docs.<span class="title function_">reduce</span>(<span class="keyword">async</span> (_, doc) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> _;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;, <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、并发实现">3、并发实现<a class="anchor" href="#3、并发实现">·</a></h4><p><code>getFoo</code>和<code>getBar</code>都是同时触发，且没有依赖项，这样就会缩短程序的执行时间</p><ul><li><h4 id="Promise-all"><code>Promise.all</code><a class="anchor" href="#Promise-all">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function"><span class="params">doc</span> =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="赋值操作">赋值操作<a class="anchor" href="#赋值操作">·</a></h4><ul><li><p>getFoo函数本身是非阻塞的，赋值后<strong>不会停在这里等待它的执行结果</strong></p></li><li><p>而await getFoo()在promise有结果之前不会执行赋值操作，async内部代码在promise返回结果之前会阻塞住</p><p>但整个主线程不会阻塞而是会执行async函数后面的同步代码，等promise有了结果且外面的同步代码执行完了就又会回到async函数原来阻塞的地方继续执行</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> p1;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> p2;</span><br></pre></td></tr></table></figure></li><li><h4 id="forEach">forEach<a class="anchor" href="#forEach">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123; <span class="comment">//这里不需要 async</span></span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">forEach</span>(<span class="keyword">async</span> doc =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Map">Map<a class="anchor" href="#Map">·</a></h4><p>虽然map方法的参数是async函数，但它是并发执行，因为只有async函数内部是继发执行，外部不受影响</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>( <span class="keyword">async</span> doc =&gt; db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3、手写promise">2.3、手写promise<a class="anchor" href="#2-3、手写promise">·</a></h2><h4 id="1、Promise的异步实现">1、Promise的异步实现<a class="anchor" href="#1、Promise的异步实现">·</a></h4><h4 id="2、promsie的链式调用">2、promsie的链式调用<a class="anchor" href="#2、promsie的链式调用">·</a></h4><ol><li><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong><ol><li>在<code>then</code>方法中先实例化了一个Promise对象并返回，我们把原来写的代码放到该实例的处理器函数中</li><li>在每个执行函数处使用<code>try..catch</code>语法，try中<code>resolve</code>执行结果，catch中<code>reject</code>异常</li><li>pending状态判断，逻辑也和resolved相似，但是由于此处为了处理异步，做了push操作，所以我们push时在onFulfilled和onRejected回调外面再套一个回调做操作即可</li></ol></li><li><strong>如果<code>then</code>方法中返回的是一个普通值(如Number、String等)就使用此值包装成一个新的Promise对象返回</strong></li><li>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用Undefined包装的Promise对象</li><li>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的onRejected</li><li><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(值穿透)</strong></li><li>如果<code>then</code>方法中返回了一个Promise对象，那就以这个对象为准，返回它的结果</li></ol><h4 id="3、根据上一个then方法的返回值来生成新Promise对象">3、根据上一个<code>then</code>方法的返回值来生成新Promise对象<a class="anchor" href="#3、根据上一个then方法的返回值来生成新Promise对象">·</a></h4><h3 id="1、基本构成">1、基本构成<a class="anchor" href="#1、基本构成">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="comment">// 托管构造函数的this指向</span></span><br><span class="line">  <span class="keyword">let</span> _this = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 状态描述 pending resolved rejected</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;pending&quot;</span></span><br><span class="line">  <span class="comment">// 成功结果</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 失败原因</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">//保存成功回调</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span> = []</span><br><span class="line">  <span class="comment">//保存失败回调</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让其处理器函数立即执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前态是否为pending，只有pending时可更该状态</span></span><br><span class="line">    <span class="keyword">if</span> (_this.<span class="property">state</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 更改为成功态</span></span><br><span class="line">      _this.<span class="property">state</span> = <span class="string">&quot;resolved&quot;</span></span><br><span class="line">      <span class="comment">// 保存成功结果</span></span><br><span class="line">      _this.<span class="property">value</span> = value</span><br><span class="line">      <span class="comment">// 遍历执行成功回调</span></span><br><span class="line">      _this.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前态是否为pending，只有pending时可更该状态</span></span><br><span class="line">    <span class="keyword">if</span> (_this.<span class="property">state</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 更改为失败态</span></span><br><span class="line">      _this.<span class="property">state</span> = <span class="string">&quot;rejected&quot;</span></span><br><span class="line">      <span class="comment">// 保存失败原因</span></span><br><span class="line">      _this.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="comment">// 遍历执行失败回调</span></span><br><span class="line">      _this.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(reason))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、then方法">2、then方法<a class="anchor" href="#2、then方法">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// then原型方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断参数不为函数时变成普通函数，成功-直接返回接收值 失败-抛出错误</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的Promise实例</span></span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 等待态判断，此时异步代码还未走完，回调入数组队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 将成功回调push入成功队列</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">            <span class="comment">// 处理返回值</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将失败回调push入失败队列</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">            <span class="comment">// 处理返回值</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">      <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">          <span class="comment">// 处理返回值</span></span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">      <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">          <span class="comment">// 处理返回值</span></span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、解析then返回值与新Promise对象">3、解析then返回值与新Promise对象<a class="anchor" href="#3、解析then返回值与新Promise对象">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析then返回值与新Promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; 新的Promise对象，就是我们创建的promise2实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; x 上一个then的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; resolve promise2处理器函数的resolve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; reject promise2处理器函数的reject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// 解决循环引用报错</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="comment">// reject报错</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;请避免Promise循环引用&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义状态-防止多次调用</span></span><br><span class="line">  <span class="keyword">let</span> called</span><br><span class="line">  <span class="comment">// x不是null 且x是对象或函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 拿到x的then方法</span></span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span></span><br><span class="line">      <span class="comment">// 如果then是函数，就默认是promise</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行then 使用call传递this 第一个参数是this 后面是成功的回调 和 失败的回调</span></span><br><span class="line">        then.<span class="title function_">call</span>(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 防止用户在resolve的时候传入Promise，递归调用</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="title function_">reject</span>(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、catch、resolve、reject方法">4、catch、resolve、reject方法<a class="anchor" href="#4、catch、resolve、reject方法">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// catch原型方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span>(<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接执行then方法，onFulfilled为null，传入onRejected</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接抛出一个成功状态的Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接抛出一个拒绝状态的Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、all方法">5、all方法<a class="anchor" href="#5、all方法">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">// 只有一个目的 获取到所有的promise，都执行then，把结果放到数组，一起返回</span></span><br><span class="line">  <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> results = []</span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> promisesLength = promises.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt; promises.<span class="property">length</span>;i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promises[i]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          results[i] = res;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="comment">// 当所有函数都正确执行了，resolve输出所有返回结果</span></span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promisesLength)  <span class="title function_">resolve</span>(results);</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)&#125;)</span><br><span class="line"> );</span><br><span class="line"><span class="keyword">var</span> p2 =<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p3 =<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2,p3]);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(e)&#125;);</span><br></pre></td></tr></table></figure><h3 id="6、race方法">6、race方法<a class="anchor" href="#6、race方法">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// race方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">// return一个Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历执行promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// then只要接收到状态改变，直接抛出</span></span><br><span class="line">      promises[i].<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4、手写Promise-all、allsettled">2.4、手写Promise.all、allsettled<a class="anchor" href="#2-4、手写Promise-all、allsettled">·</a></h2><h3 id="1、使用all：">1、使用all：<a class="anchor" href="#1、使用all：">·</a></h3><ul><li><p>iterable类型：代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型</p></li><li><p>应用场景：有一个接口，需要其他两个或多个接口返回的数据作为参数时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.all(iterable)</span><br></pre></td></tr></table></figure></li><li><p>当需要处理多个Promise并行时，大多数情况下Promise.all用起来是非常顺手的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = n =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： [1, 2]</span></span><br></pre></td></tr></table></figure></li><li><p>可是，是一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。</p><p>问题1：任意一个 promise 被 reject ，Promise.all 就会立即被 reject ，其他执行成功的Promise的消息都丢失了</p><p>问题2：大多数场景中，我们期望传入的这组 promise 无论执行失败或成功，都能获取每个 promise 的执行结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = n =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： Uncaught (in promise) 3</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))  <span class="comment">// 加入catch语句后，最终输出：3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2、手写Promise-all">2、手写Promise.all<a class="anchor" href="#2、手写Promise-all">·</a></h3><ul><li><p>将多个Promise 实例<strong>包装成一个新的 Promise实例</strong>，参数为一组 <strong>Promise 实例组成的数组</strong></p></li><li><p>只有所有的 promise <code>都成功才成功</code>, 只要有一 个失败了就直接失败</p></li><li><p>promsie.all的痛点：一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all方法: 只有一个目的 获取到所有的promise，都执行then，把结果放到数组，一起返回</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">PromiseAll</span> = promises =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.<span class="property">length</span>) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]);</span><br><span class="line"><span class="keyword">const</span> newPromises = promises.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? item :  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> results = []; <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.<span class="property">length</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line">newPromises[i].<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        results[i] = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="comment">// 当所有函数都正确执行了，resolve输出所有返回结果</span></span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promiseLen)  <span class="title function_">resolve</span>(results);</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           results[i] = &#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="title function_">reject</span>(results);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = n =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">PromiseAll</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err+<span class="string">&#x27; 捕获的错误&#x27;</span>))<span class="comment">//不然会报错走不下去</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3、使用allsettled">3、使用allsettled<a class="anchor" href="#3、使用allsettled">·</a></h3><ul><li><p>返回的新 Promise 实例，一旦结束，状态总是 fulfilled，不会变成 rejected</p></li><li><p>使用场景：</p><p>不关心异步操作的结果，只关心这些操作有没有结束时，这个方法会比较有用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>)   <span class="comment">//拒绝</span></span><br><span class="line">  ]</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： </span></span><br><span class="line"><span class="comment">//    [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 2&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, value: 3&#125;,</span></span><br><span class="line"><span class="comment">//    ]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4、手写allsettled">4、手写allsettled<a class="anchor" href="#4、手写allsettled">·</a></h3><ul><li><p>即使是遇到rejec也会等待所有的promise到最后。所以我们只需要用一个array记录各个promise的fulfill或者reject结果即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PromiseAllSettled</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.<span class="property">length</span>) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]);</span><br><span class="line"><span class="keyword">const</span> newPromises = promises.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? item :  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> results = []; <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.<span class="property">length</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line">newPromises[i].<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        results[i] = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promiseLen)  <span class="title function_">resolve</span>(results);</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           results[i] = &#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     &#125;</span><br><span class="line">           promiseCount++;</span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promiseLen)  <span class="title function_">resolve</span>(results);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、race实现">5、race实现<a class="anchor" href="#5、race实现">·</a></h3><ul><li><p>最早改变状态）resolve或reject时，就改变自身的状态，并执行响应的回调。</p></li><li><p>跟all同样对于错误的不能处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PromiseRace</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.<span class="property">length</span>) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]);</span><br><span class="line"><span class="keyword">const</span> newPromises = promises.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? item :  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.<span class="property">length</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123;</span><br><span class="line">newPromises[i].<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(&#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5、实现promisify化">5、实现promisify化<a class="anchor" href="#5、实现promisify化">·</a></h2><h3 id="1、概念-6">1、概念<a class="anchor" href="#1、概念-6">·</a></h3><ul><li><p><code>promisify</code>是node的utils模块中的一个函数</p></li><li><p>作用：<strong>将一种函数</strong>（最后一个参数是回调函数的函数，且回调函数中有两个参数：<code>error</code> 和 <code>data</code>）<strong>转换为promise函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用前</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用promisify后</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="title function_">promisify</span>(fs.<span class="property">readFile</span>)</span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;)</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、实现-4">2、实现<a class="anchor" href="#2、实现-4">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newFn = <span class="title function_">promisify</span>(fn)</span><br><span class="line"><span class="title function_">newFn</span>(a) <span class="comment">// 会执行Promise参数方法</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">promisify</span> = (<span class="params">func</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 除了调用时的传参，还需要提供一个callback函数来供异步方法调用</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">reject</span>(err);</span><br><span class="line">           <span class="keyword">return</span> <span class="title function_">resolve</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      args.<span class="title function_">push</span>(<span class="title function_">callback</span>());</span><br><span class="line">      func.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Promsie、Async、await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的继承</title>
      <link href="/posts/prototype.html"/>
      <url>/posts/prototype.html</url>
      
        <content type="html"><![CDATA[<h2 id="ES5继承">ES5继承<a class="anchor" href="#ES5继承">·</a></h2><h3 id="1、原型链-极其重要">1、原型链             极其重要<a class="anchor" href="#1、原型链-极其重要">·</a></h3><h4 id="1、-什么是原型链-2">1、 什么是原型链<a class="anchor" href="#1、-什么是原型链-2">·</a></h4><ul><li><strong>构造函数、实例、原型对象的关系</strong><ul><li>构造函数的 prototype 指向原型对象，原型对象有一个 constructor 属性指回构造函数，每个构造函数生成的实例对象都有一个 <em>proto</em> 属性，这个属性指向原型对象</li><li>最后，既然每个对象都有一个<code>_proto_</code>属性指向原型对象，那么原型对象也有_proto_指向原型对象的原型对象，它指向Object 构造函数对应的原型对象，直到<code>null</code>，到达原型链顶端</li></ul></li></ul><h4 id="2、Object、Function的关系">2、Object、Function的关系<a class="anchor" href="#2、Object、Function的关系">·</a></h4><img src="file:///C:\Users\小虎牙\Documents\Tencent Files\2575329556\Image\Group\5LOKV2$Q28$JYOMV51%$GAA.jpg" alt="img" style="zoom: 25%;" /><ul><li><code>function</code> ：所有的函数（包括构造函数）是<code>Function</code>的实例，所以所有函数的<code>_proto_</code>都指向<code>Function</code>的原型对象</li><li>所有的原型对象（包括 <code>Function</code>的原型对象）都是Object的实例，所以<code>_proto_</code>都指向 <code>Object</code>（构造函数）的原型对象。而<code>Object</code>构造函数的 <code>_proto_</code>指向 null</li><li><code>Function</code>构造函数本身就是<code>Function</code>的实例，所以<code>_proto_</code>指向<code>Function</code>的原型对象</li></ul><h4 id="3、-原型链应用-2">3、 原型链应用<a class="anchor" href="#3、-原型链应用-2">·</a></h4><ul><li><p><strong>搜索机制</strong></p><p>实例属性 — 实例的原型 — 在原型链继承后，搜索可继续向上 原型的原型  – 直到原型链的末端</p></li><li><p><strong>确定原型与继承的关系</strong></p><ul><li>法1：instanceOf</li><li>法2：isPrototypeOf：只要原型链上包含该原型就是true</li></ul></li></ul><h3 id="2、继承方式：7种-√">2、继承方式：7种  √<a class="anchor" href="#2、继承方式：7种-√">·</a></h3><h4 id="1-原型链继承">1. 原型链继承<a class="anchor" href="#1-原型链继承">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>  <span class="comment">// Child的constructor属性丢失问题</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br></pre></td></tr></table></figure><ul><li><p>**优点：**简单</p></li><li><p><strong>缺点：</strong></p><ol><li><p>共享问题，如果一个属性是引用类型，那么该属性被所有实例共享，基本类型的不会</p><p>child1改变了child1.name, child2.name不会被改变</p><p>child改变了child.obj, child2.obj会改变。因为保存了同一份地址</p></li><li><p>子原型被重写</p></li><li><p>不能向父类传参</p></li></ol></li><li><p>**注意：**子实例child1的__proto__ 和 子原型Son.prototye的constructor指向了Father，而不是子构造函数本身</p></li></ul><h4 id="2-借用构造函数（经典继承）">2. 借用构造函数（经典继承）<a class="anchor" href="#2-借用构造函数（经典继承）">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">names</span> = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心实现继承的手段</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> (name) &#123;</span><br><span class="line">  <span class="comment">//此处利用call(),将 [Child]的this传递给Parent构造函数</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>);   <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">name</span>);   <span class="comment">// daisy</span></span><br><span class="line"></span><br><span class="line">child1.<span class="property">names</span>.<span class="title function_">push</span>(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">names</span>); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">names</span>); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;]</span></span><br></pre></td></tr></table></figure><ul><li>优点：<ol><li>避免引用类型共享，实例都是独立的，不会互相影响</li><li>子可以向父类传参</li></ol></li><li>缺点：<ol><li>不能重用函数：方法是在构造函数内部定义的，每创建一个实例都会创建一遍方法</li><li><strong>子类无法访问父类原型上的方法</strong>，只能访问构造函数上的方法</li></ol></li></ul><h4 id="3-组合继承（1-2）">3. 组合继承（1+2）<a class="anchor" href="#3-组合继承（1-2）">·</a></h4><p>属性放在构造函数里，方法放在原型链上</p><ul><li><p>优点：1+2的优点</p></li><li><p>缺点：调用了两次父类构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)     <span class="comment">//1. 盗用构造函数继承实例属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()  <span class="comment">//2. 原型链继承原型上的属性+方法</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> (name, age) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"></span><br><span class="line">child1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>); <span class="comment">// kevin</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">age</span>); <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">colors</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">name</span>); <span class="comment">// daisy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">age</span>); <span class="comment">// 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">colors</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-原型式继承：（1的变种）">4. 原型式继承：（1的变种）<a class="anchor" href="#4-原型式继承：（1的变种）">·</a></h4><p>实际就是Object.create()，只是Object.create()将原型式继承进一步规范化了，在只传一个参数时，二者等价</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(o);</span><br><span class="line">p.<span class="property">__proto__</span> === o; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li><p>优点：简单，不需要再单独创建构造函数</p></li><li><p>缺点：与1一样，属性值如果有引用类型，会互相影响</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kevin&#x27;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;kelly&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createObj</span>(person);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createObj</span>(person);</span><br><span class="line"></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;person1&#x27;</span>;   <span class="comment">//person1 添加实例属性name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// kevin是原型上的name</span></span><br><span class="line"><span class="comment">//不是因为person1和person2有独立的name值。</span></span><br><span class="line"><span class="comment">//而是person1.name = &#x27;person1&#x27;给person1添加了name值，而没有修改原型上的name值</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;taylor&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">friends</span>); <span class="comment">// [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-寄生式继承（2的变种）">5. 寄生式继承（2的变种）<a class="anchor" href="#5-寄生式继承（2的变种）">·</a></h4><p>​创建一个实现继承的函数，再以某种方式增强对象（添加新方法），再返回这个对象</p><ul><li><p>优点：同样适用于关注对象，而不在乎类型和构造函数的场景</p></li><li><p>缺点：2的缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">o</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(o)  <span class="comment">//创建新对象，不是必须这个，任何可以返回新对象的函数都可在这用</span></span><br><span class="line">  clone.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;  <span class="comment">// 增强</span></span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-寄生式组合继承（3-4）引用类型继承的最佳模式！！">6. 寄生式组合继承（3+4）引用类型继承的最佳模式！！<a class="anchor" href="#6-寄生式组合继承（3-4）引用类型继承的最佳模式！！">·</a></h4><p>思路：由构造函数继承属性，混合原型链继承方法</p><ul><li><p>混合原型链继承：不再像之前用父类的实例给子类prototype赋值，而是用<strong>父类prototype</strong>的副本</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">action</span> = [<span class="string">&#x27;speak&#x27;</span>, <span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;eat&#x27;</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我被调用了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> , <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old!`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age, score</span>) &#123;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);  <span class="comment">// 借用构造函数, 第一次调用父类构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承返回的新对象赋值给子类prototype，使子类原型继承父类prototype</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>  = <span class="title class_">Son</span>;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showScore</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my score is <span class="subst">$&#123;<span class="variable language_">this</span>.score&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;78&#x27;</span>);</span><br><span class="line">xiaoming.<span class="property">action</span>.<span class="title function_">push</span>(<span class="string">&#x27;panio&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xiaoming.<span class="property">action</span>);<span class="comment">//[&#x27;speak&#x27;, &#x27;run&#x27;, &#x27;eat&#x27;, &#x27;panio&#x27;]</span></span><br><span class="line">xiaoming.<span class="title function_">say</span>();<span class="comment">//my name is xiaoming,23 years old!</span></span><br><span class="line">xiaoming.<span class="title function_">showScore</span>(); <span class="comment">//my score is 78</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaohua = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;xiaohua&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;89&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xiaohua.<span class="property">action</span>);<span class="comment">//[&#x27;speak&#x27;, &#x27;run&#x27;, &#x27;eat&#x27;]</span></span><br><span class="line">xiaohua.<span class="title function_">say</span>();<span class="comment">//my name is xiaohua,24 years old!</span></span><br><span class="line">xiaohua.<span class="title function_">showScore</span>(); <span class="comment">//my score is 89</span></span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ol><li><p>解决了组合继承（3）的<strong>效率问题</strong>：父构造函数被调用两次</p></li><li><p><strong>原型链不变</strong></p></li></ol></li></ul><h4 id="经典的题：">经典的题：<a class="anchor" href="#经典的题：">·</a></h4><p>实现：student继承person</p><ol><li>person上面有一个name属性和printName方法</li><li>student上面有一个score属性和printScore方法</li><li>student和person共享一个方法</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    conaole.<span class="title function_">log</span>(<span class="string">&#x27;我是父&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在原型上定义共享方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">commonMethods</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是共享方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, score</span>) &#123;</span><br><span class="line">  <span class="comment">//子类实现继承属性</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">printScore</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    conaole.<span class="title function_">log</span>(<span class="string">&#x27;我是子&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类继承方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 这里传参100给person是没有用的，person并没有这个属性</span></span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是父&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个方法要继承</span></span><br><span class="line">  <span class="title function_">commonMethods</span>(<span class="params"></span>) &#123;</span><br><span class="line">    conole.<span class="title function_">log</span>(<span class="string">&#x27;我是公共的方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题： 这样直接继承会导致子会继承父类的所有方法？？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, score</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">score</span> = score</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printScore</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是子&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="3、创建对象-6种">3、创建对象  6种<a class="anchor" href="#3、创建对象-6种">·</a></h3><h4 id="1、直接创建Object实例">1、直接创建Object实例<a class="anchor" href="#1、直接创建Object实例">·</a></h4><ul><li>套路: 先创建空Object对象, 再动态添加属性/方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多、代码重复</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">//它没有原型对象，百度问过</span></span><br></pre></td></tr></table></figure><h4 id="2、工厂模式">2、工厂模式<a class="anchor" href="#2、工厂模式">·</a></h4><ul><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个相似对象</li><li>问题: <code>对象没有一个具体的类型</code>, 都是Object类型</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、构造函数">3、构造函数<a class="anchor" href="#3、构造函数">·</a></h4><ul><li>套路: 自定义构造函数, 通过new创建对象</li><li>适用场景: 需要创建多个<code>类型确定</code>的对象,与上方工厂模式有所对比</li><li>问题: 每次实例化都会自动重新创建一遍，同名函数也是不相等的，每个对象都有相同的数据, 浪费内存</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、原型式：共享">4、原型式：共享<a class="anchor" href="#4、原型式：共享">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zzx&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、组合式：">5、组合式：<a class="anchor" href="#5、组合式：">·</a></h4><ul><li><p>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</p></li><li><p>适用场景: 需要<code>创建多个类型确定</code>的对象</p></li><li><p>放在原型上可以节省空间(只需要加载一遍方法)</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;wc&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6、寄生构造函数模式">6、寄生构造函数模式<a class="anchor" href="#6、寄生构造函数模式">·</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    var o = new Object()   //创建空对象</span><br><span class="line">    o.name = name;       //增强其属性、方法</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&#x27;zzx&#x27;, 22, &#x27;Programmer&#x27;);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure><h2 id="class基本语法">class基本语法<a class="anchor" href="#class基本语法">·</a></h2><h3 id="1、类与构造函数">1、类与构造函数<a class="anchor" href="#1、类与构造函数">·</a></h3><p>ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已</p><h4 id="1、相同点">1、相同点<a class="anchor" href="#1、相同点">·</a></h4><h5 id="数据类型-2">数据类型<a class="anchor" href="#数据类型-2">·</a></h5><ul><li><p>类的<strong>数据类型</strong>就是函数，类本身就指向构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Point</span><span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="title class_">Point</span> === <span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="实例化">实例化<a class="anchor" href="#实例化">·</a></h5><ul><li>使用的时候，也是直接对类使用**<code>new</code>命令**，跟构造函数的用法完全一致</li></ul><h5 id="属性、方法">属性、方法<a class="anchor" href="#属性、方法">·</a></h5><ul><li><p><strong>构造函数的</strong><code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，<strong>类的所有方法都定义在类的<code>prototype</code>属性</strong>上。在类的实例上面调用方法，其实就是调用<strong>原型上的方法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b =<span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">constructor</span> === B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>实例上的：</strong></p><ul><li>与 ES5 一样，类的所有实例共享一个原型对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 =<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 =<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">p1.<span class="property">__proto__</span> === p2.<span class="property">__proto__</span>  <span class="comment">//true      它们的原型都是Point.prototype</span></span><br></pre></td></tr></table></figure><ul><li><p>与 ES5 一样，<strong>实例的</strong>属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span><span class="string">&#x27;(&#x27;</span>+<span class="variable language_">this</span>.<span class="property">x</span> +<span class="string">&#x27;, &#x27;</span>+<span class="variable language_">this</span>.<span class="property">y</span> +<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> point =<span class="title function_">newPoint</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">point.<span class="title function_">toString</span>()<span class="comment">// (2, 3)</span></span><br><span class="line">point.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;x&#x27;</span>)<span class="comment">// true</span></span><br><span class="line">point.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;y&#x27;</span>)<span class="comment">// true</span></span><br><span class="line">point.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>)<span class="comment">// false</span></span><br><span class="line">point.<span class="property">__proto__</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>x</code>和<code>y</code>是实例<code>point</code>自身属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返<code>true</code></li><li>而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致</li></ul></li></ul></li><li><p><strong><code>prototype</code>对象的</strong></p><ul><li><p><strong><code>prototype</code>对象的</strong><code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> ===<span class="title class_">Point</span>     <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>一次向类添加多个方法：</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以<strong>类的新方法可以添加在<code>prototype</code>对象上面</strong>。<code>Object.assign</code>可以很方便地一次向类添加多个方法</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>,&#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">  <span class="title function_">toValue</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、不同点">2、不同点<a class="anchor" href="#2、不同点">·</a></h4><h5 id="方法不可枚举">方法不可枚举<a class="anchor" href="#方法不可枚举">·</a></h5><ul><li><p><code>class</code> 中定义的方法不能枚举。所以在<strong>遍历类的实例身上的属性</strong>时，<strong>原型上的属性</strong>不会遍历到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure><p>ES5中可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Point</span>=<span class="keyword">function</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// [&quot;toString&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="实例化-2">实例化<a class="anchor" href="#实例化-2">·</a></h5><ul><li>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行</li></ul><h5 id="严格模式">严格模式<a class="anchor" href="#严格模式">·</a></h5><ul><li><p><code>class</code> 默认使用<code>strict</code> 严格模式执行，避免无意中，this丢失，指向window</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//严格模式下输出 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">test</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="变量提升">变量提升<a class="anchor" href="#变量提升">·</a></h5><ul><li><p>类不存在变量提升，这一点与 ES5 完全不同。 ES6 不会把类的声明提升到代码头部。这种规定的原因与继承有关，必须保证子类在父类之后定义。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>();<span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、constructor方法">2、constructor方法<a class="anchor" href="#2、constructor方法">·</a></h3><ul><li><p><code>constructor</code>类的默认方法，在 new 时自动执行</p></li><li><p>一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加</p></li><li><p><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>() <span class="keyword">instanceof</span> <span class="title class_">Foo</span>  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3、getter、setter">3、getter、setter<a class="anchor" href="#3、getter、setter">·</a></h3><p>目的：使用访问器对对象的属性进行访问控制，有效的防止属性随意修改</p><ul><li><p>与 ES5 一样，在“类”的内部可用<code>get</code>和<code>set</code>对某个属性设置存、取值函数，拦截该属性的存取行为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">prop</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span><span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">prop</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inst =<span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst.<span class="property">prop</span> =<span class="number">123</span>;   <span class="comment">// setter: 123</span></span><br><span class="line">inst.<span class="property">prop</span>       <span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>存值函数和取值函数是设置在属性的 Descriptor 对象上的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomHTMLElement</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">html</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">element</span>.<span class="property">innerHTML</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">html</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span>.<span class="property">innerHTML</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存值函数和取值函数是定义在`html`属性的描述对象上面，这与 ES5 完全一致</span></span><br><span class="line"><span class="keyword">var</span> descriptor =<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="title class_">CustomHTMLElement</span>.<span class="property"><span class="keyword">prototype</span></span>,<span class="string">&quot;html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;get&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;set&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>类的属性名，可以采用表达式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName =<span class="string">&#x27;getArea&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  [methodName]()&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、类的注意点">4、类的注意点<a class="anchor" href="#4、类的注意点">·</a></h3><h4 id="1、严格模式">1、严格模式<a class="anchor" href="#1、严格模式">·</a></h4><ul><li>类和模块的内部，<strong>默认就是严格模式</strong>，所以不需要使用<code>use strict</code>指定运行模式</li><li>只要你的代码写在类或模块之中，就只有严格模式可用。</li><li>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式</li></ul><h4 id="2、不存在提升">2、不存在提升<a class="anchor" href="#2、不存在提升">·</a></h4><ul><li>类不存在变量提升（hoist），这一点与 ES5 完全不同</li><li>这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义</li></ul><h4 id="3、name-属性">3、name 属性<a class="anchor" href="#3、name-属性">·</a></h4><ul><li><p>本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p></li><li><p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;&#125;</span><br><span class="line"><span class="title class_">Point</span>.<span class="property">name</span> <span class="comment">// &quot;Point&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4、this-指向">4、this 指向<a class="anchor" href="#4、this-指向">·</a></h4><ul><li>类的方法内部如果含有<code>this</code>，它默认指向<strong>类的实例。</strong></li><li>但是，必须非常小心，<strong>一旦单独使用该方法，很可能报错。</strong><ul><li><code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。</li><li>但是，<strong>如果将这个方法提取出来单独使用</strong>，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">  <span class="title function_">printName</span>(<span class="params">name =<span class="string">&#x27;there&#x27;</span></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">print</span>(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params">text</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logger =<span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line"><span class="keyword">const</span>&#123; printName &#125;= logger;</span><br><span class="line"><span class="title function_">printName</span>();<span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure><h5 id="解决办法：">解决办法：<a class="anchor" href="#解决办法：">·</a></h5><ul><li><p>在构造方法中绑定<code>this</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">printName</span> =<span class="variable language_">this</span>.<span class="property">printName</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>箭头函数</p><ul><li>箭头函数内部的<code>this</code>总是指向定义时所在的对象</li><li>箭头函数位于构造函数内部，这时所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getThis</span> =<span class="function">()=&gt;</span><span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myObj =<span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line">myObj.<span class="title function_">getThis</span>()=== myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selfish</span> (target)&#123;</span><br><span class="line">    <span class="keyword">const</span> cache =<span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">    <span class="keyword">const</span> handler =&#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params">target, key</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> value =<span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> value !==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cache.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">          cache.<span class="title function_">set</span>(value, value.<span class="title function_">bind</span>(target));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.<span class="title function_">get</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy =<span class="title function_">newProxy</span>(target, handler);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="title function_">selfish</span>(<span class="title function_">newLogger</span>());</span><br></pre></td></tr></table></figure></li></ul><h5 id="Generator-方法">Generator 方法<a class="anchor" href="#Generator-方法">·</a></h5><ul><li><p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数</p></li><li><p><code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">classFoo&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">args</span> = args;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">args</span>)&#123;</span><br><span class="line">          <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">newFoo</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>))&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5、静态方法、静态方法、实例属性写法">5、静态方法、静态方法、实例属性写法<a class="anchor" href="#5、静态方法、静态方法、实例属性写法">·</a></h3><h4 id="1、静态方法定义及规则">1、静态方法定义及规则<a class="anchor" href="#1、静态方法定义及规则">·</a></h4><ul><li><p><strong>静态方法：</strong></p><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。</p><p>如果<strong>在一个方法前，加上<code>static</code>关键字</strong>，就表示<strong>该方法不会被实例继承</strong>，而是直接通过类来调用，这就<strong>称为“静态方法”。</strong></p></li><li><p><strong>规则：</strong></p><ul><li><p>如果在实例上调用静态方法，会<strong>抛出一个错误</strong>，表示不存在该方法</p></li><li><p>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</p></li><li><p>静态方法可以与非静态方法重名</p></li><li><p><strong>父类</strong>的静态方法，可以被<strong>子类</strong>继承（注意，这里是两个类，不是类与实例）</p></li><li><p>静态方法也是可以从<code>super</code>对象上调用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span><span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">classBar <span class="keyword">extends</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">classMethod</span>()+<span class="string">&#x27;, too&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bar</span>.<span class="title function_">classMethod</span>()<span class="comment">// &quot;hello, too&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3、实例属性新写法">3、实例属性新写法<a class="anchor" href="#3、实例属性新写法">·</a></h4><ul><li><p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层</p><ul><li>实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</li><li>新写法好处：所有实例对象自身的属性都定义在类的头部，一眼就能看出这个类有哪些实例属性。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span>&#123;</span><br><span class="line">  _count =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">  returnthis.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、静态属性定义及规则">4、静态属性定义及规则<a class="anchor" href="#4、静态属性定义及规则">·</a></h4><ul><li><p><strong>静态属性：</strong></p><p>指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性</p><ul><li>老写法：静态属性定义在类的外部。整个类生成以后，再生成静态属性</li><li>让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;  <span class="comment">// 老写法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">prop</span> = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">prop</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>ES6 明确规定，Class 内部只有静态方法，没有静态属性，所以新提案提供新写法：</p><ul><li><strong>写法是在实例属性的前面，加上<code>static</code>关键字</strong></li><li>显式声明（declarative），而不是赋值处理，语义更好</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">myStaticProp</span>); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6、私有方法、属性">6、私有方法、属性<a class="anchor" href="#6、私有方法、属性">·</a></h3><ul><li><p>私有方法和私有属性，是<strong>只能在类的内部访问的方法和属性，外部不能访问</strong>。</p></li><li><p>这是常见需求，<strong>有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现</strong></p></li></ul><h4 id="1、私有属性-现有方案：">1、私有属性 现有方案：<a class="anchor" href="#1、私有属性-现有方案：">·</a></h4><h5 id="1、命名保护">1、命名保护<a class="anchor" href="#1、命名保护">·</a></h5><ul><li>将属性定义为以 <code>_</code> 开始，来告诉使用者这是一个私有属性，不要在外部使用，这只是刻意的提示</li><li>外部<strong>修改私有属性时可以使用访问器 <code>setter</code> 操作</strong>，<strong>继承时是可以使用的</strong></li></ul><h5 id="2、将私有方法移出模块">2、将私有方法移出模块<a class="anchor" href="#2、将私有方法移出模块">·</a></h5><p>因为模块内部的所有方法都是对外可见的：</p><ul><li><code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar</code>实际上成为了当前模块的私有方法。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.<span class="title function_">call</span>(<span class="variable language_">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">baz</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">snaf</span> = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、Symbol">3、<code>Symbol </code><a class="anchor" href="#3、Symbol">·</a></h5><ul><li><p>利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值；</p></li><li><p>在外部通过查看对象结构无法获取的属性，继承同样可以拿到这个属性：</p><p>bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到<strong>了私有方法和私有属性的效果</strong></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);  </span><br><span class="line"><span class="keyword">const</span> snaf = <span class="title class_">Symbol</span>(<span class="string">&#x27;snaf&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">myClass</span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="params">baz</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">myClass</span>();</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(myClass.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//Symbol 值的属性名依然可以从类的外部拿到</span></span><br><span class="line"><span class="comment">// [ &#x27;constructor&#x27;, &#x27;foo&#x27;, Symbol(bar) ]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、私有属性-现有提案">2、私有属性 现有提案<a class="anchor" href="#2、私有属性-现有提案">·</a></h4><p>为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示：</p><ul><li><p><code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">IncreasingCounter</span>();</span><br><span class="line">counter.#count  <span class="comment">//代码在类的外部，读取私有属性，就会报错</span></span><br><span class="line">counter.#count = <span class="number">42</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li><li><h4 id="为什么没有采用private关键字？">为什么没有采用<code>private</code>关键字？<a class="anchor" href="#为什么没有采用private关键字？">·</a></h4><ul><li>是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性</li><li>ES6 没有用<code>@</code>符号而使用<code>#</code>，是因为<code>@</code>已经被留给了 Decorator</li></ul></li><li><p>这种方式样可用于私有方法</p></li><li><h5 id="私有属性也可以设置-getter-和-setter-方法">私有属性也可以设置 getter 和 setter 方法<a class="anchor" href="#私有属性也可以设置-getter-和-setter-方法">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  #xValue = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  get #<span class="title function_">x</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> #xValue; &#125;</span><br><span class="line">  set #<span class="title function_">x</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#xValue = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性">私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性<a class="anchor" href="#私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #privateValue = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getPrivateValue</span>(<span class="params">foo</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo.#privateValue;    <span class="comment">//从实例foo上面引用私有属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getPrivateValue</span>(<span class="keyword">new</span> <span class="title class_">Foo</span>()); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure></li><li><h5 id="私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法">私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法<a class="anchor" href="#私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FakeMath</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">PI</span> = <span class="number">22</span> / <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">static</span> #totallyRandomNumber = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">static</span> #<span class="title function_">computeRandomNumber</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">FakeMath</span>.#totallyRandomNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">random</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I heard you like random numbers…&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">FakeMath</span>.#<span class="title function_">computeRandomNumber</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">FakeMath</span>.<span class="property">PI</span> <span class="comment">// 3.142857142857143  </span></span><br><span class="line"><span class="title class_">FakeMath</span>.<span class="title function_">random</span>()           <span class="comment">// 只能在`FakeMath`这个类的内部调用，外部调用就会报错</span></span><br><span class="line"><span class="comment">// I heard you like random numbers…</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="title class_">FakeMath</span>.#totallyRandomNumber <span class="comment">// 报错  `#totallyRandomNumber`是私有属性</span></span><br><span class="line"><span class="title class_">FakeMath</span>.#<span class="title function_">computeRandomNumber</span>() <span class="comment">// 报错  `#computeRandomNumber()`是私有方法</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7、new-target-属性">7、new.target 属性<a class="anchor" href="#7、new-target-属性">·</a></h3><h4 id="1、对构造函数">1、对构造函数<a class="anchor" href="#1、对构造函数">·</a></h4><ul><li><p>ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。</p></li><li><p>如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此<strong>这个属性可以用来确定构造函数是怎么调用的</strong>。</p></li><li><p>代码确保构造函数只能通过<code>new</code>命令调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> !==<span class="literal">undefined</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Person</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>);<span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson =<span class="title class_">Person</span>.<span class="title function_">call</span>(person,<span class="string">&#x27;张三&#x27;</span>);<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、对类class">2、对类class<a class="anchor" href="#2、对类class">·</a></h4><ul><li><p>Class 内部调用<code>new.target</code>，返回当前 Class</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Rectangle</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj =<span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li><li><p>注意：子类继承父类时，<code>new.target</code>会返回子类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> ===<span class="title class_">Rectangle</span>);  <span class="comment">//new.target会返回子类</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(length, width);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> ===<span class="title class_">Square</span>); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj =<span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">3</span>);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、应用-2">3、应用<a class="anchor" href="#3、应用-2">·</a></h4><p>利用这个特点，可以写出<strong>不能独立使用、必须继承后才能使用的类</strong></p><ul><li><code>Shape</code>类不能被实例化，<strong>只能用于继承。</strong></li><li>注意，在函数外部，使用<code>new.target</code>会报错。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Shape</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;本类不能实例化&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x =<span class="keyword">new</span> <span class="title class_">Shape</span>();<span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y =<span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h2 id="class继承">class继承<a class="anchor" href="#class继承">·</a></h2><p>Class 可以通过<code>extends</code>关键字实现继承，比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><h3 id="1、继承实现">1、继承实现<a class="anchor" href="#1、继承实现">·</a></h3><h4 id="1、extends关键字">1、extends关键字<a class="anchor" href="#1、extends关键字">·</a></h4><ul><li><p>通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法</p><ul><li>父类的静态方法，会被子类继承</li><li></li></ul></li><li><p><strong>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错：</strong></p><ul><li>这是因为：子类自己的<code>this</code>对象，必须先通过父类的构造函数<strong>得到与父类同样的实例属性和方法</strong></li><li>然后再对其进行加工，加上子类自己的实例属性和方法</li><li><strong>如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</strong></li></ul></li><li><p>因此，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是<strong>因为子类实例的构建，基于父类实例</strong>，只有<code>super</code>方法才能调用父类实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y, color</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(x, y);        <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span> +<span class="string">&#x27; &#x27;</span>+ <span class="variable language_">super</span>.<span class="title function_">toString</span>();<span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、继承的实质分析">2、继承的实质分析<a class="anchor" href="#2、继承的实质分析">·</a></h4><ul><li><h5 id="ES5-的继承：">ES5 的继承：<a class="anchor" href="#ES5-的继承：">·</a></h5><p>实质是<strong>先创造子类的实例对象<code>this</code>，然后再将父类的方法添加</strong>到<code>this</code>上面（<code>Parent.apply(this)</code>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Admin</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">User</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="ES6-的继承机制：">ES6 的继承机制：<a class="anchor" href="#ES6-的继承机制：">·</a></h5><img src="https://upload-images.jianshu.io/upload_images/675733-c5dd46572ce51840.png?imageMogr2/auto-orient/strip|imageView2/2/w/504/format/webp" alt="img" style="zoom:50%;" /><p>实质是<strong>先将父类实例对象的属性和方法，加到<code>this</code>上面</strong></p><p>因此，在子类构造函数中要先执行<code>super</code>，然后再用子类的构造函数修改<code>this</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span> <span class="keyword">extends</span> <span class="title class_ inherited__">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、静态方法">3、静态方法<a class="anchor" href="#3、静态方法">·</a></h4><ul><li>父类的静态方法，也会被子类继承</li></ul><h4 id="4、Object-getPrototypeOf">4、Object.getPrototypeOf<a class="anchor" href="#4、Object-getPrototypeOf">·</a></h4><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">ColorPoint</span>)===<span class="title class_">Point</span>   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2、super关键字">2、super关键字<a class="anchor" href="#2、super关键字">·</a></h3><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><h4 id="1、作函数调用">1、作函数调用<a class="anchor" href="#1、作函数调用">·</a></h4><p><code>super</code>作为函数调用时，<strong>代表父类的构造函数</strong>。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p><ul><li><p><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例：即**<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例**，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>.<span class="property">name</span>);<span class="comment">// `new.target`指向当前正在执行的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">A</span>() <span class="comment">// A  </span></span><br><span class="line"><span class="comment">//在`super()`执行时，它指向的是子类`B`的构造函数，而不是父类`A`的构造函数，也就是说，`super()`内部的`this`指向的是`B`。</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">B</span>() <span class="comment">// B  </span></span><br></pre></td></tr></table></figure></li><li><p><code>super()</code>只能用在<strong>子类的构造函数</strong>之中，用在其他地方就会报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 报错，不是构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、作为对象调用">2、作为对象调用<a class="anchor" href="#2、作为对象调用">·</a></h4><h5 id="普通方法：">普通方法：<a class="anchor" href="#普通方法：">·</a></h5><ul><li><p><code>super</code>作为对象时，<strong>在普通方法中，指向父类的原型对象</strong>；<strong>在静态方法中，指向父类</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">p</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="comment">// 子类B当中的super.p()，就是将super当作一个对象使用。</span></span><br><span class="line">    <span class="comment">//这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">p</span>()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure></li><li><p>由于<code>super</code>指向父类的<strong>原型对象</strong>，所以定义在<strong>父类实例上的方法或属性，是无法通过<code>super</code>调用的</strong>。</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">p</span>;  <span class="comment">// p是父类A实例的属性，super.p就引用不到它</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>) <span class="comment">// 2   此时在原型上，可以取到</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">m</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例</p><p>也因此，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值属性会变成子类实例属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>(); <span class="comment">//实际上执行的是super.print.call(this)</span></span><br><span class="line">    <span class="comment">// 此时this指向子类实例，对子类实例属性赋值了</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">x</span> = <span class="number">3</span>;  <span class="comment">//等同于对this.x赋值为3</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>); <span class="comment">// 读的是A.prototype.x，所以返回undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 3  this是子类实例</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">m</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="静态方法：">静态方法：<a class="anchor" href="#静态方法：">·</a></h5><ul><li><p>在<strong>子类静态方法</strong>中通过<code>super</code>调<strong>用父类静态方法</strong>时，</p><ul><li><p><code>super</code>将指向<strong>父类</strong>，而不是父类的原型对象。</p></li><li><p>方法内部的**<code>this</code>指向当前的子类**，而不是子类的实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();  <span class="comment">//这个方法里面的this指向的是B，而不是B的实例。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">B.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">B.<span class="title function_">m</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3、使用注意">3、使用注意<a class="anchor" href="#3、使用注意">·</a></h4><ul><li><p>使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错</p></li><li><p>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MyObject: &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>(); <span class="comment">//明显是对象来用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">toString</span>(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3、prototype、-proto-属性">3、prototype、__proto__属性<a class="anchor" href="#3、prototype、-proto-属性">·</a></h3><h4 id="1、类的-prototype-属性和-proto-属性">1、类的 prototype 属性和__proto__属性<a class="anchor" href="#1、类的-prototype-属性和-proto-属性">·</a></h4><ul><li><p>ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。</p></li><li><p>Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此<strong>同时存在两条继承链</strong></p><p>（1）子类的<code>__proto__</code>属性，表示<strong>构造函数的继承</strong>，总是指向父类</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">B.<span class="property">__proto__</span> === A <span class="comment">// true 子类`B`的`__proto__`属性指向父类`A`</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true 子类`B`的`prototype`属性的`__proto__`属性指向父类`A`的`prototype`属性</span></span><br></pre></td></tr></table></figure></li><li><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B 的实例继承 A 的实例</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B.<span class="property"><span class="keyword">prototype</span></span>, A.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// B 继承 A 的静态属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"><span class="keyword">const</span> b =<span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">setPrototypeOf</span>方法的实现:</span><br><span class="line">  <span class="title class_">Object</span>.<span class="property">setPrototypeOf</span> =<span class="keyword">function</span>(<span class="params">obj, proto</span>)&#123;</span><br><span class="line">    obj.<span class="property">__proto__</span> = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>因此，可以这样理解：</p><p>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>）是父类（<code>A</code>）；</p><p>作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>）是父类原型对象（<code>prototype</code>属性）的实例</p></li></ul><h4 id="2、不同个继承类型">2、不同个继承类型<a class="anchor" href="#2、不同个继承类型">·</a></h4><ul><li><p><code>extends</code>关键字后面可以跟多种类型的值</p><p>只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B extends A &#123;//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="方式1：子类继承Object类">方式1：子类继承<code>Object</code>类<a class="anchor" href="#方式1：子类继承Object类">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Object</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property">__proto__</span> ===<span class="title class_">Object</span><span class="comment">// true</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> ===<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="方式2：不存在任何继承">方式2：不存在任何继承<a class="anchor" href="#方式2：不存在任何继承">·</a></h5><ul><li><code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。</li><li>但<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property">__proto__</span> ===<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> ===<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="3、实例的-proto-属性">3、实例的 <strong>proto</strong> 属性<a class="anchor" href="#3、实例的-proto-属性">·</a></h4><ul><li><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。</p></li><li><p>也就是说，子类的原型的原型，是父类的原型。</p><p><code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 =<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 =<span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">p2.<span class="property">__proto__</span> === p1.<span class="property">__proto__</span> <span class="comment">// false</span></span><br><span class="line">p2.<span class="property">__proto__</span>.<span class="property">__proto__</span> === p1.<span class="property">__proto__</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>应用：</p><p>通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p2.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">printName</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Ha&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">p1.<span class="title function_">printName</span>()<span class="comment">// &quot;Ha&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4、Mixin">4、Mixin<a class="anchor" href="#4、Mixin">·</a></h3><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。</p><ul><li><p><code>JS</code>不能实现多继承，如果要使用多个类的方法时可以使用<code>mixin</code>混合模式来完成</p></li><li><p><code>mixin</code> 类是一个包含许多供其它类使用的方法的类</p></li><li><p><code>mixin</code> 类不用来继承做为其它类的父类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mix</span>(<span class="params">...mixins</span>)&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Mix</span>&#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins)&#123;</span><br><span class="line">            <span class="title function_">copyProperties</span>(<span class="variable language_">this</span>,<span class="keyword">new</span> <span class="title function_">mixin</span>());<span class="comment">// 拷贝实例属性</span></span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins)&#123;</span><br><span class="line">      <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>, mixin);<span class="comment">// 拷贝静态属性</span></span><br><span class="line">      <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>.<span class="property"><span class="keyword">prototype</span></span>, mixin.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// 拷贝原型属性</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Mix</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyProperties</span>(<span class="params">target, source</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(source))&#123;</span><br><span class="line">      <span class="keyword">if</span>(key !==<span class="string">&#x27;constructor&#x27;</span> &amp;&amp; key !==<span class="string">&#x27;prototype&#x27;</span> &amp;&amp; key !==<span class="string">&#x27;name&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> desc =<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, key);</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, desc);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedEdit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mix</span>(<span class="title class_">Loggable</span>,<span class="title class_">Serializable</span>)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - 原型链</title>
      <link href="/posts/2818550155.html"/>
      <url>/posts/2818550155.html</url>
      
        <content type="html"><![CDATA[<h3 id="原型链-√√√√-极其重要">原型链  √√√√           极其重要<a class="anchor" href="#原型链-√√√√-极其重要">·</a></h3><h4 id="1、-什么是原型链">1、 什么是原型链<a class="anchor" href="#1、-什么是原型链">·</a></h4><ul><li><strong>构造函数、实例、原型对象的关系</strong><ul><li>构造函数的 prototype 指向原型对象，原型对象有一个 constructor 属性指回构造函数，每个构造函数生成的实例对象都有一个 <em>proto</em> 属性，这个属性指向原型对象</li><li>最后，既然每个对象都有一个<code>_proto_</code>属性指向原型对象，那么原型对象也有_proto_指向原型对象的原型对象，它指向Object 构造函数对应的原型对象，直到<code>null</code>，到达原型链顶端</li></ul></li></ul><h4 id="2、Object、Function的关系：">2、Object、Function的关系：<a class="anchor" href="#2、Object、Function的关系：">·</a></h4><img src="file:///C:\Users\小虎牙\Documents\Tencent Files\2575329556\Image\Group\5LOKV2$Q28$JYOMV51%$GAA.jpg" alt="img" style="zoom: 25%;" /><ul><li><code>function</code> ：所有的函数（包括构造函数）是<code>Function</code>的实例，所以所有函数的<code>_proto_</code>都指向<code>Function</code>的原型对象</li><li>所有的原型对象（包括 <code>Function</code>的原型对象）都是Object的实例，所以<code>_proto_</code>都指向 <code>Object</code>（构造函数）的原型对象。而<code>Object</code>构造函数的 <code>_proto_</code>指向 null</li><li><code>Function</code>构造函数本身就是<code>Function</code>的实例，所以<code>_proto_</code>指向<code>Function</code>的原型对象</li></ul><h4 id="3、-原型链应用">3、 原型链应用<a class="anchor" href="#3、-原型链应用">·</a></h4><ul><li><p><strong>搜索机制</strong></p><p>实例属性 — 实例的原型 — 在原型链继承后，搜索可继续向上 原型的原型  – 直到原型链的末端</p></li><li><p><strong>确定原型与继承的关系</strong></p><ul><li>法1：instanceOf</li><li>法2：isPrototypeOf：只要原型链上包含该原型就是true</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - new操作符</title>
      <link href="/posts/3912543564.html"/>
      <url>/posts/3912543564.html</url>
      
        <content type="html"><![CDATA[<h3 id="new操作符">new操作符<a class="anchor" href="#new操作符">·</a></h3><h4 id="1、内部做了什么">1、内部做了什么<a class="anchor" href="#1、内部做了什么">·</a></h4><pre><code>1. 在内存中创建一个对象2. 这个新对象内部的[prototype]特性会被赋值为构造函数的prototype属性3. 构造函数内部的this被赋值为这个新对象，即this指向新对象4. 执行构造函数内部的代码，给对象添加属性5. 如果构造函数返回非空对象，就返回该对象，否则就返回刚创建的新对象（判断）</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、实现">2、实现<a class="anchor" href="#2、实现">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNnew</span>(<span class="params">F,...arg</span>)&#123;</span><br><span class="line">  <span class="comment">//1. 创建新对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;  <span class="comment">// 或new Object()</span></span><br><span class="line">  <span class="comment">//2. __proto__指向原型</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = F.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">//3. this指向新对象，执行构造函数F中的代码</span></span><br><span class="line">  <span class="keyword">let</span> result = F.<span class="title function_">call</span>(obj, arg)</span><br><span class="line">  <span class="comment">//4. 判断</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> result === <span class="string">&quot;Object&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - Object.create</title>
      <link href="/posts/775935900.html"/>
      <url>/posts/775935900.html</url>
      
        <content type="html"><![CDATA[<h3 id="Object-create">Object.create()<a class="anchor" href="#Object-create">·</a></h3><h4 id="1、参数1：对象、null">1、参数1：对象、null<a class="anchor" href="#1、参数1：对象、null">·</a></h4><ul><li><p>如果对象的属性是基本类型，二者互不影响。如果对象的属性值是<strong>引用类型，会互相影响</strong>，因为只传一个参数的情况下本质就是浅复制</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> me = <span class="title class_">Object</span>.<span class="title function_">create</span>(person); </span><br><span class="line">me 会继承person的所有属性和方法，me.<span class="property">__proto__</span> === person为<span class="literal">true</span></span><br><span class="line">me 可以自己添加新属性和方法，也可将继承过来的属性重写，二者互不影响</span><br></pre></td></tr></table></figure></li><li><p>创造一个没有原型的空对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> my = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">此时my就是彻底的空对象，没有继承<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>上的任何属性和方法，如<span class="title function_">hasOwnProperty</span>()、<span class="title function_">toString</span>()</span><br><span class="line">my <span class="keyword">instanceof</span> <span class="title class_">Object</span>  <span class="comment">// false</span></span><br><span class="line">my.<span class="property">__proto__</span> === person <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、参数2：可选">2、参数2：可选<a class="anchor" href="#2、参数2：可选">·</a></h4><p>指定要添加到新对象上的可枚举的属性描述符、属性名称</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bb = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(bb); <span class="comment">// &#123;a: 2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bb.<span class="property">__proto__</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bb.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bb <span class="keyword">instanceof</span> <span class="title class_">Object</span>); </span><br><span class="line"><span class="comment">// false 没有继承`Object.prototype`上的任何属性和方法，所以原型链上不会出现Object</span></span><br></pre></td></tr></table></figure><h4 id="3、实现">3、实现<a class="anchor" href="#3、实现">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">mycreate</span> = <span class="keyword">function</span>(<span class="params">proto, properties</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 关键：新生成的对象的__proto__指向参数1proto</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line">    <span class="comment">// 如果有第2参数</span></span><br><span class="line">    <span class="keyword">if</span>(properties) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(F, properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - 堆与栈</title>
      <link href="/posts/1003179605.html"/>
      <url>/posts/1003179605.html</url>
      
        <content type="html"><![CDATA[<h3 id="堆和栈的区别">堆和栈的区别<a class="anchor" href="#堆和栈的区别">·</a></h3><h4 id="1、栈">1、栈<a class="anchor" href="#1、栈">·</a></h4><ul><li><p>空间分配：系统自动分配内存空间，自动释放，占据固定大小的空间，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性</p></li><li><p>数</p></li><li><p>据存储：基础变量的值、引用变量的地址会存储在栈中</p></li><li><p>读取速度：相比于堆来说存取速度会快</p></li></ul><h4 id="2、堆">2、堆<a class="anchor" href="#2、堆">·</a></h4><ul><li><p>空间分配：系统动态分配的内存，大小不定，也不会自动释放，一般由程序员分配释放，也可由垃圾回收机制回收</p><ul><li><p>基本数据类型在当前执行环境结束时销毁</p></li><li><p>而引用类型不会随执行环境结束而销毁，只有当所有引用他的变量不存在时这个对象才会被回收机制回收</p><p>堆中的对象不会随方法结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)</p></li></ul></li><li><p>存储引用类型的值</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - 你真的区分赋值、浅拷贝、深拷贝吗？</title>
      <link href="/posts/3737997078.html"/>
      <url>/posts/3737997078.html</url>
      
        <content type="html"><![CDATA[<h3 id="赋值、浅拷贝、深拷贝">赋值、浅拷贝、深拷贝<a class="anchor" href="#赋值、浅拷贝、深拷贝">·</a></h3><h4 id="1、赋值：">1、赋值：<a class="anchor" href="#1、赋值：">·</a></h4><ul><li><p>基本：直接在栈中开辟新内存，把值赋值到新内存中，互不影响</p></li><li><p>引用：直接<strong>复制栈内存中的地址，指向同一个堆内存</strong>，<strong>指向同一对象</strong>，任何操作都会互相影响</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = xxx, a内存中到底保存的是什么?</span><br><span class="line"></span><br><span class="line">xxx是基本数据, 保存的就是这个数据</span><br><span class="line">xxx是对象, 保存的是对象的地址值</span><br><span class="line">xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、拷贝：">2、拷贝：<a class="anchor" href="#2、拷贝：">·</a></h4><ul><li><p>浅拷贝：</p><ul><li>重新在堆内存中开辟新的内存             <strong>和源对象并不指向同一对象</strong></li><li>第一层数据是基本类型：  改变后，<strong>不会一起改变</strong></li><li>第一层数据为引用类型： 改变后，<strong>会一起改变</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="string">&#x27;kk&#x27;</span>: <span class="string">&#x27;hh&#x27;</span>&#125;, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">concat</span>();</span><br><span class="line"></span><br><span class="line">arr === newArr;<span class="comment">//  false</span></span><br><span class="line">newArr.<span class="title function_">push</span>(<span class="string">&#x27;four&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)    <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>][<span class="string">&#x27;kk&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">//[ &#123; kk: 1 &#125;, &#x27;two&#x27;, &#x27;three&#x27; ]</span></span><br><span class="line"><span class="comment">//[ &#123; kk: 1 &#125;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27; ]</span></span><br></pre></td></tr></table></figure></li><li><p>深拷贝：重新在堆内存中开辟新的内存        <strong>和源对象并不指向同一对象</strong></p><ul><li>第一层数据是基本类型：  改变后，<strong>不会一起改变</strong></li><li>第一层数据为引用类型： 改变后，<strong>不会一起改变</strong></li></ul></li></ul><h4 id="3、浅拷贝实现">3、浅拷贝实现<a class="anchor" href="#3、浅拷贝实现">·</a></h4><ul><li><h5 id="Object-assign">Object.assign()<a class="anchor" href="#Object-assign">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.assign(&#123;&#125;, obj1)</span><br></pre></td></tr></table></figure></li><li><p>loadsh库的clone方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;)</span><br><span class="line">var obj2 = _.clone(obj1);</span><br></pre></td></tr></table></figure></li><li><p>拓展运算符：…</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; name: &#x27;Kobe&#x27;, address:&#123;x:100,y:100&#125;&#125;</span><br><span class="line">let obj2= &#123;... obj1&#125;</span><br><span class="line">console.log(obj1 === obj2) //false</span><br></pre></td></tr></table></figure></li><li><h5 id="Array-prototype-concat-：该方法会有副本">Array.prototype.concat()：该方法会有副本<a class="anchor" href="#Array-prototype-concat-：该方法会有副本">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr2 = arr1.concat(); </span><br></pre></td></tr></table></figure></li><li><h5 id="Array-prototype-slice-：该方法同样有副本">Array.prototype.slice()：该方法同样有副本<a class="anchor" href="#Array-prototype-slice-：该方法同样有副本">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr2 = arr1.slice();</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、手写浅拷贝：">4、手写浅拷贝：<a class="anchor" href="#4、手写浅拷贝：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shallowCopy = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 只拷贝对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 根据obj的类型判断是新建一个数组还是对象</span></span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="comment">// 遍历obj，并且判断是obj的属性才拷贝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) newObj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="补充Object-assign-：">补充Object.assign()：<a class="anchor" href="#补充Object-assign-：">·</a></h4><ul><li><p>将所有可枚举属性的值从一个或多个源对象复制到目标对象，同时返回目标对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources)</span><br><span class="line">  -- <span class="string">`target`</span> 是目标对象，<span class="string">`sources`</span> 是源对象，可有多个，返回修改后目标对象 <span class="string">`target`</span></span><br><span class="line">  -- 目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖</span><br><span class="line">  -- 后来的源对象的属性将类似地覆盖早先的属性</span><br></pre></td></tr></table></figure></li><li><p>浅拷贝之后<strong>目标对象 a 的基本类型值没有改变，但是引用类型值发生了改变</strong>，因为 <code>Object.assign()</code> 拷贝的是属性值。<strong>假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用地址。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="title class_">Object</span>.<span class="title function_">assign</span>(a, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === c);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><h5 id="实现Object-assign-：">实现Object.assign()：<a class="anchor" href="#实现Object-assign-：">·</a></h5><p>思路： <code>for..in</code> 循环遍历出所有可枚举的自有属性。并复制给新的目标对象（使用 <code>hasOwnProperty</code> 获取自有属性，即非原型链上的属性）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">assign</span> = target =&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; index++) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextSource = <span class="variable language_">arguments</span>[index];</span><br><span class="line">        <span class="keyword">if</span> (nextSource != <span class="literal">null</span>) &#123;  <span class="comment">// Attention 2</span></span><br><span class="line">          <span class="comment">// Attention 4</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> nextKey <span class="keyword">in</span> nextSource) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(nextSource, nextKey)) &#123;</span><br><span class="line">              to[nextKey] = nextSource[nextKey];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、深拷贝实现">5、深拷贝实现<a class="anchor" href="#5、深拷贝实现">·</a></h4><ul><li><p>JSON.stringify：将对象转成JSON字符串，JSON.parse再将字符串解析成对象，产生新的对象</p><ul><li>可处理数组、对象                                     √</li><li>函数（得到null）、正则（得到空对象）  ×</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>())</span><br></pre></td></tr></table></figure></li><li><p>函数库lodash的_.cloneDeep方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj2 = _.cloneDeep(obj1);</span><br></pre></td></tr></table></figure></li></ul><h4 id="6、手写深拷贝：">6、手写深拷贝：<a class="anchor" href="#6、手写深拷贝：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 在克隆时遍历键时，不再用for in循环，因为它的效率不如while&gt;for&gt;for in</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEach</span>(<span class="params">array, iteratee</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> length = array.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">          <span class="title function_">iteratee</span>(array[index], index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> isArray = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target);</span><br><span class="line">          <span class="keyword">let</span> cloneTarget = isArray ? [] : &#123;&#125;;</span><br><span class="line">          <span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) &#123;          <span class="comment">// 克隆前检查是否存在</span></span><br><span class="line">              <span class="keyword">return</span> map.<span class="title function_">get</span>(target);</span><br><span class="line">          &#125;</span><br><span class="line">          map.<span class="title function_">set</span>(target, cloneTarget);   <span class="comment">// 添加本次克隆</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 1. 对于数组、对象获取索引的方式不同</span></span><br><span class="line">          <span class="keyword">const</span> keys = isArray ? <span class="literal">undefined</span> : <span class="title class_">Object</span>.<span class="title function_">keys</span>(target);</span><br><span class="line">      <span class="comment">// 2.若是对象，keys有值，forEach函数遍历的是键形成的数组，从而得到对象的属性</span></span><br><span class="line">      <span class="comment">//   若是数组，即传入的是target， forEach函数遍历的是数组本身，得到索引</span></span><br><span class="line">          <span class="title function_">forEach</span>(keys || target, <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 处理对象的情况</span></span><br><span class="line">              <span class="keyword">if</span> (keys)  key = value;</span><br><span class="line">            <span class="comment">// 拷贝</span></span><br><span class="line">              cloneTarget[key] = <span class="title function_">clone</span>(target[key], map);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> cloneTarget;   <span class="comment">// 容易遗漏！！</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- setTimeout、setInterval</title>
      <link href="/posts/2747544176.html"/>
      <url>/posts/2747544176.html</url>
      
        <content type="html"><![CDATA[<h3 id="setTimeout-setInterval">setTimeout / setInterval<a class="anchor" href="#setTimeout-setInterval">·</a></h3><h4 id="1、setTimeout">1、setTimeout<a class="anchor" href="#1、setTimeout">·</a></h4><h5 id="1、使用规则：">1、使用规则：<a class="anchor" href="#1、使用规则：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutID = scope.<span class="built_in">setTimeout</span>(<span class="keyword">function</span>[, delay, arg1, arg2, ...]);</span><br><span class="line"><span class="keyword">var</span> timeoutID = scope.<span class="built_in">setTimeout</span>(<span class="keyword">function</span>[, delay]);</span><br><span class="line"><span class="keyword">var</span> timeoutID = scope.<span class="built_in">setTimeout</span>(code[, delay]);</span><br></pre></td></tr></table></figure><ul><li>delay：延迟的毫秒数，如果省略该参数，默认值0，意味着“马上”执行，或者尽快执</li><li><code>arg1, ..., argN</code> <strong>可选</strong>：附加参数，一旦定时器到期，它们会作为参数传递给<code>function</code></li><li>code：可选语法，可以使用字符串而不是函数，但不推荐</li><li>返回值：<code>timeoutID</code>是一个正整数，表示定时器的编号。可以传递给<code>clearTimeout()</code>取消该定时器。</li></ul><h5 id="2、this问题：">2、this问题：<a class="anchor" href="#2、this问题：">·</a></h5><ul><li><p><code>setTimeout()</code>调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 <code>this</code> 在非严格模式会指向 <code>window</code> (或全局)对象，严格模式下为 undefined</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>];</span><br><span class="line">myArray.<span class="property">myMethod</span> = <span class="keyword">function</span> (<span class="params">sProperty</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="variable language_">this</span>[sProperty] : <span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myArray.<span class="title function_">myMethod</span>(); <span class="comment">// prints &quot;zero,one,two&quot;</span></span><br><span class="line">myArray.<span class="title function_">myMethod</span>(<span class="number">1</span>); <span class="comment">// prints &quot;one&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(myArray.<span class="property">myMethod</span>, <span class="number">1000</span>); <span class="comment">//  &quot;[object Window]&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(myArray.<span class="property">myMethod</span>, <span class="number">1500</span>, <span class="string">&quot;1&quot;</span>); <span class="comment">//&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>解决方法1：用包装函数来设置<code>this</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;myArray.<span class="title function_">myMethod</span>()&#125;, <span class="number">2000</span>); <span class="comment">//&quot;zero,one,two&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;myArray.<span class="title function_">myMethod</span>(<span class="string">&#x27;1&#x27;</span>)&#125;, <span class="number">2500</span>); <span class="comment">// &quot;one&quot; </span></span><br></pre></td></tr></table></figure></li><li><p>解决方法2：箭头函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;myArray.<span class="title function_">myMethod</span>()&#125;, <span class="number">2000</span>); <span class="comment">//&quot;zero,one,two&quot; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;myArray.<span class="title function_">myMethod</span>(<span class="string">&#x27;1&#x27;</span>)&#125;, <span class="number">2500</span>); <span class="comment">// &quot;one&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>解决方法3：bind显式地指定函数调用时 this 所指向的值 。解决 this 指向不确定的问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [<span class="string">&#x27;zero&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>];</span><br><span class="line">myBoundMethod = (<span class="keyword">function</span> (<span class="params">sProperty</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="variable language_">this</span>[sProperty] : <span class="variable language_">this</span>);</span><br><span class="line">&#125;).<span class="title function_">bind</span>(myArray);</span><br><span class="line"></span><br><span class="line"><span class="title function_">myBoundMethod</span>(); <span class="comment">// &quot;zero,one,two&quot;</span></span><br><span class="line"><span class="title function_">myBoundMethod</span>(<span class="number">1</span>); <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(myBoundMethod, <span class="number">1000</span>); <span class="comment">//  &quot;zero,one,two&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(myBoundMethod, <span class="number">1500</span>, <span class="string">&quot;1&quot;</span>); <span class="comment">//&quot;one&quot; </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、setInterval">2、setInterval<a class="anchor" href="#2、setInterval">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalID = scope.<span class="built_in">setInterval</span>(func, delay, [arg1, arg2, ...]);</span><br><span class="line"> <span class="comment">// func:该函数不接受任何参数，也没有返回值。</span></span><br><span class="line"> <span class="comment">// [..arg1, arg2,...] 当定时器过期的时候，将被传递给func指定函数的附加参数</span></span><br><span class="line"><span class="keyword">var</span> intervalID = scope.<span class="built_in">setInterval</span>(code, delay);</span><br><span class="line"><span class="keyword">var</span> intervalID = <span class="built_in">setInterval</span>(myCallback, <span class="number">500</span>, <span class="string">&#x27;Parameter 1&#x27;</span>, <span class="string">&#x27;Parameter2&#x27;</span>);</span><br></pre></td></tr></table></figure><p>【注意】：</p><ol><li><p>func函数不能传参：如果需要传递参数,可以使用闭包返回一个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(test,<span class="number">1000</span>);    <span class="comment">// 正常 每秒打印1次</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="title function_">test</span>(),<span class="number">1000</span>);   <span class="comment">// test已经同步调用，只会打印一次1</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;test()&quot;</span>,<span class="number">1000</span>);  <span class="comment">//每秒打印1次，</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)   &#125;</span><br></pre></td></tr></table></figure></li><li><p>需要使用<code>clearInterval</code>清除定时器,防止定时器一直执行下去,同时也需要手动释放内存</p></li><li><p><code>this</code>指向问题</p></li></ol><h4 id="3、setTimeout模拟setInterval">3、setTimeout模拟setInterval<a class="anchor" href="#3、setTimeout模拟setInterval">·</a></h4><h5 id="setInterval的执行机制">setInterval的执行机制<a class="anchor" href="#setInterval的执行机制">·</a></h5><ul><li><code>setTimeout</code> 会将当前异步任务推入队列（<code>setTimeout</code>本身就是一次调用一次执行），而 <code>setInterval</code> 则会在任务<strong>推入异步队列时判断上次异步任务是否被执行。</strong></li><li>这就导致 <code>setInterval</code> 在做<strong>定时轮训时，出现耗时操作，或者调用的异步操作耗时</strong>会导致异步任务<strong>不按照期待的时间间隔</strong>执行。</li></ul><h5 id="版本1：无法清除啊，停不下来">版本1：无法清除啊，停不下来<a class="anchor" href="#版本1：无法清除啊，停不下来">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mySetInterval</span> = (<span class="params">func, delay</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">interval</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 执行原本逻辑func</span></span><br><span class="line">    <span class="title function_">func</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="版本2：保存id来清除">版本2：保存id来清除<a class="anchor" href="#版本2：保存id来清除">·</a></h5><ul><li>执行 <code>mySetInterval</code> 的时候返回的 <code>id</code> 依然不是最新的 <code>timeId</code>。因为 <code>timeId</code> 只在 <code>fn</code> 内部被更新了，在外部并不知道它的更新,注意内层、外层的也有清除</li><li>由于 <code>timeId</code> 是<code>Number</code>类型，这样使用拿到的是<strong>全局变量 <code>timeId</code> 的值拷贝而不是引用</strong>，</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mySetInterval</span> = (<span class="params">func, delay</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timeId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">interval</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 执行原本逻辑func</span></span><br><span class="line">    <span class="title function_">func</span>();</span><br><span class="line">    timeId = <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">  &#125;</span><br><span class="line">  timeId = <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">  <span class="keyword">return</span> timeId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="版本3：闭包">版本3：闭包<a class="anchor" href="#版本3：闭包">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mySetInterval</span> = (<span class="params">func, delay, ...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">interval</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">func</span>(...args);</span><br><span class="line">    timeId = <span class="built_in">setTimeout</span>(interval, delay,...args);</span><br><span class="line">  &#125;</span><br><span class="line">  timeId = <span class="built_in">setTimeout</span>(interval, delay, ...args);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">cancel</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a=<span class="title function_">mySetInterval</span>(<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(...args);</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b=<span class="title function_">mySetInterval</span>(<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(...args);</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- this指向问题</title>
      <link href="/posts/1207877865.html"/>
      <url>/posts/1207877865.html</url>
      
        <content type="html"><![CDATA[<h3 id="this指向问题">this指向问题<a class="anchor" href="#this指向问题">·</a></h3><p>一句话总结：<strong><code>this</code>指向的是函数运行时的所在的环境对象</strong>，它的绑定机制，就是要找到这个函数的直接调用位置，然后应用绑定的四条规则，当出现满足多个规则时，按照优先级的高低决定最终的绑定规则</p><h4 id="new-显式绑定-隐式绑定-默认绑定">new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定<a class="anchor" href="#new-显式绑定-隐式绑定-默认绑定">·</a></h4><h4 id="1、new-绑定">1、<code>new</code> 绑定<a class="anchor" href="#1、new-绑定">·</a></h4><ul><li>new操作符创建的新对象</li></ul><h4 id="2、显式绑定">2、显式绑定<a class="anchor" href="#2、显式绑定">·</a></h4><p>当想绑定指定的对象，用call/apply/bind：null、undefined时为window，否则是调用他们的那个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    foo.<span class="title function_">call</span>(obj1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(bar, <span class="number">100</span>); <span class="comment">//2  3</span></span><br><span class="line">bar.<span class="title function_">call</span>(obj2); <span class="comment">//4 3 </span></span><br></pre></td></tr></table></figure><ul><li>虽然<code>bar</code>被显示绑定到<code>obj2</code>上，对于<code>bar</code>，<code>function()&#123;…&#125;</code> 中的<code>this</code>确实被绑定到了<code>obj2</code></li><li>而<code>foo</code>因为通过<code>foo.call(obj1)</code>已经显示绑定了<code>obj1</code>，所以在<code>foo</code>函数内，<code>this</code>指向的是<code>obj1</code>，不会因为<code>bar</code>函数内指向<code>obj2</code>而改变自身。所以打印的是<code>obj1.a</code>（即3）。</li></ul><h4 id="3、隐式绑定">3、隐式绑定<a class="anchor" href="#3、隐式绑定">·</a></h4><p>函数的调用是在某个对象上触发的，指向这个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thisTo</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>:thisTo <span class="comment">//通过属性引用this所在函数 </span></span><br><span class="line">&#125;;</span><br><span class="line">data.<span class="title function_">foo</span>(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="4、默认绑定">4、默认绑定<a class="anchor" href="#4、默认绑定">·</a></h4><p>将全局对象绑定 <code>this</code> 上</p><ul><li>全局函数调用、变量访问：指向window，严格模式undefined</li></ul><h4 id="5、this绑定的特殊情况">5、this绑定的特殊情况<a class="anchor" href="#5、this绑定的特殊情况">·</a></h4><h5 id="1-隐式丢失">1. 隐式丢失<a class="anchor" href="#1-隐式丢失">·</a></h5><p>当进行隐式绑定时，<strong>如果进行一次引用赋值或者传参操作，会造成this的丢失</strong>，从而最后将this绑定到全局对象中去。</p><ul><li><p>引用赋值丢失</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thisTo</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>:thisTo <span class="comment">//通过属性引用this所在函数 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;<span class="comment">//全局属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar=obj.<span class="property">foo</span>; <span class="comment">//这里进行了一次引用赋值 </span></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2种写法一样的结果</span></span><br><span class="line"><span class="keyword">var</span> bar;</span><br><span class="line">(bar=obj.<span class="property">foo</span>)();</span><br></pre></td></tr></table></figure><p>因为bar实际上引用的是foo函数本身，跟obj对象没有任何关系,obj对象只是一个中间桥梁。而bar就是一个本身不带a属性的对象，自然最后只能把a绑定到全局对象上了</p></li><li><p>函数传参丢失</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thisTo</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>:thisTo <span class="comment">//通过属性引用this所在函数 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;<span class="comment">//全局属性</span></span><br><span class="line"><span class="built_in">setTimeout</span>(data.<span class="property">foo</span>,<span class="number">100</span>);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>setTimeout(fn,delay) { fn(); } 实际上fn是一个参数传递的引用(fn=data.foo)，与引用丢失原理一样</p></li></ul><p>bind：<strong>为了解决隐式丢失的问题，ES5提供了bind方法，把参数设置为this的上下文并调用原始函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thisTo</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> bar=thisTo.<span class="title function_">bind</span>(data);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h5 id="2-间接引用">2. 间接引用<a class="anchor" href="#2-间接引用">·</a></h5><p>一个定义对象的方法引用另一个对象存在的方法，这种情况下会使得this进行默认绑定</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thisTo</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>:thisTo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newData=&#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">4</span>;</span><br><span class="line">data.<span class="title function_">foo</span>(); <span class="comment">//2</span></span><br><span class="line">(newData.<span class="property">foo</span>=data.<span class="property">foo</span>)() <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>newData.foo=data.foo的返回值是目标函数的引用，因此调用的位置实际上是foo(),根据之前的隐式丢失里面说的原则，这里会应用默认绑定</p><h4 id="6、改变this的方法">6、改变this的方法<a class="anchor" href="#6、改变this的方法">·</a></h4><ul><li>call/bind/apply改变this指向</li><li>通过对象的方法来定义一个函数：this指向实例化对象</li><li>new：构造函数被new了，创建了新对象，构造函数内部的this会指向该</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 箭头函数</title>
      <link href="/posts/4075683688.html"/>
      <url>/posts/4075683688.html</url>
      
        <content type="html"><![CDATA[<h3 id="箭头函数">箭头函数<a class="anchor" href="#箭头函数">·</a></h3><h4 id="1、箭头函数与普通函数的区别">1、箭头函数与普通函数的区别<a class="anchor" href="#1、箭头函数与普通函数的区别">·</a></h4><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li><p>参数处理更自由，函数体的返回值只有一句，可以省略大括号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">void</span> <span class="title function_">doesNotReturn</span>();</span><br></pre></td></tr></table></figure></li></ul><p><strong>（2）箭头函数没有自己的this</strong></p><ul><li>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。</li><li>所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</li></ul><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">a</span>();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.<span class="title function_">b</span>();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">a</span>()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">b</span>()  <span class="comment">// Uncaught TypeError: obj.b is not a constructor</span></span><br></pre></td></tr></table></figure><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fun1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fun1</span>();                     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">apply</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);    <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">bind</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;)();   <span class="comment">// &#x27;Global&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><ul><li>构造函数在new的步骤第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</li></ul><p><strong>（6）箭头函数没有自己的arguments</strong></p><ul><li>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</li></ul><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h4 id="2、箭头函数的this指向">2、箭头函数的this指向<a class="anchor" href="#2、箭头函数的this指向">·</a></h4><ul><li><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值</p></li><li><p>由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 柯里化</title>
      <link href="/posts/428414458.html"/>
      <url>/posts/428414458.html</url>
      
        <content type="html"><![CDATA[<h3 id="柯里化-√">柯里化 √<a class="anchor" href="#柯里化-√">·</a></h3><ul><li>概念：把接收带多个参数的函数转换成接收单个参数的函数，并且返回一个新函数，这个函数会接收余下的参数，并将结果返回</li></ul><h4 id="版本1">版本1<a class="anchor" href="#版本1">·</a></h4><ul><li><p>将所有传入的参数收集起来，再最后通过reduce函数，统一进行累加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addCurry</span> = (<span class="params">...args1</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> args = args1;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">newFunc</span> = (<span class="params">...args2</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//其实每次柯里化的参数都被收集在args里面了。</span></span><br><span class="line">    args = [...args, ...args2]; <span class="comment">//注意这里是args，不是args1</span></span><br><span class="line">    <span class="keyword">return</span> newFunc;<span class="comment">//这里要返回函数，以便能继续传参</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//在传参够了后，再调用这个方法进行累加</span></span><br><span class="line">  newFunc.<span class="property">getResult</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curv</span>) =&gt;</span> prev+curv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addCurry</span>(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>).<span class="title function_">getResult</span>())<span class="comment">//12</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="版本2：">版本2：<a class="anchor" href="#版本2：">·</a></h4><ul><li><p>用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addCurry</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">     <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> <span class="title function_">currying</span>(fn, ...args, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params">a, b</span>) =&gt; a+b;</span><br><span class="line">  <span class="keyword">const</span> curryingFun = <span class="title function_">currying</span>(fun)</span><br><span class="line">  <span class="title function_">curryingFun</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);  <span class="comment">// 1 2 3 </span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- call、apply、bind</title>
      <link href="/posts/4184919567.html"/>
      <url>/posts/4184919567.html</url>
      
        <content type="html"><![CDATA[<h3 id="call、apply、bind-√">call、apply、bind √<a class="anchor" href="#call、apply、bind-√">·</a></h3><h4 id="1、使用上">1、使用上<a class="anchor" href="#1、使用上">·</a></h4><ul><li><p>传参</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数列表， call与apply的区别就是传参形式不同</span></span><br><span class="line">fun.<span class="title function_">call</span>(thisArg, param1, param2, ...)</span><br><span class="line">fun.<span class="title function_">bind</span>(thisArg, param1, param2, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2个参数必须是数组</span></span><br><span class="line">fun.<span class="title function_">apply</span>(thisArg, [param1,param2,...])</span><br></pre></td></tr></table></figure></li><li><p>返回值</p><p>call/apply：<code>fun</code>执行的结果，改变this上下文后马上执行该函数</p><p>bind：返回<code>fun</code>的拷贝，不执行函数，并指定了fun的this指向，保存了fun的参数</p></li><li><p><code>thisArg</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thisArg的值为null/undefined时，非严格模式下，fun中的this指向window对象，严格模式下，fun的this值为undefined</span><br><span class="line">thisArg的值为原始值时，fun的this指向该原始值的包装对象，如 String、Number、Boolean</span><br></pre></td></tr></table></figure></li><li><p>这3个方法的调用者必须是函数，它们是挂载在Function对象上的3个方法，只有函数才有这些方法</p></li></ul><h4 id="2、功能上">2、功能上<a class="anchor" href="#2、功能上">·</a></h4><ul><li>改变函数执行时的this指向</li><li>带来的好处：可以将任意对象设置为任意函数的作用域，这样对象就不用关心方法，而是<strong>借用方法</strong></li></ul><h4 id="3、apply-call的应用场景：">3、apply/call的应用场景：<a class="anchor" href="#3、apply-call的应用场景：">·</a></h4><h5 id="1、判断数据类型">1、判断数据类型<a class="anchor" href="#1、判断数据类型">·</a></h5><p>为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，传递要检查的对象作为第一个参数，称为 <code>thisArg</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="title class_">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure><h5 id="2、类数组借用数组的方法">2、类数组借用数组的方法<a class="anchor" href="#2、类数组借用数组的方法">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;OB&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;Koro1&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">call</span>(arrayLike, <span class="string">&#x27;添加元素1&#x27;</span>, <span class="string">&#x27;添加元素2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLike)</span><br><span class="line"><span class="comment">//&#123;&quot;0&quot;:&quot;OB&quot;,&quot;1&quot;:&quot;Koro1&quot;,&quot;2&quot;:&quot;添加元素1&quot;,&quot;3&quot;:&quot;添加元素2&quot;,&quot;length&quot;:4&#125;</span></span><br></pre></td></tr></table></figure><h5 id="3、apply获取数组最大值最小值">3、apply获取数组最大值最小值<a class="anchor" href="#3、apply获取数组最大值最小值">·</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [15, 6, 12, 13, 16];</span><br><span class="line">const max = Math.max.apply(Math, arr); // 16</span><br><span class="line">const min = Math.min.apply(Math, arr); // 6</span><br></pre></td></tr></table></figure><h5 id="4、继承">4、继承<a class="anchor" href="#4、继承">·</a></h5><p>在子类构造函数中，通过<code>apply/call</code>借用父类构造函数中的属性，并可传参</p><h4 id="4、bind的应用场景">4、bind的应用场景<a class="anchor" href="#4、bind的应用场景">·</a></h4><h5 id="1、保存函数参数">1、保存函数参数<a class="anchor" href="#1、保存函数参数">·</a></h5><p>原理：bind会返回一个函数，它保存了函数的this指向、初始参数，所以每次i的变量会被bind保存</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;.<span class="title function_">bind</span>(<span class="literal">null</span>, i)，i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、绑定this指向，用做回调函数，解决回调函数this丢失问题">2、绑定this指向，用做回调函数，解决回调函数this丢失问题<a class="anchor" href="#2、绑定this指向，用做回调函数，解决回调函数this丢失问题">·</a></h5><h4 id="5、手写call">5、手写call<a class="anchor" href="#5、手写call">·</a></h4><ul><li>获取方法的调用者，通过this拿到，因为函数myCall内部的this指向的是调用者</li><li>其次，拿到谁调用这个函数，其实就是传参的第一个，也就是context上下文</li><li>为上下文context添加这个属性，属性值就是这个函数，让其具备该函数的功能，使用该功能</li><li>使用完，删除该属性，不能改变其上下文</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context, ...arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="variable language_">window</span> <span class="comment">// 指定为 null/undefined时this指向全局对象(浏览器中为window)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//1.Object():将值为原始值（数字字符串布尔值）包装成对象</span></span><br><span class="line">      context = <span class="title class_">Object</span>(context)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> testFn = <span class="title class_">Symbol</span>();  <span class="comment">// 保证属性不会出现同名覆盖的情况</span></span><br><span class="line">  context.<span class="property">testFn</span> = <span class="variable language_">this</span>;  <span class="comment">//添加属性this, this就是调用call的那个函数</span></span><br><span class="line">  <span class="keyword">let</span> result = context.<span class="title function_">testFn</span>(...arr); </span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">testFn</span>;  <span class="comment">// 删除上下文对象的属性</span></span><br><span class="line">  <span class="comment">// 若不删除，result：[ 12, 8, 4, 6, 7, testFn: [Function: push] ]</span></span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">12</span>,<span class="number">8</span>]，;<span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">myCall</span>(arr1,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">// [ 12, 8, 4, 6, 7 ]</span></span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断函数上下文绑定到`window`不够严谨</span></span><br><span class="line">context = context ? <span class="title class_">Object</span>(context) : <span class="variable language_">window</span>; </span><br><span class="line">context = context || <span class="variable language_">window</span>; </span><br><span class="line"><span class="comment">// 会导致：本应该绑定到原始值的实例对象上，却绑到window上</span></span><br><span class="line">handle.<span class="title function_">elseCall</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// window  </span></span><br><span class="line">handle.<span class="title function_">elseCall</span>(<span class="number">0</span>) <span class="comment">// window</span></span><br><span class="line">handle.<span class="title function_">elseCall</span>(<span class="literal">false</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure><h4 id="6、手写Apply">6、手写Apply<a class="anchor" href="#6、手写Apply">·</a></h4><ul><li>与call大致相同，但参数形式不一样；增加了类数组的判断</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      context = <span class="variable language_">window</span> </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      context = <span class="title class_">Object</span>(context) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// JavaScript权威指南判断是否为类数组对象</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isArrayLike</span>(<span class="params">o</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (o &amp;&amp;                                    <span class="comment">// o不是null、undefined等</span></span><br><span class="line">          <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp;                <span class="comment">// o是对象</span></span><br><span class="line">          <span class="built_in">isFinite</span>(o.<span class="property">length</span>) &amp;&amp;                   <span class="comment">// o.length是有限数值</span></span><br><span class="line">          o.<span class="property">length</span> &gt;= <span class="number">0</span> &amp;&amp;                        <span class="comment">// o.length为非负值</span></span><br><span class="line">          o.<span class="property">length</span> === <span class="title class_">Math</span>.<span class="title function_">floor</span>(o.<span class="property">length</span>) &amp;&amp;    <span class="comment">// o.length是整数</span></span><br><span class="line">          o.<span class="property">length</span> &lt; <span class="number">4294967296</span>)                  <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  context.<span class="property">testFn</span> = <span class="variable language_">this</span>; <span class="comment">// 隐式绑定this指向到context上</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="variable language_">arguments</span>[<span class="number">1</span>]; <span class="comment">// 获取参数数组</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="comment">// 处理传进来的第二个参数</span></span><br><span class="line">  <span class="keyword">if</span> (args) &#123;</span><br><span class="line">      <span class="comment">// 是否传递第二个参数</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(args) &amp;&amp; !<span class="title function_">isArrayLike</span>(args)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;myApply 第二个参数不为数组并且不为类数组对象抛出错误&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          args = <span class="title class_">Array</span>.<span class="title function_">from</span>(args) <span class="comment">// 转为数组</span></span><br><span class="line">          result = context.<span class="title function_">testFn</span>(...args); <span class="comment">// 执行函数并展开数组，传递函数参数，注意要展开</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = context.<span class="title function_">testFn</span>(); <span class="comment">// 执行函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">testFn</span>; <span class="comment">// 删除上下文对象的属性</span></span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、手写bind：">7、手写bind：<a class="anchor" href="#7、手写bind：">·</a></h4><ul><li><p>bind() 方法会创建一个新函数。当这个新函数被调用时，<strong>bind() 的第一个参数将作为它运行时的 this</strong>，之后的一序列参数将会在传递的实参前传入作为它的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context,...args1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> _this = <span class="variable language_">this</span>   <span class="comment">// _this就是bind函数的调用者</span></span><br><span class="line">  <span class="comment">// bind函数的调用后，返回一个新函数,既可以new，也可以直接调用</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否用于构造函数</span></span><br><span class="line">    <span class="comment">// this是F的调用者，当它是普通调用时this指向函数调用者，</span></span><br><span class="line">    <span class="comment">// 做构造函数时指向那个实例对象 context</span></span><br><span class="line">    context = <span class="variable language_">this</span> <span class="keyword">instanceof</span> F? <span class="attr">this</span>: <span class="title class_">Object</span>(context);</span><br><span class="line">    <span class="keyword">return</span> _this.<span class="title function_">apply</span>(context, args1.<span class="title function_">concat</span>(args2))</span><br><span class="line">  &#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(_this.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//弄个中间值</span></span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">&#x27;v in window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">value</span>: <span class="string">&#x27;v in obj&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFunc = func.<span class="title function_">bind</span>(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="title function_">newFunc</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>); </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 节流、防抖</title>
      <link href="/posts/3067404590.html"/>
      <url>/posts/3067404590.html</url>
      
        <content type="html"><![CDATA[<h3 id="防抖与节流">防抖与节流<a class="anchor" href="#防抖与节流">·</a></h3><h4 id="1、防抖">1、防抖<a class="anchor" href="#1、防抖">·</a></h4><ul><li><p>单位时间n秒内，操作很多次，命中最后一次。会无限的延迟，不断刷新定时器的一个东西</p></li><li><p>应用场景：</p><ul><li>窗口大小变化，调整样式</li><li>搜索框，输入后1000毫秒搜索</li><li>表单验证，输入1000毫秒后验证</li></ul></li></ul><h5 id="1、基本实现：">1、基本实现：<a class="anchor" href="#1、基本实现：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn 是需要防抖处理的函数,wait 是时间间隔</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait = <span class="number">50</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;    <span class="comment">//  let还是var都没有关系，为什么呢？？？</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;透传的参数&#x27;</span>, ...args, <span class="variable language_">this</span>); <span class="comment">// 123  document</span></span><br><span class="line">    </span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)  <span class="comment">// 清除定时器，重新设置定时器</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//注意这个箭头函数的this指向的是闭包函数的调用者，而不是debounce的调用者</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer&#x27;</span>,<span class="variable language_">this</span>);  <span class="comment">// document，疯狂点击后，最后一次才执行1</span></span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)  </span><br><span class="line">      &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了防抖函数&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// document，疯狂点击后，最后一次才执行1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">debounce</span>(test, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">betterFn</span>(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><ul><li>在<code>debounce</code>函数中返回一个闭包，这里用的普通<code>function</code>，里面的<code>setTimeout</code>则用的箭头函数，这样做的意义是让<code>this</code>的指向准确，<code>this</code>的真实指向并非<code>debounce</code>的调用者，而是返回闭包的调用者。<strong>对传入闭包的参数进行透传。</strong></li></ul><h5 id="2、加标志位，触发第一次">2、加标志位，触发第一次<a class="anchor" href="#2、加标志位，触发第一次">·</a></h5><ul><li><p>有时候需要<strong>让函数立即执行一次，再等后面事件触发后等待<code>n</code>秒执行</strong>，给<code>debounce</code>函数一个<code>flag</code>用于标示是否立即执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait = <span class="number">50</span>, flag</span>) &#123;</span><br><span class="line">  <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer) </span><br><span class="line">    <span class="comment">// 当定时器变量timer为空时，说明是第一次执行，我们立即执行它</span></span><br><span class="line">    <span class="keyword">if</span> (!timer &amp;&amp; flag)&#123;</span><br><span class="line">    fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)  </span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、节流">2、节流<a class="anchor" href="#2、节流">·</a></h4><ul><li><p>连续触发事件，n秒内只执行1次函数并一定会执行1次，需要设置标识位，看能不能触发事件</p></li><li><p>应用场景：</p><ul><li>onresize、mousemove、滚动事件等事件中使用，防止过多的请求造成服务器压力</li></ul></li></ul><h5 id="1、定时器版本">1、定时器版本<a class="anchor" href="#1、定时器版本">·</a></h5><p>第一次事件不会触发，最后一次一定触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="keyword">function</span>(<span class="params">func, wait</span>) &#123;            </span><br><span class="line">      <span class="keyword">var</span> timer = <span class="literal">null</span>;            </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;                 </span><br><span class="line">          <span class="keyword">if</span> (!timer) &#123;                    </span><br><span class="line">              timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">                  timer = <span class="literal">null</span>;  </span><br><span class="line">                  func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">              &#125;, wait);             </span><br><span class="line">          &#125;            </span><br><span class="line">      &#125;        </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="2、时间戳版本">2、时间戳版本<a class="anchor" href="#2、时间戳版本">·</a></h5><p>第一次事件肯定触发，最后一次不会触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, wait = <span class="number">50</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">      <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - previous &gt; wait) &#123;</span><br><span class="line">          previous = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">          fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> betterFn = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 函数执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">setInterval</span>(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h5 id="3、定时器和时间戳的结合版">3、定时器和时间戳的结合版<a class="anchor" href="#3、定时器和时间戳的结合版">·</a></h5><ul><li><p>也相当于节流和防抖的结合版，第一次和最后一次都会触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - previous &gt; time) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">      previous = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 作用域、作用域链</title>
      <link href="/posts/235914813.html"/>
      <url>/posts/235914813.html</url>
      
        <content type="html"><![CDATA[<h3 id="作用域、作用域链">作用域、作用域链<a class="anchor" href="#作用域、作用域链">·</a></h3><h4 id="1、全局作用域：">1、全局作用域：<a class="anchor" href="#1、全局作用域：">·</a></h4><ul><li>直接编写在script标签中的JS代码，都在全局作用域</li><li>全局作用域在页面打开时创建，在页面关闭时销毁</li><li>在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用</li><li>在全局作用域中：创建的变量都会作为window对象的属性保存；创建的函数都会作为window对象的方法保存</li><li>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到</li></ul><h4 id="2、函数作用域：">2、函数作用域：<a class="anchor" href="#2、函数作用域：">·</a></h4><ul><li><p>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</p></li><li><p>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的</p></li><li><p>在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量</p></li><li><p>当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用；</p><p>如果没有则向上一级作用域中寻找，直到找到全局作用域；</p><p>如果全局作用域中依然没有找到，则会报错ReferenceError</p></li><li><p><strong>【注意大坑】：</strong></p><ol><li><p><strong>使用var关键字声明的变量或函数声明，会在函数中所有的代码执行之前被声明</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在函数中，不适用var声明的变量都会成为全局变量</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cc&#x27;</span>+c); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">45</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cc&#x27;</span>+c); <span class="comment">// 123</span></span><br><span class="line">  c = <span class="number">45</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  d = <span class="number">123</span>;  <span class="comment">// 没有使用关键字声明，会weiwindow属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dd&#x27;</span>+d); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义形参就相当于在函数作用域中声明了变量</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">// 相当于 var e;</span></span><br><span class="line">  <span class="title function_">alert</span>(e);   <span class="comment">//值为undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="3、块级作用域：ES6">3、块级作用域：ES6<a class="anchor" href="#3、块级作用域：ES6">·</a></h4><ul><li><p>不合理性：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量    for循环定时器</li></ul></li><li><p>{}内的只能访问{}内的，不能跨块访问</p></li><li><p><strong>不用担心变量重名，也不用担心外界干扰</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数- 闭包</title>
      <link href="/posts/686254810.html"/>
      <url>/posts/686254810.html</url>
      
        <content type="html"><![CDATA[<h3 id="2、闭包-√">2、闭包  √<a class="anchor" href="#2、闭包-√">·</a></h3><h4 id="1、基本概念">1、基本概念<a class="anchor" href="#1、基本概念">·</a></h4><ul><li><p>概念：有权访问另一个函数作用域中的变量的函数；函数 <code>A</code> 内部有一个函数 <code>B</code>，函数 <code>B</code> 可以访问到函数 <code>A</code> 中的变量，那么函数 <code>B</code> 就是闭包</p></li><li><p>为什么可以访问：</p><p>在一个函数内部定义的函数会将其包含函数的活动对象添加到自己的作用域链中，所以闭包才可以去引用到外部的活动对象</p></li><li><p>优点：</p><ul><li>使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)</li><li>让函数外部可以操作(读写)到函数内部的数据(变量/函数)</li><li>可以<strong>把局部变量驻留在内存</strong>中,可以避免使用全局变量，<strong>JS不推荐使用全局变量</strong></li><li>可以在一个函数中再创建个函数，避免了传参的问题</li></ul></li><li><p>缺点：</p><ul><li>内存过度占用</li></ul></li><li><p>可以赋值为null，解除引用；也可以func()();这样使其成为一个立即执行函数，函数中执行完，变量销毁</p></li></ul><h4 id="2、应用场景：">2、应用场景：<a class="anchor" href="#2、应用场景：">·</a></h4><ul><li>在异步任务例如 <code>timer</code> 定时器，事件回调函数处理，<code>Ajax</code> 请求中被作为回调</li><li>防抖、节流、柯里化、bind、立即执行函数</li><li>模块化：<ul><li>具有特定功能的js文件，将所有的数据和功能都封装在一个函数内部(私有的)，</li><li>只向外暴露一个包信n个方法的对象或函数</li><li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</li></ul></li></ul><h4 id="4、常见的闭包：">4、常见的闭包：<a class="anchor" href="#4、常见的闭包：">·</a></h4><h5 id="①-将函数作为另一个函数的返回值">① 将函数作为另一个函数的返回值<a class="anchor" href="#①-将函数作为另一个函数的返回值">·</a></h5><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 1. 将函数作为另一个函数的返回值</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;a++</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> fn2</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> f = <span class="title function_">fn1</span>()</span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="②-将函数作为实参传递给另一个函数调用">② 将函数作为实参传递给另一个函数调用<a class="anchor" href="#②-将函数作为实参传递给另一个函数调用">·</a></h5><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 2. 将函数作为实参传递给另一个函数调用</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">showDelay</span>(<span class="params">msg, time</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(msg)</span><br><span class="line">&gt;&#125;, time)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">showDelay</span>(<span class="string">&#x27;atguigu&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></blockquote><h5 id="③-高阶函数与柯里化">③ 高阶函数与柯里化<a class="anchor" href="#③-高阶函数与柯里化">·</a></h5><h4 id="5、经典的题：">5、经典的题：<a class="anchor" href="#5、经典的题：">·</a></h4><ul><li><h4 id="定时器">定时器<a class="anchor" href="#定时器">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用闭包：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            btnDom.<span class="property">innerHTML</span> = dp[j]; <span class="comment">// dp是斐波那契数列</span></span><br><span class="line">        &#125;, j*<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>(i)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用闭包：立即执行函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          btnDom.<span class="property">innerHTML</span> = dp[j];</span><br><span class="line">      &#125;, j*<span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用let</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    btnDom.<span class="property">innerHTML</span> = dp[i];</span><br><span class="line">  &#125;, i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="点击异步回调函数">点击异步回调函数<a class="anchor" href="#点击异步回调函数">·</a></h4></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> op = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; op.<span class="property">length</span>; j++) &#123;</span><br><span class="line">  op[j].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(j);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决1：利用闭包：立即执行函数">解决1：利用闭包：立即执行函数<a class="anchor" href="#解决1：利用闭包：立即执行函数">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; op.<span class="property">length</span>; j++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    op[j].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决2：闭包">解决2：闭包<a class="anchor" href="#解决2：闭包">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; op.<span class="property">length</span>; j++) &#123;</span><br><span class="line">  op[j].<span class="property">onclick</span> = (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决3：闭包">解决3：闭包<a class="anchor" href="#解决3：闭包">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; op.<span class="property">length</span>; j++) &#123;</span><br><span class="line">  op[j].<span class="property">onclick</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = j;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><h4 id="IIFE-自调用函数">IIFE (自调用函数)<a class="anchor" href="#IIFE-自调用函数">·</a></h4><blockquote><ol><li><p>全称: <code>Immediately-Invoked Function Expression</code> 自调用函数</p></li><li><p>作用:</p></li></ol><ul><li>隐藏实现</li><li>不会污染外部(一般指全局)命名空间</li><li>用它来编码js模块</li></ul><ol start="3"><li>代码示例</li></ol>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> (<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">//匿名函数自调用</span></span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="number">3</span>)</span><br><span class="line"> &#125;)()</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// a is not defined</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//此处前方为何要一个`;`--&gt;因为自调用函数外部有一个()包裹,可能与前方以()结尾的代码被一起认为是函数调用</span></span><br><span class="line"> <span class="comment">//不加分号可能会被认为这样 console.log(a)(IIFE)</span></span><br><span class="line"> ;(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//不会污染外部(全局)命名空间--&gt;举例</span></span><br><span class="line">   <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">test</span> () &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(++a) &#125; <span class="comment">//声明一个局部函数test</span></span><br><span class="line">   <span class="variable language_">window</span>.<span class="property">$</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="keyword">return</span> &#123;<span class="attr">test</span>: test&#125; &#125;<span class="comment">// 向外暴露一个全局函数</span></span><br><span class="line"> &#125;)()</span><br><span class="line">test ()  <span class="comment">//test is not defined</span></span><br><span class="line"> $().<span class="title function_">test</span>() <span class="comment">// 1. $是一个函数 2. $执行后返回的是一个对象</span></span><br></pre></td></tr></table></figure></blockquote><h3 id=""><a class="anchor" href="#">·</a></h3>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数-let、const、var</title>
      <link href="/posts/2580568501.html"/>
      <url>/posts/2580568501.html</url>
      
        <content type="html"><![CDATA[<h3 id="let、var、const">let、var、const<a class="anchor" href="#let、var、const">·</a></h3><h4 id="1、var">1、var<a class="anchor" href="#1、var">·</a></h4><ul><li><p>**有变量提升：**变量可以在声明之前使用，值为undefined，没有暂时性死区</p></li><li><p>**作用域：**没有块级作用域的概念，可以顺着作用域链查找。</p></li><li><p><strong>声明的时候：</strong></p><ul><li>可重复申明，不会报错</li><li>申明变量时，<strong>不用对其赋值</strong></li><li>声明的全局变量会挂在顶层对象下面（window、global）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">b</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，这样的设计缺点：</p><ol><li>没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的</li><li>程序员很容易不知不觉地就创建了全局变量（比如打字出错）；</li><li>顶层对象的属性是到处可以读写的，这非常不利于模块化编程。</li><li>另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</li></ol></li></ul><h4 id="2、Let">2、Let<a class="anchor" href="#2、Let">·</a></h4><ul><li><p><strong>变量不提升</strong>：变量不可以在声明之前使用，会报错reference error</p><p>**暂时性死区：**只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><p>只要块级作用域内存在let、const命令，它声明的变量就“绑定”这个区域，从一开始就形成了封闭作用域不再受外部影响，即使外部有跟它同名的变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 报错 因为本区域有tmp声明变量</span></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// 绑定if这个块级的作用域 不能出现tmp变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**作用域：**只在声明所在的块级作用域{}有效，与const相同</p></li><li><p><strong>声明的时候：</strong></p><ul><li>同一作用域不能对同一变量重复申明；</li><li>申明变量时，<strong>不用对其赋值</strong></li></ul></li><li><p><strong>let、const不会挂在顶层对象下面</strong></p><p>ES6 为了改变上述缺点，规定：</p><ol><li>为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；</li><li><code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;   全局变量<span class="string">`a`</span>由<span class="string">`var`</span>命令声明，所以它是顶层对象的属性；</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;  全局变量<span class="string">`b`</span>由<span class="string">`let`</span>命令声明，所以它不是顶层对象的属性，返回<span class="string">`undefined`</span>。</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">b</span> <span class="comment">// undefined   </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、const">3、const<a class="anchor" href="#3、const">·</a></h4><ul><li><p><strong>变量不提升</strong>：变量不可以在声明之前使用，会报错reference error</p><p>**暂时性死区：**只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><p>只要块级作用域内存在let、const命令，它声明的变量就“绑定”这个区域，从一开始就形成了封闭作用域不再受外部影响，即使外部有跟它同名的变量</p></li><li><p>**作用域：**只在声明所在的块级作用域有效，与let相同</p></li><li><p><strong>声明的时候：</strong></p><ul><li>同一作用域不能对同一变量重复申明；</li><li>申明变量时，<strong>必须对其赋值</strong></li></ul></li><li><p>let、const不会挂在顶层对象下面</p></li><li><p><strong>申明的变量赋值后不可更改</strong></p><ul><li><p>赋值为基本数据类型，就不能改值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">a = <span class="string">&#x27;string&#x27;</span> <span class="comment">//报错</span></span><br></pre></td></tr></table></figure></li><li><p>赋值为引用数据类型，变量是一个指针，指针指向不能改，永远指向堆中某个对象，但是这个对象本身能改，也就是说<strong>不能给这个变量赋值另一个对象</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(&#x27;Hello&#x27;); // 可执行</span><br><span class="line">a.length = 0;    // 可执行</span><br><span class="line">a = [&#x27;Dave&#x27;];    // 报错</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;);</span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;  </span><br></pre></td></tr></table></figure><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">constantize</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      <span class="title function_">constantize</span>( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的0.1+0.2</title>
      <link href="/posts/2217063026.html"/>
      <url>/posts/2217063026.html</url>
      
        <content type="html"><![CDATA[<h3 id="0-1-0-2-0-3">0.1+0.2 !=0.3<a class="anchor" href="#0-1-0-2-0-3">·</a></h3><ul><li><p>0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数</p></li><li><p>在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。保存格式如下：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cb225cf71d748a8b2d6a5615e402711~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom: 50%;" /><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul></li><li><p>所以双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><ul><li><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="number">10011.</span>..</span><br></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="number">2</span>^-<span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure><p><strong>指数位是负数，该如何保存</strong>呢？</p></li></ul></li><li><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1111111011</span> <span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure><h4 id="如何实现0-1-0-2-0-3呢？">如何实现0.1+0.2=0.3呢？<a class="anchor" href="#如何实现0-1-0-2-0-3呢？">·</a></h4><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numberepsilon</span>(<span class="params">arg1,arg2</span>)&#123;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(arg1 - arg2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numberepsilon</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的Symbol特性</title>
      <link href="/posts/1405183845.html"/>
      <url>/posts/1405183845.html</url>
      
        <content type="html"><![CDATA[<h3 id="4、补充Symbol">4、补充Symbol<a class="anchor" href="#4、补充Symbol">·</a></h3><ul><li><code>ES6</code>中新加入的一种原始类型，每个从Symbol()返回的symbol值都是唯一的。</li><li>一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的</li></ul><h4 id="特性1：独一无二">特性1：独一无二<a class="anchor" href="#特性1：独一无二">·</a></h4><ul><li>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="title class_">Symbol</span>();  <span class="comment">// Symbol() </span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="title class_">Symbol</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;ConardLi&#x27;</span>&#125;); <span class="comment">// Symbol([object Object])</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sym2 === sym3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</li></ul><blockquote><p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="特性2：原始类型">特性2：原始类型<a class="anchor" href="#特性2：原始类型">·</a></h4><p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Symbol</span>(); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="特性3：不可枚举">特性3：不可枚举<a class="anchor" href="#特性3：不可枚举">·</a></h4><ul><li><p>使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性</p></li><li><p>调用<code>for...in</code>、<code>Object.getOwnPropertyNames、Object.keys()</code>不能获取<code>Symbol</code>属性</p></li><li><p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性，会变成一个数组集</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;ConardLi&#x27;</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&#x27;name2&#x27;</span>)]:<span class="string">&#x27;code秘密花园&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj); <span class="comment">// [&quot;name&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj); <span class="comment">// [&quot;name&quot;]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj) <span class="comment">// [Symbol(name)]</span></span><br></pre></td></tr></table></figure><h4 id="2、应用场景">2、应用场景<a class="anchor" href="#2、应用场景">·</a></h4><h5 id="1、应用一：防止XSS">1、应用一：防止XSS<a class="anchor" href="#1、应用一：防止XSS">·</a></h5><ul><li><p>在React中，我们所写的JSX实际上是babel 解析时，调用React.createElement，转换成 <code>ReactElement</code>对象</p></li><li><p>这个对象里，有type、props、key、ref属性，还有一个<code>$$typeof</code>属性，就是在这个过程中添加的：它是一个<code>Symbol</code>类型的变量，值为变量 REACT_ELEMENT_TYPE</p><ul><li><p>如果当前浏览器支持 Symbol ，则 <code>REACT_ELEMENT_TYPE </code>为 Symbol 类型的变量，否则为 16 进制的数字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">REACT_ELEMENT_TYPE</span> =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="title class_">Symbol</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title class_">Symbol</span>.<span class="property">for</span> &amp;&amp; <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;react.element&#x27;</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>React</code>渲染时会把没有<code>$$typeof</code>标识，以及规则校验不通过的组件过滤掉，通过<code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReactElement</span>.<span class="property">isValidElement</span> = <span class="keyword">function</span> (<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">&#x27;object&#x27;</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.<span class="property">$$typeof</span> === <span class="variable constant_">REACT_ELEMENT_TYPE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>**添加这个属性的意义： **           安全</p><p>基于以下几个共识：</p><ol><li>数据库是不能存储<code>Symbol</code>类型的变量，所以用户恶意存入的数据是无法带有合法的 <code>$$typeof</code>字段的</li><li>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="keyword">let</span> expectedTextButGotJSON = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">dangerouslySetInnerHTML</span>: &#123;</span><br><span class="line">      <span class="attr">__html</span>: <span class="string">&#x27;/* put your exploit here */&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> message = &#123; <span class="attr">text</span>: expectedTextButGotJSON &#125;;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;message.text&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2、应用二：私有属性">2、<strong>应用二：私有属性</strong><a class="anchor" href="#2、应用二：私有属性">·</a></h5><ul><li>借助<code>Symbol</code>类型的不可枚举，可以在类中模拟私有属性，控制变量读写</li><li><strong>因为通过 Symbol 作为属性名的属性，在常规的属性遍历和获取方法中，并不能够查询到</strong></li><li>在使用者不看内部代码的情况下，通过正常方法是无法获取和使用到这些属性的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> privateField = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>[privateField] = <span class="string">&#x27;ConardLi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getField</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[privateField];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setField</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>[privateField] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、应用三：防止属性污染">3、应用三：防止属性污染<a class="anchor" href="#3、应用三：防止属性污染">·</a></h5><ul><li>为对象添加一个属性，可能造成属性覆盖</li><li>用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。在手写call中有应用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数据类型转换</title>
      <link href="/posts/219349139.html"/>
      <url>/posts/219349139.html</url>
      
        <content type="html"><![CDATA[<h3 id="3-1、类型转换1-基本">3.1、类型转换1(基本)<a class="anchor" href="#3-1、类型转换1-基本">·</a></h3><ul><li>两种转换形式：<strong>显式类型转换</strong>和<strong>隐式类型转换</strong></li><li>三种转换结果：<strong>Number</strong> 、<strong>String</strong> 、<strong>Boolean</strong></li></ul><h4 id="3-1-1、转string">3.1.1、转string<a class="anchor" href="#3-1-1、转string">·</a></h4><h5 id="1、String-函数：强制转换">1、String()函数：强制转换<a class="anchor" href="#1、String-函数：强制转换">·</a></h5><ul><li><strong>对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串；</strong></li><li><strong>对于null值，直接转换为字符串&quot;null&quot;。对于undefined直接转换为字符串&quot;undefined&quot;</strong>  ，结果如下</li></ul><table><thead><tr><th><strong>参数类型</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>Undefined</td><td><strong>“undefined”</strong></td></tr><tr><td>Null</td><td><strong>“null”</strong></td></tr><tr><td>Boolean</td><td><strong>true</strong>返回**“true”<strong>,<strong>false</strong>返回</strong>&quot;false&quot;**</td></tr><tr><td><strong>Number</strong></td><td>情况比较复杂</td></tr><tr><td>String</td><td>没转换</td></tr></tbody></table><ul><li>Number的补充说明：<ol><li>NaN，转换为&quot;NaN&quot;</li><li>+0/-0，转换为&quot;0&quot;</li><li>Infinity，转换为&quot;Infinity&quot;</li><li><strong>会发生进制转换</strong></li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(<span class="title class_">NaN</span>));         <span class="comment">//&quot;NaN&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(-<span class="number">0</span>));          <span class="comment">//&quot;0&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(+<span class="number">0</span>));          <span class="comment">//&quot;0&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(-<span class="title class_">Infinity</span>));   <span class="comment">//&quot;-Infinity&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(<span class="title class_">Infinity</span>));    <span class="comment">//&quot;Infinity&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(<span class="number">0xf</span>));         <span class="comment">//&quot;15&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(<span class="number">070</span>));         <span class="comment">//&quot;56&quot;  转成8进制</span></span><br></pre></td></tr></table></figure><h5 id="2、-toString-方法：强制转换">2、.toString()方法：强制转换<a class="anchor" href="#2、-toString-方法：强制转换">·</a></h5><ol><li>Boolean、Number、String是基本包装类型，有toString方法，转换规则和String是一样的</li><li>**null和undefined没有toString方法，**所以没法转换，会报错</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((-<span class="number">0</span>).<span class="title function_">toString</span>());         <span class="comment">//&quot;0&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="title class_">NaN</span>).<span class="title function_">toString</span>());        <span class="comment">//&#x27;NaN&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">0xf</span>).<span class="title function_">toString</span>());        <span class="comment">//&#x27;15&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">070</span>).<span class="title function_">toString</span>());        <span class="comment">//&#x27;56&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((-<span class="title class_">Infinity</span>).<span class="title function_">toString</span>());  <span class="comment">//&#x27;-Infinity&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="3、隐式转换：">3、隐式转换： +<a class="anchor" href="#3、隐式转换：">·</a></h5><ul><li><strong>为任意的数据类型 +“”</strong>  ， 原理：和String()函数一样</li></ul><h4 id="3-1-2、转number">3.1.2、转number<a class="anchor" href="#3-1-2、转number">·</a></h4><p><code>Number()</code> / <code>parseFloat()</code> / <code>parseInt()</code></p><h5 id="1、Number-：强制转换">1、Number()：强制转换<a class="anchor" href="#1、Number-：强制转换">·</a></h5><p>如果传入参数，调用底层函数<strong>ToNumber()</strong>，如果未传入参数，返回0：</p><table><thead><tr><th><strong>参数类型</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>Undefined</td><td><strong>NaN</strong></td></tr><tr><td>Null</td><td><strong>+0</strong></td></tr><tr><td>Boolean</td><td><strong>true</strong>返回<strong>1</strong>，<strong>false</strong>返回**+0**</td></tr><tr><td>Number</td><td>就是输入的参数了</td></tr><tr><td>String</td><td><strong>情况比较复杂</strong></td></tr></tbody></table><p>补充String类型：</p><ol><li><p>如果字符串中只包含数字**(包括前面带正号或负号的情况)**，则将其转换为十进制数值：</p><p>即&quot;1&quot; 会变成 1，&quot;123&quot;会变成 123，而&quot;011&quot;会变成 11**(注意:前导的零被忽略了)**;</p></li><li><p>如果字符串中包含<strong>有效的浮点格式</strong>，如&quot;1.1&quot;，则将其转换为对应的浮点数值(同样，也会忽略前导零);</p></li><li><p>如果字符串中包含有效的<strong>十六进制格式</strong>，例如&quot;0xf&quot;，则将其转换为相同大小的<strong>十进制整数值</strong>;</p></li><li><p>如果字符串是<strong>空串或纯空格</strong>，则将其转换为0;</p></li><li><p>如果字符串中包含除上述格式之外的字符，则将其转换为NaN。</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;123&quot;</span>)) <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;-123&quot;</span>)) <span class="comment">// -123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;1.2&quot;</span>)) <span class="comment">// 1.2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;000123&quot;</span>)) <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;-000123&quot;</span>)) <span class="comment">// -123</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;0x11&quot;</span>)) <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot; &quot;</span>)) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;123 123&quot;</span>)) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;foo&quot;</span>)) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;100a&quot;</span>)) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h5 id="2、parseFloat-：强制转换">2、parseFloat() ：强制转换<a class="anchor" href="#2、parseFloat-：强制转换">·</a></h5><p>专门针对<strong>字符串转数字</strong>的情况，因为用Number()转字符串的时候，复杂又不合理</p><ul><li><p>忽略<strong>前导空格</strong>，第一个不为空的字符如果不是<strong>数字/正负号</strong>，就返回NaN；</p></li><li><p>解析后续字符直到遇到不是数字的字符，后面的字符全部忽略，返回之前的数字</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;  +3&#x27;</span>)     <span class="comment">//+3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>)         <span class="comment">//空字符串，NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27; &#x27;</span>)        <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;*12&#x27;</span>)      <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123blue&#x27;</span>)  <span class="comment">//123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">2.25</span>)       <span class="comment">//2，&#x27;.&#x27;不是数字，小数点后面都被忽略了</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xf&#x27;</span>)      <span class="comment">//15，十六进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;070&#x27;</span>)      <span class="comment">//70，八进制，但是ES5认为这是70</span></span><br></pre></td></tr></table></figure></li><li><p>如果对非String使用parseInt()或parseFloat()，它会<strong>先将其转换为String</strong>然后在操作 parseInt() ，可以将<strong>一个字符串中的有效的整数位</strong>提取出来，并转换为Number ， 例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123.456px&quot;</span>;  </span><br><span class="line">a = <span class="built_in">parseInt</span>(a); <span class="comment">//123  </span></span><br></pre></td></tr></table></figure></li><li><p>第二个参数可以指定进制</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;070&#x27;</span>,<span class="number">8</span>)  <span class="comment">//56</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3、parseFloat-强制转换">3、parseFloat()  强制转换<a class="anchor" href="#3、parseFloat-强制转换">·</a></h5><p>专门针对<strong>字符串转数字</strong>的情况，因为用Number()转字符串的时候，复杂又不合理</p><ul><li><p>忽略<strong>前导0和空格</strong>，第一个不为空的字符如果不是<strong>数字/正负号</strong>，就返回NaN；</p></li><li><p>解析后续字符，<strong>第一次遇到小数点有效，第二次就无效了</strong>，其他非数字字符第一次就无效，返回前面的数字</p></li><li><p><strong>只解析十进制</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;  +3&#x27;</span>));    <span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;  -3&#x27;</span>));    <span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>));        <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27; &#x27;</span>));       <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;*12&#x27;</span>));     <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;123blue&#x27;</span>)); <span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="number">2.25</span>));      <span class="comment">//2.25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;2.25.4&#x27;</span>));  <span class="comment">//2.25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;0xf&#x27;</span>));     <span class="comment">//0，遇到十六进制都是0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;070&#x27;</span>));     <span class="comment">//70</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="4、隐式转换">4、隐式转换  +<a class="anchor" href="#4、隐式转换">·</a></h5><p>使用一元的+来进行隐式的类型转换，<strong>原理：和Number()函数一样</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123&quot;</span>;  </span><br><span class="line">a = +a;  </span><br></pre></td></tr></table></figure><h4 id="3-1-3、转boolean">3.1.3、转boolean<a class="anchor" href="#3-1-3、转boolean">·</a></h4><ul><li>字符串 &gt; 布尔   除了空串其余全是true</li><li>数值 &gt; 布尔      除了0和NaN其余的全是true</li><li>null、undefined &gt; 布尔 都是false</li><li>对象 &gt; 布尔  ，都是true</li></ul><h5 id="1、显式转换">1、显式转换<a class="anchor" href="#1、显式转换">·</a></h5><ul><li>Boolean()：<strong>有6种值会被转换为false，其余均为true</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下都是false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>());  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">false</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">null</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="title class_">NaN</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(-<span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(+<span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27; &#x27;</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="2、隐式转换：！！">2、隐式转换：！！<a class="anchor" href="#2、隐式转换：！！">·</a></h5><p><strong>为任意的数据类型做两次非运算，即可将其转换为布尔值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">a = !!a; <span class="comment">//true </span></span><br></pre></td></tr></table></figure><h3 id="3-2、如何隐式转换的？">3.2、如何隐式转换的？<a class="anchor" href="#3-2、如何隐式转换的？">·</a></h3><h4 id="1、ToPrimitive方法：">1、<code>ToPrimitive</code>方法：<a class="anchor" href="#1、ToPrimitive方法：">·</a></h4><ul><li><p><code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值</p><ul><li>如果值为基本类型，则直接返回值本身；</li><li>如果值为对象，则：ToPrimitive(obj,type)</li></ul></li><li><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul></li></ul><p>两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">objToNumber</span> = value =&gt; <span class="title class_">Number</span>(value.<span class="title function_">valueOf</span>().<span class="title function_">toString</span>())</span><br><span class="line"><span class="title function_">objToNumber</span>([]) === <span class="number">0</span></span><br><span class="line"><span class="title function_">objToNumber</span>(&#123;&#125;) === <span class="title class_">NaN</span></span><br></pre></td></tr></table></figure><h5 id="2、toString">2、toString()<a class="anchor" href="#2、toString">·</a></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">val</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> x++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">var</span> e = <span class="regexp">/\d+/g</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>());  <span class="comment">//&#x27;1,2,3&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="title function_">toString</span>());  <span class="comment">//&quot;[object object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">toString</span>());  <span class="comment">//&#x27;function(x)&#123; return x++ &#125;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="title function_">toString</span>());  <span class="comment">//Thu Apr 09 2020 17:55:26 GMT+0800 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="title function_">toString</span>());  <span class="comment">///\d+/g</span></span><br></pre></td></tr></table></figure><h5 id="3、valueOf">3、valueOf()<a class="anchor" href="#3、valueOf">·</a></h5><ol><li>无论是哪种数据类型，返回参数本身，类型也不会变化，唯一特殊的是<strong>Date对象</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">valueOf</span>());  <span class="comment">//1586426466217，1970.1.1距今的毫秒数</span></span><br></pre></td></tr></table></figure><ol start="2"><li>包装类型Number、String、Boolean，也是Object类，用valueOf后类型转换为<strong>基本数据类型</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">12</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> <span class="title class_">Number</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> <span class="title class_">Object</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">valueOf</span>());          <span class="comment">//12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> c.<span class="title function_">valueOf</span>());   <span class="comment">//Number</span></span><br></pre></td></tr></table></figure><h5 id="4、隐式转换发生的场景">4、隐式转换发生的场景<a class="anchor" href="#4、隐式转换发生的场景">·</a></h5><p>隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而<strong>这些运算符只能操作基本类型值</strong>，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成<strong>基本类型</strong>，再进行操作</p><h4 id="1、-a">1、+a<a class="anchor" href="#1、-a">·</a></h4><p>调用<strong>ToNumber()</strong>，对+后面的数据进行转换</p><ul><li><h5 id="基本数据类型：">基本数据类型：<a class="anchor" href="#基本数据类型：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&#x27;12.3&#x27;</span>);    <span class="comment">//12.3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&#x27;-12.3&#x27;</span>);   <span class="comment">//-12.3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&#x27;&#x27;</span>);        <span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="literal">true</span>);      <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="literal">null</span>);      <span class="comment">//+0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="literal">undefined</span>); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li><li><h5 id="对象：">对象：<a class="anchor" href="#对象：">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+[]);        <span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+[ ]);       <span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+[<span class="number">1</span>]);       <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+[<span class="number">1</span>,<span class="number">2</span>]);     <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+&#123;&#125;);        <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+&#123;<span class="attr">val</span>: <span class="string">&#x27;happy&#x27;</span>&#125;); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="keyword">new</span> <span class="title class_">Date</span>());     <span class="comment">//1586433193168，1970.1.1距今毫秒数</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2、二元运算符a-b-、-、">2、二元运算符a+b <code>-</code>、<code>*</code>、<code>\</code><a class="anchor" href="#2、二元运算符a-b-、-、">·</a></h4><p>left = ToPrimitive(a)，right = ToPrimitive(b)，a和b是基本数据类型的话，left = a，right = b</p><ol><li><p><strong>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型</strong></p></li><li><p>其他情况下两边的变量都会被转换为数字。</p><p>当一侧为<code>Number</code>类型，另一侧为<strong>原始类型</strong>，则将原始类型转换为<code>Number</code>类型</p><p>两个数字相加遵循以下规则：</p><ol><li>如果有一个操作数是 NaN，则结果是 NaN</li><li>Infinity + Infinity = Infinity、(-Infinity) + (-Infinity )= -Infinity、Infinity + (-Infinity) = NaN</li><li>(+0) + (+0) = +0、(-0) +(-0) = -0、(+0) + (-0) = +0</li></ol></li><li><p>当一侧为<code>Number</code>类型，另一侧为<strong>引用类型</strong>，将引用类型和<code>Number</code>类型转换成字符串后拼接</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>+<span class="number">123</span>);  <span class="comment">//&#x27;1123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>+<span class="number">1</span>);   <span class="comment">//1，两个都不是字符串，所以null转换为0，和1相加</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([]+[]);    <span class="comment">//&#x27;&#x27;，经过ToPrimitive得到&#x27;&#x27;+&#x27;&#x27; = &#x27;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="string">&#x27;1&#x27;</span>]+<span class="number">1</span>);  <span class="comment">//&#x27;11&#x27;，经过ToPrimitive得到&#x27;1&#x27;+1 = &#x27;11&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([]+&#123;&#125;);    <span class="comment">//&#x27;[object Object]&#x27;，经ToPrimitive得&#x27;&#x27;+&#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>NaN</code>也是一个数字</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="string">&#x27;23&#x27;</span> <span class="comment">// 23</span></span><br><span class="line"> <span class="number">1</span> * <span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"> <span class="number">1</span> / <span class="string">&#x27;aa&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h4 id="3、-、-、">3、==  、 === 、!=<a class="anchor" href="#3、-、-、">·</a></h4><ul><li><p>三等号（===）相等判断时，如果两边类型不一致时，不会做强制类型准换，直接返false</p></li><li><p>对于 <code>==</code> 来说，**若类型不同，否则会发生隐式转换： **    重要准则</p><ul><li>a和b为 String、Number、Boolean 中的某一类型，则使用 <strong>ToNumber</strong> 函数转化为 Number 类型再进行比较；</li><li>有一个是Object，另一个是 String、Number、Boolean 中的某一类型，则**ToPrimitive(Object)**转换为基础数据类型，再按照上一步比较</li></ul></li><li><p>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></p></li><li><p>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></p></li><li><p>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</p></li><li><p>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c451c19e23dd4726b3f36223b6c18a1e~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:50%;" /></li></ul><h5 id="1、准则1：NaN，和其他任何类型比较永远返回false-包括和他自己">1、准则1：NaN，和其他任何类型比较永远返回<code>false</code>(包括和他自己)<a class="anchor" href="#1、准则1：NaN，和其他任何类型比较永远返回false-包括和他自己">·</a></h5><h5 id="2、准则2：Boolean-Boolean-Number">2、准则2：Boolean             Boolean &lt; Number<a class="anchor" href="#2、准则2：Boolean-Boolean-Number">·</a></h5><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规则3</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">1</span>  <span class="comment">// true </span></span><br><span class="line"><span class="literal">true</span> == <span class="string">&#x27;2&#x27;</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>]  <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;2&#x27;</span>]  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; == &#123;&#125;);    </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] == <span class="literal">false</span>);   <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">0</span>] == <span class="number">0</span>);      <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="string">&#x27;0&#x27;</span>] == <span class="number">0</span>);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>【注意】：</p><p><code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但他们比较结果是<code>false</code>，原因是**<code>false</code>首先被转换成<code>0</code>：**</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>  <span class="comment">// false   bollean先被转换为number</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="3、准则3：String">3、准则3：String  :<a class="anchor" href="#3、准则3：String">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规则3.1</span></span><br><span class="line"><span class="number">123</span> == <span class="string">&#x27;123&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> == <span class="literal">true</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == <span class="literal">false</span>);   <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span> == <span class="number">1</span>);     <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="4、准则4：null和undefined">4、准则4：null和undefined<a class="anchor" href="#4、准则4：null和undefined">·</a></h5><p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a∈&#123;<span class="literal">null</span>,<span class="literal">undefined</span>&#125;且b∈&#123;<span class="literal">null</span>,<span class="literal">undefined</span>&#125;，返回<span class="literal">true</span>，有一个不属于&#123;<span class="literal">null</span>,<span class="literal">undefined</span>&#125;，返回<span class="literal">false</span></span><br><span class="line"><span class="comment">//规则2</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">null</span>);           <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> == <span class="literal">undefined</span>); <span class="comment">//true    </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == &#123;&#125;);             <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h5 id="5、准则5：引用类型">5、准则5：引用类型<a class="anchor" href="#5、准则5：引用类型">·</a></h5><ol><li>a和b为 String、Number、Boolean 中的某一类型，则使用 <strong>ToNumber</strong> 函数转化为 Number 类型再进行比较</li><li>有一个是Object，另一个是 String、Number、Boolean 中的某一类型，则ToPrimitive(Object)转换为基础数据类型，再按照上一步比较</li></ol><ul><li>依照<code>ToPrimitive</code>规则转换为原始类型：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>判断：<code>[] == ![] // true</code><ol><li><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code></li><li><code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等</li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">null</span>] == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">[<span class="literal">undefined</span>] == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">//规则4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">0</span>] == [<span class="string">&#x27;0&#x27;</span>]);  <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> == <span class="number">0</span>);       <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> == <span class="number">0</span>);       <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> == -<span class="number">0</span>);      <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>根据数组的<code>ToPrimitive</code>规则：</p><ul><li>数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code></li></ul><h4 id="3-2、逻辑运算符">3.2、逻辑运算符<a class="anchor" href="#3-2、逻辑运算符">·</a></h4><ul><li><p>注意[]是为真的，所以在数组if判断时要用length</p></li><li><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面6种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span>  <span class="literal">undefined</span>  <span class="string">&#x27;&#x27;</span>   <span class="title class_">NaN</span>  <span class="number">0</span>  <span class="literal">false</span>   </span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1、对象转Number">4.1、对象转Number<a class="anchor" href="#4-1、对象转Number">·</a></h4><p>对象转数字的过程：</p><ol><li>有**valueOf()**方法，就用，结果为基本数据类型就返回，否则下一步</li><li>有**toString()**方法，就用，结果为基本数据类型就返回，否则报错</li><li>得到基本数据类型后，调用<strong>ToNumber(primValue)</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));  <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>([]));       <span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>([<span class="number">0</span>]));      <span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(&#123;<span class="attr">val</span>:<span class="number">4</span>&#125;));  <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(&#123;&#125;));       <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="keyword">function</span>(<span class="params">x</span>)&#123; <span class="keyword">return</span> x++ &#125;)); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="regexp">/\d+/g</span>));   <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><p>试着分析[]和[1,2,3]的情况</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[].<span class="title function_">valueOf</span>() == [],不是基本数据类型</span><br><span class="line">[].<span class="title function_">toString</span>() == <span class="string">&#x27;&#x27;</span>,是基本数据类型</span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27;&#x27;</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3].valueOf() == [1,2,3],不是基本数据类型</span><br><span class="line">[1,2,3].toString() == &#x27;1,2,3&#x27;,是基本数据类型</span><br><span class="line">ToNumber(&#x27;1,2,3&#x27;) == NaN</span><br></pre></td></tr></table></figure><h4 id="4-2、对象转字符串">4.2、对象转字符串<a class="anchor" href="#4-2、对象转字符串">·</a></h4><p>参考转数字的过程，有</p><ul><li>有**toString()**方法，就用，结果为基本数据类型就返回，否则下一步</li><li>有**valueOf()**方法，就用，结果为基本数据类型就返回，否则报错</li><li>得到基本数据类型primValue后，调用<strong>ToString(primValue)</strong>，下面就很熟悉了</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));    <span class="comment">//&#x27;1,2,3&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>([]));         <span class="comment">//一个空格</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>([<span class="number">0</span>]));        <span class="comment">//&#x27;0&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(&#123;<span class="attr">val</span>:<span class="number">4</span>&#125;));    <span class="comment">//&#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(&#123;&#125;));         <span class="comment">//&#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(<span class="keyword">function</span>(<span class="params">x</span>)&#123; <span class="keyword">return</span> x++ &#125;));  <span class="comment">//&#x27;function(x)&#123; return x++ &#125;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()))<span class="comment">//&#x27;Thu Apr 09 2020 19:23:31 GMT+0800 (标准时间)&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(<span class="regexp">/\d+/g</span>));     <span class="comment">//&#x27;/\d+/g&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="4-3、对象转布尔值">4.3、对象转布尔值<a class="anchor" href="#4-3、对象转布尔值">·</a></h4><ul><li><strong>都转为true！包装类型也是！</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数据类型判断</title>
      <link href="/posts/611441247.html"/>
      <url>/posts/611441247.html</url>
      
        <content type="html"><![CDATA[<h3 id="类型判断5种">类型判断5种<a class="anchor" href="#类型判断5种">·</a></h3><h4 id="1、typeOf（适合基本类型）">1、typeOf（适合基本类型）<a class="anchor" href="#1、typeOf（适合基本类型）">·</a></h4><p>typeof是操作符，不是函数，返回一个字符串</p><p>唯一要注意的就是：</p><ol><li><strong>null用typeof返回的是object</strong>，但是这并不意味着null是对象</li><li><strong>函数function用typeof返回的是function</strong>，其余对象都返回object</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">typeOf xxx</span><br><span class="line"><span class="attr">object</span>: <span class="keyword">new</span> <span class="title class_">Array</span>()、 [<span class="number">11</span>] 、<span class="title class_">Object</span> 、 <span class="literal">null</span> 、 <span class="keyword">new</span> <span class="title class_">String</span>()、 <span class="keyword">new</span> <span class="title class_">Number</span>()</span><br><span class="line"><span class="attr">undefined</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="attr">boolean</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">string</span>: <span class="string">&#x27;ssss&#x27;</span></span><br><span class="line"><span class="attr">number</span>: <span class="number">123</span></span><br><span class="line"><span class="attr">function</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2、instanceof：及手写">2、instanceof：及手写<a class="anchor" href="#2、instanceof：及手写">·</a></h4><img src="file:///C:\Users\小虎牙\Documents\Tencent Files\2575329556\Image\Group\5LOKV2$Q28$JYOMV51%$GAA.jpg" alt="img" style="zoom: 25%;" /><ul><li><p><code>A instanceof B</code>：检测B的 <code>prototype</code> 属性是否在A对象的原型链上，缺点：</p><ol><li>不能检测基本数据类型</li><li>检测不准确，判断数组时需要用Array，而不用Object</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span>  <span class="title class_">Foo</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span> <span class="keyword">instanceof</span>  <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span> <span class="keyword">instanceof</span>  <span class="title class_">Function</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="instanceof手写">instanceof手写<a class="anchor" href="#instanceof手写">·</a></h5><ul><li>不断向上取A的__proto__与B的prototype对比</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceOf</span>(<span class="params">A, B</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> A === <span class="string">&#x27;object&#x27;</span>|| A === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> p = A <span class="comment">// 链表遍历</span></span><br><span class="line">  <span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p === B.<span class="property"><span class="keyword">prototype</span></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = p.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="3、isArray">3、isArray<a class="anchor" href="#3、isArray">·</a></h4><p><strong>检测数组的比较好的方式</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr2))  <span class="comment">// true  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj2))  <span class="comment">// false  </span></span><br></pre></td></tr></table></figure><h4 id="4、constructor属性">4、constructor属性<a class="anchor" href="#4、constructor属性">·</a></h4><p>返回创建该对象的构造函数的引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1,2];</span><br><span class="line">console.log(arr.constructor === Array);        //true</span><br><span class="line">console.log(arr.constructor === Object);    //false</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>constructor属性存在原型上面，一旦原型被重写，就不再指向之前的构造函数了</li><li><code>null</code>和<code>undefined</code>是无效的对象,因此是不会有<code>constructor</code>存在的</li></ul><h4 id="5、Object-prototype-toString">5、Object.prototype.toString()<a class="anchor" href="#5、Object-prototype-toString">·</a></h4><p><code>Object.prototype.toString().call(thisArg)</code></p><h5 id="1、执行流程：">1、执行流程：<a class="anchor" href="#1、执行流程：">·</a></h5><ol><li>如果 this 值是 undefined，就返回 [object Undefined]</li><li>如果 this 的值是 null，就返回 [object Null]</li><li>让 O 成为 ToObject(this) 的结果</li><li>让 class 成为 O 的内部属性 [[Class]] 的值</li><li><strong>最后返回由 &quot;[object &quot; 和 class 和 “]” 三个部分组成的字符串</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;          <span class="comment">// [object Number]</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;123&#x27;</span>;      <span class="comment">// [object String]</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">true</span>;      <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="keyword">var</span> und = <span class="literal">undefined</span>;     <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="keyword">var</span> nul = <span class="literal">null</span>;          <span class="comment">// [object Null]</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;         <span class="comment">// [object Object]</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// [object Array]</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();   <span class="comment">// [object Date]</span></span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(); <span class="comment">// [object Error]</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;          <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// [object Function]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">       <span class="comment">//注意调用方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>[i]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkType</span>(number, string, boolean, und, nul, obj, array, date, error, reg, func)</span><br></pre></td></tr></table></figure><h5 id="2、调用这个方法、直接toString的区别">2、调用这个方法、直接toString的区别<a class="anchor" href="#2、调用这个方法、直接toString的区别">·</a></h5><ul><li><h5 id="普通对象Object调用这个方法和直接obj-toString-结果是相同的">普通对象Object调用这个方法和直接obj.toString()结果是相同的<a class="anchor" href="#普通对象Object调用这个方法和直接obj-toString-结果是相同的">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>());                      <span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(a)); <span class="comment">//[object Object]</span></span><br></pre></td></tr></table></figure></li><li><h5 id="其他数据类型就不是：">其他数据类型就不是：<a class="anchor" href="#其他数据类型就不是：">·</a></h5><ol><li>字符串 String 的 toString 方法返回还是本身</li><li>数组 Number 的 toString 方法返回字符串的数字</li><li>数组 Array 的 toString 方法将每个数组元素转换成一个字符串，并在<strong>元素之间添加逗号后合并成结果字符串</strong>。</li><li>函数 Function 的 toString 方法返回源代码字符串。</li><li>日期 Date 的 toString 方法返回一个可读的日期和时间字符串。</li><li>正则表达式 RegExp 的 toString 方法返回一个表示正则表达式直接量的字符串。</li><li>Null 和 Undefined 没有 toString 方法</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;123&#x27;</span>.<span class="title function_">valueOf</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="title function_">toString</span>());                      <span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(b)); <span class="comment">//[object String]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">toString</span>());                      <span class="comment">//1,2,3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(c)); <span class="comment">//[object Array]</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数据类型</title>
      <link href="/posts/1174755164.html"/>
      <url>/posts/1174755164.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型">数据类型<a class="anchor" href="#数据类型">·</a></h3><p>八种数据类型，分别是基本引用类型与基本引用类型</p><h4 id="1-1、原始类型">1.1、原始类型<a class="anchor" href="#1-1、原始类型">·</a></h4><ul><li><p><code>Null</code>：只包含一个值：<code>null</code></p></li><li><p><code>Undefined</code>：只包含一个值：<code>undefined</code></p></li><li><p><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></p></li><li><p><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最大能表示的值：Number.MAX_VALUE=1.7976931348623157e+308</span><br><span class="line">Infinity 正无穷 （大于Number.MAX_VALUE的数字）</span><br><span class="line">-Infinity 负无穷 </span><br><span class="line">NaN 非法数字（Not A Number）</span><br><span class="line">0b 开头表示二进制，但是不是所有的浏览器都支持  </span><br><span class="line">0 开头表示八进制  </span><br><span class="line">0x 开头表示十六进制 </span><br></pre></td></tr></table></figure></li><li><p><code>String</code>：一串表示文本值的字符序列</p></li><li><p><code>Symbol</code>：创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</p></li><li><p><code>BigInt</code>：是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p></li></ul><h4 id="1-2、undefined和null的区别">1.2、undefined和null的区别<a class="anchor" href="#1-2、undefined和null的区别">·</a></h4><ul><li><p>undefined:  表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义，undefined转为数值时为NaN。典型用法：</p><ul><li>变量被声明了，但没有赋值时，就等于undefined</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li><li>对象没有赋值的属性，该属性的值为undefined</li><li>函数没有返回值时，默认返回undefined</li></ul></li><li><p>null:  “没有对象”，即该处不应该有值。<code>null</code>转换为数值时值为<code>0</code>，典型用法：</p><ul><li>作为函数的参数，表示该函数的参数不是对象</li></ul></li><li><p>作为对象原型链的终点</p><ul><li>不会占用内存,在清理内存占用可以使用<code>null</code>赋值</li></ul></li></ul><h4 id="typeof-null">typeof null<a class="anchor" href="#typeof-null">·</a></h4><p>typeof null 的结果是Object。</p><ul><li><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  1: int      - 当前存储的数据是一个 31 位的有符号整数。</span><br><span class="line">010: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line">100: string   - 当前存储的数据指向一个字符串。</span><br><span class="line">110: boolean  - 当前存储的数据是布尔值。</span><br></pre></td></tr></table></figure></li></ul><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h4 id="1-3、原始值特点">1.3、原始值特点<a class="anchor" href="#1-3、原始值特点">·</a></h4><ul><li>按值访问，变量以变量的标识符和变量的值的形式保存在栈内存中，<strong>栈内存的特点</strong>：<ul><li>存储的值大小固定</li><li>空间较小</li><li>可以直接操作其保存的变量，运行效率高</li><li>由系统自动分配存储空间</li></ul></li><li>值本身是不可被改变的，被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间<ul><li>比如操作字符串，是在原字符串的基础上产生了一个新字符串，而非直接去改变<code>str</code></li></ul></li><li>如果值相等，即返回<code>true</code></li><li>函数传参：参数<strong>仅仅是被传入变量复制给了的一个局部变量</strong>，改变这个局部变量不会对外部变量产生影响</li><li>原始类型不能扩展属性和方法，每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而能够调用一些方法和属性。<strong>装箱/拆箱操作</strong></li></ul><h4 id="2-1、引用类型">2.1、引用类型<a class="anchor" href="#2-1、引用类型">·</a></h4><ul><li><p>基本引用类型：并不是由<code>Object</code>构造的，但是它们原型链的终点都是<code>Object</code></p><ul><li><code>Date</code> 日期</li><li><code>RegExp</code> 正则</li></ul></li><li><p>包装类型：基本类型的包装类型:<code>Boolean</code>、<code>Number</code>、<code>String</code></p></li><li><p>单例内置对象：<code>Global</code>、<code>Math</code></p></li><li><p>基本类型和包装类型的主要区别：<strong>对象的生存期</strong></p><ul><li>包装类型使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中</li><li>而基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ConardLi&#x27;</span></span><br><span class="line">name.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">color</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>集合引用类型：</p><ul><li><code>Object</code></li><li><code>Array</code> 数组</li><li><code>Function</code> 函数</li><li><code>Map</code>、<code>WeakMap</code>、<code>Set</code>、<code>WeakSet</code></li></ul></li></ul><h4 id="2-2、引用类型特点">2.2、引用类型特点<a class="anchor" href="#2-2、引用类型特点">·</a></h4><ul><li><p>按址访问，该类型的值是同时保存在堆和栈内存中的，这两个栈区共同完成</p><ul><li>存储的值大小不定，可动态调整</li><li>空间较大，运行效率低</li><li>无法直接操作其内部存储，使用引用地址读取</li><li>通过代码进行分配空间</li></ul></li><li><p>具有可变性，赋值的时候两个变量保存了同一对象地址，执行同一对象，二者互相影响</p></li><li><p>值的比较：值相等，类型相同，堆中的地址也要相同</p></li><li><p>函数传参：<strong><code>ECMAScript</code>中所有的函数的参数都是按值传递的。</strong></p><p>参数是引用类型时，同样将参数复制了一个副本到局部变量，只不过<strong>复制的这个副本是指向堆内存中的地址</strong>而已。</p><p>在函数内对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但<strong>这并不代表引用传递</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;ConardLi&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeValue</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&#x27;code秘密花园&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeValue</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// code秘密花园</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeValue</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&#x27;ConardLi&#x27;</span>;</span><br><span class="line">  obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;code秘密花园&#x27;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeValue</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.2-JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的盒模型</title>
      <link href="/posts/282252185.html"/>
      <url>/posts/282252185.html</url>
      
        <content type="html"><![CDATA[<h2 id="二、盒模型">二、盒模型<a class="anchor" href="#二、盒模型">·</a></h2><h3 id="0、文档流">0、文档流<a class="anchor" href="#0、文档流">·</a></h3><ul><li><p>网页是一个多层结构，是一层一层的；我们可以通过css为每一层设置样式，而用户只能看到最上面的一层</p></li><li><p>我们称最下面的一层叫<strong>文档流，文档流是网页的基础</strong>，也是<strong>css的一种基本定位和布局机制</strong></p></li><li><p>我们创建的元素默认是在文档流中进行排列：</p><ol><li>比如写的html不用css，默认自上而下（块级元素如<code>div</code>）从左到右（内联元素如<code>span</code>）堆砌的布局方式</li><li>元素主要有两种状态：在文档流中、不在文档流中</li></ol></li></ul><h3 id="1、盒模型">1、盒模型<a class="anchor" href="#1、盒模型">·</a></h3><ul><li>盒子构成4部分：content（有width和height）、padding、border、margin</li><li>分类上：<ol><li>块级元素的盒模型、行内元素的盒模型</li><li>标准盒模型、怪异盒模型</li></ol></li></ul><h4 id="1、盒子尺寸计算">1、盒子尺寸计算<a class="anchor" href="#1、盒子尺寸计算">·</a></h4><h5 id="IE盒模型：border-box">IE盒模型：border-box<a class="anchor" href="#IE盒模型：border-box">·</a></h5><ul><li>css指定的width、height指的是：实际盒子的大小（<strong>内容区域+border+padding</strong>）；不是内容区大小</li><li>属性控制：<strong>box-sizing</strong>：<strong>border-box</strong></li><li>所以这种模式下，<strong>增加border和padding会减小内容区域的大小</strong>，而实际盒子大小不变</li></ul><h5 id="标准模型（默认）：content-box">标准模型（默认）：content-box<a class="anchor" href="#标准模型（默认）：content-box">·</a></h5><ol><li>css指定的width、height指的是：内容区content的大小；</li><li>此时<strong>实际盒子</strong>的大小：<strong>内容区域+border+padding</strong></li><li>属性控制：<strong>box-sizing</strong>为<strong>content-box</strong>（默认值）</li><li>所以，这种模式下，<strong>增加border和padding不会影响内容区域的大小</strong>，只是会影响实际盒子的大小</li><li>声明了DOCTYPE类型，会解读为标准盒模型；</li></ol><h4 id="2、盒子宽高尺寸获取">2、盒子宽高尺寸获取<a class="anchor" href="#2、盒子宽高尺寸获取">·</a></h4><h5 id="1-方式一：通过DOM节点的-style-样式获取：element-style-width-height">1. 方式一：通过DOM节点的 style 样式获取：element.style.width/height<a class="anchor" href="#1-方式一：通过DOM节点的-style-样式获取：element-style-width-height">·</a></h5><ul><li>缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px&quot;</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> oDiv1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">console</span>.<span class="title function_">log</span>(oDiv1.<span class="property">style</span>.<span class="property">width</span> ) ;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-方式二（通用型）：window-getComputedStyle-element-width-height">2. 方式二（通用型）：window.getComputedStyle(element).width/height<a class="anchor" href="#2-方式二（通用型）：window-getComputedStyle-element-width-height">·</a></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> &gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> oDiv1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(oDiv1).<span class="property">width</span> ) ;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-方式三：IE独有的element-currentStyle-width-height">3. 方式三：IE独有的element.currentStyle.width/height<a class="anchor" href="#3-方式三：IE独有的element-currentStyle-width-height">·</a></h5><ul><li>获取到的是运行完之后的宽高，三种css样式都可以获取</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( oDiv1.<span class="property">currentStyle</span>.<span class="property">width</span>);</span><br></pre></td></tr></table></figure><h5 id="4-方式四（通用型）：element-getBoundingClientRect-width-height">4. 方式四（通用型）：element.getBoundingClientRect().width/height<a class="anchor" href="#4-方式四（通用型）：element-getBoundingClientRect-width-height">·</a></h5><ul><li>这种方式获得到的宽度是内容content+padding+border</li><li>此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oDiv1.<span class="title function_">getBoundingClientRect</span>().<span class="property">width</span>);</span><br></pre></td></tr></table></figure><h3 id="2、块级元素的盒模型">2、块级元素的盒模型<a class="anchor" href="#2、块级元素的盒模型">·</a></h3><h4 id="1、盒模型水平方向布局规则：">1、盒模型水平方向布局规则：<a class="anchor" href="#1、盒模型水平方向布局规则：">·</a></h4><p>元素在父元素的位置由以下属性决定：</p><p>margin-left、border-left、padding-left   width、padding-right、border-right、margin-right</p><p>这7个值构成了父元素的content内容区；</p><p>必须满足的条件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子元素margin-left+border-left+padding-left+width+padding-right+border-right=父元素宽度</span><br></pre></td></tr></table></figure><ul><li><p>当等式不成立时，称为过度约束，浏览器会自动调整：</p><p>这7个值中有三个可以设置为auto：width (默认是auto)、margin-left、margin-right</p><ol><li>如果7个值中没有auto会先调整margin-right；所以即使设置margin-right是无效的；</li><li>如果某一个值为auto就会先自动调整那个值；</li><li>如果一个宽度和一个外边距是auto，那么宽度会调整到最大</li><li>如果三个都是auto，那么宽度会是最大；</li><li>如果外边距都是auto，那么两个auto会赋相同的值(常用这个特点实现水平居中)</li></ol></li></ul><h4 id="2、盒模型垂直方向布局">2、盒模型垂直方向布局<a class="anchor" href="#2、盒模型垂直方向布局">·</a></h4><ul><li><p><strong>默认情况下，如果父元素不设置高度，父元素是被子元素撑开的</strong>。如果父元素指定了高度，设置多少就是多少；</p></li><li><p>子元素在内容区中排列：</p><ol><li><p>如果子元素的大小超过父元素：则子元素会从父元素中溢出；</p></li><li><p>使用overflow属性来设置父元素如何处理溢出的子元素：</p><p>visible：(默认值)子元素从父元素中溢出，在父元素的外部显示hidden:溢出的元素将会被裁减而不显示scroll:生成两个滚动条，通过两个滚动条实现浏览auto：根据需要生成两个滚动条</p></li></ol></li></ul><h4 id="3、垂直外边距塌陷">3、垂直外边距塌陷<a class="anchor" href="#3、垂直外边距塌陷">·</a></h4><p><strong>概念：<strong>两个或多个相邻普通流中的盒子（父子或兄弟元素）在</strong>垂直方向</strong>上的外边距会发生叠加</p><h5 id="兄弟元素：外边距的计算">兄弟元素：外边距的计算<a class="anchor" href="#兄弟元素：外边距的计算">·</a></h5><ul><li>两数为正，取最大值</li><li>两数为负，取绝对值最大的数</li><li>一正一负：取二者之和</li></ul><p>怎么解决：（兄弟元素的外边距重叠问题不用处理，因为就希望这样的效果）</p><ul><li><h5 id="为什么这样设计：">为什么这样设计：<a class="anchor" href="#为什么这样设计：">·</a></h5><p>解决垂直方向的多个段落之间的间隔：为了兼顾顶部、底部的没有空隙，所以添加了margin-bottom，margin-top ，由于外边距的合并这样的设计，不会让每个段落之间多出来一份宽度，这样整体间距一样，整齐布局</p></li></ul><h5 id="父子元素：">父子元素：<a class="anchor" href="#父子元素：">·</a></h5><p>外边距计算：</p><ul><li>父子元素之间的外边距子元素会传递给父元素（子会将父带下来，这样不好，需要解决）</li></ul><p>怎么解决：</p><ol><li><p>不用margin，换用padding，再将高度减去（需要计算）</p></li><li><p>改父元素定义上边框，设置透明，还需要减去高度，margin-top</p></li><li><p>解决思路：用一个东西，将上边的外边距与下边的外边距隔开，不要互相影响</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box1 clearfix&quot;&gt;</span><br><span class="line">// 阻隔的添加在这里</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;box2&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,  //<span class="number">1</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;  //<span class="number">4</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;  //<span class="number">2</span></span><br><span class="line">    <span class="attribute">display</span>: table; //<span class="selector-tag">table</span>可以隔开，本身不占据位置，既可以解决高度塌陷、外边距重叠问题 //<span class="number">3</span></span><br><span class="line">    <span class="attribute">clear</span>: both; //<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span> 其实是解决了 外边距重叠问题；</span><br><span class="line">// <span class="number">4</span>、<span class="number">5</span>是解决 高度塌陷问题</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>什么时候用before的问题？</p><ul><li><strong>其实它是用来处理margin边距重叠的，由于内部元素 float 创建了BFC，导致内部元素的margin-top和 上一个盒子的margin-bottom 发生叠加</strong>。如果这不是你所希望的，那么就可以加上before</li></ul></li></ul><h3 id="3、行内、替换元素">3、行内、替换元素<a class="anchor" href="#3、行内、替换元素">·</a></h3><h4 id="1、行内元素">1、行内元素<a class="anchor" href="#1、行内元素">·</a></h4><ul><li>不会独占一行，多个行内元素从左到右(行内元素可以共处一行)，从上到下排列；</li><li>不能设置宽高：宽高是由其文本内容撑开</li><li>可以设置margin、padding、border，但<strong>垂直方向</strong>上均不影响页面的布局，下面一行的元素不受影响</li><li>行内元素<strong>左右margin和padding</strong>有效，直接相加</li><li>行内元素使用float属性后，设置宽高生效</li><li>a、span、img、br、strong</li></ul><h4 id="2、行内块元素">2、行内块元素<a class="anchor" href="#2、行内块元素">·</a></h4><ul><li>结合了inline和block特性，既能设置宽高也不会换行</li><li>行内块级元素起始就是行内元素设置宽高可以生效</li><li>img、input、button、textarea、select</li></ul><h4 id="3、display-none">3、display:none<a class="anchor" href="#3、display-none">·</a></h4><ul><li>此时元素<strong>仍存在于DOM</strong>结构中</li><li>但<strong>不存在于render tree</strong> 中，<strong>不会被渲染</strong>，就<strong>不会占据空间</strong>，后面的元素会顶上来</li><li>会引起回流</li><li>不能点击</li></ul><h4 id="5、display-flex">5、display:flex<a class="anchor" href="#5、display-flex">·</a></h4><ul><li>弹性元素：更像是移动端的布局方式</li><li>设为flex布局后，子元素的float，clear和vertical-align属性将失效</li><li>此元素即为弹性布局容器，会按弹性布局规则</li></ul><h4 id="6、可替换元素：">6、可替换元素：<a class="anchor" href="#6、可替换元素：">·</a></h4><ul><li><p>特点：展现效果不是由 CSS 来控制的，外观渲染独立于CSS</p></li><li><h5 id="举例：">举例：<a class="anchor" href="#举例：">·</a></h5><ol><li><p>典型的可替换元素：iframe、video</p><p><strong>img</strong>：浏览器去下载 src 属性给到的图片，并用该图片资源替换掉 <code>img</code> 标签，而且浏览器在下载前并不知道图片的宽高。所以，可替换元素比较特殊，它的宽高是由其加载的内容决定的。（当然 CSS 可以覆盖其样式）</p><ul><li>display 属性的默认值是 inline，默认分辨率是由被嵌入的图片的原始宽高来确定的，使得它就像 inline-block 一样</li></ul></li></ol></li><li><p>没有基线：使用 vertical-align: baseline 时，图像的底部将会与容器的文字基线对齐</p></li></ul><ol start="2"><li><p>仅在特定情况下被作为可替换元素处理：audio、canvas</p></li><li><p>特殊的 input</p><ul><li><p>根据<code>type</code>属性来决定是显示输入框，还是单选按钮等</p></li><li><p>规范说明了input元素可替换，除了其他形式的控制元素，包括其他类型的 <input> 元素，被明确地列为非可替换元素</p></li></ul></li></ol><h4 id="7、不可替换元素：">7、不可替换元素：<a class="anchor" href="#7、不可替换元素：">·</a></h4><ul><li><code>html</code> 的大多数元素是不可替换元素，即其内容直接表现给用户端：div、p、h1</li></ul><h4 id="3、总结">3、总结<a class="anchor" href="#3、总结">·</a></h4><ol><li><p>几乎所有的<strong>替换元素</strong>都是<strong>行内元素</strong></p><p>不过元素的类型也不是固定的，通过设定CSS 的display属性，可以使行内元素变为块级元素，也可以让块级元素变为行内元素</p></li><li><p>替换元素一般有内在尺寸，所以具有width和height</p><p>不指定img的width和height时，就按其内在尺寸显示</p><p>对于表单元素，浏览器也有默认的样式，包括宽度和高度</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盒模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的常见布局</title>
      <link href="/posts/2387908466.html"/>
      <url>/posts/2387908466.html</url>
      
        <content type="html"><![CDATA[<h2 id="两栏布局">两栏布局<a class="anchor" href="#两栏布局">·</a></h2><h3 id="1-左定宽右适应-6种">1. 左定宽右适应  6种<a class="anchor" href="#1-左定宽右适应-6种">·</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box-left&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box-right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>解法1：float+margin，利用浮动，这样两侧就在同一行了，因为左侧宽度已知，那么右侧margin-left等于左侧宽度即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line"> height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &gt; div &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  float: left;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-right &#123;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：flex布局，其实和两栏自适应的方法二一模一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  height: 200px;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &gt; div &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-right &#123;</span><br><span class="line">  flex: 1; // 设置flex-grow属性为1，默认为0</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法3：float+overflow</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line"> height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &gt; div &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  float: left;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-right &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法4：cal计算</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">200px</span>);</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法5：左侧绝对定位，脱离标准流，那么两侧就能在同一行，右侧margin-left等于左侧宽度</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-right</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法6:右侧绝对定位，那么两侧就能在同一侧，右侧定位的时候要把left等于左侧宽度</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-left</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-right</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-两列自适应">2. <strong>两列自适应</strong><a class="anchor" href="#2-两列自适应">·</a></h3><p><strong>左侧宽度由内容撑开，右侧撑满剩余宽度</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outter&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">  如果是普通的两列布局，浮动+普通元素的margin便可以实现，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    但如果是自适应的两列布局，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    利用float+overflow:hidden便可以实现，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    这种办法主要通过overflow触发BFC,<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    而BFC不会重叠浮动元素。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>方法一：左侧浮动，右侧BFC</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outter</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left; //关键</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">overflow</span>: hidden; //关键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：flex布局，右侧flex-grow:1，使其能放大，从而占满剩余宽度</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outter</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;  //关键</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>flex-grow</strong></p><ul><li><p>定义item的放大比例，<strong>默认值为0，如果有空余空间也不会放大</strong>。</p></li><li><p>container在main axis方向上<strong>有剩余空间</strong>时，才生效</p></li><li><p>如果item的flex-grow总和sum&gt;1，每个item<strong>扩展的size</strong>为</p><p>container剩余size*flex-grow/sum</p></li></ul><p>如果所有项目的flex-grow属性都为1，则它们将<strong>等分剩余空间</strong>（如果有的话）。</p><p>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的<strong>剩余空间</strong>将比其他项多一倍。</p></li></ul><h2 id="三栏布局">三栏布局<a class="anchor" href="#三栏布局">·</a></h2><h3 id="1-三栏自适应">1.三栏自适应<a class="anchor" href="#1-三栏自适应">·</a></h3><p><strong>中间自适应宽度，两侧固定宽度</strong></p><h4 id="1-圣杯布局"><strong>1.圣杯布局</strong><a class="anchor" href="#1-圣杯布局">·</a></h4><ul><li>结构</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;center&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //center在前面，从而最先渲染出来</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;right&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>实现步骤</p><ul><li>center、right、left均为<code>float:left</code>，center宽度100%，则独自占据一行</li><li>left和right设置负margin，使得和center同一行</li><li>包裹三者的container设置padding-left和padding-right，为left和right留位置</li><li>left和right设置相对定位，移到container留出的空白位置中</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  //为<span class="attribute">left</span>和<span class="attribute">right</span>留位置</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;  </span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-双飞翼布局"><strong>2.双飞翼布局</strong><a class="anchor" href="#2-双飞翼布局">·</a></h4><ul><li><p>结构</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&#x27;container&#x27;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;center&#x27;&gt; //center在前面，从而最先渲染出来</span><br><span class="line">      &lt;<span class="selector-tag">div</span> class=&#x27;inner&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">left</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">right</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>实现步骤</p><ul><li>center、right、left均为<code>float:left</code>，center宽度100%，则独自占据一行</li><li>left和right设置负margin，使得和center同一行</li><li>inner设置<code>margin:0 200px</code>，为left和right留位置</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-flex布局⭐️⭐️"><strong>3.flex布局</strong>⭐️⭐️<a class="anchor" href="#3-flex布局⭐️⭐️">·</a></h4><ul><li><p>结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;center&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  //center在前面，从而最先渲染出来</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;right&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实现步骤</p><ul><li>container设置flex</li><li>此时显示center、left、right的顺序，要把center调整到中间，设置left和right的order属性</li><li>center要扩充页面剩余部分，故<code>flex-grow: 1;</code></li><li>left和right宽度通过flex-basis设置，从而在拓宽center前宽度正常</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;//<span class="attribute">flex-grow</span>:<span class="number">0</span>;<span class="attribute">flex-shrink</span>:<span class="number">0</span>;<span class="attribute">flex-basis</span>:<span class="number">200px</span></span><br><span class="line"></span><br><span class="line">  width: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-非自适应"><strong>2. 非自适应</strong><a class="anchor" href="#2-非自适应">·</a></h3><ul><li><p>流式布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&#x27;container&#x27;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">left</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">right</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;center&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;  //center最后渲染</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">210px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">210px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BFC</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&#x27;container&#x27;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">left</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">right</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;center&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;  //center最后渲染</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;   //center变成BFC，不会与浮动元素重叠</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>绝对定位</p><ul><li>container相对定位，子元素left和right绝对定位</li><li>center设置margin为left和right留位置</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&#x27;container&#x27;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;center&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt; //center可以先渲染</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">left</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&#x27;<span class="attribute">right</span>&#x27;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;  //脱离了文档流，后代元素也脱离了文档流，高度未知会有问题</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1.1-CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
